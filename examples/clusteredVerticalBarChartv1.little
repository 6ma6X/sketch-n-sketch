
; QUESTIONS: 

; this version will be the "lerped" version 
; change size of the chart by clicking on the rectangle


; TODO: 
; 1. Fix gap_2 left padding 
; 2. Fix vertical positioning 
; 3. Fix labels
; 4. Deal with ForegroundRect


; ENTER DATA VALUES HERE ---------->

; now make 'data' into a list of lists 
(def data [90 170 144 200 215 150 120 90])

(def data_1 [[90 100 110]
             [150 110 120]
             [200 300 500]
             [100 200 400]])

(def colors [100 200 300 270])

(def categorical_data ['Case 1' 'Case 2' 'Case 3'])

(def title_text 'Title Here')
(def xaxis_text 'X Label')
(def yaxis_text 'Y Label')

(def title_on true)
(def xaxis_label_on true)
(def yaxis_label_on true)

(def xaxis_on true)
(def yaxis_on true)

(def xaxis_ticks_on true)
(def yaxis_ticks_on true)
(def yaxis_number_of_ticks 5!)

(def numbers_above_bars_on true)

(def bar_stroke_width 1!)
(def bar_stroke_color 400{0-499})

(def background_color 475{0-499})

(def axis_color 400{0-499})
(def axis_width 1!)

(def tick_color 400{0-499})
(def tick_width 1!)

(def fit_xlabels_to_bar_width false)



; DEFINE DATA FUNCTIONS ---------->

(def lerp (\(w [a b])
    (+ (* (- 1 w) a) (* w b))))

(def unlerp (\(x [x0 x1])
    (/ (- x x0) (- x1 x0))))

; need a function that 
; 1. extracts the first element from a list (map hd)
; 2. draws a group for those "mapped" elements 
; 3. recurses down the rest of the 'data' list 
; 4. lerp all values

; _lol -> list of lists tag

; number of elements in each sublist
(def num_elements (len (hd data_1)))

; numbers of sublists
(def num_lists (len data_1))

(def data_len_lol 
    (* num_elements num_lists))

; l is a list of lists
(def extractHead (\l
    (map hd l)))

(def extractTail (\l
    (map tl l)))

; group the elements in clusters 
(defrec getClusters (\l
    (case (concat l)
        ([] [])
        ([head|tail]
            (let cluster (extractHead l)
            [cluster| (getClusters (extractTail l))])))))



; DEFINE CONSTANTS ---------->

; Find maximum and minimum points of data 
(def maxD 
    (let max_list (map maximum data_1)
    (maximum max_list)))
(def minD 
    (let min_list (map minimum data_1)
    (minimum min_list)))

; round maxD to nearest 10th (that is >= to maxD): 
(def maxGraph 
    (let remainder (mod maxD 10!)
    (if (= remainder 0) maxD (+ maxD (- 10! remainder)))))

(def data_len (len data))

; Deal with starting position, width of bars, and gap between bars 
; define everything in terms of left and top point 
; similar to positioning in HTML and CSS 

(def [x0 y0 w h] [175 200 275! 225])

(def unlerp_y (\y 
    (unlerp y [0! maxGraph])))

(def lerp_y (\yp
    (round (lerp yp [0! h]))))

(def unlerped_values (map unlerp_y data))

(def lerped_values (map lerp_y unlerped_values))

; -----------> CLUSTERED


(def clustered_list (getClusters data_1))

(def unlerp_y_lol (\sub_l
    (map unlerp_y sub_l)))

(def lerp_y_lol (\sub_l
    (map lerp_y sub_l)))

(def unlerped_values_lol (map unlerp_y_lol clustered_list))
(def lerped_values_lol (map lerp_y_lol unlerped_values_lol))


; ----->

(def rect_left x0)
(def rect_bot (+ y0 h))
(def wid 100!{10-150})
(def width 
    (let smoother (/ 100! wid)
    (/ w (* data_len_lol smoother))))

; don't let the gap between bars change unless slider value changes
; gap is defined as a percentage of the width 
; so if the "space" slider says "100", it means 100% of width 

(def gap 
    (let space 30!{0-100}
    (* (/ space 100!) width)))

(def gap_2
    (let group_space 30!{0-100}
    (* (/ group_space 100!) width)))


; GRAPH FUNCTIONS AND CONSTANTS ----------> 

; Derive bounds of x and y axes 

(def axis_left 
    (if (< gap bar_stroke_width) (- rect_left (* 0.5! bar_stroke_width))
    (- rect_left (- gap (* 0.5! bar_stroke_width)))))
(def axis_right (+ (+ rect_left (+ (* data_len_lol width) (* data_len_lol gap))) 
                (* data_len_lol gap_2)))
(def axis_bot (+ rect_bot (* 0.5! bar_stroke_width)))
(def axis_top (- axis_bot (+ h  bar_stroke_width)))

; attempt creating a bounding box (for axes)
(def [x1 y1 w1 h1] [axis_left axis_top (- axis_right axis_left) (- axis_bot axis_top)])

(def BackgroundRect 
    [(rect background_color (- x1 100!) (- y1 75!) (+ w1 120!) (+ h1 175!))])
    
(def ForegroundRect 
    [(rect 'none' (- x1 120!) (- y1 95!) (+ w1 160!) (+ h1 215!))])

; Define graph labels
(def title 
    (if title_on 
        [(addAttr
            (addAttr 
                (addAttr 
                    (text (/ (+ axis_left axis_right) 2!) (- axis_top 20!) title_text)
                    ['text-anchor' 'middle'])
                ['font-size' '20'])
            ['font-weight' 'bold'])]
        []))
    
(def xLabel 
    (if xaxis_label_on
        [(addAttr
            (addAttr
                (text (/ (+ axis_left axis_right) 2!) (+ axis_bot 60!) xaxis_text)
                ['text-anchor' 'middle'])
            ['font-weight' 'bold'])]
        []))
    
(def yLabel
    (if yaxis_label_on
        [(addAttr 
            (addAttr
                (rotateAround -90! 
                    (- axis_left 60!)
                    (+ axis_top (/ (- axis_bot axis_top) 2!))
                    (text (- axis_left 60!) (+ axis_top (/ (- axis_bot axis_top) 2!)) yaxis_text))
                ['text-anchor' 'middle'])
            ['font-weight' 'bold'])]
        []))
        
; Define lines that comprise x and y axes
(def xAxis
    (if xaxis_on 
        (let [x1 y1 x2 y2] [axis_left axis_bot axis_right axis_bot]
        (let [color width] [axis_color axis_width]
            [(line color width x1 y1 x2 y2)]))
        []))
    
(def yAxis
    (if yaxis_on
        (let [x1 y1 x2 y2] [axis_left axis_top axis_left (+ 1! axis_bot)]
        (let [color width] [axis_color axis_width]
            [(line color width x1 y1 x2 y2)]))
        []))

; Draw bar based on index i and datapoint d 
(def drawBar_lol (\[i [n d]]
    (let group_index (* n num_lists)
    (let padding (* group_index (+ gap (+ gap_2 width)))
    (let [left top] [ (+ padding (+ (* i gap) (+ rect_left (* width i))))
        (- rect_bot d)]
    (let bounds [left top (+ width left) rect_bot]
    (let [color strokeColor] [(nth colors i) bar_stroke_color]
    [ (rectangle color strokeColor bar_stroke_width 0 bounds) ])))))))

(defrec makePairedList (\(x y)
    (case y
        ([] [])
        ([head|tail]
            (let new_head [x head]
                [new_head| (makePairedList x tail)])))))

(def drawBars (\[i d]
    (let paired_list (makePairedList i d)
    (mapi drawBar_lol paired_list))))

; Drawing functions for additional features on graph, like 
; 1. ticks on x axis
; 2. ticks on y axis
; 3. labels associated with x axis ticks
; 4. labels associated with y axis ticks
; 5. data numbers above the bars 

(def drawXTicks (\[i d]
    (if (and xaxis_on xaxis_ticks_on)
        (let [left] [ (+ (* 0.5! width) (+ (* i gap) (+ rect_left (* width i))))]
        (let [x1 y1 x2 y2] [left axis_bot left (+ axis_bot 10!)]
        (let [color width] [tick_color tick_width]
          [(line color width x1 y1 x2 y2)])))
        [])))
      
(def drawYTicks (\i
    (if (and yaxis_on yaxis_ticks_on)
        (let height (- axis_bot axis_top)
        (let ygap (/ height (- yaxis_number_of_ticks 1!))
        (let [bot] [(- axis_bot (* ygap i))]
        (let [x1 y1 x2 y2] [(- axis_left 10!) bot axis_left bot]
        (let [color width] [tick_color tick_width]
            [(line color width x1 y1 x2 y2)])))))
        [])))

; currently doesn't let the group resize horizontally 

(def drawXLabels (\[i cd]
    (if xaxis_on 
        (if fit_xlabels_to_bar_width
            (let [left] [ (+ (* 0.5! width) (+ (* i gap) (+ rect_left (* width i))))]
            (let bot (+ axis_bot 30!)
            [(addAttr
                (addAttr
                    (text left bot cd)
                    ['text-anchor' 'middle'])
                ['textLength' (toString width)])]))
            (let [left] [ (+ (* 0.5! width) (+ (* i gap) (+ rect_left (* width i))))]
            (let bot (+ axis_bot 30!)
            [(addAttr
                (text left bot cd)
                ['text-anchor' 'middle'])])))
        [])))


(def drawXLabels_lol (\[i cd]
    (if xaxis_on 
        (if fit_xlabels_to_bar_width
            (let group_index (* (+ i 1!) num_lists)
            (let left (* group_index (+ gap (+ gap_2 width)))
            (let bot (+ axis_bot 30!)
            [(addAttr
                (addAttr
                    (text left bot cd)
                    ['text-anchor' 'middle'])
                ['textLength' (toString width)])])))

            (let group_index (* (+ i 1!) num_lists)
            (let left (* group_index (+ gap (+ gap_2 width)))
            (let bot (+ axis_bot 30!)
            [(addAttr
                (text left bot cd)
                ['text-anchor' 'middle'])]))))
        [])))
        
(def drawYLabels (\i 
    (if yaxis_on
        (let height (- axis_bot axis_top)
        (let ygap (/ height (- yaxis_number_of_ticks 1))
        (let textgap (/ maxGraph (- yaxis_number_of_ticks 1))
        (let [bot] [(- axis_bot (* ygap i))]
        (let val (+ 0 (* textgap i))
        [(addAttr
            (text (- axis_left 30) (+ bot 5) (toString (round val)))
            ['text-anchor' 'middle'])])))))
        [])))
            
(def drawDataNumber_lol (\[i [n d]]
    (if numbers_above_bars_on 
        (let group_index (* n num_lists)
        (let padding (* group_index (+ gap (+ gap_2 width)))
        (let [left] [ (+ (* 0.5! width) (+ padding (+ (* i gap) (+ rect_left (* width i)))))]
        (let top_padding 5!
        (let lerp_d (lerp_y (unlerp_y d))
        (let top (- axis_bot (+ top_padding (+ lerp_d bar_stroke_width)))
        [(addAttr
            (text left top (toString d))
            ['text-anchor' 'middle'])]))))))

        [])))

(def drawDataNumbers (\[i d]
    (let paired_list (makePairedList i d)
    (mapi drawDataNumber_lol paired_list))))

; Now call the drawing functions above to create lists of shapes
(def Bars (concat (mapi drawBars lerped_values_lol)))
(def XTicks (mapi drawXTicks (hd data_1)))
(def YTicks (map drawYTicks (range 0! (- yaxis_number_of_ticks 1!))))
(def YLabels (map drawYLabels (range 0! (- yaxis_number_of_ticks 1!))))
(def XLabels (mapi drawXLabels categorical_data))
(def DataNumbers (concat (mapi drawDataNumbers clustered_list)))


; GRAPH REPRESENTATION ----------> 

; TESTING (for debugging purposes) ----->
; testing constants:

(def xval_test 100!)
(def yval_test 50!)
(def spacing_test 20!)

; testing functions: 
(def toText_test (\[i d]
    (let x xval_test
    (let y (+ yval_test (* i spacing_test))
    [(text x y (toString d))]))))
    
; (def Text_test (mapi toText_test lerped_values))
(def Text_test (mapi toText_test [width]))

(def testing_getClusters (getClusters data_1))

; CANVAS -----> 


; Essentially the drawing canvas
(svg (append BackgroundRect
    (append (concat Text_test)
    (append (concat Bars)
    (append (concat [xAxis yAxis title xLabel yLabel]) 
    (append (concat YTicks)
    (append (concat XTicks)
    (append (concat YLabels)
    (append (concat XLabels)
    (append (concat DataNumbers) ForegroundRect))))))))))

