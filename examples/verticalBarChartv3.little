
; QUESTIONS: 

; this version (version 3) will be the "lerped" version
; change size of graph through clicking on the bars  


; TODO: 
; 1. Fix positioning 
; 2. Deal with ForegroundRect


; ENTER DATA VALUES HERE ---------->

(def data [90 170 144 200 215 150 120 90])
(def categorical_data ['Case 1' 'Case 2' 'Case 3' 'Case 4' 'Case 5'
    'Case 6' 'Case 7' 'Case 8'])

(def title_text 'Title Here')
(def xaxis_text 'X Label')
(def yaxis_text 'Y Label')

(def title_on true)
(def xaxis_label_on true)
(def yaxis_label_on true)

(def xaxis_on true)
(def yaxis_on true)

(def xaxis_ticks_on true)
(def yaxis_ticks_on true)
(def yaxis_number_of_ticks 5!)

(def numbers_above_bars_on true)

(def bar_color 246)
(def bar_stroke_width 1) ; not fixed, unlike in version 2
(def bar_stroke_color 499)

(def axis_color 400)
(def axis_width 1!)

(def tick_color 400)
(def tick_width 1!)

(def fit_xlabels_to_bar_width false)

; DEFINE DATA FUNCTIONS ---------->

(def lerp (\(w [a b])
    (+ (* (- 1 w) a) (* w b))))

(def unlerp (\(x [x0 x1])
    (/ (- x x0) (- x1 x0))))

; DEFINE CONSTANTS ---------->

; Find maximum and minimum points of data 
(def maxD (maximum data))
(def minD (minimum data))

; round maxD to nearest 10th (that is >= to maxD): 
(def maxGraph 
    (let remainder (mod maxD 10!)
    (if (= remainder 0) maxD (+ maxD (- 10! remainder)))))

(def data_len (len data))

; Deal with starting position, width of bars, and gap between bars 
; define everything in terms of left and top point 
; similar to positioning in HTML and CSS 

(def [x0 y0 w h] [175 200 275! 225])

(def unlerp_y (\y 
    (unlerp y [0! maxGraph])))

(def lerp_y (\yp
    (round (lerp yp [0! h]))))

(def unlerped_values (map unlerp_y data))
(def lerped_values (map lerp_y unlerped_values))

(def rect_left x0)
(def rect_bot (+ y0 h))
(def wid 100!{10-150})
(def width 
    (let smoother (/ 100! wid)
    (/ w (* data_len smoother))))

; don't let the gap between bars change unless slider value changes
; gap is defined as a percentage of the width 
; so if the "spacing" slider says "100", it means 100% of width 
(def gap 
    (let spacing 94!{0-100}
    (* (/ spacing 100!) width)))


; Define color range (supplementary)
(def COLORMIN 100)
(def COLORMAX 250)

; Assign color to each data point based on color range (supplementary)
(def mapColor (\(val d_min d_max col_min col_max) 
(+ (* (- 1 (/ (- val d_min) (- d_max d_min))) col_min) (* (/ (- val d_min) (- d_max d_min)) col_max))))


; GRAPH FUNCTIONS AND CONSTANTS ----------> 

; Derive bounds of x and y axes 

(def axis_left 
    (if (< gap bar_stroke_width) (- rect_left (* 0.5! bar_stroke_width))
    (- rect_left (- gap (* 0.5! bar_stroke_width)))))
(def axis_right (+ rect_left (+ (* data_len width) (* data_len gap))))
(def axis_bot (+ rect_bot (* 0.5! bar_stroke_width)))
(def axis_top (- axis_bot (+ h  bar_stroke_width)))

; attempt creating a bounding box (for axes)
(def [x1 y1 w1 h1] [axis_left axis_top (- axis_right axis_left) (- axis_bot axis_top)])
(def BackgroundRect 
    (let background_color 470{0-499}
    [(rect background_color (- x1 100!) (- y1 75!) (+ w1 120!) (+ h1 175!))]))

; Define graph labels
(def title 
    (if title_on 
        [(addAttr
            (addAttr 
                (addAttr 
                    (text (/ (+ axis_left axis_right) 2!) (- axis_top 20!) title_text)
                    ['text-anchor' 'middle'])
                ['font-size' '20'])
            ['font-weight' 'bold'])]
        []))
    
(def xLabel 
    (if xaxis_label_on
        [(addAttr
            (addAttr
                (text (/ (+ axis_left axis_right) 2!) (+ axis_bot 60!) xaxis_text)
                ['text-anchor' 'middle'])
            ['font-weight' 'bold'])]
        []))
    
(def yLabel
    (if yaxis_label_on
        [(addAttr 
            (addAttr
                (rotateAround -90! 
                    (- axis_left 60!)
                    (+ axis_top (/ (- axis_bot axis_top) 2!))
                    (text (- axis_left 60!) (+ axis_top (/ (- axis_bot axis_top) 2!)) yaxis_text))
                ['text-anchor' 'middle'])
            ['font-weight' 'bold'])]
        []))
        
; Define lines that comprise x and y axes
(def xAxis
    (if xaxis_on 
        (let [x1 y1 x2 y2] [axis_left axis_bot axis_right axis_bot]
        (let [color width] [axis_color axis_width]
            [(line color width x1 y1 x2 y2)]))
        []))
    
(def yAxis
    (if yaxis_on
        (let [x1 y1 x2 y2] [axis_left axis_top axis_left (+ 1! axis_bot)]
        (let [color width] [axis_color axis_width]
            [(line color width x1 y1 x2 y2)]))
        []))

; Draw bar based on index i and datapoint d 
(def drawBar (\[i d]
  (let [left top] [ (+ (* i gap) (+ rect_left (* width i))) (- rect_bot d)]
  (let bounds [left top (+ width left) rect_bot]
  (let [color strokeColor] [bar_color bar_stroke_color]
    [ (rectangle color strokeColor bar_stroke_width 0 bounds) ])))))

; Draw bar based on index i and datapoint d 
; (supplementary, as it is the "colored" version -- bars take a certain color in a range based on their data value)
; (def drawBar (\[i d]
;   (let [left top] [ (+ (* i gap) (+ rect_left (* width i))) (- rect_bot d)]
;   (let bounds [left top (+ width left) rect_bot]
;   (let color ( mapColor d minD maxD COLORMIN COLORMAX)
;     [ (rectangle color 'black' 0 0 bounds) ])))))

; Drawing functions for additional features on graph, like 
; 1. ticks on x axis
; 2. ticks on y axis
; 3. labels associated with x axis ticks
; 4. labels associated with y axis ticks
; 5. data numbers above the bars 

(def drawXTicks (\[i d]
    (if (and xaxis_on xaxis_ticks_on)
        (let [left] [ (+ (* 0.5! width) (+ (* i gap) (+ rect_left (* width i))))]
        (let [x1 y1 x2 y2] [left axis_bot left (+ axis_bot 10!)]
        (let [color width] [tick_color tick_width]
          [(line color width x1 y1 x2 y2)])))
        [])))
      
(def drawYTicks (\i
    (if (and yaxis_on yaxis_ticks_on)
        (let height (- axis_bot axis_top)
        (let ygap (/ height (- yaxis_number_of_ticks 1!))
        (let [bot] [(- axis_bot (* ygap i))]
        (let [x1 y1 x2 y2] [(- axis_left 10!) bot axis_left bot]
        (let [color width] [tick_color tick_width]
            [(line color width x1 y1 x2 y2)])))))
        [])))

(def drawXLabels (\[i cd]
    (if xaxis_on 
        (if fit_xlabels_to_bar_width
            (let [left] [ (+ (* 0.5! width) (+ (* i gap) (+ rect_left (* width i))))]
            (let bot (+ axis_bot 30!)
            [(addAttr
                (addAttr
                    (text left bot cd)
                    ['text-anchor' 'middle'])
                ['textLength' (toString width)])]))
            (let [left] [ (+ (* 0.5! width) (+ (* i gap) (+ rect_left (* width i))))]
            (let bot (+ axis_bot 30!)
            [(addAttr
                (text left bot cd)
                ['text-anchor' 'middle'])])))
        [])))
        
(def drawYLabels (\i 
    (if yaxis_on
        (let height (- axis_bot axis_top)
        (let ygap (/ height (- yaxis_number_of_ticks 1))
        (let textgap (/ maxGraph (- yaxis_number_of_ticks 1))
        (let [bot] [(- axis_bot (* ygap i))]
        (let val (+ 0 (* textgap i))
        [(addAttr
            (text (- axis_left 30) (+ bot 5) (toString (round val)))
            ['text-anchor' 'middle'])])))))
        [])))
            
(def drawDataNumbers (\[i d]
    (if numbers_above_bars_on 
        (let [left] [ (+ (* 0.5! width) (+ (* i gap) (+ rect_left (* width i))))]
        (let top_padding 5!
        (let lerp_d (lerp_y (unlerp_y d))
        (let top (- axis_bot (+ top_padding (+ lerp_d bar_stroke_width)))
        [(addAttr
            (text left top (toString d))
            ['text-anchor' 'middle'])]))))

        [])))

; Now call the drawing functions above to create lists of shapes
(def Bars (mapi drawBar lerped_values))
(def XTicks (mapi drawXTicks data))
(def YTicks (map drawYTicks (range 0! (- yaxis_number_of_ticks 1!))))
(def YLabels (map drawYLabels (range 0! (- yaxis_number_of_ticks 1!))))
(def XLabels (mapi drawXLabels categorical_data))
(def DataNumbers (mapi drawDataNumbers data))


; GRAPH REPRESENTATION ----------> 

; TESTING (for debugging purposes) ----->
; testing constants:

(def xval_test 100!)
(def yval_test 50!)
(def spacing_test 20!)

; testing functions: 
(def toText_test (\[i d]
    (let x xval_test
    (let y (+ yval_test (* i spacing_test))
    [(text x y (toString d))]))))
    
(def Text_test (mapi toText_test lerped_values))



; CANVAS -----> 


; Essentially the drawing canvas
(svg (append BackgroundRect 
    (append (concat Bars)
    (append (concat [xAxis yAxis title xLabel yLabel]) 
    (append (concat YTicks)
    (append (concat XTicks)
    (append (concat YLabels)
    (append (concat XLabels)
    (append (concat DataNumbers) [])))))))))

