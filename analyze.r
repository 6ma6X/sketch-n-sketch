# $ r --file=analyze.r

library(lme4)

tasks <- read.csv("tasks.csv", header = TRUE)

# 'data.frame':  208 obs. of  27 variables:
#  $ participantNumber                   : int  1 1 1 1 1 1 1 1 1 1 ...
#  $ usedMouse                           : Factor w/ 2 levels "no","yes": 1 1 1 1 1 1 1 1 1 1 ...
#  $ taskNumber                          : int  1 2 3 4 5 6 7 8 9 10 ...
#  $ secondEncounter                     : Factor w/ 2 levels "no","yes": 1 1 1 1 2 2 2 2 1 1 ...
#  $ task                                : Factor w/ 6 levels "Four Squares",..: 5 3 4 6 5 4 6 3 1 2 ...
#  $ treatment                           : Factor w/ 3 levels "BoxSelectOnly",..: 3 1 1 1 1 3 3 3 2 2 ...
#  $ allEventsLogged                     : Factor w/ 2 levels "no","yes": 2 2 2 2 2 2 2 2 2 2 ...
#  $ completed                           : Factor w/ 2 levels "no","yes": 2 2 2 2 2 2 2 1 2 1 ...
#  $ timedOut                            : Factor w/ 2 levels "no","yes": 1 1 1 1 1 1 1 2 1 2 ...
#  $ grossTime                           : num  141.6 201.2 118.1 72 59.9 ...
#  $ interactionTime                     : num  91.4 178.8 94.6 52.2 29.2 ...
#  $ textSelectInteractionsStartedCount  : int  3 0 0 0 0 7 4 19 4 10 ...
#  $ textSelectInteractingTime           : num  71.6 0 0 0 0 ...
#  $ textSelectRefactoringsCount         : int  2 0 0 0 0 6 3 5 3 6 ...
#  $ singleArgTextSelectRefactoringsCount: int  1 0 0 0 0 5 1 0 3 6 ...
#  $ multiArgTextSelectRefactoringsCount : int  1 0 0 0 0 1 2 5 0 0 ...
#  $ boxSelectInteractionsStartedCount   : int  0 9 4 3 2 0 0 0 12 54 ...
#  $ boxSelectInteractingTime            : num  0 96.2 68.2 38.6 22.8 ...
#  $ boxSelectRefactoringsCount          : int  0 9 4 2 2 0 0 0 10 33 ...
#  $ singleArgBoxSelectRefactoringsCount : int  0 2 2 0 1 0 0 0 3 6 ...
#  $ multiArgBoxSelectRefactoringsCount  : int  0 7 2 2 1 0 0 0 7 27 ...
#  $ interactionsStartedCount            : int  3 9 4 3 2 7 4 19 16 64 ...
#  $ interactingTime                     : num  71.6 96.2 68.2 38.6 22.8 ...
#  $ refactoringsCount                   : int  2 9 4 2 2 6 3 5 13 39 ...
#  $ undoCount                           : int  0 4 0 0 0 0 0 5 2 39 ...
#  $ redoCount                           : int  0 0 0 0 0 0 0 0 0 3 ...
#  $ invocations                         : Factor w/ 155 levels "","Abstract (rect \"yellowgree... over its constants; Rename 'rect2' to 'oneCorner'; Undo; Undo; Merge 4 rects by "| __truncated__,..: 72 147 111 15 72 109 21 135 81 61 ...

tasks[ , "completionProbability"] <- sapply(tasks$completed, function (yn) { as.double(yn == "yes") })
tasks[ , "firstEncounter"]        <- sapply(tasks$secondEncounter, function (yn) { if(yn=="yes") "no" else "yes" })
tasks[ , "logInteractionTime"]    <- sapply(tasks$interactionTime, log)

headToHeadTasks <- subset(tasks, treatment != "CodeToolsOnly")

completedHeadToHeadTasks <- subset(headToHeadTasks, completed == "yes")

interactionTimeModel <- lmer(interactionTime ~ treatment + (1 | participantNumber) + (1 + secondEncounter | task) + secondEncounter + treatment:secondEncounter + taskNumber + usedMouse + usedOwnComputer, completedHeadToHeadTasks)
summary(interactionTimeModel)

logInteractionTimeModel <- lmer(logInteractionTime ~ treatment + (1 | participantNumber) + (1 + secondEncounter | task) + secondEncounter + treatment:secondEncounter + taskNumber + usedMouse + usedOwnComputer, completedHeadToHeadTasks)
summary(logInteractionTimeModel)

# Swap firstEncounter for secondEncounter to get an easy to interpret p value for treatment on second encounter.
interactionTimeModel <- lmer(interactionTime ~ treatment + (1 | participantNumber) + (1 + firstEncounter | task) + firstEncounter + treatment:firstEncounter + taskNumber + usedMouse + usedOwnComputer, completedHeadToHeadTasks)
summary(interactionTimeModel)

# Swap firstEncounter for secondEncounter to get an easy to interpret p value for treatment on second encounter.
logInteractionTimeModel <- lmer(logInteractionTime ~ treatment + (1 | participantNumber) + (1 + firstEncounter | task) + firstEncounter + treatment:firstEncounter + taskNumber + usedMouse + usedOwnComputer, completedHeadToHeadTasks)
summary(logInteractionTimeModel)

completionProbabilityModel <- glmer(completionProbability ~ treatment + (1 | participantNumber) + (1 + secondEncounter | task) + secondEncounter + treatment:secondEncounter + taskNumber + usedMouse + usedOwnComputer, headToHeadTasks, family=binomial(link="logit"), control=glmerControl(optimizer="bobyqa"))
summary(completionProbabilityModel)

# Swap firstEncounter for secondEncounter to get an easy to interpret p value for treatment on second encounter.
completionProbabilityModel <- glmer(completionProbability ~ treatment + (1 | participantNumber) + (1 + firstEncounter | task) + firstEncounter + treatment:firstEncounter + taskNumber + usedMouse + usedOwnComputer, headToHeadTasks, family=binomial(link="logit"), control=glmerControl(optimizer="bobyqa"))
summary(completionProbabilityModel)

invocationsModel <- lmer(refactoringsCount ~ treatment + (1 | participantNumber) + (1 + secondEncounter | task) + secondEncounter + treatment:secondEncounter + taskNumber + usedMouse + usedOwnComputer, completedHeadToHeadTasks)
summary(invocationsModel)

# Swap firstEncounter for secondEncounter to get an easy to interpret p value for treatment on second encounter.
invocationsModel <- lmer(refactoringsCount ~ treatment + (1 | participantNumber) + (1 + firstEncounter | task) + firstEncounter + treatment:firstEncounter + taskNumber + usedMouse + usedOwnComputer, completedHeadToHeadTasks)
summary(invocationsModel)

interactingTimeModel <- lmer(interactingTime ~ treatment + (1 | participantNumber) + (1 + secondEncounter | task) + secondEncounter + treatment:secondEncounter + taskNumber + usedMouse + usedOwnComputer, completedHeadToHeadTasks)
summary(interactingTimeModel)

# Swap firstEncounter for secondEncounter to get an easy to interpret p value for treatment on second encounter.
interactingTimeModel <- lmer(interactingTime ~ treatment + (1 | participantNumber) + (1 + firstEncounter | task) + firstEncounter + treatment:firstEncounter + taskNumber + usedMouse + usedOwnComputer, completedHeadToHeadTasks)
summary(interactingTimeModel)

# summaryToBootstrap <- function(.) { fixef(.) }
#
# set.seed(101)
# ## 3.8s (on a 5600 MIPS 64bit fast(year 2009) desktop "AMD Phenom(tm) II X4 925"):
# boot01 <- bootMer(interactionTimeModel, summaryToBootstrap, nsim = 100)
#
# ## to "look" at it
# require("boot") ## a recommended package, i.e. *must* be there
# boot01