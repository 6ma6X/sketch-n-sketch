var Elm = Elm || { Native: {} };
Elm.Native.Basics = {};
Elm.Native.Basics.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Basics = localRuntime.Native.Basics || {};
	if (localRuntime.Native.Basics.values)
	{
		return localRuntime.Native.Basics.values;
	}

	var Utils = Elm.Native.Utils.make(localRuntime);

	function div(a, b)
	{
		return (a / b) | 0;
	}
	function rem(a, b)
	{
		return a % b;
	}
	function mod(a, b)
	{
		if (b === 0)
		{
			throw new Error('Cannot perform mod 0. Division by zero error.');
		}
		var r = a % b;
		var m = a === 0 ? 0 : (b > 0 ? (a >= 0 ? r : r + b) : -mod(-a, -b));

		return m === b ? 0 : m;
	}
	function logBase(base, n)
	{
		return Math.log(n) / Math.log(base);
	}
	function negate(n)
	{
		return -n;
	}
	function abs(n)
	{
		return n < 0 ? -n : n;
	}

	function min(a, b)
	{
		return Utils.cmp(a, b) < 0 ? a : b;
	}
	function max(a, b)
	{
		return Utils.cmp(a, b) > 0 ? a : b;
	}
	function clamp(lo, hi, n)
	{
		return Utils.cmp(n, lo) < 0 ? lo : Utils.cmp(n, hi) > 0 ? hi : n;
	}

	function xor(a, b)
	{
		return a !== b;
	}
	function not(b)
	{
		return !b;
	}
	function isInfinite(n)
	{
		return n === Infinity || n === -Infinity;
	}

	function truncate(n)
	{
		return n | 0;
	}

	function degrees(d)
	{
		return d * Math.PI / 180;
	}
	function turns(t)
	{
		return 2 * Math.PI * t;
	}
	function fromPolar(point)
	{
		var r = point._0;
		var t = point._1;
		return Utils.Tuple2(r * Math.cos(t), r * Math.sin(t));
	}
	function toPolar(point)
	{
		var x = point._0;
		var y = point._1;
		return Utils.Tuple2(Math.sqrt(x * x + y * y), Math.atan2(y, x));
	}

	return localRuntime.Native.Basics.values = {
		div: F2(div),
		rem: F2(rem),
		mod: F2(mod),

		pi: Math.PI,
		e: Math.E,
		cos: Math.cos,
		sin: Math.sin,
		tan: Math.tan,
		acos: Math.acos,
		asin: Math.asin,
		atan: Math.atan,
		atan2: F2(Math.atan2),

		degrees: degrees,
		turns: turns,
		fromPolar: fromPolar,
		toPolar: toPolar,

		sqrt: Math.sqrt,
		logBase: F2(logBase),
		negate: negate,
		abs: abs,
		min: F2(min),
		max: F2(max),
		clamp: F3(clamp),
		compare: Utils.compare,

		xor: F2(xor),
		not: not,

		truncate: truncate,
		ceiling: Math.ceil,
		floor: Math.floor,
		round: Math.round,
		toFloat: function(x) { return x; },
		isNaN: isNaN,
		isInfinite: isInfinite
	};
};

Elm.Native.Port = {};

Elm.Native.Port.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Port = localRuntime.Native.Port || {};
	if (localRuntime.Native.Port.values)
	{
		return localRuntime.Native.Port.values;
	}

	var NS;

	// INBOUND

	function inbound(name, type, converter)
	{
		if (!localRuntime.argsTracker[name])
		{
			throw new Error(
				'Port Error:\n' +
				'No argument was given for the port named \'' + name + '\' with type:\n\n' +
				'    ' + type.split('\n').join('\n        ') + '\n\n' +
				'You need to provide an initial value!\n\n' +
				'Find out more about ports here <http://elm-lang.org/learn/Ports.elm>'
			);
		}
		var arg = localRuntime.argsTracker[name];
		arg.used = true;

		return jsToElm(name, type, converter, arg.value);
	}


	function inboundSignal(name, type, converter)
	{
		var initialValue = inbound(name, type, converter);

		if (!NS)
		{
			NS = Elm.Native.Signal.make(localRuntime);
		}
		var signal = NS.input('inbound-port-' + name, initialValue);

		function send(jsValue)
		{
			var elmValue = jsToElm(name, type, converter, jsValue);
			setTimeout(function() {
				localRuntime.notify(signal.id, elmValue);
			}, 0);
		}

		localRuntime.ports[name] = { send: send };

		return signal;
	}


	function jsToElm(name, type, converter, value)
	{
		try
		{
			return converter(value);
		}
		catch(e)
		{
			throw new Error(
				'Port Error:\n' +
				'Regarding the port named \'' + name + '\' with type:\n\n' +
				'    ' + type.split('\n').join('\n        ') + '\n\n' +
				'You just sent the value:\n\n' +
				'    ' + JSON.stringify(value) + '\n\n' +
				'but it cannot be converted to the necessary type.\n' +
				e.message
			);
		}
	}


	// OUTBOUND

	function outbound(name, converter, elmValue)
	{
		localRuntime.ports[name] = converter(elmValue);
	}


	function outboundSignal(name, converter, signal)
	{
		var subscribers = [];

		function subscribe(handler)
		{
			subscribers.push(handler);
		}
		function unsubscribe(handler)
		{
			subscribers.pop(subscribers.indexOf(handler));
		}

		function notify(elmValue)
		{
			var jsValue = converter(elmValue);
			var len = subscribers.length;
			for (var i = 0; i < len; ++i)
			{
				subscribers[i](jsValue);
			}
		}

		if (!NS)
		{
			NS = Elm.Native.Signal.make(localRuntime);
		}
		NS.output('outbound-port-' + name, notify, signal);

		localRuntime.ports[name] = {
			subscribe: subscribe,
			unsubscribe: unsubscribe
		};

		return signal;
	}


	return localRuntime.Native.Port.values = {
		inbound: inbound,
		outbound: outbound,
		inboundSignal: inboundSignal,
		outboundSignal: outboundSignal
	};
};

if (!Elm.fullscreen) {
	(function() {
		'use strict';

		var Display = {
			FULLSCREEN: 0,
			COMPONENT: 1,
			NONE: 2
		};

		Elm.fullscreen = function(module, args)
		{
			var container = document.createElement('div');
			document.body.appendChild(container);
			return init(Display.FULLSCREEN, container, module, args || {});
		};

		Elm.embed = function(module, container, args)
		{
			var tag = container.tagName;
			if (tag !== 'DIV')
			{
				throw new Error('Elm.node must be given a DIV, not a ' + tag + '.');
			}
			return init(Display.COMPONENT, container, module, args || {});
		};

		Elm.worker = function(module, args)
		{
			return init(Display.NONE, {}, module, args || {});
		};

		function init(display, container, module, args, moduleToReplace)
		{
			// defining state needed for an instance of the Elm RTS
			var inputs = [];

			/* OFFSET
			 * Elm's time traveling debugger lets you pause time. This means
			 * "now" may be shifted a bit into the past. By wrapping Date.now()
			 * we can manage this.
			 */
			var timer = {
				programStart: Date.now(),
				now: function()
				{
					return Date.now();
				}
			};

			var updateInProgress = false;
			function notify(id, v)
			{
				if (updateInProgress)
				{
					throw new Error(
						'The notify function has been called synchronously!\n' +
						'This can lead to frames being dropped.\n' +
						'Definitely report this to <https://github.com/elm-lang/Elm/issues>\n');
				}
				updateInProgress = true;
				var timestep = timer.now();
				for (var i = inputs.length; i--; )
				{
					inputs[i].notify(timestep, id, v);
				}
				updateInProgress = false;
			}
			function setTimeout(func, delay)
			{
				return window.setTimeout(func, delay);
			}

			var listeners = [];
			function addListener(relevantInputs, domNode, eventName, func)
			{
				domNode.addEventListener(eventName, func);
				var listener = {
					relevantInputs: relevantInputs,
					domNode: domNode,
					eventName: eventName,
					func: func
				};
				listeners.push(listener);
			}

			var argsTracker = {};
			for (var name in args)
			{
				argsTracker[name] = {
					value: args[name],
					used: false
				};
			}

			// create the actual RTS. Any impure modules will attach themselves to this
			// object. This permits many Elm programs to be embedded per document.
			var elm = {
				notify: notify,
				setTimeout: setTimeout,
				node: container,
				addListener: addListener,
				inputs: inputs,
				timer: timer,
				argsTracker: argsTracker,
				ports: {},

				isFullscreen: function() { return display === Display.FULLSCREEN; },
				isEmbed: function() { return display === Display.COMPONENT; },
				isWorker: function() { return display === Display.NONE; }
			};

			function swap(newModule)
			{
				removeListeners(listeners);
				var div = document.createElement('div');
				var newElm = init(display, div, newModule, args, elm);
				inputs = [];

				return newElm;
			}

			function dispose()
			{
				removeListeners(listeners);
				inputs = [];
			}

			var Module = {};
			try
			{
				Module = module.make(elm);
				checkInputs(elm);
			}
			catch (error)
			{
				if (typeof container.appendChild === "function")
				{
					container.appendChild(errorNode(error.message));
				}
				else
				{
					console.error(error.message);
				}
				throw error;
			}

			if (display !== Display.NONE)
			{
				var graphicsNode = initGraphics(elm, Module);
			}

			var rootNode = { kids: inputs };
			trimDeadNodes(rootNode);
			inputs = rootNode.kids;
			filterListeners(inputs, listeners);

			addReceivers(elm.ports);

			if (typeof moduleToReplace !== 'undefined')
			{
				hotSwap(moduleToReplace, elm);

				// rerender scene if graphics are enabled.
				if (typeof graphicsNode !== 'undefined')
				{
					graphicsNode.notify(0, true, 0);
				}
			}

			return {
				swap: swap,
				ports: elm.ports,
				dispose: dispose
			};
		}

		function checkInputs(elm)
		{
			var argsTracker = elm.argsTracker;
			for (var name in argsTracker)
			{
				if (!argsTracker[name].used)
				{
					throw new Error(
						"Port Error:\nYou provided an argument named '" + name +
						"' but there is no corresponding port!\n\n" +
						"Maybe add a port '" + name + "' to your Elm module?\n" +
						"Maybe remove the '" + name + "' argument from your initialization code in JS?"
					);
				}
			}
		}

		function errorNode(message)
		{
			var code = document.createElement('code');

			var lines = message.split('\n');
			code.appendChild(document.createTextNode(lines[0]));
			code.appendChild(document.createElement('br'));
			code.appendChild(document.createElement('br'));
			for (var i = 1; i < lines.length; ++i)
			{
				code.appendChild(document.createTextNode('\u00A0 \u00A0 ' + lines[i].replace(/  /g, '\u00A0 ')));
				code.appendChild(document.createElement('br'));
			}
			code.appendChild(document.createElement('br'));
			code.appendChild(document.createTextNode('Open the developer console for more details.'));
			return code;
		}


		//// FILTER SIGNALS ////

		// TODO: move this code into the signal module and create a function
		// Signal.initializeGraph that actually instantiates everything.

		function filterListeners(inputs, listeners)
		{
			loop:
			for (var i = listeners.length; i--; )
			{
				var listener = listeners[i];
				for (var j = inputs.length; j--; )
				{
					if (listener.relevantInputs.indexOf(inputs[j].id) >= 0)
					{
						continue loop;
					}
				}
				listener.domNode.removeEventListener(listener.eventName, listener.func);
			}
		}

		function removeListeners(listeners)
		{
			for (var i = listeners.length; i--; )
			{
				var listener = listeners[i];
				listener.domNode.removeEventListener(listener.eventName, listener.func);
			}
		}

		// add receivers for built-in ports if they are defined
		function addReceivers(ports)
		{
			if ('title' in ports)
			{
				if (typeof ports.title === 'string')
				{
					document.title = ports.title;
				}
				else
				{
					ports.title.subscribe(function(v) { document.title = v; });
				}
			}
			if ('redirect' in ports)
			{
				ports.redirect.subscribe(function(v) {
					if (v.length > 0)
					{
						window.location = v;
					}
				});
			}
		}


		// returns a boolean representing whether the node is alive or not.
		function trimDeadNodes(node)
		{
			if (node.isOutput)
			{
				return true;
			}

			var liveKids = [];
			for (var i = node.kids.length; i--; )
			{
				var kid = node.kids[i];
				if (trimDeadNodes(kid))
				{
					liveKids.push(kid);
				}
			}
			node.kids = liveKids;

			return liveKids.length > 0;
		}


		////  RENDERING  ////

		function initGraphics(elm, Module)
		{
			if (!('main' in Module))
			{
				throw new Error("'main' is missing! What do I display?!");
			}

			var signalGraph = Module.main;

			// make sure the signal graph is actually a signal & extract the visual model
			if (!('notify' in signalGraph))
			{
				signalGraph = Elm.Signal.make(elm).constant(signalGraph);
			}
			var initialScene = signalGraph.value;

			// Figure out what the render functions should be
			var render;
			var update;
			if (initialScene.ctor === 'Element_elm_builtin')
			{
				var Element = Elm.Native.Graphics.Element.make(elm);
				render = Element.render;
				update = Element.updateAndReplace;
			}
			else
			{
				var VirtualDom = Elm.Native.VirtualDom.make(elm);
				render = VirtualDom.render;
				update = VirtualDom.updateAndReplace;
			}

			// Add the initialScene to the DOM
			var container = elm.node;
			var node = render(initialScene);
			while (container.firstChild)
			{
				container.removeChild(container.firstChild);
			}
			container.appendChild(node);

			var _requestAnimationFrame =
				typeof requestAnimationFrame !== 'undefined'
					? requestAnimationFrame
					: function(cb) { setTimeout(cb, 1000 / 60); }
					;

			// domUpdate is called whenever the main Signal changes.
			//
			// domUpdate and drawCallback implement a small state machine in order
			// to schedule only 1 draw per animation frame. This enforces that
			// once draw has been called, it will not be called again until the
			// next frame.
			//
			// drawCallback is scheduled whenever
			// 1. The state transitions from PENDING_REQUEST to EXTRA_REQUEST, or
			// 2. The state transitions from NO_REQUEST to PENDING_REQUEST
			//
			// Invariants:
			// 1. In the NO_REQUEST state, there is never a scheduled drawCallback.
			// 2. In the PENDING_REQUEST and EXTRA_REQUEST states, there is always exactly 1
			//    scheduled drawCallback.
			var NO_REQUEST = 0;
			var PENDING_REQUEST = 1;
			var EXTRA_REQUEST = 2;
			var state = NO_REQUEST;
			var savedScene = initialScene;
			var scheduledScene = initialScene;

			function domUpdate(newScene)
			{
				scheduledScene = newScene;

				switch (state)
				{
					case NO_REQUEST:
						_requestAnimationFrame(drawCallback);
						state = PENDING_REQUEST;
						return;
					case PENDING_REQUEST:
						state = PENDING_REQUEST;
						return;
					case EXTRA_REQUEST:
						state = PENDING_REQUEST;
						return;
				}
			}

			function drawCallback()
			{
				switch (state)
				{
					case NO_REQUEST:
						// This state should not be possible. How can there be no
						// request, yet somehow we are actively fulfilling a
						// request?
						throw new Error(
							'Unexpected draw callback.\n' +
							'Please report this to <https://github.com/elm-lang/core/issues>.'
						);

					case PENDING_REQUEST:
						// At this point, we do not *know* that another frame is
						// needed, but we make an extra request to rAF just in
						// case. It's possible to drop a frame if rAF is called
						// too late, so we just do it preemptively.
						_requestAnimationFrame(drawCallback);
						state = EXTRA_REQUEST;

						// There's also stuff we definitely need to draw.
						draw();
						return;

					case EXTRA_REQUEST:
						// Turns out the extra request was not needed, so we will
						// stop calling rAF. No reason to call it all the time if
						// no one needs it.
						state = NO_REQUEST;
						return;
				}
			}

			function draw()
			{
				update(elm.node.firstChild, savedScene, scheduledScene);
				if (elm.Native.Window)
				{
					elm.Native.Window.values.resizeIfNeeded();
				}
				savedScene = scheduledScene;
			}

			var renderer = Elm.Native.Signal.make(elm).output('main', domUpdate, signalGraph);

			// must check for resize after 'renderer' is created so
			// that changes show up.
			if (elm.Native.Window)
			{
				elm.Native.Window.values.resizeIfNeeded();
			}

			return renderer;
		}

		//// HOT SWAPPING ////

		// Returns boolean indicating if the swap was successful.
		// Requires that the two signal graphs have exactly the same
		// structure.
		function hotSwap(from, to)
		{
			function similar(nodeOld, nodeNew)
			{
				if (nodeOld.id !== nodeNew.id)
				{
					return false;
				}
				if (nodeOld.isOutput)
				{
					return nodeNew.isOutput;
				}
				return nodeOld.kids.length === nodeNew.kids.length;
			}
			function swap(nodeOld, nodeNew)
			{
				nodeNew.value = nodeOld.value;
				return true;
			}
			var canSwap = depthFirstTraversals(similar, from.inputs, to.inputs);
			if (canSwap)
			{
				depthFirstTraversals(swap, from.inputs, to.inputs);
			}
			from.node.parentNode.replaceChild(to.node, from.node);

			return canSwap;
		}

		// Returns false if the node operation f ever fails.
		function depthFirstTraversals(f, queueOld, queueNew)
		{
			if (queueOld.length !== queueNew.length)
			{
				return false;
			}
			queueOld = queueOld.slice(0);
			queueNew = queueNew.slice(0);

			var seen = [];
			while (queueOld.length > 0 && queueNew.length > 0)
			{
				var nodeOld = queueOld.pop();
				var nodeNew = queueNew.pop();
				if (seen.indexOf(nodeOld.id) < 0)
				{
					if (!f(nodeOld, nodeNew))
					{
						return false;
					}
					queueOld = queueOld.concat(nodeOld.kids || []);
					queueNew = queueNew.concat(nodeNew.kids || []);
					seen.push(nodeOld.id);
				}
			}
			return true;
		}
	}());

	function F2(fun)
	{
		function wrapper(a) { return function(b) { return fun(a,b); }; }
		wrapper.arity = 2;
		wrapper.func = fun;
		return wrapper;
	}

	function F3(fun)
	{
		function wrapper(a) {
			return function(b) { return function(c) { return fun(a, b, c); }; };
		}
		wrapper.arity = 3;
		wrapper.func = fun;
		return wrapper;
	}

	function F4(fun)
	{
		function wrapper(a) { return function(b) { return function(c) {
			return function(d) { return fun(a, b, c, d); }; }; };
		}
		wrapper.arity = 4;
		wrapper.func = fun;
		return wrapper;
	}

	function F5(fun)
	{
		function wrapper(a) { return function(b) { return function(c) {
			return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };
		}
		wrapper.arity = 5;
		wrapper.func = fun;
		return wrapper;
	}

	function F6(fun)
	{
		function wrapper(a) { return function(b) { return function(c) {
			return function(d) { return function(e) { return function(f) {
			return fun(a, b, c, d, e, f); }; }; }; }; };
		}
		wrapper.arity = 6;
		wrapper.func = fun;
		return wrapper;
	}

	function F7(fun)
	{
		function wrapper(a) { return function(b) { return function(c) {
			return function(d) { return function(e) { return function(f) {
			return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };
		}
		wrapper.arity = 7;
		wrapper.func = fun;
		return wrapper;
	}

	function F8(fun)
	{
		function wrapper(a) { return function(b) { return function(c) {
			return function(d) { return function(e) { return function(f) {
			return function(g) { return function(h) {
			return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };
		}
		wrapper.arity = 8;
		wrapper.func = fun;
		return wrapper;
	}

	function F9(fun)
	{
		function wrapper(a) { return function(b) { return function(c) {
			return function(d) { return function(e) { return function(f) {
			return function(g) { return function(h) { return function(i) {
			return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };
		}
		wrapper.arity = 9;
		wrapper.func = fun;
		return wrapper;
	}

	function A2(fun, a, b)
	{
		return fun.arity === 2
			? fun.func(a, b)
			: fun(a)(b);
	}
	function A3(fun, a, b, c)
	{
		return fun.arity === 3
			? fun.func(a, b, c)
			: fun(a)(b)(c);
	}
	function A4(fun, a, b, c, d)
	{
		return fun.arity === 4
			? fun.func(a, b, c, d)
			: fun(a)(b)(c)(d);
	}
	function A5(fun, a, b, c, d, e)
	{
		return fun.arity === 5
			? fun.func(a, b, c, d, e)
			: fun(a)(b)(c)(d)(e);
	}
	function A6(fun, a, b, c, d, e, f)
	{
		return fun.arity === 6
			? fun.func(a, b, c, d, e, f)
			: fun(a)(b)(c)(d)(e)(f);
	}
	function A7(fun, a, b, c, d, e, f, g)
	{
		return fun.arity === 7
			? fun.func(a, b, c, d, e, f, g)
			: fun(a)(b)(c)(d)(e)(f)(g);
	}
	function A8(fun, a, b, c, d, e, f, g, h)
	{
		return fun.arity === 8
			? fun.func(a, b, c, d, e, f, g, h)
			: fun(a)(b)(c)(d)(e)(f)(g)(h);
	}
	function A9(fun, a, b, c, d, e, f, g, h, i)
	{
		return fun.arity === 9
			? fun.func(a, b, c, d, e, f, g, h, i)
			: fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
	}
}

Elm.Native = Elm.Native || {};
Elm.Native.Utils = {};
Elm.Native.Utils.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Utils = localRuntime.Native.Utils || {};
	if (localRuntime.Native.Utils.values)
	{
		return localRuntime.Native.Utils.values;
	}


	// COMPARISONS

	function eq(l, r)
	{
		var stack = [{'x': l, 'y': r}];
		while (stack.length > 0)
		{
			var front = stack.pop();
			var x = front.x;
			var y = front.y;
			if (x === y)
			{
				continue;
			}
			if (typeof x === 'object')
			{
				var c = 0;
				for (var i in x)
				{
					++c;
					if (i in y)
					{
						if (i !== 'ctor')
						{
							stack.push({ 'x': x[i], 'y': y[i] });
						}
					}
					else
					{
						return false;
					}
				}
				if ('ctor' in x)
				{
					stack.push({'x': x.ctor, 'y': y.ctor});
				}
				if (c !== Object.keys(y).length)
				{
					return false;
				}
			}
			else if (typeof x === 'function')
			{
				throw new Error('Equality error: general function equality is ' +
								'undecidable, and therefore, unsupported');
			}
			else
			{
				return false;
			}
		}
		return true;
	}

	// code in Generate/JavaScript.hs depends on the particular
	// integer values assigned to LT, EQ, and GT
	var LT = -1, EQ = 0, GT = 1, ord = ['LT', 'EQ', 'GT'];

	function compare(x, y)
	{
		return {
			ctor: ord[cmp(x, y) + 1]
		};
	}

	function cmp(x, y) {
		var ord;
		if (typeof x !== 'object')
		{
			return x === y ? EQ : x < y ? LT : GT;
		}
		else if (x.isChar)
		{
			var a = x.toString();
			var b = y.toString();
			return a === b
				? EQ
				: a < b
					? LT
					: GT;
		}
		else if (x.ctor === '::' || x.ctor === '[]')
		{
			while (true)
			{
				if (x.ctor === '[]' && y.ctor === '[]')
				{
					return EQ;
				}
				if (x.ctor !== y.ctor)
				{
					return x.ctor === '[]' ? LT : GT;
				}
				ord = cmp(x._0, y._0);
				if (ord !== EQ)
				{
					return ord;
				}
				x = x._1;
				y = y._1;
			}
		}
		else if (x.ctor.slice(0, 6) === '_Tuple')
		{
			var n = x.ctor.slice(6) - 0;
			var err = 'cannot compare tuples with more than 6 elements.';
			if (n === 0) return EQ;
			if (n >= 1) { ord = cmp(x._0, y._0); if (ord !== EQ) return ord;
			if (n >= 2) { ord = cmp(x._1, y._1); if (ord !== EQ) return ord;
			if (n >= 3) { ord = cmp(x._2, y._2); if (ord !== EQ) return ord;
			if (n >= 4) { ord = cmp(x._3, y._3); if (ord !== EQ) return ord;
			if (n >= 5) { ord = cmp(x._4, y._4); if (ord !== EQ) return ord;
			if (n >= 6) { ord = cmp(x._5, y._5); if (ord !== EQ) return ord;
			if (n >= 7) throw new Error('Comparison error: ' + err); } } } } } }
			return EQ;
		}
		else
		{
			throw new Error('Comparison error: comparison is only defined on ints, ' +
							'floats, times, chars, strings, lists of comparable values, ' +
							'and tuples of comparable values.');
		}
	}


	// TUPLES

	var Tuple0 = {
		ctor: '_Tuple0'
	};

	function Tuple2(x, y)
	{
		return {
			ctor: '_Tuple2',
			_0: x,
			_1: y
		};
	}


	// LITERALS

	function chr(c)
	{
		var x = new String(c);
		x.isChar = true;
		return x;
	}

	function txt(str)
	{
		var t = new String(str);
		t.text = true;
		return t;
	}


	// GUID

	var count = 0;
	function guid(_)
	{
		return count++;
	}


	// RECORDS

	function update(oldRecord, updatedFields)
	{
		var newRecord = {};
		for (var key in oldRecord)
		{
			var value = (key in updatedFields) ? updatedFields[key] : oldRecord[key];
			newRecord[key] = value;
		}
		return newRecord;
	}


	// MOUSE COORDINATES

	function getXY(e)
	{
		var posx = 0;
		var posy = 0;
		if (e.pageX || e.pageY)
		{
			posx = e.pageX;
			posy = e.pageY;
		}
		else if (e.clientX || e.clientY)
		{
			posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
			posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
		}

		if (localRuntime.isEmbed())
		{
			var rect = localRuntime.node.getBoundingClientRect();
			var relx = rect.left + document.body.scrollLeft + document.documentElement.scrollLeft;
			var rely = rect.top + document.body.scrollTop + document.documentElement.scrollTop;
			// TODO: figure out if there is a way to avoid rounding here
			posx = posx - Math.round(relx) - localRuntime.node.clientLeft;
			posy = posy - Math.round(rely) - localRuntime.node.clientTop;
		}
		return Tuple2(posx, posy);
	}


	//// LIST STUFF ////

	var Nil = { ctor: '[]' };

	function Cons(hd, tl)
	{
		return {
			ctor: '::',
			_0: hd,
			_1: tl
		};
	}

	function list(arr)
	{
		var out = Nil;
		for (var i = arr.length; i--; )
		{
			out = Cons(arr[i], out);
		}
		return out;
	}

	function range(lo, hi)
	{
		var list = Nil;
		if (lo <= hi)
		{
			do
			{
				list = Cons(hi, list);
			}
			while (hi-- > lo);
		}
		return list;
	}

	function append(xs, ys)
	{
		// append Strings
		if (typeof xs === 'string')
		{
			return xs + ys;
		}

		// append Text
		if (xs.ctor.slice(0, 5) === 'Text:')
		{
			return {
				ctor: 'Text:Append',
				_0: xs,
				_1: ys
			};
		}


		// append Lists
		if (xs.ctor === '[]')
		{
			return ys;
		}
		var root = Cons(xs._0, Nil);
		var curr = root;
		xs = xs._1;
		while (xs.ctor !== '[]')
		{
			curr._1 = Cons(xs._0, Nil);
			xs = xs._1;
			curr = curr._1;
		}
		curr._1 = ys;
		return root;
	}


	// CRASHES

	function crash(moduleName, region)
	{
		return function(message) {
			throw new Error(
				'Ran into a `Debug.crash` in module `' + moduleName + '` ' + regionToString(region) + '\n'
				+ 'The message provided by the code author is:\n\n    '
				+ message
			);
		};
	}

	function crashCase(moduleName, region, value)
	{
		return function(message) {
			throw new Error(
				'Ran into a `Debug.crash` in module `' + moduleName + '`\n\n'
				+ 'This was caused by the `case` expression ' + regionToString(region) + '.\n'
				+ 'One of the branches ended with a crash and the following value got through:\n\n    ' + toString(value) + '\n\n'
				+ 'The message provided by the code author is:\n\n    '
				+ message
			);
		};
	}

	function regionToString(region)
	{
		if (region.start.line == region.end.line)
		{
			return 'on line ' + region.start.line;
		}
		return 'between lines ' + region.start.line + ' and ' + region.end.line;
	}


	// BAD PORTS

	function badPort(expected, received)
	{
		throw new Error(
			'Runtime error when sending values through a port.\n\n'
			+ 'Expecting ' + expected + ' but was given ' + formatValue(received)
		);
	}

	function formatValue(value)
	{
		// Explicity format undefined values as "undefined"
		// because JSON.stringify(undefined) unhelpfully returns ""
		return (value === undefined) ? "undefined" : JSON.stringify(value);
	}


	// TO STRING

	var _Array;
	var Dict;
	var List;

	var toString = function(v)
	{
		var type = typeof v;
		if (type === 'function')
		{
			var name = v.func ? v.func.name : v.name;
			return '<function' + (name === '' ? '' : ': ') + name + '>';
		}
		else if (type === 'boolean')
		{
			return v ? 'True' : 'False';
		}
		else if (type === 'number')
		{
			return v + '';
		}
		else if ((v instanceof String) && v.isChar)
		{
			return '\'' + addSlashes(v, true) + '\'';
		}
		else if (type === 'string')
		{
			return '"' + addSlashes(v, false) + '"';
		}
		else if (type === 'object' && 'ctor' in v)
		{
			if (v.ctor.substring(0, 6) === '_Tuple')
			{
				var output = [];
				for (var k in v)
				{
					if (k === 'ctor') continue;
					output.push(toString(v[k]));
				}
				return '(' + output.join(',') + ')';
			}
			else if (v.ctor === '_Array')
			{
				if (!_Array)
				{
					_Array = Elm.Array.make(localRuntime);
				}
				var list = _Array.toList(v);
				return 'Array.fromList ' + toString(list);
			}
			else if (v.ctor === '::')
			{
				var output = '[' + toString(v._0);
				v = v._1;
				while (v.ctor === '::')
				{
					output += ',' + toString(v._0);
					v = v._1;
				}
				return output + ']';
			}
			else if (v.ctor === '[]')
			{
				return '[]';
			}
			else if (v.ctor === 'RBNode_elm_builtin' || v.ctor === 'RBEmpty_elm_builtin' || v.ctor === 'Set_elm_builtin')
			{
				if (!Dict)
				{
					Dict = Elm.Dict.make(localRuntime);
				}
				var list;
				var name;
				if (v.ctor === 'Set_elm_builtin')
				{
					if (!List)
					{
						List = Elm.List.make(localRuntime);
					}
					name = 'Set';
					list = A2(List.map, function(x) {return x._0; }, Dict.toList(v._0));
				}
				else
				{
					name = 'Dict';
					list = Dict.toList(v);
				}
				return name + '.fromList ' + toString(list);
			}
			else if (v.ctor.slice(0, 5) === 'Text:')
			{
				return '<text>';
			}
			else if (v.ctor === 'Element_elm_builtin')
			{
				return '<element>'
			}
			else if (v.ctor === 'Form_elm_builtin')
			{
				return '<form>'
			}
			else
			{
				var output = '';
				for (var i in v)
				{
					if (i === 'ctor') continue;
					var str = toString(v[i]);
					var parenless = str[0] === '{' || str[0] === '<' || str.indexOf(' ') < 0;
					output += ' ' + (parenless ? str : '(' + str + ')');
				}
				return v.ctor + output;
			}
		}
		else if (type === 'object' && 'notify' in v && 'id' in v)
		{
			return '<signal>';
		}
		else if (type === 'object')
		{
			var output = [];
			for (var k in v)
			{
				output.push(k + ' = ' + toString(v[k]));
			}
			if (output.length === 0)
			{
				return '{}';
			}
			return '{ ' + output.join(', ') + ' }';
		}
		return '<internal structure>';
	};

	function addSlashes(str, isChar)
	{
		var s = str.replace(/\\/g, '\\\\')
				  .replace(/\n/g, '\\n')
				  .replace(/\t/g, '\\t')
				  .replace(/\r/g, '\\r')
				  .replace(/\v/g, '\\v')
				  .replace(/\0/g, '\\0');
		if (isChar)
		{
			return s.replace(/\'/g, '\\\'');
		}
		else
		{
			return s.replace(/\"/g, '\\"');
		}
	}


	return localRuntime.Native.Utils.values = {
		eq: eq,
		cmp: cmp,
		compare: F2(compare),
		Tuple0: Tuple0,
		Tuple2: Tuple2,
		chr: chr,
		txt: txt,
		update: update,
		guid: guid,
		getXY: getXY,

		Nil: Nil,
		Cons: Cons,
		list: list,
		range: range,
		append: F2(append),

		crash: crash,
		crashCase: crashCase,
		badPort: badPort,

		toString: toString
	};
};

Elm.Basics = Elm.Basics || {};
Elm.Basics.make = function (_elm) {
   "use strict";
   _elm.Basics = _elm.Basics || {};
   if (_elm.Basics.values) return _elm.Basics.values;
   var _U = Elm.Native.Utils.make(_elm),$Native$Basics = Elm.Native.Basics.make(_elm),$Native$Utils = Elm.Native.Utils.make(_elm);
   var _op = {};
   var uncurry = F2(function (f,_p0) {    var _p1 = _p0;return A2(f,_p1._0,_p1._1);});
   var curry = F3(function (f,a,b) {    return f({ctor: "_Tuple2",_0: a,_1: b});});
   var flip = F3(function (f,b,a) {    return A2(f,a,b);});
   var snd = function (_p2) {    var _p3 = _p2;return _p3._1;};
   var fst = function (_p4) {    var _p5 = _p4;return _p5._0;};
   var always = F2(function (a,_p6) {    return a;});
   var identity = function (x) {    return x;};
   _op["<|"] = F2(function (f,x) {    return f(x);});
   _op["|>"] = F2(function (x,f) {    return f(x);});
   _op[">>"] = F3(function (f,g,x) {    return g(f(x));});
   _op["<<"] = F3(function (g,f,x) {    return g(f(x));});
   _op["++"] = $Native$Utils.append;
   var toString = $Native$Utils.toString;
   var isInfinite = $Native$Basics.isInfinite;
   var isNaN = $Native$Basics.isNaN;
   var toFloat = $Native$Basics.toFloat;
   var ceiling = $Native$Basics.ceiling;
   var floor = $Native$Basics.floor;
   var truncate = $Native$Basics.truncate;
   var round = $Native$Basics.round;
   var not = $Native$Basics.not;
   var xor = $Native$Basics.xor;
   _op["||"] = $Native$Basics.or;
   _op["&&"] = $Native$Basics.and;
   var max = $Native$Basics.max;
   var min = $Native$Basics.min;
   var GT = {ctor: "GT"};
   var EQ = {ctor: "EQ"};
   var LT = {ctor: "LT"};
   var compare = $Native$Basics.compare;
   _op[">="] = $Native$Basics.ge;
   _op["<="] = $Native$Basics.le;
   _op[">"] = $Native$Basics.gt;
   _op["<"] = $Native$Basics.lt;
   _op["/="] = $Native$Basics.neq;
   _op["=="] = $Native$Basics.eq;
   var e = $Native$Basics.e;
   var pi = $Native$Basics.pi;
   var clamp = $Native$Basics.clamp;
   var logBase = $Native$Basics.logBase;
   var abs = $Native$Basics.abs;
   var negate = $Native$Basics.negate;
   var sqrt = $Native$Basics.sqrt;
   var atan2 = $Native$Basics.atan2;
   var atan = $Native$Basics.atan;
   var asin = $Native$Basics.asin;
   var acos = $Native$Basics.acos;
   var tan = $Native$Basics.tan;
   var sin = $Native$Basics.sin;
   var cos = $Native$Basics.cos;
   _op["^"] = $Native$Basics.exp;
   _op["%"] = $Native$Basics.mod;
   var rem = $Native$Basics.rem;
   _op["//"] = $Native$Basics.div;
   _op["/"] = $Native$Basics.floatDiv;
   _op["*"] = $Native$Basics.mul;
   _op["-"] = $Native$Basics.sub;
   _op["+"] = $Native$Basics.add;
   var toPolar = $Native$Basics.toPolar;
   var fromPolar = $Native$Basics.fromPolar;
   var turns = $Native$Basics.turns;
   var degrees = $Native$Basics.degrees;
   var radians = function (t) {    return t;};
   return _elm.Basics.values = {_op: _op
                               ,max: max
                               ,min: min
                               ,compare: compare
                               ,not: not
                               ,xor: xor
                               ,rem: rem
                               ,negate: negate
                               ,abs: abs
                               ,sqrt: sqrt
                               ,clamp: clamp
                               ,logBase: logBase
                               ,e: e
                               ,pi: pi
                               ,cos: cos
                               ,sin: sin
                               ,tan: tan
                               ,acos: acos
                               ,asin: asin
                               ,atan: atan
                               ,atan2: atan2
                               ,round: round
                               ,floor: floor
                               ,ceiling: ceiling
                               ,truncate: truncate
                               ,toFloat: toFloat
                               ,degrees: degrees
                               ,radians: radians
                               ,turns: turns
                               ,toPolar: toPolar
                               ,fromPolar: fromPolar
                               ,isNaN: isNaN
                               ,isInfinite: isInfinite
                               ,toString: toString
                               ,fst: fst
                               ,snd: snd
                               ,identity: identity
                               ,always: always
                               ,flip: flip
                               ,curry: curry
                               ,uncurry: uncurry
                               ,LT: LT
                               ,EQ: EQ
                               ,GT: GT};
};
Elm.Maybe = Elm.Maybe || {};
Elm.Maybe.make = function (_elm) {
   "use strict";
   _elm.Maybe = _elm.Maybe || {};
   if (_elm.Maybe.values) return _elm.Maybe.values;
   var _U = Elm.Native.Utils.make(_elm);
   var _op = {};
   var withDefault = F2(function ($default,maybe) {    var _p0 = maybe;if (_p0.ctor === "Just") {    return _p0._0;} else {    return $default;}});
   var Nothing = {ctor: "Nothing"};
   var oneOf = function (maybes) {
      oneOf: while (true) {
         var _p1 = maybes;
         if (_p1.ctor === "[]") {
               return Nothing;
            } else {
               var _p3 = _p1._0;
               var _p2 = _p3;
               if (_p2.ctor === "Nothing") {
                     var _v3 = _p1._1;
                     maybes = _v3;
                     continue oneOf;
                  } else {
                     return _p3;
                  }
            }
      }
   };
   var andThen = F2(function (maybeValue,callback) {
      var _p4 = maybeValue;
      if (_p4.ctor === "Just") {
            return callback(_p4._0);
         } else {
            return Nothing;
         }
   });
   var Just = function (a) {    return {ctor: "Just",_0: a};};
   var map = F2(function (f,maybe) {    var _p5 = maybe;if (_p5.ctor === "Just") {    return Just(f(_p5._0));} else {    return Nothing;}});
   var map2 = F3(function (func,ma,mb) {
      var _p6 = {ctor: "_Tuple2",_0: ma,_1: mb};
      if (_p6.ctor === "_Tuple2" && _p6._0.ctor === "Just" && _p6._1.ctor === "Just") {
            return Just(A2(func,_p6._0._0,_p6._1._0));
         } else {
            return Nothing;
         }
   });
   var map3 = F4(function (func,ma,mb,mc) {
      var _p7 = {ctor: "_Tuple3",_0: ma,_1: mb,_2: mc};
      if (_p7.ctor === "_Tuple3" && _p7._0.ctor === "Just" && _p7._1.ctor === "Just" && _p7._2.ctor === "Just") {
            return Just(A3(func,_p7._0._0,_p7._1._0,_p7._2._0));
         } else {
            return Nothing;
         }
   });
   var map4 = F5(function (func,ma,mb,mc,md) {
      var _p8 = {ctor: "_Tuple4",_0: ma,_1: mb,_2: mc,_3: md};
      if (_p8.ctor === "_Tuple4" && _p8._0.ctor === "Just" && _p8._1.ctor === "Just" && _p8._2.ctor === "Just" && _p8._3.ctor === "Just") {
            return Just(A4(func,_p8._0._0,_p8._1._0,_p8._2._0,_p8._3._0));
         } else {
            return Nothing;
         }
   });
   var map5 = F6(function (func,ma,mb,mc,md,me) {
      var _p9 = {ctor: "_Tuple5",_0: ma,_1: mb,_2: mc,_3: md,_4: me};
      if (_p9.ctor === "_Tuple5" && _p9._0.ctor === "Just" && _p9._1.ctor === "Just" && _p9._2.ctor === "Just" && _p9._3.ctor === "Just" && _p9._4.ctor === "Just")
      {
            return Just(A5(func,_p9._0._0,_p9._1._0,_p9._2._0,_p9._3._0,_p9._4._0));
         } else {
            return Nothing;
         }
   });
   return _elm.Maybe.values = {_op: _op
                              ,andThen: andThen
                              ,map: map
                              ,map2: map2
                              ,map3: map3
                              ,map4: map4
                              ,map5: map5
                              ,withDefault: withDefault
                              ,oneOf: oneOf
                              ,Just: Just
                              ,Nothing: Nothing};
};
Elm.Native.List = {};
Elm.Native.List.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.List = localRuntime.Native.List || {};
	if (localRuntime.Native.List.values)
	{
		return localRuntime.Native.List.values;
	}
	if ('values' in Elm.Native.List)
	{
		return localRuntime.Native.List.values = Elm.Native.List.values;
	}

	var Utils = Elm.Native.Utils.make(localRuntime);

	var Nil = Utils.Nil;
	var Cons = Utils.Cons;

	var fromArray = Utils.list;

	function toArray(xs)
	{
		var out = [];
		while (xs.ctor !== '[]')
		{
			out.push(xs._0);
			xs = xs._1;
		}
		return out;
	}

	// f defined similarly for both foldl and foldr (NB: different from Haskell)
	// ie, foldl : (a -> b -> b) -> b -> [a] -> b
	function foldl(f, b, xs)
	{
		var acc = b;
		while (xs.ctor !== '[]')
		{
			acc = A2(f, xs._0, acc);
			xs = xs._1;
		}
		return acc;
	}

	function foldr(f, b, xs)
	{
		var arr = toArray(xs);
		var acc = b;
		for (var i = arr.length; i--; )
		{
			acc = A2(f, arr[i], acc);
		}
		return acc;
	}

	function map2(f, xs, ys)
	{
		var arr = [];
		while (xs.ctor !== '[]' && ys.ctor !== '[]')
		{
			arr.push(A2(f, xs._0, ys._0));
			xs = xs._1;
			ys = ys._1;
		}
		return fromArray(arr);
	}

	function map3(f, xs, ys, zs)
	{
		var arr = [];
		while (xs.ctor !== '[]' && ys.ctor !== '[]' && zs.ctor !== '[]')
		{
			arr.push(A3(f, xs._0, ys._0, zs._0));
			xs = xs._1;
			ys = ys._1;
			zs = zs._1;
		}
		return fromArray(arr);
	}

	function map4(f, ws, xs, ys, zs)
	{
		var arr = [];
		while (   ws.ctor !== '[]'
			   && xs.ctor !== '[]'
			   && ys.ctor !== '[]'
			   && zs.ctor !== '[]')
		{
			arr.push(A4(f, ws._0, xs._0, ys._0, zs._0));
			ws = ws._1;
			xs = xs._1;
			ys = ys._1;
			zs = zs._1;
		}
		return fromArray(arr);
	}

	function map5(f, vs, ws, xs, ys, zs)
	{
		var arr = [];
		while (   vs.ctor !== '[]'
			   && ws.ctor !== '[]'
			   && xs.ctor !== '[]'
			   && ys.ctor !== '[]'
			   && zs.ctor !== '[]')
		{
			arr.push(A5(f, vs._0, ws._0, xs._0, ys._0, zs._0));
			vs = vs._1;
			ws = ws._1;
			xs = xs._1;
			ys = ys._1;
			zs = zs._1;
		}
		return fromArray(arr);
	}

	function sortBy(f, xs)
	{
		return fromArray(toArray(xs).sort(function(a, b) {
			return Utils.cmp(f(a), f(b));
		}));
	}

	function sortWith(f, xs)
	{
		return fromArray(toArray(xs).sort(function(a, b) {
			var ord = f(a)(b).ctor;
			return ord === 'EQ' ? 0 : ord === 'LT' ? -1 : 1;
		}));
	}

	function take(n, xs)
	{
		var arr = [];
		while (xs.ctor !== '[]' && n > 0)
		{
			arr.push(xs._0);
			xs = xs._1;
			--n;
		}
		return fromArray(arr);
	}


	Elm.Native.List.values = {
		Nil: Nil,
		Cons: Cons,
		cons: F2(Cons),
		toArray: toArray,
		fromArray: fromArray,

		foldl: F3(foldl),
		foldr: F3(foldr),

		map2: F3(map2),
		map3: F4(map3),
		map4: F5(map4),
		map5: F6(map5),
		sortBy: F2(sortBy),
		sortWith: F2(sortWith),
		take: F2(take)
	};
	return localRuntime.Native.List.values = Elm.Native.List.values;
};

Elm.List = Elm.List || {};
Elm.List.make = function (_elm) {
   "use strict";
   _elm.List = _elm.List || {};
   if (_elm.List.values) return _elm.List.values;
   var _U = Elm.Native.Utils.make(_elm),$Basics = Elm.Basics.make(_elm),$Maybe = Elm.Maybe.make(_elm),$Native$List = Elm.Native.List.make(_elm);
   var _op = {};
   var sortWith = $Native$List.sortWith;
   var sortBy = $Native$List.sortBy;
   var sort = function (xs) {    return A2(sortBy,$Basics.identity,xs);};
   var drop = F2(function (n,list) {
      drop: while (true) if (_U.cmp(n,0) < 1) return list; else {
            var _p0 = list;
            if (_p0.ctor === "[]") {
                  return list;
               } else {
                  var _v1 = n - 1,_v2 = _p0._1;
                  n = _v1;
                  list = _v2;
                  continue drop;
               }
         }
   });
   var take = $Native$List.take;
   var map5 = $Native$List.map5;
   var map4 = $Native$List.map4;
   var map3 = $Native$List.map3;
   var map2 = $Native$List.map2;
   var any = F2(function (isOkay,list) {
      any: while (true) {
         var _p1 = list;
         if (_p1.ctor === "[]") {
               return false;
            } else {
               if (isOkay(_p1._0)) return true; else {
                     var _v4 = isOkay,_v5 = _p1._1;
                     isOkay = _v4;
                     list = _v5;
                     continue any;
                  }
            }
      }
   });
   var all = F2(function (isOkay,list) {    return $Basics.not(A2(any,function (_p2) {    return $Basics.not(isOkay(_p2));},list));});
   var foldr = $Native$List.foldr;
   var foldl = $Native$List.foldl;
   var length = function (xs) {    return A3(foldl,F2(function (_p3,i) {    return i + 1;}),0,xs);};
   var sum = function (numbers) {    return A3(foldl,F2(function (x,y) {    return x + y;}),0,numbers);};
   var product = function (numbers) {    return A3(foldl,F2(function (x,y) {    return x * y;}),1,numbers);};
   var maximum = function (list) {
      var _p4 = list;
      if (_p4.ctor === "::") {
            return $Maybe.Just(A3(foldl,$Basics.max,_p4._0,_p4._1));
         } else {
            return $Maybe.Nothing;
         }
   };
   var minimum = function (list) {
      var _p5 = list;
      if (_p5.ctor === "::") {
            return $Maybe.Just(A3(foldl,$Basics.min,_p5._0,_p5._1));
         } else {
            return $Maybe.Nothing;
         }
   };
   var indexedMap = F2(function (f,xs) {    return A3(map2,f,_U.range(0,length(xs) - 1),xs);});
   var member = F2(function (x,xs) {    return A2(any,function (a) {    return _U.eq(a,x);},xs);});
   var isEmpty = function (xs) {    var _p6 = xs;if (_p6.ctor === "[]") {    return true;} else {    return false;}};
   var tail = function (list) {    var _p7 = list;if (_p7.ctor === "::") {    return $Maybe.Just(_p7._1);} else {    return $Maybe.Nothing;}};
   var head = function (list) {    var _p8 = list;if (_p8.ctor === "::") {    return $Maybe.Just(_p8._0);} else {    return $Maybe.Nothing;}};
   _op["::"] = $Native$List.cons;
   var map = F2(function (f,xs) {    return A3(foldr,F2(function (x,acc) {    return A2(_op["::"],f(x),acc);}),_U.list([]),xs);});
   var filter = F2(function (pred,xs) {
      var conditionalCons = F2(function (x,xs$) {    return pred(x) ? A2(_op["::"],x,xs$) : xs$;});
      return A3(foldr,conditionalCons,_U.list([]),xs);
   });
   var maybeCons = F3(function (f,mx,xs) {    var _p9 = f(mx);if (_p9.ctor === "Just") {    return A2(_op["::"],_p9._0,xs);} else {    return xs;}});
   var filterMap = F2(function (f,xs) {    return A3(foldr,maybeCons(f),_U.list([]),xs);});
   var reverse = function (list) {    return A3(foldl,F2(function (x,y) {    return A2(_op["::"],x,y);}),_U.list([]),list);};
   var scanl = F3(function (f,b,xs) {
      var scan1 = F2(function (x,accAcc) {
         var _p10 = accAcc;
         if (_p10.ctor === "::") {
               return A2(_op["::"],A2(f,x,_p10._0),accAcc);
            } else {
               return _U.list([]);
            }
      });
      return reverse(A3(foldl,scan1,_U.list([b]),xs));
   });
   var append = F2(function (xs,ys) {
      var _p11 = ys;
      if (_p11.ctor === "[]") {
            return xs;
         } else {
            return A3(foldr,F2(function (x,y) {    return A2(_op["::"],x,y);}),ys,xs);
         }
   });
   var concat = function (lists) {    return A3(foldr,append,_U.list([]),lists);};
   var concatMap = F2(function (f,list) {    return concat(A2(map,f,list));});
   var partition = F2(function (pred,list) {
      var step = F2(function (x,_p12) {
         var _p13 = _p12;
         var _p15 = _p13._0;
         var _p14 = _p13._1;
         return pred(x) ? {ctor: "_Tuple2",_0: A2(_op["::"],x,_p15),_1: _p14} : {ctor: "_Tuple2",_0: _p15,_1: A2(_op["::"],x,_p14)};
      });
      return A3(foldr,step,{ctor: "_Tuple2",_0: _U.list([]),_1: _U.list([])},list);
   });
   var unzip = function (pairs) {
      var step = F2(function (_p17,_p16) {
         var _p18 = _p17;
         var _p19 = _p16;
         return {ctor: "_Tuple2",_0: A2(_op["::"],_p18._0,_p19._0),_1: A2(_op["::"],_p18._1,_p19._1)};
      });
      return A3(foldr,step,{ctor: "_Tuple2",_0: _U.list([]),_1: _U.list([])},pairs);
   };
   var intersperse = F2(function (sep,xs) {
      var _p20 = xs;
      if (_p20.ctor === "[]") {
            return _U.list([]);
         } else {
            var step = F2(function (x,rest) {    return A2(_op["::"],sep,A2(_op["::"],x,rest));});
            var spersed = A3(foldr,step,_U.list([]),_p20._1);
            return A2(_op["::"],_p20._0,spersed);
         }
   });
   var repeatHelp = F3(function (result,n,value) {
      repeatHelp: while (true) if (_U.cmp(n,0) < 1) return result; else {
            var _v18 = A2(_op["::"],value,result),_v19 = n - 1,_v20 = value;
            result = _v18;
            n = _v19;
            value = _v20;
            continue repeatHelp;
         }
   });
   var repeat = F2(function (n,value) {    return A3(repeatHelp,_U.list([]),n,value);});
   return _elm.List.values = {_op: _op
                             ,isEmpty: isEmpty
                             ,length: length
                             ,reverse: reverse
                             ,member: member
                             ,head: head
                             ,tail: tail
                             ,filter: filter
                             ,take: take
                             ,drop: drop
                             ,repeat: repeat
                             ,append: append
                             ,concat: concat
                             ,intersperse: intersperse
                             ,partition: partition
                             ,unzip: unzip
                             ,map: map
                             ,map2: map2
                             ,map3: map3
                             ,map4: map4
                             ,map5: map5
                             ,filterMap: filterMap
                             ,concatMap: concatMap
                             ,indexedMap: indexedMap
                             ,foldr: foldr
                             ,foldl: foldl
                             ,sum: sum
                             ,product: product
                             ,maximum: maximum
                             ,minimum: minimum
                             ,all: all
                             ,any: any
                             ,scanl: scanl
                             ,sort: sort
                             ,sortBy: sortBy
                             ,sortWith: sortWith};
};
Elm.Native.Transform2D = {};
Elm.Native.Transform2D.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Transform2D = localRuntime.Native.Transform2D || {};
	if (localRuntime.Native.Transform2D.values)
	{
		return localRuntime.Native.Transform2D.values;
	}

	var A;
	if (typeof Float32Array === 'undefined')
	{
		A = function(arr)
		{
			this.length = arr.length;
			this[0] = arr[0];
			this[1] = arr[1];
			this[2] = arr[2];
			this[3] = arr[3];
			this[4] = arr[4];
			this[5] = arr[5];
		};
	}
	else
	{
		A = Float32Array;
	}

	// layout of matrix in an array is
	//
	//   | m11 m12 dx |
	//   | m21 m22 dy |
	//   |  0   0   1 |
	//
	//  new A([ m11, m12, dx, m21, m22, dy ])

	var identity = new A([1, 0, 0, 0, 1, 0]);
	function matrix(m11, m12, m21, m22, dx, dy)
	{
		return new A([m11, m12, dx, m21, m22, dy]);
	}

	function rotation(t)
	{
		var c = Math.cos(t);
		var s = Math.sin(t);
		return new A([c, -s, 0, s, c, 0]);
	}

	function rotate(t, m)
	{
		var c = Math.cos(t);
		var s = Math.sin(t);
		var m11 = m[0], m12 = m[1], m21 = m[3], m22 = m[4];
		return new A([m11 * c + m12 * s, -m11 * s + m12 * c, m[2],
					  m21 * c + m22 * s, -m21 * s + m22 * c, m[5]]);
	}
	/*
	function move(xy,m) {
		var x = xy._0;
		var y = xy._1;
		var m11 = m[0], m12 = m[1], m21 = m[3], m22 = m[4];
		return new A([m11, m12, m11*x + m12*y + m[2],
					  m21, m22, m21*x + m22*y + m[5]]);
	}
	function scale(s,m) { return new A([m[0]*s, m[1]*s, m[2], m[3]*s, m[4]*s, m[5]]); }
	function scaleX(x,m) { return new A([m[0]*x, m[1], m[2], m[3]*x, m[4], m[5]]); }
	function scaleY(y,m) { return new A([m[0], m[1]*y, m[2], m[3], m[4]*y, m[5]]); }
	function reflectX(m) { return new A([-m[0], m[1], m[2], -m[3], m[4], m[5]]); }
	function reflectY(m) { return new A([m[0], -m[1], m[2], m[3], -m[4], m[5]]); }

	function transform(m11, m21, m12, m22, mdx, mdy, n) {
		var n11 = n[0], n12 = n[1], n21 = n[3], n22 = n[4], ndx = n[2], ndy = n[5];
		return new A([m11*n11 + m12*n21,
					  m11*n12 + m12*n22,
					  m11*ndx + m12*ndy + mdx,
					  m21*n11 + m22*n21,
					  m21*n12 + m22*n22,
					  m21*ndx + m22*ndy + mdy]);
	}
	*/
	function multiply(m, n)
	{
		var m11 = m[0], m12 = m[1], m21 = m[3], m22 = m[4], mdx = m[2], mdy = m[5];
		var n11 = n[0], n12 = n[1], n21 = n[3], n22 = n[4], ndx = n[2], ndy = n[5];
		return new A([m11 * n11 + m12 * n21,
					  m11 * n12 + m12 * n22,
					  m11 * ndx + m12 * ndy + mdx,
					  m21 * n11 + m22 * n21,
					  m21 * n12 + m22 * n22,
					  m21 * ndx + m22 * ndy + mdy]);
	}

	return localRuntime.Native.Transform2D.values = {
		identity: identity,
		matrix: F6(matrix),
		rotation: rotation,
		multiply: F2(multiply)
		/*
		transform: F7(transform),
		rotate: F2(rotate),
		move: F2(move),
		scale: F2(scale),
		scaleX: F2(scaleX),
		scaleY: F2(scaleY),
		reflectX: reflectX,
		reflectY: reflectY
		*/
	};
};

Elm.Transform2D = Elm.Transform2D || {};
Elm.Transform2D.make = function (_elm) {
   "use strict";
   _elm.Transform2D = _elm.Transform2D || {};
   if (_elm.Transform2D.values) return _elm.Transform2D.values;
   var _U = Elm.Native.Utils.make(_elm),$Native$Transform2D = Elm.Native.Transform2D.make(_elm);
   var _op = {};
   var multiply = $Native$Transform2D.multiply;
   var rotation = $Native$Transform2D.rotation;
   var matrix = $Native$Transform2D.matrix;
   var translation = F2(function (x,y) {    return A6(matrix,1,0,0,1,x,y);});
   var scale = function (s) {    return A6(matrix,s,0,0,s,0,0);};
   var scaleX = function (x) {    return A6(matrix,x,0,0,1,0,0);};
   var scaleY = function (y) {    return A6(matrix,1,0,0,y,0,0);};
   var identity = $Native$Transform2D.identity;
   var Transform2D = {ctor: "Transform2D"};
   return _elm.Transform2D.values = {_op: _op
                                    ,identity: identity
                                    ,matrix: matrix
                                    ,multiply: multiply
                                    ,rotation: rotation
                                    ,translation: translation
                                    ,scale: scale
                                    ,scaleX: scaleX
                                    ,scaleY: scaleY};
};

// setup
Elm.Native = Elm.Native || {};
Elm.Native.Graphics = Elm.Native.Graphics || {};
Elm.Native.Graphics.Collage = Elm.Native.Graphics.Collage || {};

// definition
Elm.Native.Graphics.Collage.make = function(localRuntime) {
	'use strict';

	// attempt to short-circuit
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Graphics = localRuntime.Native.Graphics || {};
	localRuntime.Native.Graphics.Collage = localRuntime.Native.Graphics.Collage || {};
	if ('values' in localRuntime.Native.Graphics.Collage)
	{
		return localRuntime.Native.Graphics.Collage.values;
	}

	// okay, we cannot short-ciruit, so now we define everything
	var Color = Elm.Native.Color.make(localRuntime);
	var List = Elm.Native.List.make(localRuntime);
	var NativeElement = Elm.Native.Graphics.Element.make(localRuntime);
	var Transform = Elm.Transform2D.make(localRuntime);
	var Utils = Elm.Native.Utils.make(localRuntime);

	function setStrokeStyle(ctx, style)
	{
		ctx.lineWidth = style.width;

		var cap = style.cap.ctor;
		ctx.lineCap = cap === 'Flat'
			? 'butt'
			: cap === 'Round'
				? 'round'
				: 'square';

		var join = style.join.ctor;
		ctx.lineJoin = join === 'Smooth'
			? 'round'
			: join === 'Sharp'
				? 'miter'
				: 'bevel';

		ctx.miterLimit = style.join._0 || 10;
		ctx.strokeStyle = Color.toCss(style.color);
	}

	function setFillStyle(redo, ctx, style)
	{
		var sty = style.ctor;
		ctx.fillStyle = sty === 'Solid'
			? Color.toCss(style._0)
			: sty === 'Texture'
				? texture(redo, ctx, style._0)
				: gradient(ctx, style._0);
	}

	function trace(ctx, path)
	{
		var points = List.toArray(path);
		var i = points.length - 1;
		if (i <= 0)
		{
			return;
		}
		ctx.moveTo(points[i]._0, points[i]._1);
		while (i--)
		{
			ctx.lineTo(points[i]._0, points[i]._1);
		}
		if (path.closed)
		{
			i = points.length - 1;
			ctx.lineTo(points[i]._0, points[i]._1);
		}
	}

	function line(ctx, style, path)
	{
		if (style.dashing.ctor === '[]')
		{
			trace(ctx, path);
		}
		else
		{
			customLineHelp(ctx, style, path);
		}
		ctx.scale(1, -1);
		ctx.stroke();
	}

	function customLineHelp(ctx, style, path)
	{
		var points = List.toArray(path);
		if (path.closed)
		{
			points.push(points[0]);
		}
		var pattern = List.toArray(style.dashing);
		var i = points.length - 1;
		if (i <= 0)
		{
			return;
		}
		var x0 = points[i]._0, y0 = points[i]._1;
		var x1 = 0, y1 = 0, dx = 0, dy = 0, remaining = 0;
		var pindex = 0, plen = pattern.length;
		var draw = true, segmentLength = pattern[0];
		ctx.moveTo(x0, y0);
		while (i--)
		{
			x1 = points[i]._0;
			y1 = points[i]._1;
			dx = x1 - x0;
			dy = y1 - y0;
			remaining = Math.sqrt(dx * dx + dy * dy);
			while (segmentLength <= remaining)
			{
				x0 += dx * segmentLength / remaining;
				y0 += dy * segmentLength / remaining;
				ctx[draw ? 'lineTo' : 'moveTo'](x0, y0);
				// update starting position
				dx = x1 - x0;
				dy = y1 - y0;
				remaining = Math.sqrt(dx * dx + dy * dy);
				// update pattern
				draw = !draw;
				pindex = (pindex + 1) % plen;
				segmentLength = pattern[pindex];
			}
			if (remaining > 0)
			{
				ctx[draw ? 'lineTo' : 'moveTo'](x1, y1);
				segmentLength -= remaining;
			}
			x0 = x1;
			y0 = y1;
		}
	}

	function drawLine(ctx, style, path)
	{
		setStrokeStyle(ctx, style);
		return line(ctx, style, path);
	}

	function texture(redo, ctx, src)
	{
		var img = new Image();
		img.src = src;
		img.onload = redo;
		return ctx.createPattern(img, 'repeat');
	}

	function gradient(ctx, grad)
	{
		var g;
		var stops = [];
		if (grad.ctor === 'Linear')
		{
			var p0 = grad._0, p1 = grad._1;
			g = ctx.createLinearGradient(p0._0, -p0._1, p1._0, -p1._1);
			stops = List.toArray(grad._2);
		}
		else
		{
			var p0 = grad._0, p2 = grad._2;
			g = ctx.createRadialGradient(p0._0, -p0._1, grad._1, p2._0, -p2._1, grad._3);
			stops = List.toArray(grad._4);
		}
		var len = stops.length;
		for (var i = 0; i < len; ++i)
		{
			var stop = stops[i];
			g.addColorStop(stop._0, Color.toCss(stop._1));
		}
		return g;
	}

	function drawShape(redo, ctx, style, path)
	{
		trace(ctx, path);
		setFillStyle(redo, ctx, style);
		ctx.scale(1, -1);
		ctx.fill();
	}


	// TEXT RENDERING

	function fillText(redo, ctx, text)
	{
		drawText(ctx, text, ctx.fillText);
	}

	function strokeText(redo, ctx, style, text)
	{
		setStrokeStyle(ctx, style);
		// Use native canvas API for dashes only for text for now
		// Degrades to non-dashed on IE 9 + 10
		if (style.dashing.ctor !== '[]' && ctx.setLineDash)
		{
			var pattern = List.toArray(style.dashing);
			ctx.setLineDash(pattern);
		}
		drawText(ctx, text, ctx.strokeText);
	}

	function drawText(ctx, text, canvasDrawFn)
	{
		var textChunks = chunkText(defaultContext, text);

		var totalWidth = 0;
		var maxHeight = 0;
		var numChunks = textChunks.length;

		ctx.scale(1,-1);

		for (var i = numChunks; i--; )
		{
			var chunk = textChunks[i];
			ctx.font = chunk.font;
			var metrics = ctx.measureText(chunk.text);
			chunk.width = metrics.width;
			totalWidth += chunk.width;
			if (chunk.height > maxHeight)
			{
				maxHeight = chunk.height;
			}
		}

		var x = -totalWidth / 2.0;
		for (var i = 0; i < numChunks; ++i)
		{
			var chunk = textChunks[i];
			ctx.font = chunk.font;
			ctx.fillStyle = chunk.color;
			canvasDrawFn.call(ctx, chunk.text, x, maxHeight / 2);
			x += chunk.width;
		}
	}

	function toFont(props)
	{
		return [
			props['font-style'],
			props['font-variant'],
			props['font-weight'],
			props['font-size'],
			props['font-family']
		].join(' ');
	}


	// Convert the object returned by the text module
	// into something we can use for styling canvas text
	function chunkText(context, text)
	{
		var tag = text.ctor;
		if (tag === 'Text:Append')
		{
			var leftChunks = chunkText(context, text._0);
			var rightChunks = chunkText(context, text._1);
			return leftChunks.concat(rightChunks);
		}
		if (tag === 'Text:Text')
		{
			return [{
				text: text._0,
				color: context.color,
				height: context['font-size'].slice(0, -2) | 0,
				font: toFont(context)
			}];
		}
		if (tag === 'Text:Meta')
		{
			var newContext = freshContext(text._0, context);
			return chunkText(newContext, text._1);
		}
	}

	function freshContext(props, ctx)
	{
		return {
			'font-style': props['font-style'] || ctx['font-style'],
			'font-variant': props['font-variant'] || ctx['font-variant'],
			'font-weight': props['font-weight'] || ctx['font-weight'],
			'font-size': props['font-size'] || ctx['font-size'],
			'font-family': props['font-family'] || ctx['font-family'],
			'color': props['color'] || ctx['color']
		};
	}

	var defaultContext = {
		'font-style': 'normal',
		'font-variant': 'normal',
		'font-weight': 'normal',
		'font-size': '12px',
		'font-family': 'sans-serif',
		'color': 'black'
	};


	// IMAGES

	function drawImage(redo, ctx, form)
	{
		var img = new Image();
		img.onload = redo;
		img.src = form._3;
		var w = form._0,
			h = form._1,
			pos = form._2,
			srcX = pos._0,
			srcY = pos._1,
			srcW = w,
			srcH = h,
			destX = -w / 2,
			destY = -h / 2,
			destW = w,
			destH = h;

		ctx.scale(1, -1);
		ctx.drawImage(img, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
	}

	function renderForm(redo, ctx, form)
	{
		ctx.save();

		var x = form.x,
			y = form.y,
			theta = form.theta,
			scale = form.scale;

		if (x !== 0 || y !== 0)
		{
			ctx.translate(x, y);
		}
		if (theta !== 0)
		{
			ctx.rotate(theta % (Math.PI * 2));
		}
		if (scale !== 1)
		{
			ctx.scale(scale, scale);
		}
		if (form.alpha !== 1)
		{
			ctx.globalAlpha = ctx.globalAlpha * form.alpha;
		}

		ctx.beginPath();
		var f = form.form;
		switch (f.ctor)
		{
			case 'FPath':
				drawLine(ctx, f._0, f._1);
				break;

			case 'FImage':
				drawImage(redo, ctx, f);
				break;

			case 'FShape':
				if (f._0.ctor === 'Line')
				{
					f._1.closed = true;
					drawLine(ctx, f._0._0, f._1);
				}
				else
				{
					drawShape(redo, ctx, f._0._0, f._1);
				}
				break;

			case 'FText':
				fillText(redo, ctx, f._0);
				break;

			case 'FOutlinedText':
				strokeText(redo, ctx, f._0, f._1);
				break;
		}
		ctx.restore();
	}

	function formToMatrix(form)
	{
	   var scale = form.scale;
	   var matrix = A6( Transform.matrix, scale, 0, 0, scale, form.x, form.y );

	   var theta = form.theta;
	   if (theta !== 0)
	   {
		   matrix = A2( Transform.multiply, matrix, Transform.rotation(theta) );
	   }

	   return matrix;
	}

	function str(n)
	{
		if (n < 0.00001 && n > -0.00001)
		{
			return 0;
		}
		return n;
	}

	function makeTransform(w, h, form, matrices)
	{
		var props = form.form._0._0.props;
		var m = A6( Transform.matrix, 1, 0, 0, -1,
					(w - props.width ) / 2,
					(h - props.height) / 2 );
		var len = matrices.length;
		for (var i = 0; i < len; ++i)
		{
			m = A2( Transform.multiply, m, matrices[i] );
		}
		m = A2( Transform.multiply, m, formToMatrix(form) );

		return 'matrix(' +
			str( m[0]) + ', ' + str( m[3]) + ', ' +
			str(-m[1]) + ', ' + str(-m[4]) + ', ' +
			str( m[2]) + ', ' + str( m[5]) + ')';
	}

	function stepperHelp(list)
	{
		var arr = List.toArray(list);
		var i = 0;
		function peekNext()
		{
			return i < arr.length ? arr[i]._0.form.ctor : '';
		}
		// assumes that there is a next element
		function next()
		{
			var out = arr[i]._0;
			++i;
			return out;
		}
		return {
			peekNext: peekNext,
			next: next
		};
	}

	function formStepper(forms)
	{
		var ps = [stepperHelp(forms)];
		var matrices = [];
		var alphas = [];
		function peekNext()
		{
			var len = ps.length;
			var formType = '';
			for (var i = 0; i < len; ++i )
			{
				if (formType = ps[i].peekNext()) return formType;
			}
			return '';
		}
		// assumes that there is a next element
		function next(ctx)
		{
			while (!ps[0].peekNext())
			{
				ps.shift();
				matrices.pop();
				alphas.shift();
				if (ctx)
				{
					ctx.restore();
				}
			}
			var out = ps[0].next();
			var f = out.form;
			if (f.ctor === 'FGroup')
			{
				ps.unshift(stepperHelp(f._1));
				var m = A2(Transform.multiply, f._0, formToMatrix(out));
				ctx.save();
				ctx.transform(m[0], m[3], m[1], m[4], m[2], m[5]);
				matrices.push(m);

				var alpha = (alphas[0] || 1) * out.alpha;
				alphas.unshift(alpha);
				ctx.globalAlpha = alpha;
			}
			return out;
		}
		function transforms()
		{
			return matrices;
		}
		function alpha()
		{
			return alphas[0] || 1;
		}
		return {
			peekNext: peekNext,
			next: next,
			transforms: transforms,
			alpha: alpha
		};
	}

	function makeCanvas(w, h)
	{
		var canvas = NativeElement.createNode('canvas');
		canvas.style.width  = w + 'px';
		canvas.style.height = h + 'px';
		canvas.style.display = 'block';
		canvas.style.position = 'absolute';
		var ratio = window.devicePixelRatio || 1;
		canvas.width  = w * ratio;
		canvas.height = h * ratio;
		return canvas;
	}

	function render(model)
	{
		var div = NativeElement.createNode('div');
		div.style.overflow = 'hidden';
		div.style.position = 'relative';
		update(div, model, model);
		return div;
	}

	function nodeStepper(w, h, div)
	{
		var kids = div.childNodes;
		var i = 0;
		var ratio = window.devicePixelRatio || 1;

		function transform(transforms, ctx)
		{
			ctx.translate( w / 2 * ratio, h / 2 * ratio );
			ctx.scale( ratio, -ratio );
			var len = transforms.length;
			for (var i = 0; i < len; ++i)
			{
				var m = transforms[i];
				ctx.save();
				ctx.transform(m[0], m[3], m[1], m[4], m[2], m[5]);
			}
			return ctx;
		}
		function nextContext(transforms)
		{
			while (i < kids.length)
			{
				var node = kids[i];
				if (node.getContext)
				{
					node.width = w * ratio;
					node.height = h * ratio;
					node.style.width = w + 'px';
					node.style.height = h + 'px';
					++i;
					return transform(transforms, node.getContext('2d'));
				}
				div.removeChild(node);
			}
			var canvas = makeCanvas(w, h);
			div.appendChild(canvas);
			// we have added a new node, so we must step our position
			++i;
			return transform(transforms, canvas.getContext('2d'));
		}
		function addElement(matrices, alpha, form)
		{
			var kid = kids[i];
			var elem = form.form._0;

			var node = (!kid || kid.getContext)
				? NativeElement.render(elem)
				: NativeElement.update(kid, kid.oldElement, elem);

			node.style.position = 'absolute';
			node.style.opacity = alpha * form.alpha * elem._0.props.opacity;
			NativeElement.addTransform(node.style, makeTransform(w, h, form, matrices));
			node.oldElement = elem;
			++i;
			if (!kid)
			{
				div.appendChild(node);
			}
			else
			{
				div.insertBefore(node, kid);
			}
		}
		function clearRest()
		{
			while (i < kids.length)
			{
				div.removeChild(kids[i]);
			}
		}
		return {
			nextContext: nextContext,
			addElement: addElement,
			clearRest: clearRest
		};
	}


	function update(div, _, model)
	{
		var w = model.w;
		var h = model.h;

		var forms = formStepper(model.forms);
		var nodes = nodeStepper(w, h, div);
		var ctx = null;
		var formType = '';

		while (formType = forms.peekNext())
		{
			// make sure we have context if we need it
			if (ctx === null && formType !== 'FElement')
			{
				ctx = nodes.nextContext(forms.transforms());
				ctx.globalAlpha = forms.alpha();
			}

			var form = forms.next(ctx);
			// if it is FGroup, all updates are made within formStepper when next is called.
			if (formType === 'FElement')
			{
				// update or insert an element, get a new context
				nodes.addElement(forms.transforms(), forms.alpha(), form);
				ctx = null;
			}
			else if (formType !== 'FGroup')
			{
				renderForm(function() { update(div, model, model); }, ctx, form);
			}
		}
		nodes.clearRest();
		return div;
	}


	function collage(w, h, forms)
	{
		return A3(NativeElement.newElement, w, h, {
			ctor: 'Custom',
			type: 'Collage',
			render: render,
			update: update,
			model: {w: w, h: h, forms: forms}
		});
	}

	return localRuntime.Native.Graphics.Collage.values = {
		collage: F3(collage)
	};
};

Elm.Native.Color = {};
Elm.Native.Color.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Color = localRuntime.Native.Color || {};
	if (localRuntime.Native.Color.values)
	{
		return localRuntime.Native.Color.values;
	}

	function toCss(c)
	{
		var format = '';
		var colors = '';
		if (c.ctor === 'RGBA')
		{
			format = 'rgb';
			colors = c._0 + ', ' + c._1 + ', ' + c._2;
		}
		else
		{
			format = 'hsl';
			colors = (c._0 * 180 / Math.PI) + ', ' +
					 (c._1 * 100) + '%, ' +
					 (c._2 * 100) + '%';
		}
		if (c._3 === 1)
		{
			return format + '(' + colors + ')';
		}
		else
		{
			return format + 'a(' + colors + ', ' + c._3 + ')';
		}
	}

	return localRuntime.Native.Color.values = {
		toCss: toCss
	};
};

Elm.Color = Elm.Color || {};
Elm.Color.make = function (_elm) {
   "use strict";
   _elm.Color = _elm.Color || {};
   if (_elm.Color.values) return _elm.Color.values;
   var _U = Elm.Native.Utils.make(_elm),$Basics = Elm.Basics.make(_elm);
   var _op = {};
   var Radial = F5(function (a,b,c,d,e) {    return {ctor: "Radial",_0: a,_1: b,_2: c,_3: d,_4: e};});
   var radial = Radial;
   var Linear = F3(function (a,b,c) {    return {ctor: "Linear",_0: a,_1: b,_2: c};});
   var linear = Linear;
   var fmod = F2(function (f,n) {    var integer = $Basics.floor(f);return $Basics.toFloat(A2($Basics._op["%"],integer,n)) + f - $Basics.toFloat(integer);});
   var rgbToHsl = F3(function (red,green,blue) {
      var b = $Basics.toFloat(blue) / 255;
      var g = $Basics.toFloat(green) / 255;
      var r = $Basics.toFloat(red) / 255;
      var cMax = A2($Basics.max,A2($Basics.max,r,g),b);
      var cMin = A2($Basics.min,A2($Basics.min,r,g),b);
      var c = cMax - cMin;
      var lightness = (cMax + cMin) / 2;
      var saturation = _U.eq(lightness,0) ? 0 : c / (1 - $Basics.abs(2 * lightness - 1));
      var hue = $Basics.degrees(60) * (_U.eq(cMax,r) ? A2(fmod,(g - b) / c,6) : _U.eq(cMax,g) ? (b - r) / c + 2 : (r - g) / c + 4);
      return {ctor: "_Tuple3",_0: hue,_1: saturation,_2: lightness};
   });
   var hslToRgb = F3(function (hue,saturation,lightness) {
      var hue$ = hue / $Basics.degrees(60);
      var chroma = (1 - $Basics.abs(2 * lightness - 1)) * saturation;
      var x = chroma * (1 - $Basics.abs(A2(fmod,hue$,2) - 1));
      var _p0 = _U.cmp(hue$,0) < 0 ? {ctor: "_Tuple3",_0: 0,_1: 0,_2: 0} : _U.cmp(hue$,1) < 0 ? {ctor: "_Tuple3",_0: chroma,_1: x,_2: 0} : _U.cmp(hue$,
      2) < 0 ? {ctor: "_Tuple3",_0: x,_1: chroma,_2: 0} : _U.cmp(hue$,3) < 0 ? {ctor: "_Tuple3",_0: 0,_1: chroma,_2: x} : _U.cmp(hue$,4) < 0 ? {ctor: "_Tuple3"
                                                                                                                                               ,_0: 0
                                                                                                                                               ,_1: x
                                                                                                                                               ,_2: chroma} : _U.cmp(hue$,
      5) < 0 ? {ctor: "_Tuple3",_0: x,_1: 0,_2: chroma} : _U.cmp(hue$,6) < 0 ? {ctor: "_Tuple3",_0: chroma,_1: 0,_2: x} : {ctor: "_Tuple3",_0: 0,_1: 0,_2: 0};
      var r = _p0._0;
      var g = _p0._1;
      var b = _p0._2;
      var m = lightness - chroma / 2;
      return {ctor: "_Tuple3",_0: r + m,_1: g + m,_2: b + m};
   });
   var toRgb = function (color) {
      var _p1 = color;
      if (_p1.ctor === "RGBA") {
            return {red: _p1._0,green: _p1._1,blue: _p1._2,alpha: _p1._3};
         } else {
            var _p2 = A3(hslToRgb,_p1._0,_p1._1,_p1._2);
            var r = _p2._0;
            var g = _p2._1;
            var b = _p2._2;
            return {red: $Basics.round(255 * r),green: $Basics.round(255 * g),blue: $Basics.round(255 * b),alpha: _p1._3};
         }
   };
   var toHsl = function (color) {
      var _p3 = color;
      if (_p3.ctor === "HSLA") {
            return {hue: _p3._0,saturation: _p3._1,lightness: _p3._2,alpha: _p3._3};
         } else {
            var _p4 = A3(rgbToHsl,_p3._0,_p3._1,_p3._2);
            var h = _p4._0;
            var s = _p4._1;
            var l = _p4._2;
            return {hue: h,saturation: s,lightness: l,alpha: _p3._3};
         }
   };
   var HSLA = F4(function (a,b,c,d) {    return {ctor: "HSLA",_0: a,_1: b,_2: c,_3: d};});
   var hsla = F4(function (hue,saturation,lightness,alpha) {
      return A4(HSLA,hue - $Basics.turns($Basics.toFloat($Basics.floor(hue / (2 * $Basics.pi)))),saturation,lightness,alpha);
   });
   var hsl = F3(function (hue,saturation,lightness) {    return A4(hsla,hue,saturation,lightness,1);});
   var complement = function (color) {
      var _p5 = color;
      if (_p5.ctor === "HSLA") {
            return A4(hsla,_p5._0 + $Basics.degrees(180),_p5._1,_p5._2,_p5._3);
         } else {
            var _p6 = A3(rgbToHsl,_p5._0,_p5._1,_p5._2);
            var h = _p6._0;
            var s = _p6._1;
            var l = _p6._2;
            return A4(hsla,h + $Basics.degrees(180),s,l,_p5._3);
         }
   };
   var grayscale = function (p) {    return A4(HSLA,0,0,1 - p,1);};
   var greyscale = function (p) {    return A4(HSLA,0,0,1 - p,1);};
   var RGBA = F4(function (a,b,c,d) {    return {ctor: "RGBA",_0: a,_1: b,_2: c,_3: d};});
   var rgba = RGBA;
   var rgb = F3(function (r,g,b) {    return A4(RGBA,r,g,b,1);});
   var lightRed = A4(RGBA,239,41,41,1);
   var red = A4(RGBA,204,0,0,1);
   var darkRed = A4(RGBA,164,0,0,1);
   var lightOrange = A4(RGBA,252,175,62,1);
   var orange = A4(RGBA,245,121,0,1);
   var darkOrange = A4(RGBA,206,92,0,1);
   var lightYellow = A4(RGBA,255,233,79,1);
   var yellow = A4(RGBA,237,212,0,1);
   var darkYellow = A4(RGBA,196,160,0,1);
   var lightGreen = A4(RGBA,138,226,52,1);
   var green = A4(RGBA,115,210,22,1);
   var darkGreen = A4(RGBA,78,154,6,1);
   var lightBlue = A4(RGBA,114,159,207,1);
   var blue = A4(RGBA,52,101,164,1);
   var darkBlue = A4(RGBA,32,74,135,1);
   var lightPurple = A4(RGBA,173,127,168,1);
   var purple = A4(RGBA,117,80,123,1);
   var darkPurple = A4(RGBA,92,53,102,1);
   var lightBrown = A4(RGBA,233,185,110,1);
   var brown = A4(RGBA,193,125,17,1);
   var darkBrown = A4(RGBA,143,89,2,1);
   var black = A4(RGBA,0,0,0,1);
   var white = A4(RGBA,255,255,255,1);
   var lightGrey = A4(RGBA,238,238,236,1);
   var grey = A4(RGBA,211,215,207,1);
   var darkGrey = A4(RGBA,186,189,182,1);
   var lightGray = A4(RGBA,238,238,236,1);
   var gray = A4(RGBA,211,215,207,1);
   var darkGray = A4(RGBA,186,189,182,1);
   var lightCharcoal = A4(RGBA,136,138,133,1);
   var charcoal = A4(RGBA,85,87,83,1);
   var darkCharcoal = A4(RGBA,46,52,54,1);
   return _elm.Color.values = {_op: _op
                              ,rgb: rgb
                              ,rgba: rgba
                              ,hsl: hsl
                              ,hsla: hsla
                              ,greyscale: greyscale
                              ,grayscale: grayscale
                              ,complement: complement
                              ,linear: linear
                              ,radial: radial
                              ,toRgb: toRgb
                              ,toHsl: toHsl
                              ,red: red
                              ,orange: orange
                              ,yellow: yellow
                              ,green: green
                              ,blue: blue
                              ,purple: purple
                              ,brown: brown
                              ,lightRed: lightRed
                              ,lightOrange: lightOrange
                              ,lightYellow: lightYellow
                              ,lightGreen: lightGreen
                              ,lightBlue: lightBlue
                              ,lightPurple: lightPurple
                              ,lightBrown: lightBrown
                              ,darkRed: darkRed
                              ,darkOrange: darkOrange
                              ,darkYellow: darkYellow
                              ,darkGreen: darkGreen
                              ,darkBlue: darkBlue
                              ,darkPurple: darkPurple
                              ,darkBrown: darkBrown
                              ,white: white
                              ,lightGrey: lightGrey
                              ,grey: grey
                              ,darkGrey: darkGrey
                              ,lightCharcoal: lightCharcoal
                              ,charcoal: charcoal
                              ,darkCharcoal: darkCharcoal
                              ,black: black
                              ,lightGray: lightGray
                              ,gray: gray
                              ,darkGray: darkGray};
};

// setup
Elm.Native = Elm.Native || {};
Elm.Native.Graphics = Elm.Native.Graphics || {};
Elm.Native.Graphics.Element = Elm.Native.Graphics.Element || {};

// definition
Elm.Native.Graphics.Element.make = function(localRuntime) {
	'use strict';

	// attempt to short-circuit
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Graphics = localRuntime.Native.Graphics || {};
	localRuntime.Native.Graphics.Element = localRuntime.Native.Graphics.Element || {};
	if ('values' in localRuntime.Native.Graphics.Element)
	{
		return localRuntime.Native.Graphics.Element.values;
	}

	var Color = Elm.Native.Color.make(localRuntime);
	var List = Elm.Native.List.make(localRuntime);
	var Maybe = Elm.Maybe.make(localRuntime);
	var Text = Elm.Native.Text.make(localRuntime);
	var Utils = Elm.Native.Utils.make(localRuntime);


	// CREATION

	var createNode =
		typeof document === 'undefined'
			?
				function(_)
				{
					return {
						style: {},
						appendChild: function() {}
					};
				}
			:
				function(elementType)
				{
					var node = document.createElement(elementType);
					node.style.padding = '0';
					node.style.margin = '0';
					return node;
				}
			;


	function newElement(width, height, elementPrim)
	{
		return {
			ctor: 'Element_elm_builtin',
			_0: {
				element: elementPrim,
				props: {
					id: Utils.guid(),
					width: width,
					height: height,
					opacity: 1,
					color: Maybe.Nothing,
					href: '',
					tag: '',
					hover: Utils.Tuple0,
					click: Utils.Tuple0
				}
			}
		};
	}


	// PROPERTIES

	function setProps(elem, node)
	{
		var props = elem.props;

		var element = elem.element;
		var width = props.width - (element.adjustWidth || 0);
		var height = props.height - (element.adjustHeight || 0);
		node.style.width  = (width | 0) + 'px';
		node.style.height = (height | 0) + 'px';

		if (props.opacity !== 1)
		{
			node.style.opacity = props.opacity;
		}

		if (props.color.ctor === 'Just')
		{
			node.style.backgroundColor = Color.toCss(props.color._0);
		}

		if (props.tag !== '')
		{
			node.id = props.tag;
		}

		if (props.hover.ctor !== '_Tuple0')
		{
			addHover(node, props.hover);
		}

		if (props.click.ctor !== '_Tuple0')
		{
			addClick(node, props.click);
		}

		if (props.href !== '')
		{
			var anchor = createNode('a');
			anchor.href = props.href;
			anchor.style.display = 'block';
			anchor.style.pointerEvents = 'auto';
			anchor.appendChild(node);
			node = anchor;
		}

		return node;
	}

	function addClick(e, handler)
	{
		e.style.pointerEvents = 'auto';
		e.elm_click_handler = handler;
		function trigger(ev)
		{
			e.elm_click_handler(Utils.Tuple0);
			ev.stopPropagation();
		}
		e.elm_click_trigger = trigger;
		e.addEventListener('click', trigger);
	}

	function removeClick(e, handler)
	{
		if (e.elm_click_trigger)
		{
			e.removeEventListener('click', e.elm_click_trigger);
			e.elm_click_trigger = null;
			e.elm_click_handler = null;
		}
	}

	function addHover(e, handler)
	{
		e.style.pointerEvents = 'auto';
		e.elm_hover_handler = handler;
		e.elm_hover_count = 0;

		function over(evt)
		{
			if (e.elm_hover_count++ > 0) return;
			e.elm_hover_handler(true);
			evt.stopPropagation();
		}
		function out(evt)
		{
			if (e.contains(evt.toElement || evt.relatedTarget)) return;
			e.elm_hover_count = 0;
			e.elm_hover_handler(false);
			evt.stopPropagation();
		}
		e.elm_hover_over = over;
		e.elm_hover_out = out;
		e.addEventListener('mouseover', over);
		e.addEventListener('mouseout', out);
	}

	function removeHover(e)
	{
		e.elm_hover_handler = null;
		if (e.elm_hover_over)
		{
			e.removeEventListener('mouseover', e.elm_hover_over);
			e.elm_hover_over = null;
		}
		if (e.elm_hover_out)
		{
			e.removeEventListener('mouseout', e.elm_hover_out);
			e.elm_hover_out = null;
		}
	}


	// IMAGES

	function image(props, img)
	{
		switch (img._0.ctor)
		{
			case 'Plain':
				return plainImage(img._3);

			case 'Fitted':
				return fittedImage(props.width, props.height, img._3);

			case 'Cropped':
				return croppedImage(img, props.width, props.height, img._3);

			case 'Tiled':
				return tiledImage(img._3);
		}
	}

	function plainImage(src)
	{
		var img = createNode('img');
		img.src = src;
		img.name = src;
		img.style.display = 'block';
		return img;
	}

	function tiledImage(src)
	{
		var div = createNode('div');
		div.style.backgroundImage = 'url(' + src + ')';
		return div;
	}

	function fittedImage(w, h, src)
	{
		var div = createNode('div');
		div.style.background = 'url(' + src + ') no-repeat center';
		div.style.webkitBackgroundSize = 'cover';
		div.style.MozBackgroundSize = 'cover';
		div.style.OBackgroundSize = 'cover';
		div.style.backgroundSize = 'cover';
		return div;
	}

	function croppedImage(elem, w, h, src)
	{
		var pos = elem._0._0;
		var e = createNode('div');
		e.style.overflow = 'hidden';

		var img = createNode('img');
		img.onload = function() {
			var sw = w / elem._1, sh = h / elem._2;
			img.style.width = ((this.width * sw) | 0) + 'px';
			img.style.height = ((this.height * sh) | 0) + 'px';
			img.style.marginLeft = ((- pos._0 * sw) | 0) + 'px';
			img.style.marginTop = ((- pos._1 * sh) | 0) + 'px';
		};
		img.src = src;
		img.name = src;
		e.appendChild(img);
		return e;
	}


	// FLOW

	function goOut(node)
	{
		node.style.position = 'absolute';
		return node;
	}
	function goDown(node)
	{
		return node;
	}
	function goRight(node)
	{
		node.style.styleFloat = 'left';
		node.style.cssFloat = 'left';
		return node;
	}

	var directionTable = {
		DUp: goDown,
		DDown: goDown,
		DLeft: goRight,
		DRight: goRight,
		DIn: goOut,
		DOut: goOut
	};
	function needsReversal(dir)
	{
		return dir === 'DUp' || dir === 'DLeft' || dir === 'DIn';
	}

	function flow(dir, elist)
	{
		var array = List.toArray(elist);
		var container = createNode('div');
		var goDir = directionTable[dir];
		if (goDir === goOut)
		{
			container.style.pointerEvents = 'none';
		}
		if (needsReversal(dir))
		{
			array.reverse();
		}
		var len = array.length;
		for (var i = 0; i < len; ++i)
		{
			container.appendChild(goDir(render(array[i])));
		}
		return container;
	}


	// CONTAINER

	function toPos(pos)
	{
		return pos.ctor === 'Absolute'
			? pos._0 + 'px'
			: (pos._0 * 100) + '%';
	}

	// must clear right, left, top, bottom, and transform
	// before calling this function
	function setPos(pos, wrappedElement, e)
	{
		var elem = wrappedElement._0;
		var element = elem.element;
		var props = elem.props;
		var w = props.width + (element.adjustWidth ? element.adjustWidth : 0);
		var h = props.height + (element.adjustHeight ? element.adjustHeight : 0);

		e.style.position = 'absolute';
		e.style.margin = 'auto';
		var transform = '';

		switch (pos.horizontal.ctor)
		{
			case 'P':
				e.style.right = toPos(pos.x);
				e.style.removeProperty('left');
				break;

			case 'Z':
				transform = 'translateX(' + ((-w / 2) | 0) + 'px) ';

			case 'N':
				e.style.left = toPos(pos.x);
				e.style.removeProperty('right');
				break;
		}
		switch (pos.vertical.ctor)
		{
			case 'N':
				e.style.bottom = toPos(pos.y);
				e.style.removeProperty('top');
				break;

			case 'Z':
				transform += 'translateY(' + ((-h / 2) | 0) + 'px)';

			case 'P':
				e.style.top = toPos(pos.y);
				e.style.removeProperty('bottom');
				break;
		}
		if (transform !== '')
		{
			addTransform(e.style, transform);
		}
		return e;
	}

	function addTransform(style, transform)
	{
		style.transform       = transform;
		style.msTransform     = transform;
		style.MozTransform    = transform;
		style.webkitTransform = transform;
		style.OTransform      = transform;
	}

	function container(pos, elem)
	{
		var e = render(elem);
		setPos(pos, elem, e);
		var div = createNode('div');
		div.style.position = 'relative';
		div.style.overflow = 'hidden';
		div.appendChild(e);
		return div;
	}


	function rawHtml(elem)
	{
		var html = elem.html;
		var align = elem.align;

		var div = createNode('div');
		div.innerHTML = html;
		div.style.visibility = 'hidden';
		if (align)
		{
			div.style.textAlign = align;
		}
		div.style.visibility = 'visible';
		div.style.pointerEvents = 'auto';
		return div;
	}


	// RENDER

	function render(wrappedElement)
	{
		var elem = wrappedElement._0;
		return setProps(elem, makeElement(elem));
	}

	function makeElement(e)
	{
		var elem = e.element;
		switch (elem.ctor)
		{
			case 'Image':
				return image(e.props, elem);

			case 'Flow':
				return flow(elem._0.ctor, elem._1);

			case 'Container':
				return container(elem._0, elem._1);

			case 'Spacer':
				return createNode('div');

			case 'RawHtml':
				return rawHtml(elem);

			case 'Custom':
				return elem.render(elem.model);
		}
	}

	function updateAndReplace(node, curr, next)
	{
		var newNode = update(node, curr, next);
		if (newNode !== node)
		{
			node.parentNode.replaceChild(newNode, node);
		}
		return newNode;
	}


	// UPDATE

	function update(node, wrappedCurrent, wrappedNext)
	{
		var curr = wrappedCurrent._0;
		var next = wrappedNext._0;
		var rootNode = node;
		if (node.tagName === 'A')
		{
			node = node.firstChild;
		}
		if (curr.props.id === next.props.id)
		{
			updateProps(node, curr, next);
			return rootNode;
		}
		if (curr.element.ctor !== next.element.ctor)
		{
			return render(wrappedNext);
		}
		var nextE = next.element;
		var currE = curr.element;
		switch (nextE.ctor)
		{
			case 'Spacer':
				updateProps(node, curr, next);
				return rootNode;

			case 'RawHtml':
				if(currE.html.valueOf() !== nextE.html.valueOf())
				{
					node.innerHTML = nextE.html;
				}
				updateProps(node, curr, next);
				return rootNode;

			case 'Image':
				if (nextE._0.ctor === 'Plain')
				{
					if (nextE._3 !== currE._3)
					{
						node.src = nextE._3;
					}
				}
				else if (!Utils.eq(nextE, currE)
					|| next.props.width !== curr.props.width
					|| next.props.height !== curr.props.height)
				{
					return render(wrappedNext);
				}
				updateProps(node, curr, next);
				return rootNode;

			case 'Flow':
				var arr = List.toArray(nextE._1);
				for (var i = arr.length; i--; )
				{
					arr[i] = arr[i]._0.element.ctor;
				}
				if (nextE._0.ctor !== currE._0.ctor)
				{
					return render(wrappedNext);
				}
				var nexts = List.toArray(nextE._1);
				var kids = node.childNodes;
				if (nexts.length !== kids.length)
				{
					return render(wrappedNext);
				}
				var currs = List.toArray(currE._1);
				var dir = nextE._0.ctor;
				var goDir = directionTable[dir];
				var toReverse = needsReversal(dir);
				var len = kids.length;
				for (var i = len; i--; )
				{
					var subNode = kids[toReverse ? len - i - 1 : i];
					goDir(updateAndReplace(subNode, currs[i], nexts[i]));
				}
				updateProps(node, curr, next);
				return rootNode;

			case 'Container':
				var subNode = node.firstChild;
				var newSubNode = updateAndReplace(subNode, currE._1, nextE._1);
				setPos(nextE._0, nextE._1, newSubNode);
				updateProps(node, curr, next);
				return rootNode;

			case 'Custom':
				if (currE.type === nextE.type)
				{
					var updatedNode = nextE.update(node, currE.model, nextE.model);
					updateProps(updatedNode, curr, next);
					return updatedNode;
				}
				return render(wrappedNext);
		}
	}

	function updateProps(node, curr, next)
	{
		var nextProps = next.props;
		var currProps = curr.props;

		var element = next.element;
		var width = nextProps.width - (element.adjustWidth || 0);
		var height = nextProps.height - (element.adjustHeight || 0);
		if (width !== currProps.width)
		{
			node.style.width = (width | 0) + 'px';
		}
		if (height !== currProps.height)
		{
			node.style.height = (height | 0) + 'px';
		}

		if (nextProps.opacity !== currProps.opacity)
		{
			node.style.opacity = nextProps.opacity;
		}

		var nextColor = nextProps.color.ctor === 'Just'
			? Color.toCss(nextProps.color._0)
			: '';
		if (node.style.backgroundColor !== nextColor)
		{
			node.style.backgroundColor = nextColor;
		}

		if (nextProps.tag !== currProps.tag)
		{
			node.id = nextProps.tag;
		}

		if (nextProps.href !== currProps.href)
		{
			if (currProps.href === '')
			{
				// add a surrounding href
				var anchor = createNode('a');
				anchor.href = nextProps.href;
				anchor.style.display = 'block';
				anchor.style.pointerEvents = 'auto';

				node.parentNode.replaceChild(anchor, node);
				anchor.appendChild(node);
			}
			else if (nextProps.href === '')
			{
				// remove the surrounding href
				var anchor = node.parentNode;
				anchor.parentNode.replaceChild(node, anchor);
			}
			else
			{
				// just update the link
				node.parentNode.href = nextProps.href;
			}
		}

		// update click and hover handlers
		var removed = false;

		// update hover handlers
		if (currProps.hover.ctor === '_Tuple0')
		{
			if (nextProps.hover.ctor !== '_Tuple0')
			{
				addHover(node, nextProps.hover);
			}
		}
		else
		{
			if (nextProps.hover.ctor === '_Tuple0')
			{
				removed = true;
				removeHover(node);
			}
			else
			{
				node.elm_hover_handler = nextProps.hover;
			}
		}

		// update click handlers
		if (currProps.click.ctor === '_Tuple0')
		{
			if (nextProps.click.ctor !== '_Tuple0')
			{
				addClick(node, nextProps.click);
			}
		}
		else
		{
			if (nextProps.click.ctor === '_Tuple0')
			{
				removed = true;
				removeClick(node);
			}
			else
			{
				node.elm_click_handler = nextProps.click;
			}
		}

		// stop capturing clicks if
		if (removed
			&& nextProps.hover.ctor === '_Tuple0'
			&& nextProps.click.ctor === '_Tuple0')
		{
			node.style.pointerEvents = 'none';
		}
	}


	// TEXT

	function block(align)
	{
		return function(text)
		{
			var raw = {
				ctor: 'RawHtml',
				html: Text.renderHtml(text),
				align: align
			};
			var pos = htmlHeight(0, raw);
			return newElement(pos._0, pos._1, raw);
		};
	}

	function markdown(text)
	{
		var raw = {
			ctor: 'RawHtml',
			html: text,
			align: null
		};
		var pos = htmlHeight(0, raw);
		return newElement(pos._0, pos._1, raw);
	}

	var htmlHeight =
		typeof document !== 'undefined'
			? realHtmlHeight
			: function(a, b) { return Utils.Tuple2(0, 0); };

	function realHtmlHeight(width, rawHtml)
	{
		// create dummy node
		var temp = document.createElement('div');
		temp.innerHTML = rawHtml.html;
		if (width > 0)
		{
			temp.style.width = width + 'px';
		}
		temp.style.visibility = 'hidden';
		temp.style.styleFloat = 'left';
		temp.style.cssFloat = 'left';

		document.body.appendChild(temp);

		// get dimensions
		var style = window.getComputedStyle(temp, null);
		var w = Math.ceil(style.getPropertyValue('width').slice(0, -2) - 0);
		var h = Math.ceil(style.getPropertyValue('height').slice(0, -2) - 0);
		document.body.removeChild(temp);
		return Utils.Tuple2(w, h);
	}


	return localRuntime.Native.Graphics.Element.values = {
		render: render,
		update: update,
		updateAndReplace: updateAndReplace,

		createNode: createNode,
		newElement: F3(newElement),
		addTransform: addTransform,
		htmlHeight: F2(htmlHeight),
		guid: Utils.guid,

		block: block,
		markdown: markdown
	};
};

Elm.Native.Text = {};
Elm.Native.Text.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Text = localRuntime.Native.Text || {};
	if (localRuntime.Native.Text.values)
	{
		return localRuntime.Native.Text.values;
	}

	var toCss = Elm.Native.Color.make(localRuntime).toCss;
	var List = Elm.Native.List.make(localRuntime);


	// CONSTRUCTORS

	function fromString(str)
	{
		return {
			ctor: 'Text:Text',
			_0: str
		};
	}

	function append(a, b)
	{
		return {
			ctor: 'Text:Append',
			_0: a,
			_1: b
		};
	}

	function addMeta(field, value, text)
	{
		var newProps = {};
		var newText = {
			ctor: 'Text:Meta',
			_0: newProps,
			_1: text
		};

		if (text.ctor === 'Text:Meta')
		{
			newText._1 = text._1;
			var props = text._0;
			for (var i = metaKeys.length; i--; )
			{
				var key = metaKeys[i];
				var val = props[key];
				if (val)
				{
					newProps[key] = val;
				}
			}
		}
		newProps[field] = value;
		return newText;
	}

	var metaKeys = [
		'font-size',
		'font-family',
		'font-style',
		'font-weight',
		'href',
		'text-decoration',
		'color'
	];


	// conversions from Elm values to CSS

	function toTypefaces(list)
	{
		var typefaces = List.toArray(list);
		for (var i = typefaces.length; i--; )
		{
			var typeface = typefaces[i];
			if (typeface.indexOf(' ') > -1)
			{
				typefaces[i] = "'" + typeface + "'";
			}
		}
		return typefaces.join(',');
	}

	function toLine(line)
	{
		var ctor = line.ctor;
		return ctor === 'Under'
			? 'underline'
			: ctor === 'Over'
				? 'overline'
				: 'line-through';
	}

	// setting styles of Text

	function style(style, text)
	{
		var newText = addMeta('color', toCss(style.color), text);
		var props = newText._0;

		if (style.typeface.ctor !== '[]')
		{
			props['font-family'] = toTypefaces(style.typeface);
		}
		if (style.height.ctor !== 'Nothing')
		{
			props['font-size'] = style.height._0 + 'px';
		}
		if (style.bold)
		{
			props['font-weight'] = 'bold';
		}
		if (style.italic)
		{
			props['font-style'] = 'italic';
		}
		if (style.line.ctor !== 'Nothing')
		{
			props['text-decoration'] = toLine(style.line._0);
		}
		return newText;
	}

	function height(px, text)
	{
		return addMeta('font-size', px + 'px', text);
	}

	function typeface(names, text)
	{
		return addMeta('font-family', toTypefaces(names), text);
	}

	function monospace(text)
	{
		return addMeta('font-family', 'monospace', text);
	}

	function italic(text)
	{
		return addMeta('font-style', 'italic', text);
	}

	function bold(text)
	{
		return addMeta('font-weight', 'bold', text);
	}

	function link(href, text)
	{
		return addMeta('href', href, text);
	}

	function line(line, text)
	{
		return addMeta('text-decoration', toLine(line), text);
	}

	function color(color, text)
	{
		return addMeta('color', toCss(color), text);
	}


	// RENDER

	function renderHtml(text)
	{
		var tag = text.ctor;
		if (tag === 'Text:Append')
		{
			return renderHtml(text._0) + renderHtml(text._1);
		}
		if (tag === 'Text:Text')
		{
			return properEscape(text._0);
		}
		if (tag === 'Text:Meta')
		{
			return renderMeta(text._0, renderHtml(text._1));
		}
	}

	function renderMeta(metas, string)
	{
		var href = metas.href;
		if (href)
		{
			string = '<a href="' + href + '">' + string + '</a>';
		}
		var styles = '';
		for (var key in metas)
		{
			if (key === 'href')
			{
				continue;
			}
			styles += key + ':' + metas[key] + ';';
		}
		if (styles)
		{
			string = '<span style="' + styles + '">' + string + '</span>';
		}
		return string;
	}

	function properEscape(str)
	{
		if (str.length === 0)
		{
			return str;
		}
		str = str //.replace(/&/g,  '&#38;')
			.replace(/"/g,  '&#34;')
			.replace(/'/g,  '&#39;')
			.replace(/</g,  '&#60;')
			.replace(/>/g,  '&#62;');
		var arr = str.split('\n');
		for (var i = arr.length; i--; )
		{
			arr[i] = makeSpaces(arr[i]);
		}
		return arr.join('<br/>');
	}

	function makeSpaces(s)
	{
		if (s.length === 0)
		{
			return s;
		}
		var arr = s.split('');
		if (arr[0] === ' ')
		{
			arr[0] = '&nbsp;';
		}
		for (var i = arr.length; --i; )
		{
			if (arr[i][0] === ' ' && arr[i - 1] === ' ')
			{
				arr[i - 1] = arr[i - 1] + arr[i];
				arr[i] = '';
			}
		}
		for (var i = arr.length; i--; )
		{
			if (arr[i].length > 1 && arr[i][0] === ' ')
			{
				var spaces = arr[i].split('');
				for (var j = spaces.length - 2; j >= 0; j -= 2)
				{
					spaces[j] = '&nbsp;';
				}
				arr[i] = spaces.join('');
			}
		}
		arr = arr.join('');
		if (arr[arr.length - 1] === ' ')
		{
			return arr.slice(0, -1) + '&nbsp;';
		}
		return arr;
	}


	return localRuntime.Native.Text.values = {
		fromString: fromString,
		append: F2(append),

		height: F2(height),
		italic: italic,
		bold: bold,
		line: F2(line),
		monospace: monospace,
		typeface: F2(typeface),
		color: F2(color),
		link: F2(link),
		style: F2(style),

		toTypefaces: toTypefaces,
		toLine: toLine,
		renderHtml: renderHtml
	};
};

Elm.Text = Elm.Text || {};
Elm.Text.make = function (_elm) {
   "use strict";
   _elm.Text = _elm.Text || {};
   if (_elm.Text.values) return _elm.Text.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Color = Elm.Color.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Text = Elm.Native.Text.make(_elm);
   var _op = {};
   var line = $Native$Text.line;
   var italic = $Native$Text.italic;
   var bold = $Native$Text.bold;
   var color = $Native$Text.color;
   var height = $Native$Text.height;
   var link = $Native$Text.link;
   var monospace = $Native$Text.monospace;
   var typeface = $Native$Text.typeface;
   var style = $Native$Text.style;
   var append = $Native$Text.append;
   var fromString = $Native$Text.fromString;
   var empty = fromString("");
   var concat = function (texts) {    return A3($List.foldr,append,empty,texts);};
   var join = F2(function (seperator,texts) {    return concat(A2($List.intersperse,seperator,texts));});
   var defaultStyle = {typeface: _U.list([]),height: $Maybe.Nothing,color: $Color.black,bold: false,italic: false,line: $Maybe.Nothing};
   var Style = F6(function (a,b,c,d,e,f) {    return {typeface: a,height: b,color: c,bold: d,italic: e,line: f};});
   var Through = {ctor: "Through"};
   var Over = {ctor: "Over"};
   var Under = {ctor: "Under"};
   var Text = {ctor: "Text"};
   return _elm.Text.values = {_op: _op
                             ,fromString: fromString
                             ,empty: empty
                             ,append: append
                             ,concat: concat
                             ,join: join
                             ,link: link
                             ,style: style
                             ,defaultStyle: defaultStyle
                             ,typeface: typeface
                             ,monospace: monospace
                             ,height: height
                             ,color: color
                             ,bold: bold
                             ,italic: italic
                             ,line: line
                             ,Style: Style
                             ,Under: Under
                             ,Over: Over
                             ,Through: Through};
};
Elm.Graphics = Elm.Graphics || {};
Elm.Graphics.Element = Elm.Graphics.Element || {};
Elm.Graphics.Element.make = function (_elm) {
   "use strict";
   _elm.Graphics = _elm.Graphics || {};
   _elm.Graphics.Element = _elm.Graphics.Element || {};
   if (_elm.Graphics.Element.values) return _elm.Graphics.Element.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Color = Elm.Color.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Graphics$Element = Elm.Native.Graphics.Element.make(_elm),
   $Text = Elm.Text.make(_elm);
   var _op = {};
   var DOut = {ctor: "DOut"};
   var outward = DOut;
   var DIn = {ctor: "DIn"};
   var inward = DIn;
   var DRight = {ctor: "DRight"};
   var right = DRight;
   var DLeft = {ctor: "DLeft"};
   var left = DLeft;
   var DDown = {ctor: "DDown"};
   var down = DDown;
   var DUp = {ctor: "DUp"};
   var up = DUp;
   var RawPosition = F4(function (a,b,c,d) {    return {horizontal: a,vertical: b,x: c,y: d};});
   var Position = function (a) {    return {ctor: "Position",_0: a};};
   var Relative = function (a) {    return {ctor: "Relative",_0: a};};
   var relative = Relative;
   var Absolute = function (a) {    return {ctor: "Absolute",_0: a};};
   var absolute = Absolute;
   var N = {ctor: "N"};
   var bottomLeft = Position({horizontal: N,vertical: N,x: Absolute(0),y: Absolute(0)});
   var bottomLeftAt = F2(function (x,y) {    return Position({horizontal: N,vertical: N,x: x,y: y});});
   var Z = {ctor: "Z"};
   var middle = Position({horizontal: Z,vertical: Z,x: Relative(0.5),y: Relative(0.5)});
   var midLeft = Position({horizontal: N,vertical: Z,x: Absolute(0),y: Relative(0.5)});
   var midBottom = Position({horizontal: Z,vertical: N,x: Relative(0.5),y: Absolute(0)});
   var middleAt = F2(function (x,y) {    return Position({horizontal: Z,vertical: Z,x: x,y: y});});
   var midLeftAt = F2(function (x,y) {    return Position({horizontal: N,vertical: Z,x: x,y: y});});
   var midBottomAt = F2(function (x,y) {    return Position({horizontal: Z,vertical: N,x: x,y: y});});
   var P = {ctor: "P"};
   var topLeft = Position({horizontal: N,vertical: P,x: Absolute(0),y: Absolute(0)});
   var topRight = Position({horizontal: P,vertical: P,x: Absolute(0),y: Absolute(0)});
   var bottomRight = Position({horizontal: P,vertical: N,x: Absolute(0),y: Absolute(0)});
   var midRight = Position({horizontal: P,vertical: Z,x: Absolute(0),y: Relative(0.5)});
   var midTop = Position({horizontal: Z,vertical: P,x: Relative(0.5),y: Absolute(0)});
   var topLeftAt = F2(function (x,y) {    return Position({horizontal: N,vertical: P,x: x,y: y});});
   var topRightAt = F2(function (x,y) {    return Position({horizontal: P,vertical: P,x: x,y: y});});
   var bottomRightAt = F2(function (x,y) {    return Position({horizontal: P,vertical: N,x: x,y: y});});
   var midRightAt = F2(function (x,y) {    return Position({horizontal: P,vertical: Z,x: x,y: y});});
   var midTopAt = F2(function (x,y) {    return Position({horizontal: Z,vertical: P,x: x,y: y});});
   var justified = $Native$Graphics$Element.block("justify");
   var centered = $Native$Graphics$Element.block("center");
   var rightAligned = $Native$Graphics$Element.block("right");
   var leftAligned = $Native$Graphics$Element.block("left");
   var show = function (value) {    return leftAligned($Text.monospace($Text.fromString($Basics.toString(value))));};
   var Tiled = {ctor: "Tiled"};
   var Cropped = function (a) {    return {ctor: "Cropped",_0: a};};
   var Fitted = {ctor: "Fitted"};
   var Plain = {ctor: "Plain"};
   var Custom = {ctor: "Custom"};
   var RawHtml = {ctor: "RawHtml"};
   var Spacer = {ctor: "Spacer"};
   var Flow = F2(function (a,b) {    return {ctor: "Flow",_0: a,_1: b};});
   var Container = F2(function (a,b) {    return {ctor: "Container",_0: a,_1: b};});
   var Image = F4(function (a,b,c,d) {    return {ctor: "Image",_0: a,_1: b,_2: c,_3: d};});
   var newElement = $Native$Graphics$Element.newElement;
   var image = F3(function (w,h,src) {    return A3(newElement,w,h,A4(Image,Plain,w,h,src));});
   var fittedImage = F3(function (w,h,src) {    return A3(newElement,w,h,A4(Image,Fitted,w,h,src));});
   var croppedImage = F4(function (pos,w,h,src) {    return A3(newElement,w,h,A4(Image,Cropped(pos),w,h,src));});
   var tiledImage = F3(function (w,h,src) {    return A3(newElement,w,h,A4(Image,Tiled,w,h,src));});
   var container = F4(function (w,h,_p0,e) {    var _p1 = _p0;return A3(newElement,w,h,A2(Container,_p1._0,e));});
   var spacer = F2(function (w,h) {    return A3(newElement,w,h,Spacer);});
   var sizeOf = function (_p2) {    var _p3 = _p2;var _p4 = _p3._0;return {ctor: "_Tuple2",_0: _p4.props.width,_1: _p4.props.height};};
   var heightOf = function (_p5) {    var _p6 = _p5;return _p6._0.props.height;};
   var widthOf = function (_p7) {    var _p8 = _p7;return _p8._0.props.width;};
   var above = F2(function (hi,lo) {
      return A3(newElement,A2($Basics.max,widthOf(hi),widthOf(lo)),heightOf(hi) + heightOf(lo),A2(Flow,DDown,_U.list([hi,lo])));
   });
   var below = F2(function (lo,hi) {
      return A3(newElement,A2($Basics.max,widthOf(hi),widthOf(lo)),heightOf(hi) + heightOf(lo),A2(Flow,DDown,_U.list([hi,lo])));
   });
   var beside = F2(function (lft,rht) {
      return A3(newElement,widthOf(lft) + widthOf(rht),A2($Basics.max,heightOf(lft),heightOf(rht)),A2(Flow,right,_U.list([lft,rht])));
   });
   var layers = function (es) {
      var hs = A2($List.map,heightOf,es);
      var ws = A2($List.map,widthOf,es);
      return A3(newElement,A2($Maybe.withDefault,0,$List.maximum(ws)),A2($Maybe.withDefault,0,$List.maximum(hs)),A2(Flow,DOut,es));
   };
   var empty = A2(spacer,0,0);
   var flow = F2(function (dir,es) {
      var newFlow = F2(function (w,h) {    return A3(newElement,w,h,A2(Flow,dir,es));});
      var maxOrZero = function (list) {    return A2($Maybe.withDefault,0,$List.maximum(list));};
      var hs = A2($List.map,heightOf,es);
      var ws = A2($List.map,widthOf,es);
      if (_U.eq(es,_U.list([]))) return empty; else {
            var _p9 = dir;
            switch (_p9.ctor)
            {case "DUp": return A2(newFlow,maxOrZero(ws),$List.sum(hs));
               case "DDown": return A2(newFlow,maxOrZero(ws),$List.sum(hs));
               case "DLeft": return A2(newFlow,$List.sum(ws),maxOrZero(hs));
               case "DRight": return A2(newFlow,$List.sum(ws),maxOrZero(hs));
               case "DIn": return A2(newFlow,maxOrZero(ws),maxOrZero(hs));
               default: return A2(newFlow,maxOrZero(ws),maxOrZero(hs));}
         }
   });
   var Properties = F9(function (a,b,c,d,e,f,g,h,i) {    return {id: a,width: b,height: c,opacity: d,color: e,href: f,tag: g,hover: h,click: i};});
   var Element_elm_builtin = function (a) {    return {ctor: "Element_elm_builtin",_0: a};};
   var width = F2(function (newWidth,_p10) {
      var _p11 = _p10;
      var _p14 = _p11._0.props;
      var _p13 = _p11._0.element;
      var newHeight = function () {
         var _p12 = _p13;
         switch (_p12.ctor)
         {case "Image": return $Basics.round($Basics.toFloat(_p12._2) / $Basics.toFloat(_p12._1) * $Basics.toFloat(newWidth));
            case "RawHtml": return $Basics.snd(A2($Native$Graphics$Element.htmlHeight,newWidth,_p13));
            default: return _p14.height;}
      }();
      return Element_elm_builtin({element: _p13,props: _U.update(_p14,{width: newWidth,height: newHeight})});
   });
   var height = F2(function (newHeight,_p15) {
      var _p16 = _p15;
      return Element_elm_builtin({element: _p16._0.element,props: _U.update(_p16._0.props,{height: newHeight})});
   });
   var size = F3(function (w,h,e) {    return A2(height,h,A2(width,w,e));});
   var opacity = F2(function (givenOpacity,_p17) {
      var _p18 = _p17;
      return Element_elm_builtin({element: _p18._0.element,props: _U.update(_p18._0.props,{opacity: givenOpacity})});
   });
   var color = F2(function (clr,_p19) {
      var _p20 = _p19;
      return Element_elm_builtin({element: _p20._0.element,props: _U.update(_p20._0.props,{color: $Maybe.Just(clr)})});
   });
   var tag = F2(function (name,_p21) {    var _p22 = _p21;return Element_elm_builtin({element: _p22._0.element,props: _U.update(_p22._0.props,{tag: name})});});
   var link = F2(function (href,_p23) {
      var _p24 = _p23;
      return Element_elm_builtin({element: _p24._0.element,props: _U.update(_p24._0.props,{href: href})});
   });
   return _elm.Graphics.Element.values = {_op: _op
                                         ,image: image
                                         ,fittedImage: fittedImage
                                         ,croppedImage: croppedImage
                                         ,tiledImage: tiledImage
                                         ,leftAligned: leftAligned
                                         ,rightAligned: rightAligned
                                         ,centered: centered
                                         ,justified: justified
                                         ,show: show
                                         ,width: width
                                         ,height: height
                                         ,size: size
                                         ,color: color
                                         ,opacity: opacity
                                         ,link: link
                                         ,tag: tag
                                         ,widthOf: widthOf
                                         ,heightOf: heightOf
                                         ,sizeOf: sizeOf
                                         ,flow: flow
                                         ,up: up
                                         ,down: down
                                         ,left: left
                                         ,right: right
                                         ,inward: inward
                                         ,outward: outward
                                         ,layers: layers
                                         ,above: above
                                         ,below: below
                                         ,beside: beside
                                         ,empty: empty
                                         ,spacer: spacer
                                         ,container: container
                                         ,middle: middle
                                         ,midTop: midTop
                                         ,midBottom: midBottom
                                         ,midLeft: midLeft
                                         ,midRight: midRight
                                         ,topLeft: topLeft
                                         ,topRight: topRight
                                         ,bottomLeft: bottomLeft
                                         ,bottomRight: bottomRight
                                         ,absolute: absolute
                                         ,relative: relative
                                         ,middleAt: middleAt
                                         ,midTopAt: midTopAt
                                         ,midBottomAt: midBottomAt
                                         ,midLeftAt: midLeftAt
                                         ,midRightAt: midRightAt
                                         ,topLeftAt: topLeftAt
                                         ,topRightAt: topRightAt
                                         ,bottomLeftAt: bottomLeftAt
                                         ,bottomRightAt: bottomRightAt};
};
Elm.Graphics = Elm.Graphics || {};
Elm.Graphics.Collage = Elm.Graphics.Collage || {};
Elm.Graphics.Collage.make = function (_elm) {
   "use strict";
   _elm.Graphics = _elm.Graphics || {};
   _elm.Graphics.Collage = _elm.Graphics.Collage || {};
   if (_elm.Graphics.Collage.values) return _elm.Graphics.Collage.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Color = Elm.Color.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $List = Elm.List.make(_elm),
   $Native$Graphics$Collage = Elm.Native.Graphics.Collage.make(_elm),
   $Text = Elm.Text.make(_elm),
   $Transform2D = Elm.Transform2D.make(_elm);
   var _op = {};
   var Shape = function (a) {    return {ctor: "Shape",_0: a};};
   var polygon = function (points) {    return Shape(points);};
   var rect = F2(function (w,h) {
      var hh = h / 2;
      var hw = w / 2;
      return Shape(_U.list([{ctor: "_Tuple2",_0: 0 - hw,_1: 0 - hh}
                           ,{ctor: "_Tuple2",_0: 0 - hw,_1: hh}
                           ,{ctor: "_Tuple2",_0: hw,_1: hh}
                           ,{ctor: "_Tuple2",_0: hw,_1: 0 - hh}]));
   });
   var square = function (n) {    return A2(rect,n,n);};
   var oval = F2(function (w,h) {
      var hh = h / 2;
      var hw = w / 2;
      var n = 50;
      var t = 2 * $Basics.pi / n;
      var f = function (i) {    return {ctor: "_Tuple2",_0: hw * $Basics.cos(t * i),_1: hh * $Basics.sin(t * i)};};
      return Shape(A2($List.map,f,_U.range(0,n - 1)));
   });
   var circle = function (r) {    return A2(oval,2 * r,2 * r);};
   var ngon = F2(function (n,r) {
      var m = $Basics.toFloat(n);
      var t = 2 * $Basics.pi / m;
      var f = function (i) {    return {ctor: "_Tuple2",_0: r * $Basics.cos(t * i),_1: r * $Basics.sin(t * i)};};
      return Shape(A2($List.map,f,_U.range(0,m - 1)));
   });
   var Path = function (a) {    return {ctor: "Path",_0: a};};
   var path = function (ps) {    return Path(ps);};
   var segment = F2(function (p1,p2) {    return Path(_U.list([p1,p2]));});
   var collage = $Native$Graphics$Collage.collage;
   var Fill = function (a) {    return {ctor: "Fill",_0: a};};
   var Line = function (a) {    return {ctor: "Line",_0: a};};
   var FGroup = F2(function (a,b) {    return {ctor: "FGroup",_0: a,_1: b};});
   var FElement = function (a) {    return {ctor: "FElement",_0: a};};
   var FImage = F4(function (a,b,c,d) {    return {ctor: "FImage",_0: a,_1: b,_2: c,_3: d};});
   var FText = function (a) {    return {ctor: "FText",_0: a};};
   var FOutlinedText = F2(function (a,b) {    return {ctor: "FOutlinedText",_0: a,_1: b};});
   var FShape = F2(function (a,b) {    return {ctor: "FShape",_0: a,_1: b};});
   var FPath = F2(function (a,b) {    return {ctor: "FPath",_0: a,_1: b};});
   var LineStyle = F6(function (a,b,c,d,e,f) {    return {color: a,width: b,cap: c,join: d,dashing: e,dashOffset: f};});
   var Clipped = {ctor: "Clipped"};
   var Sharp = function (a) {    return {ctor: "Sharp",_0: a};};
   var Smooth = {ctor: "Smooth"};
   var Padded = {ctor: "Padded"};
   var Round = {ctor: "Round"};
   var Flat = {ctor: "Flat"};
   var defaultLine = {color: $Color.black,width: 1,cap: Flat,join: Sharp(10),dashing: _U.list([]),dashOffset: 0};
   var solid = function (clr) {    return _U.update(defaultLine,{color: clr});};
   var dashed = function (clr) {    return _U.update(defaultLine,{color: clr,dashing: _U.list([8,4])});};
   var dotted = function (clr) {    return _U.update(defaultLine,{color: clr,dashing: _U.list([3,3])});};
   var Grad = function (a) {    return {ctor: "Grad",_0: a};};
   var Texture = function (a) {    return {ctor: "Texture",_0: a};};
   var Solid = function (a) {    return {ctor: "Solid",_0: a};};
   var Form_elm_builtin = function (a) {    return {ctor: "Form_elm_builtin",_0: a};};
   var form = function (f) {    return Form_elm_builtin({theta: 0,scale: 1,x: 0,y: 0,alpha: 1,form: f});};
   var fill = F2(function (style,_p0) {    var _p1 = _p0;return form(A2(FShape,Fill(style),_p1._0));});
   var filled = F2(function (color,shape) {    return A2(fill,Solid(color),shape);});
   var textured = F2(function (src,shape) {    return A2(fill,Texture(src),shape);});
   var gradient = F2(function (grad,shape) {    return A2(fill,Grad(grad),shape);});
   var outlined = F2(function (style,_p2) {    var _p3 = _p2;return form(A2(FShape,Line(style),_p3._0));});
   var traced = F2(function (style,_p4) {    var _p5 = _p4;return form(A2(FPath,style,_p5._0));});
   var sprite = F4(function (w,h,pos,src) {    return form(A4(FImage,w,h,pos,src));});
   var toForm = function (e) {    return form(FElement(e));};
   var group = function (fs) {    return form(A2(FGroup,$Transform2D.identity,fs));};
   var groupTransform = F2(function (matrix,fs) {    return form(A2(FGroup,matrix,fs));});
   var text = function (t) {    return form(FText(t));};
   var outlinedText = F2(function (ls,t) {    return form(A2(FOutlinedText,ls,t));});
   var move = F2(function (_p7,_p6) {
      var _p8 = _p7;
      var _p9 = _p6;
      var _p10 = _p9._0;
      return Form_elm_builtin(_U.update(_p10,{x: _p10.x + _p8._0,y: _p10.y + _p8._1}));
   });
   var moveX = F2(function (x,_p11) {    var _p12 = _p11;var _p13 = _p12._0;return Form_elm_builtin(_U.update(_p13,{x: _p13.x + x}));});
   var moveY = F2(function (y,_p14) {    var _p15 = _p14;var _p16 = _p15._0;return Form_elm_builtin(_U.update(_p16,{y: _p16.y + y}));});
   var scale = F2(function (s,_p17) {    var _p18 = _p17;var _p19 = _p18._0;return Form_elm_builtin(_U.update(_p19,{scale: _p19.scale * s}));});
   var rotate = F2(function (t,_p20) {    var _p21 = _p20;var _p22 = _p21._0;return Form_elm_builtin(_U.update(_p22,{theta: _p22.theta + t}));});
   var alpha = F2(function (a,_p23) {    var _p24 = _p23;return Form_elm_builtin(_U.update(_p24._0,{alpha: a}));});
   return _elm.Graphics.Collage.values = {_op: _op
                                         ,collage: collage
                                         ,toForm: toForm
                                         ,filled: filled
                                         ,textured: textured
                                         ,gradient: gradient
                                         ,outlined: outlined
                                         ,traced: traced
                                         ,text: text
                                         ,outlinedText: outlinedText
                                         ,move: move
                                         ,moveX: moveX
                                         ,moveY: moveY
                                         ,scale: scale
                                         ,rotate: rotate
                                         ,alpha: alpha
                                         ,group: group
                                         ,groupTransform: groupTransform
                                         ,rect: rect
                                         ,oval: oval
                                         ,square: square
                                         ,circle: circle
                                         ,ngon: ngon
                                         ,polygon: polygon
                                         ,segment: segment
                                         ,path: path
                                         ,solid: solid
                                         ,dashed: dashed
                                         ,dotted: dotted
                                         ,defaultLine: defaultLine
                                         ,LineStyle: LineStyle
                                         ,Flat: Flat
                                         ,Round: Round
                                         ,Padded: Padded
                                         ,Smooth: Smooth
                                         ,Sharp: Sharp
                                         ,Clipped: Clipped};
};
Elm.Native.Debug = {};
Elm.Native.Debug.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Debug = localRuntime.Native.Debug || {};
	if (localRuntime.Native.Debug.values)
	{
		return localRuntime.Native.Debug.values;
	}

	var toString = Elm.Native.Utils.make(localRuntime).toString;

	function log(tag, value)
	{
		var msg = tag + ': ' + toString(value);
		var process = process || {};
		if (process.stdout)
		{
			process.stdout.write(msg);
		}
		else
		{
			console.log(msg);
		}
		return value;
	}

	function crash(message)
	{
		throw new Error(message);
	}

	function tracePath(tag, form)
	{
		if (localRuntime.debug)
		{
			return localRuntime.debug.trace(tag, form);
		}
		return form;
	}

	function watch(tag, value)
	{
		if (localRuntime.debug)
		{
			localRuntime.debug.watch(tag, value);
		}
		return value;
	}

	function watchSummary(tag, summarize, value)
	{
		if (localRuntime.debug)
		{
			localRuntime.debug.watch(tag, summarize(value));
		}
		return value;
	}

	return localRuntime.Native.Debug.values = {
		crash: crash,
		tracePath: F2(tracePath),
		log: F2(log),
		watch: F2(watch),
		watchSummary: F3(watchSummary)
	};
};

Elm.Debug = Elm.Debug || {};
Elm.Debug.make = function (_elm) {
   "use strict";
   _elm.Debug = _elm.Debug || {};
   if (_elm.Debug.values) return _elm.Debug.values;
   var _U = Elm.Native.Utils.make(_elm),$Graphics$Collage = Elm.Graphics.Collage.make(_elm),$Native$Debug = Elm.Native.Debug.make(_elm);
   var _op = {};
   var trace = $Native$Debug.tracePath;
   var watchSummary = $Native$Debug.watchSummary;
   var watch = $Native$Debug.watch;
   var crash = $Native$Debug.crash;
   var log = $Native$Debug.log;
   return _elm.Debug.values = {_op: _op,log: log,crash: crash,watch: watch,watchSummary: watchSummary,trace: trace};
};
Elm.Result = Elm.Result || {};
Elm.Result.make = function (_elm) {
   "use strict";
   _elm.Result = _elm.Result || {};
   if (_elm.Result.values) return _elm.Result.values;
   var _U = Elm.Native.Utils.make(_elm),$Maybe = Elm.Maybe.make(_elm);
   var _op = {};
   var toMaybe = function (result) {    var _p0 = result;if (_p0.ctor === "Ok") {    return $Maybe.Just(_p0._0);} else {    return $Maybe.Nothing;}};
   var withDefault = F2(function (def,result) {    var _p1 = result;if (_p1.ctor === "Ok") {    return _p1._0;} else {    return def;}});
   var Err = function (a) {    return {ctor: "Err",_0: a};};
   var andThen = F2(function (result,callback) {    var _p2 = result;if (_p2.ctor === "Ok") {    return callback(_p2._0);} else {    return Err(_p2._0);}});
   var Ok = function (a) {    return {ctor: "Ok",_0: a};};
   var map = F2(function (func,ra) {    var _p3 = ra;if (_p3.ctor === "Ok") {    return Ok(func(_p3._0));} else {    return Err(_p3._0);}});
   var map2 = F3(function (func,ra,rb) {
      var _p4 = {ctor: "_Tuple2",_0: ra,_1: rb};
      if (_p4._0.ctor === "Ok") {
            if (_p4._1.ctor === "Ok") {
                  return Ok(A2(func,_p4._0._0,_p4._1._0));
               } else {
                  return Err(_p4._1._0);
               }
         } else {
            return Err(_p4._0._0);
         }
   });
   var map3 = F4(function (func,ra,rb,rc) {
      var _p5 = {ctor: "_Tuple3",_0: ra,_1: rb,_2: rc};
      if (_p5._0.ctor === "Ok") {
            if (_p5._1.ctor === "Ok") {
                  if (_p5._2.ctor === "Ok") {
                        return Ok(A3(func,_p5._0._0,_p5._1._0,_p5._2._0));
                     } else {
                        return Err(_p5._2._0);
                     }
               } else {
                  return Err(_p5._1._0);
               }
         } else {
            return Err(_p5._0._0);
         }
   });
   var map4 = F5(function (func,ra,rb,rc,rd) {
      var _p6 = {ctor: "_Tuple4",_0: ra,_1: rb,_2: rc,_3: rd};
      if (_p6._0.ctor === "Ok") {
            if (_p6._1.ctor === "Ok") {
                  if (_p6._2.ctor === "Ok") {
                        if (_p6._3.ctor === "Ok") {
                              return Ok(A4(func,_p6._0._0,_p6._1._0,_p6._2._0,_p6._3._0));
                           } else {
                              return Err(_p6._3._0);
                           }
                     } else {
                        return Err(_p6._2._0);
                     }
               } else {
                  return Err(_p6._1._0);
               }
         } else {
            return Err(_p6._0._0);
         }
   });
   var map5 = F6(function (func,ra,rb,rc,rd,re) {
      var _p7 = {ctor: "_Tuple5",_0: ra,_1: rb,_2: rc,_3: rd,_4: re};
      if (_p7._0.ctor === "Ok") {
            if (_p7._1.ctor === "Ok") {
                  if (_p7._2.ctor === "Ok") {
                        if (_p7._3.ctor === "Ok") {
                              if (_p7._4.ctor === "Ok") {
                                    return Ok(A5(func,_p7._0._0,_p7._1._0,_p7._2._0,_p7._3._0,_p7._4._0));
                                 } else {
                                    return Err(_p7._4._0);
                                 }
                           } else {
                              return Err(_p7._3._0);
                           }
                     } else {
                        return Err(_p7._2._0);
                     }
               } else {
                  return Err(_p7._1._0);
               }
         } else {
            return Err(_p7._0._0);
         }
   });
   var formatError = F2(function (f,result) {    var _p8 = result;if (_p8.ctor === "Ok") {    return Ok(_p8._0);} else {    return Err(f(_p8._0));}});
   var fromMaybe = F2(function (err,maybe) {    var _p9 = maybe;if (_p9.ctor === "Just") {    return Ok(_p9._0);} else {    return Err(err);}});
   return _elm.Result.values = {_op: _op
                               ,withDefault: withDefault
                               ,map: map
                               ,map2: map2
                               ,map3: map3
                               ,map4: map4
                               ,map5: map5
                               ,andThen: andThen
                               ,toMaybe: toMaybe
                               ,fromMaybe: fromMaybe
                               ,formatError: formatError
                               ,Ok: Ok
                               ,Err: Err};
};
Elm.Native.Signal = {};

Elm.Native.Signal.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Signal = localRuntime.Native.Signal || {};
	if (localRuntime.Native.Signal.values)
	{
		return localRuntime.Native.Signal.values;
	}


	var Task = Elm.Native.Task.make(localRuntime);
	var Utils = Elm.Native.Utils.make(localRuntime);


	function broadcastToKids(node, timestamp, update)
	{
		var kids = node.kids;
		for (var i = kids.length; i--; )
		{
			kids[i].notify(timestamp, update, node.id);
		}
	}


	// INPUT

	function input(name, base)
	{
		var node = {
			id: Utils.guid(),
			name: 'input-' + name,
			value: base,
			parents: [],
			kids: []
		};

		node.notify = function(timestamp, targetId, value) {
			var update = targetId === node.id;
			if (update)
			{
				node.value = value;
			}
			broadcastToKids(node, timestamp, update);
			return update;
		};

		localRuntime.inputs.push(node);

		return node;
	}

	function constant(value)
	{
		return input('constant', value);
	}


	// MAILBOX

	function mailbox(base)
	{
		var signal = input('mailbox', base);

		function send(value) {
			return Task.asyncFunction(function(callback) {
				localRuntime.setTimeout(function() {
					localRuntime.notify(signal.id, value);
				}, 0);
				callback(Task.succeed(Utils.Tuple0));
			});
		}

		return {
			signal: signal,
			address: {
				ctor: 'Address',
				_0: send
			}
		};
	}

	function sendMessage(message)
	{
		Task.perform(message._0);
	}


	// OUTPUT

	function output(name, handler, parent)
	{
		var node = {
			id: Utils.guid(),
			name: 'output-' + name,
			parents: [parent],
			isOutput: true
		};

		node.notify = function(timestamp, parentUpdate, parentID)
		{
			if (parentUpdate)
			{
				handler(parent.value);
			}
		};

		parent.kids.push(node);

		return node;
	}


	// MAP

	function mapMany(refreshValue, args)
	{
		var node = {
			id: Utils.guid(),
			name: 'map' + args.length,
			value: refreshValue(),
			parents: args,
			kids: []
		};

		var numberOfParents = args.length;
		var count = 0;
		var update = false;

		node.notify = function(timestamp, parentUpdate, parentID)
		{
			++count;

			update = update || parentUpdate;

			if (count === numberOfParents)
			{
				if (update)
				{
					node.value = refreshValue();
				}
				broadcastToKids(node, timestamp, update);
				update = false;
				count = 0;
			}
		};

		for (var i = numberOfParents; i--; )
		{
			args[i].kids.push(node);
		}

		return node;
	}


	function map(func, a)
	{
		function refreshValue()
		{
			return func(a.value);
		}
		return mapMany(refreshValue, [a]);
	}


	function map2(func, a, b)
	{
		function refreshValue()
		{
			return A2( func, a.value, b.value );
		}
		return mapMany(refreshValue, [a, b]);
	}


	function map3(func, a, b, c)
	{
		function refreshValue()
		{
			return A3( func, a.value, b.value, c.value );
		}
		return mapMany(refreshValue, [a, b, c]);
	}


	function map4(func, a, b, c, d)
	{
		function refreshValue()
		{
			return A4( func, a.value, b.value, c.value, d.value );
		}
		return mapMany(refreshValue, [a, b, c, d]);
	}


	function map5(func, a, b, c, d, e)
	{
		function refreshValue()
		{
			return A5( func, a.value, b.value, c.value, d.value, e.value );
		}
		return mapMany(refreshValue, [a, b, c, d, e]);
	}


	// FOLD

	function foldp(update, state, signal)
	{
		var node = {
			id: Utils.guid(),
			name: 'foldp',
			parents: [signal],
			kids: [],
			value: state
		};

		node.notify = function(timestamp, parentUpdate, parentID)
		{
			if (parentUpdate)
			{
				node.value = A2( update, signal.value, node.value );
			}
			broadcastToKids(node, timestamp, parentUpdate);
		};

		signal.kids.push(node);

		return node;
	}


	// TIME

	function timestamp(signal)
	{
		var node = {
			id: Utils.guid(),
			name: 'timestamp',
			value: Utils.Tuple2(localRuntime.timer.programStart, signal.value),
			parents: [signal],
			kids: []
		};

		node.notify = function(timestamp, parentUpdate, parentID)
		{
			if (parentUpdate)
			{
				node.value = Utils.Tuple2(timestamp, signal.value);
			}
			broadcastToKids(node, timestamp, parentUpdate);
		};

		signal.kids.push(node);

		return node;
	}


	function delay(time, signal)
	{
		var delayed = input('delay-input-' + time, signal.value);

		function handler(value)
		{
			setTimeout(function() {
				localRuntime.notify(delayed.id, value);
			}, time);
		}

		output('delay-output-' + time, handler, signal);

		return delayed;
	}


	// MERGING

	function genericMerge(tieBreaker, leftStream, rightStream)
	{
		var node = {
			id: Utils.guid(),
			name: 'merge',
			value: A2(tieBreaker, leftStream.value, rightStream.value),
			parents: [leftStream, rightStream],
			kids: []
		};

		var left = { touched: false, update: false, value: null };
		var right = { touched: false, update: false, value: null };

		node.notify = function(timestamp, parentUpdate, parentID)
		{
			if (parentID === leftStream.id)
			{
				left.touched = true;
				left.update = parentUpdate;
				left.value = leftStream.value;
			}
			if (parentID === rightStream.id)
			{
				right.touched = true;
				right.update = parentUpdate;
				right.value = rightStream.value;
			}

			if (left.touched && right.touched)
			{
				var update = false;
				if (left.update && right.update)
				{
					node.value = A2(tieBreaker, left.value, right.value);
					update = true;
				}
				else if (left.update)
				{
					node.value = left.value;
					update = true;
				}
				else if (right.update)
				{
					node.value = right.value;
					update = true;
				}
				left.touched = false;
				right.touched = false;

				broadcastToKids(node, timestamp, update);
			}
		};

		leftStream.kids.push(node);
		rightStream.kids.push(node);

		return node;
	}


	// FILTERING

	function filterMap(toMaybe, base, signal)
	{
		var maybe = toMaybe(signal.value);
		var node = {
			id: Utils.guid(),
			name: 'filterMap',
			value: maybe.ctor === 'Nothing' ? base : maybe._0,
			parents: [signal],
			kids: []
		};

		node.notify = function(timestamp, parentUpdate, parentID)
		{
			var update = false;
			if (parentUpdate)
			{
				var maybe = toMaybe(signal.value);
				if (maybe.ctor === 'Just')
				{
					update = true;
					node.value = maybe._0;
				}
			}
			broadcastToKids(node, timestamp, update);
		};

		signal.kids.push(node);

		return node;
	}


	// SAMPLING

	function sampleOn(ticker, signal)
	{
		var node = {
			id: Utils.guid(),
			name: 'sampleOn',
			value: signal.value,
			parents: [ticker, signal],
			kids: []
		};

		var signalTouch = false;
		var tickerTouch = false;
		var tickerUpdate = false;

		node.notify = function(timestamp, parentUpdate, parentID)
		{
			if (parentID === ticker.id)
			{
				tickerTouch = true;
				tickerUpdate = parentUpdate;
			}
			if (parentID === signal.id)
			{
				signalTouch = true;
			}

			if (tickerTouch && signalTouch)
			{
				if (tickerUpdate)
				{
					node.value = signal.value;
				}
				tickerTouch = false;
				signalTouch = false;

				broadcastToKids(node, timestamp, tickerUpdate);
			}
		};

		ticker.kids.push(node);
		signal.kids.push(node);

		return node;
	}


	// DROP REPEATS

	function dropRepeats(signal)
	{
		var node = {
			id: Utils.guid(),
			name: 'dropRepeats',
			value: signal.value,
			parents: [signal],
			kids: []
		};

		node.notify = function(timestamp, parentUpdate, parentID)
		{
			var update = false;
			if (parentUpdate && !Utils.eq(node.value, signal.value))
			{
				node.value = signal.value;
				update = true;
			}
			broadcastToKids(node, timestamp, update);
		};

		signal.kids.push(node);

		return node;
	}


	return localRuntime.Native.Signal.values = {
		input: input,
		constant: constant,
		mailbox: mailbox,
		sendMessage: sendMessage,
		output: output,
		map: F2(map),
		map2: F3(map2),
		map3: F4(map3),
		map4: F5(map4),
		map5: F6(map5),
		foldp: F3(foldp),
		genericMerge: F3(genericMerge),
		filterMap: F3(filterMap),
		sampleOn: F2(sampleOn),
		dropRepeats: dropRepeats,
		timestamp: timestamp,
		delay: F2(delay)
	};
};

Elm.Native.Task = {};

Elm.Native.Task.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Task = localRuntime.Native.Task || {};
	if (localRuntime.Native.Task.values)
	{
		return localRuntime.Native.Task.values;
	}

	var Result = Elm.Result.make(localRuntime);
	var Signal;
	var Utils = Elm.Native.Utils.make(localRuntime);


	// CONSTRUCTORS

	function succeed(value)
	{
		return {
			tag: 'Succeed',
			value: value
		};
	}

	function fail(error)
	{
		return {
			tag: 'Fail',
			value: error
		};
	}

	function asyncFunction(func)
	{
		return {
			tag: 'Async',
			asyncFunction: func
		};
	}

	function andThen(task, callback)
	{
		return {
			tag: 'AndThen',
			task: task,
			callback: callback
		};
	}

	function catch_(task, callback)
	{
		return {
			tag: 'Catch',
			task: task,
			callback: callback
		};
	}


	// RUNNER

	function perform(task) {
		runTask({ task: task }, function() {});
	}

	function performSignal(name, signal)
	{
		var workQueue = [];

		function onComplete()
		{
			workQueue.shift();

			if (workQueue.length > 0)
			{
				var task = workQueue[0];

				setTimeout(function() {
					runTask(task, onComplete);
				}, 0);
			}
		}

		function register(task)
		{
			var root = { task: task };
			workQueue.push(root);
			if (workQueue.length === 1)
			{
				runTask(root, onComplete);
			}
		}

		if (!Signal)
		{
			Signal = Elm.Native.Signal.make(localRuntime);
		}
		Signal.output('perform-tasks-' + name, register, signal);

		register(signal.value);

		return signal;
	}

	function mark(status, task)
	{
		return { status: status, task: task };
	}

	function runTask(root, onComplete)
	{
		var result = mark('runnable', root.task);
		while (result.status === 'runnable')
		{
			result = stepTask(onComplete, root, result.task);
		}

		if (result.status === 'done')
		{
			root.task = result.task;
			onComplete();
		}

		if (result.status === 'blocked')
		{
			root.task = result.task;
		}
	}

	function stepTask(onComplete, root, task)
	{
		var tag = task.tag;

		if (tag === 'Succeed' || tag === 'Fail')
		{
			return mark('done', task);
		}

		if (tag === 'Async')
		{
			var placeHolder = {};
			var couldBeSync = true;
			var wasSync = false;

			task.asyncFunction(function(result) {
				placeHolder.tag = result.tag;
				placeHolder.value = result.value;
				if (couldBeSync)
				{
					wasSync = true;
				}
				else
				{
					runTask(root, onComplete);
				}
			});
			couldBeSync = false;
			return mark(wasSync ? 'done' : 'blocked', placeHolder);
		}

		if (tag === 'AndThen' || tag === 'Catch')
		{
			var result = mark('runnable', task.task);
			while (result.status === 'runnable')
			{
				result = stepTask(onComplete, root, result.task);
			}

			if (result.status === 'done')
			{
				var activeTask = result.task;
				var activeTag = activeTask.tag;

				var succeedChain = activeTag === 'Succeed' && tag === 'AndThen';
				var failChain = activeTag === 'Fail' && tag === 'Catch';

				return (succeedChain || failChain)
					? mark('runnable', task.callback(activeTask.value))
					: mark('runnable', activeTask);
			}
			if (result.status === 'blocked')
			{
				return mark('blocked', {
					tag: tag,
					task: result.task,
					callback: task.callback
				});
			}
		}
	}


	// THREADS

	function sleep(time) {
		return asyncFunction(function(callback) {
			setTimeout(function() {
				callback(succeed(Utils.Tuple0));
			}, time);
		});
	}

	function spawn(task) {
		return asyncFunction(function(callback) {
			var id = setTimeout(function() {
				perform(task);
			}, 0);
			callback(succeed(id));
		});
	}


	return localRuntime.Native.Task.values = {
		succeed: succeed,
		fail: fail,
		asyncFunction: asyncFunction,
		andThen: F2(andThen),
		catch_: F2(catch_),
		perform: perform,
		performSignal: performSignal,
		spawn: spawn,
		sleep: sleep
	};
};

Elm.Task = Elm.Task || {};
Elm.Task.make = function (_elm) {
   "use strict";
   _elm.Task = _elm.Task || {};
   if (_elm.Task.values) return _elm.Task.values;
   var _U = Elm.Native.Utils.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Task = Elm.Native.Task.make(_elm),
   $Result = Elm.Result.make(_elm);
   var _op = {};
   var sleep = $Native$Task.sleep;
   var spawn = $Native$Task.spawn;
   var ThreadID = function (a) {    return {ctor: "ThreadID",_0: a};};
   var onError = $Native$Task.catch_;
   var andThen = $Native$Task.andThen;
   var fail = $Native$Task.fail;
   var mapError = F2(function (f,task) {    return A2(onError,task,function (err) {    return fail(f(err));});});
   var succeed = $Native$Task.succeed;
   var map = F2(function (func,taskA) {    return A2(andThen,taskA,function (a) {    return succeed(func(a));});});
   var map2 = F3(function (func,taskA,taskB) {
      return A2(andThen,taskA,function (a) {    return A2(andThen,taskB,function (b) {    return succeed(A2(func,a,b));});});
   });
   var map3 = F4(function (func,taskA,taskB,taskC) {
      return A2(andThen,
      taskA,
      function (a) {
         return A2(andThen,taskB,function (b) {    return A2(andThen,taskC,function (c) {    return succeed(A3(func,a,b,c));});});
      });
   });
   var map4 = F5(function (func,taskA,taskB,taskC,taskD) {
      return A2(andThen,
      taskA,
      function (a) {
         return A2(andThen,
         taskB,
         function (b) {
            return A2(andThen,taskC,function (c) {    return A2(andThen,taskD,function (d) {    return succeed(A4(func,a,b,c,d));});});
         });
      });
   });
   var map5 = F6(function (func,taskA,taskB,taskC,taskD,taskE) {
      return A2(andThen,
      taskA,
      function (a) {
         return A2(andThen,
         taskB,
         function (b) {
            return A2(andThen,
            taskC,
            function (c) {
               return A2(andThen,taskD,function (d) {    return A2(andThen,taskE,function (e) {    return succeed(A5(func,a,b,c,d,e));});});
            });
         });
      });
   });
   var andMap = F2(function (taskFunc,taskValue) {
      return A2(andThen,taskFunc,function (func) {    return A2(andThen,taskValue,function (value) {    return succeed(func(value));});});
   });
   var sequence = function (tasks) {
      var _p0 = tasks;
      if (_p0.ctor === "[]") {
            return succeed(_U.list([]));
         } else {
            return A3(map2,F2(function (x,y) {    return A2($List._op["::"],x,y);}),_p0._0,sequence(_p0._1));
         }
   };
   var toMaybe = function (task) {    return A2(onError,A2(map,$Maybe.Just,task),function (_p1) {    return succeed($Maybe.Nothing);});};
   var fromMaybe = F2(function ($default,maybe) {    var _p2 = maybe;if (_p2.ctor === "Just") {    return succeed(_p2._0);} else {    return fail($default);}});
   var toResult = function (task) {    return A2(onError,A2(map,$Result.Ok,task),function (msg) {    return succeed($Result.Err(msg));});};
   var fromResult = function (result) {    var _p3 = result;if (_p3.ctor === "Ok") {    return succeed(_p3._0);} else {    return fail(_p3._0);}};
   var Task = {ctor: "Task"};
   return _elm.Task.values = {_op: _op
                             ,succeed: succeed
                             ,fail: fail
                             ,map: map
                             ,map2: map2
                             ,map3: map3
                             ,map4: map4
                             ,map5: map5
                             ,andMap: andMap
                             ,sequence: sequence
                             ,andThen: andThen
                             ,onError: onError
                             ,mapError: mapError
                             ,toMaybe: toMaybe
                             ,fromMaybe: fromMaybe
                             ,toResult: toResult
                             ,fromResult: fromResult
                             ,spawn: spawn
                             ,sleep: sleep};
};
Elm.Signal = Elm.Signal || {};
Elm.Signal.make = function (_elm) {
   "use strict";
   _elm.Signal = _elm.Signal || {};
   if (_elm.Signal.values) return _elm.Signal.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Signal = Elm.Native.Signal.make(_elm),
   $Task = Elm.Task.make(_elm);
   var _op = {};
   var send = F2(function (_p0,value) {
      var _p1 = _p0;
      return A2($Task.onError,_p1._0(value),function (_p2) {    return $Task.succeed({ctor: "_Tuple0"});});
   });
   var Message = function (a) {    return {ctor: "Message",_0: a};};
   var message = F2(function (_p3,value) {    var _p4 = _p3;return Message(_p4._0(value));});
   var mailbox = $Native$Signal.mailbox;
   var Address = function (a) {    return {ctor: "Address",_0: a};};
   var forwardTo = F2(function (_p5,f) {    var _p6 = _p5;return Address(function (x) {    return _p6._0(f(x));});});
   var Mailbox = F2(function (a,b) {    return {address: a,signal: b};});
   var sampleOn = $Native$Signal.sampleOn;
   var dropRepeats = $Native$Signal.dropRepeats;
   var filterMap = $Native$Signal.filterMap;
   var filter = F3(function (isOk,base,signal) {
      return A3(filterMap,function (value) {    return isOk(value) ? $Maybe.Just(value) : $Maybe.Nothing;},base,signal);
   });
   var merge = F2(function (left,right) {    return A3($Native$Signal.genericMerge,$Basics.always,left,right);});
   var mergeMany = function (signalList) {
      var _p7 = $List.reverse(signalList);
      if (_p7.ctor === "[]") {
            return _U.crashCase("Signal",{start: {line: 184,column: 3},end: {line: 189,column: 40}},_p7)("mergeMany was given an empty list!");
         } else {
            return A3($List.foldl,merge,_p7._0,_p7._1);
         }
   };
   var foldp = $Native$Signal.foldp;
   var map5 = $Native$Signal.map5;
   var map4 = $Native$Signal.map4;
   var map3 = $Native$Signal.map3;
   var map2 = $Native$Signal.map2;
   var map = $Native$Signal.map;
   var constant = $Native$Signal.constant;
   var Signal = {ctor: "Signal"};
   return _elm.Signal.values = {_op: _op
                               ,merge: merge
                               ,mergeMany: mergeMany
                               ,map: map
                               ,map2: map2
                               ,map3: map3
                               ,map4: map4
                               ,map5: map5
                               ,constant: constant
                               ,dropRepeats: dropRepeats
                               ,filter: filter
                               ,filterMap: filterMap
                               ,sampleOn: sampleOn
                               ,foldp: foldp
                               ,mailbox: mailbox
                               ,send: send
                               ,message: message
                               ,forwardTo: forwardTo
                               ,Mailbox: Mailbox};
};
Elm.Signal = Elm.Signal || {};
Elm.Signal.Extra = Elm.Signal.Extra || {};
Elm.Signal.Extra.make = function (_elm) {
   "use strict";
   _elm.Signal = _elm.Signal || {};
   _elm.Signal.Extra = _elm.Signal.Extra || {};
   if (_elm.Signal.Extra.values) return _elm.Signal.Extra.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var unsafeFromJust = function (maybe) {
      var _p0 = maybe;
      if (_p0.ctor === "Just") {
            return _p0._0;
         } else {
            return _U.crashCase("Signal.Extra",{start: {line: 510,column: 3},end: {line: 515,column: 59}},_p0)("This case should have been unreachable");
         }
   };
   var passiveMap2 = F2(function (func,a) {    return function (_p2) {    return A3($Signal.map2,func,a,A2($Signal.sampleOn,a,_p2));};});
   var withPassive = passiveMap2(F2(function (x,y) {    return x(y);}));
   var combine = A2($List.foldr,$Signal.map2(F2(function (x,y) {    return A2($List._op["::"],x,y);})),$Signal.constant(_U.list([])));
   var mergeMany = F2(function (original,others) {    return A3($List.foldl,$Signal.merge,original,others);});
   var filter = function (initial) {    return A2($Signal.filterMap,$Basics.identity,initial);};
   var keepIf = $Signal.filter;
   var runBuffer$ = F3(function (l,n,input) {
      var f = F2(function (inp,prev) {
         var l = $List.length(prev);
         return _U.cmp(l,n) < 0 ? A2($Basics._op["++"],prev,_U.list([inp])) : A2($Basics._op["++"],A2($List.drop,l - n + 1,prev),_U.list([inp]));
      });
      return A3($Signal.foldp,f,l,input);
   });
   var runBuffer = runBuffer$(_U.list([]));
   var initSignal = function (s) {    return A2($Signal.sampleOn,$Signal.constant({ctor: "_Tuple0"}),s);};
   var zip4 = $Signal.map4(F4(function (v0,v1,v2,v3) {    return {ctor: "_Tuple4",_0: v0,_1: v1,_2: v2,_3: v3};}));
   var zip3 = $Signal.map3(F3(function (v0,v1,v2) {    return {ctor: "_Tuple3",_0: v0,_1: v1,_2: v2};}));
   var zip = $Signal.map2(F2(function (v0,v1) {    return {ctor: "_Tuple2",_0: v0,_1: v1};}));
   var keepWhen = F3(function (boolSig,a,aSig) {
      return A2($Signal.map,$Basics.snd,A3(keepIf,$Basics.fst,{ctor: "_Tuple2",_0: true,_1: a},A2($Signal.sampleOn,aSig,A2(zip,boolSig,aSig))));
   });
   var sampleWhen = F3(function (bs,def,sig) {
      return A2($Signal.map,$Basics.snd,A3(keepIf,$Basics.fst,{ctor: "_Tuple2",_0: true,_1: def},A2(zip,bs,sig)));
   });
   var andMap = $Signal.map2(F2(function (x,y) {    return x(y);}));
   _op["~"] = andMap;
   var applyMany = F2(function (fs,l) {    return A2(_op["~"],fs,combine(l));});
   _op["~>"] = $Basics.flip($Signal.map);
   var foldpWith = F4(function (unpack,step,init,input) {
      var step$ = F2(function (a,_p3) {    var _p4 = _p3;return unpack(A2(step,a,_p4._1));});
      return A2(_op["~>"],A3($Signal.foldp,step$,init,input),$Basics.fst);
   });
   _op["<~"] = $Signal.map;
   var unzip = function (pairS) {    return {ctor: "_Tuple2",_0: A2(_op["<~"],$Basics.fst,pairS),_1: A2(_op["<~"],$Basics.snd,pairS)};};
   var unzip3 = function (pairS) {
      return {ctor: "_Tuple3"
             ,_0: A2(_op["<~"],function (_p5) {    var _p6 = _p5;return _p6._0;},pairS)
             ,_1: A2(_op["<~"],function (_p7) {    var _p8 = _p7;return _p8._1;},pairS)
             ,_2: A2(_op["<~"],function (_p9) {    var _p10 = _p9;return _p10._2;},pairS)};
   };
   var unzip4 = function (pairS) {
      return {ctor: "_Tuple4"
             ,_0: A2(_op["<~"],function (_p11) {    var _p12 = _p11;return _p12._0;},pairS)
             ,_1: A2(_op["<~"],function (_p13) {    var _p14 = _p13;return _p14._1;},pairS)
             ,_2: A2(_op["<~"],function (_p15) {    var _p16 = _p15;return _p16._2;},pairS)
             ,_3: A2(_op["<~"],function (_p17) {    var _p18 = _p17;return _p18._3;},pairS)};
   };
   var foldp$ = F3(function (fun,initFun,input) {
      var fun$ = F2(function (_p19,mb) {    var _p20 = _p19;return $Maybe.Just(A2(fun,_p20._0,A2($Maybe.withDefault,_p20._1,mb)));});
      var initial = A2(_op["~>"],initSignal(input),initFun);
      var rest = A3($Signal.foldp,fun$,$Maybe.Nothing,A2(zip,input,initial));
      return A2(_op["<~"],unsafeFromJust,A2($Signal.merge,A2(_op["<~"],$Maybe.Just,initial),rest));
   });
   var deltas = function (signal) {
      var initial = function (value) {    return {ctor: "_Tuple2",_0: value,_1: value};};
      var step = F2(function (value,delta) {    return {ctor: "_Tuple2",_0: $Basics.snd(delta),_1: value};});
      return A3(foldp$,step,initial,signal);
   };
   var foldps = F3(function (f,bs,aS) {
      return A2(_op["<~"],$Basics.fst,A3($Signal.foldp,F2(function (a,_p21) {    var _p22 = _p21;return A2(f,a,_p22._1);}),bs,aS));
   });
   var delayRound = F2(function (b,bS) {
      return A3(foldps,F2(function ($new,old) {    return {ctor: "_Tuple2",_0: old,_1: $new};}),{ctor: "_Tuple2",_0: b,_1: b},bS);
   });
   var filterFold = F2(function (f,initial) {
      var f$ = F2(function (a,s) {    var res = A2(f,a,s);return {ctor: "_Tuple2",_0: res,_1: A2($Maybe.withDefault,s,res)};});
      return function (_p23) {
         return A2(filter,initial,A3(foldps,f$,{ctor: "_Tuple2",_0: $Maybe.Just(initial),_1: initial},_p23));
      };
   });
   var foldps$ = F3(function (f,iF,aS) {
      return A2(_op["<~"],$Basics.fst,A3(foldp$,F2(function (a,_p24) {    var _p25 = _p24;return A2(f,a,_p25._1);}),iF,aS));
   });
   var switchHelper = F4(function (filter,b,l,r) {
      var lAndR = A2($Signal.merge,
      A3(filter,b,$Maybe.Nothing,A2(_op["<~"],$Maybe.Just,l)),
      A3(filter,A2(_op["<~"],$Basics.not,b),$Maybe.Nothing,A2(_op["<~"],$Maybe.Just,r)));
      var base = A2(_op["~"],
      A2(_op["~"],A2(_op["<~"],F3(function (bi,li,ri) {    return $Maybe.Just(bi ? li : ri);}),initSignal(b)),initSignal(l)),
      initSignal(r));
      return A2(_op["<~"],unsafeFromJust,A2($Signal.merge,base,lAndR));
   });
   var switchWhen = F3(function (b,l,r) {    return A4(switchHelper,keepWhen,b,l,r);});
   var switchSample = F3(function (b,l,r) {    return A4(switchHelper,sampleWhen,b,l,r);});
   var keepThen = F3(function (choice,base,signal) {    return A3(switchSample,choice,signal,$Signal.constant(base));});
   var keepWhenI = F2(function (fs,s) {
      return A2(_op["~>"],A3(keepWhen,A2($Signal.merge,$Signal.constant(true),fs),$Maybe.Nothing,A2(_op["<~"],$Maybe.Just,s)),unsafeFromJust);
   });
   var fairMerge = F3(function (resolve,left,right) {
      var merged = A2($Signal.merge,left,right);
      var boolRight = A2(_op["<~"],$Basics.always(false),right);
      var boolLeft = A2(_op["<~"],$Basics.always(true),left);
      var bothUpdated = A2(_op["~"],
      A2(_op["<~"],F2(function (x,y) {    return !_U.eq(x,y);}),A2($Signal.merge,boolLeft,boolRight)),
      A2($Signal.merge,boolRight,boolLeft));
      var keep = keepWhenI(bothUpdated);
      var resolved = A2(_op["~"],A2(_op["<~"],resolve,keep(left)),keep(right));
      return A2($Signal.merge,resolved,merged);
   });
   var mapMany = F2(function (f,l) {    return A2(_op["<~"],f,combine(l));});
   return _elm.Signal.Extra.values = {_op: _op
                                     ,andMap: andMap
                                     ,zip: zip
                                     ,zip3: zip3
                                     ,zip4: zip4
                                     ,unzip: unzip
                                     ,unzip3: unzip3
                                     ,unzip4: unzip4
                                     ,foldp$: foldp$
                                     ,foldps: foldps
                                     ,foldps$: foldps$
                                     ,runBuffer: runBuffer
                                     ,runBuffer$: runBuffer$
                                     ,deltas: deltas
                                     ,delayRound: delayRound
                                     ,keepIf: keepIf
                                     ,keepWhen: keepWhen
                                     ,sampleWhen: sampleWhen
                                     ,switchWhen: switchWhen
                                     ,keepWhenI: keepWhenI
                                     ,switchSample: switchSample
                                     ,keepThen: keepThen
                                     ,filter: filter
                                     ,filterFold: filterFold
                                     ,fairMerge: fairMerge
                                     ,mergeMany: mergeMany
                                     ,combine: combine
                                     ,mapMany: mapMany
                                     ,applyMany: applyMany
                                     ,passiveMap2: passiveMap2
                                     ,withPassive: withPassive};
};
Elm.Native.Time = {};

Elm.Native.Time.make = function(localRuntime)
{
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Time = localRuntime.Native.Time || {};
	if (localRuntime.Native.Time.values)
	{
		return localRuntime.Native.Time.values;
	}

	var NS = Elm.Native.Signal.make(localRuntime);
	var Maybe = Elm.Maybe.make(localRuntime);


	// FRAMES PER SECOND

	function fpsWhen(desiredFPS, isOn)
	{
		var msPerFrame = 1000 / desiredFPS;
		var ticker = NS.input('fps-' + desiredFPS, null);

		function notifyTicker()
		{
			localRuntime.notify(ticker.id, null);
		}

		function firstArg(x, y)
		{
			return x;
		}

		// input fires either when isOn changes, or when ticker fires.
		// Its value is a tuple with the current timestamp, and the state of isOn
		var input = NS.timestamp(A3(NS.map2, F2(firstArg), NS.dropRepeats(isOn), ticker));

		var initialState = {
			isOn: false,
			time: localRuntime.timer.programStart,
			delta: 0
		};

		var timeoutId;

		function update(input, state)
		{
			var currentTime = input._0;
			var isOn = input._1;
			var wasOn = state.isOn;
			var previousTime = state.time;

			if (isOn)
			{
				timeoutId = localRuntime.setTimeout(notifyTicker, msPerFrame);
			}
			else if (wasOn)
			{
				clearTimeout(timeoutId);
			}

			return {
				isOn: isOn,
				time: currentTime,
				delta: (isOn && !wasOn) ? 0 : currentTime - previousTime
			};
		}

		return A2(
			NS.map,
			function(state) { return state.delta; },
			A3(NS.foldp, F2(update), update(input.value, initialState), input)
		);
	}


	// EVERY

	function every(t)
	{
		var ticker = NS.input('every-' + t, null);
		function tellTime()
		{
			localRuntime.notify(ticker.id, null);
		}
		var clock = A2(NS.map, fst, NS.timestamp(ticker));
		setInterval(tellTime, t);
		return clock;
	}


	function fst(pair)
	{
		return pair._0;
	}


	function read(s)
	{
		var t = Date.parse(s);
		return isNaN(t) ? Maybe.Nothing : Maybe.Just(t);
	}

	return localRuntime.Native.Time.values = {
		fpsWhen: F2(fpsWhen),
		every: every,
		toDate: function(t) { return new Date(t); },
		read: read
	};
};

Elm.Time = Elm.Time || {};
Elm.Time.make = function (_elm) {
   "use strict";
   _elm.Time = _elm.Time || {};
   if (_elm.Time.values) return _elm.Time.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Native$Signal = Elm.Native.Signal.make(_elm),
   $Native$Time = Elm.Native.Time.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var delay = $Native$Signal.delay;
   var since = F2(function (time,signal) {
      var stop = A2($Signal.map,$Basics.always(-1),A2(delay,time,signal));
      var start = A2($Signal.map,$Basics.always(1),signal);
      var delaydiff = A3($Signal.foldp,F2(function (x,y) {    return x + y;}),0,A2($Signal.merge,start,stop));
      return A2($Signal.map,F2(function (x,y) {    return !_U.eq(x,y);})(0),delaydiff);
   });
   var timestamp = $Native$Signal.timestamp;
   var every = $Native$Time.every;
   var fpsWhen = $Native$Time.fpsWhen;
   var fps = function (targetFrames) {    return A2(fpsWhen,targetFrames,$Signal.constant(true));};
   var inMilliseconds = function (t) {    return t;};
   var millisecond = 1;
   var second = 1000 * millisecond;
   var minute = 60 * second;
   var hour = 60 * minute;
   var inHours = function (t) {    return t / hour;};
   var inMinutes = function (t) {    return t / minute;};
   var inSeconds = function (t) {    return t / second;};
   return _elm.Time.values = {_op: _op
                             ,millisecond: millisecond
                             ,second: second
                             ,minute: minute
                             ,hour: hour
                             ,inMilliseconds: inMilliseconds
                             ,inSeconds: inSeconds
                             ,inMinutes: inMinutes
                             ,inHours: inHours
                             ,fps: fps
                             ,fpsWhen: fpsWhen
                             ,every: every
                             ,timestamp: timestamp
                             ,delay: delay
                             ,since: since};
};
Elm.Native.Array = {};
Elm.Native.Array.make = function(localRuntime) {

	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Array = localRuntime.Native.Array || {};
	if (localRuntime.Native.Array.values)
	{
		return localRuntime.Native.Array.values;
	}
	if ('values' in Elm.Native.Array)
	{
		return localRuntime.Native.Array.values = Elm.Native.Array.values;
	}

	var List = Elm.Native.List.make(localRuntime);

	// A RRB-Tree has two distinct data types.
	// Leaf -> "height"  is always 0
	//         "table"   is an array of elements
	// Node -> "height"  is always greater than 0
	//         "table"   is an array of child nodes
	//         "lengths" is an array of accumulated lengths of the child nodes

	// M is the maximal table size. 32 seems fast. E is the allowed increase
	// of search steps when concatting to find an index. Lower values will
	// decrease balancing, but will increase search steps.
	var M = 32;
	var E = 2;

	// An empty array.
	var empty = {
		ctor: '_Array',
		height: 0,
		table: []
	};


	function get(i, array)
	{
		if (i < 0 || i >= length(array))
		{
			throw new Error(
				'Index ' + i + ' is out of range. Check the length of ' +
				'your array first or use getMaybe or getWithDefault.');
		}
		return unsafeGet(i, array);
	}


	function unsafeGet(i, array)
	{
		for (var x = array.height; x > 0; x--)
		{
			var slot = i >> (x * 5);
			while (array.lengths[slot] <= i)
			{
				slot++;
			}
			if (slot > 0)
			{
				i -= array.lengths[slot - 1];
			}
			array = array.table[slot];
		}
		return array.table[i];
	}


	// Sets the value at the index i. Only the nodes leading to i will get
	// copied and updated.
	function set(i, item, array)
	{
		if (i < 0 || length(array) <= i)
		{
			return array;
		}
		return unsafeSet(i, item, array);
	}


	function unsafeSet(i, item, array)
	{
		array = nodeCopy(array);

		if (array.height === 0)
		{
			array.table[i] = item;
		}
		else
		{
			var slot = getSlot(i, array);
			if (slot > 0)
			{
				i -= array.lengths[slot - 1];
			}
			array.table[slot] = unsafeSet(i, item, array.table[slot]);
		}
		return array;
	}


	function initialize(len, f)
	{
		if (len <= 0)
		{
			return empty;
		}
		var h = Math.floor( Math.log(len) / Math.log(M) );
		return initialize_(f, h, 0, len);
	}

	function initialize_(f, h, from, to)
	{
		if (h === 0)
		{
			var table = new Array((to - from) % (M + 1));
			for (var i = 0; i < table.length; i++)
			{
			  table[i] = f(from + i);
			}
			return {
				ctor: '_Array',
				height: 0,
				table: table
			};
		}

		var step = Math.pow(M, h);
		var table = new Array(Math.ceil((to - from) / step));
		var lengths = new Array(table.length);
		for (var i = 0; i < table.length; i++)
		{
			table[i] = initialize_(f, h - 1, from + (i * step), Math.min(from + ((i + 1) * step), to));
			lengths[i] = length(table[i]) + (i > 0 ? lengths[i-1] : 0);
		}
		return {
			ctor: '_Array',
			height: h,
			table: table,
			lengths: lengths
		};
	}

	function fromList(list)
	{
		if (list === List.Nil)
		{
			return empty;
		}

		// Allocate M sized blocks (table) and write list elements to it.
		var table = new Array(M);
		var nodes = [];
		var i = 0;

		while (list.ctor !== '[]')
		{
			table[i] = list._0;
			list = list._1;
			i++;

			// table is full, so we can push a leaf containing it into the
			// next node.
			if (i === M)
			{
				var leaf = {
					ctor: '_Array',
					height: 0,
					table: table
				};
				fromListPush(leaf, nodes);
				table = new Array(M);
				i = 0;
			}
		}

		// Maybe there is something left on the table.
		if (i > 0)
		{
			var leaf = {
				ctor: '_Array',
				height: 0,
				table: table.splice(0, i)
			};
			fromListPush(leaf, nodes);
		}

		// Go through all of the nodes and eventually push them into higher nodes.
		for (var h = 0; h < nodes.length - 1; h++)
		{
			if (nodes[h].table.length > 0)
			{
				fromListPush(nodes[h], nodes);
			}
		}

		var head = nodes[nodes.length - 1];
		if (head.height > 0 && head.table.length === 1)
		{
			return head.table[0];
		}
		else
		{
			return head;
		}
	}

	// Push a node into a higher node as a child.
	function fromListPush(toPush, nodes)
	{
		var h = toPush.height;

		// Maybe the node on this height does not exist.
		if (nodes.length === h)
		{
			var node = {
				ctor: '_Array',
				height: h + 1,
				table: [],
				lengths: []
			};
			nodes.push(node);
		}

		nodes[h].table.push(toPush);
		var len = length(toPush);
		if (nodes[h].lengths.length > 0)
		{
			len += nodes[h].lengths[nodes[h].lengths.length - 1];
		}
		nodes[h].lengths.push(len);

		if (nodes[h].table.length === M)
		{
			fromListPush(nodes[h], nodes);
			nodes[h] = {
				ctor: '_Array',
				height: h + 1,
				table: [],
				lengths: []
			};
		}
	}

	// Pushes an item via push_ to the bottom right of a tree.
	function push(item, a)
	{
		var pushed = push_(item, a);
		if (pushed !== null)
		{
			return pushed;
		}

		var newTree = create(item, a.height);
		return siblise(a, newTree);
	}

	// Recursively tries to push an item to the bottom-right most
	// tree possible. If there is no space left for the item,
	// null will be returned.
	function push_(item, a)
	{
		// Handle resursion stop at leaf level.
		if (a.height === 0)
		{
			if (a.table.length < M)
			{
				var newA = {
					ctor: '_Array',
					height: 0,
					table: a.table.slice()
				};
				newA.table.push(item);
				return newA;
			}
			else
			{
			  return null;
			}
		}

		// Recursively push
		var pushed = push_(item, botRight(a));

		// There was space in the bottom right tree, so the slot will
		// be updated.
		if (pushed !== null)
		{
			var newA = nodeCopy(a);
			newA.table[newA.table.length - 1] = pushed;
			newA.lengths[newA.lengths.length - 1]++;
			return newA;
		}

		// When there was no space left, check if there is space left
		// for a new slot with a tree which contains only the item
		// at the bottom.
		if (a.table.length < M)
		{
			var newSlot = create(item, a.height - 1);
			var newA = nodeCopy(a);
			newA.table.push(newSlot);
			newA.lengths.push(newA.lengths[newA.lengths.length - 1] + length(newSlot));
			return newA;
		}
		else
		{
			return null;
		}
	}

	// Converts an array into a list of elements.
	function toList(a)
	{
		return toList_(List.Nil, a);
	}

	function toList_(list, a)
	{
		for (var i = a.table.length - 1; i >= 0; i--)
		{
			list =
				a.height === 0
					? List.Cons(a.table[i], list)
					: toList_(list, a.table[i]);
		}
		return list;
	}

	// Maps a function over the elements of an array.
	function map(f, a)
	{
		var newA = {
			ctor: '_Array',
			height: a.height,
			table: new Array(a.table.length)
		};
		if (a.height > 0)
		{
			newA.lengths = a.lengths;
		}
		for (var i = 0; i < a.table.length; i++)
		{
			newA.table[i] =
				a.height === 0
					? f(a.table[i])
					: map(f, a.table[i]);
		}
		return newA;
	}

	// Maps a function over the elements with their index as first argument.
	function indexedMap(f, a)
	{
		return indexedMap_(f, a, 0);
	}

	function indexedMap_(f, a, from)
	{
		var newA = {
			ctor: '_Array',
			height: a.height,
			table: new Array(a.table.length)
		};
		if (a.height > 0)
		{
			newA.lengths = a.lengths;
		}
		for (var i = 0; i < a.table.length; i++)
		{
			newA.table[i] =
				a.height === 0
					? A2(f, from + i, a.table[i])
					: indexedMap_(f, a.table[i], i == 0 ? from : from + a.lengths[i - 1]);
		}
		return newA;
	}

	function foldl(f, b, a)
	{
		if (a.height === 0)
		{
			for (var i = 0; i < a.table.length; i++)
			{
				b = A2(f, a.table[i], b);
			}
		}
		else
		{
			for (var i = 0; i < a.table.length; i++)
			{
				b = foldl(f, b, a.table[i]);
			}
		}
		return b;
	}

	function foldr(f, b, a)
	{
		if (a.height === 0)
		{
			for (var i = a.table.length; i--; )
			{
				b = A2(f, a.table[i], b);
			}
		}
		else
		{
			for (var i = a.table.length; i--; )
			{
				b = foldr(f, b, a.table[i]);
			}
		}
		return b;
	}

	// TODO: currently, it slices the right, then the left. This can be
	// optimized.
	function slice(from, to, a)
	{
		if (from < 0)
		{
			from += length(a);
		}
		if (to < 0)
		{
			to += length(a);
		}
		return sliceLeft(from, sliceRight(to, a));
	}

	function sliceRight(to, a)
	{
		if (to === length(a))
		{
			return a;
		}

		// Handle leaf level.
		if (a.height === 0)
		{
			var newA = { ctor:'_Array', height:0 };
			newA.table = a.table.slice(0, to);
			return newA;
		}

		// Slice the right recursively.
		var right = getSlot(to, a);
		var sliced = sliceRight(to - (right > 0 ? a.lengths[right - 1] : 0), a.table[right]);

		// Maybe the a node is not even needed, as sliced contains the whole slice.
		if (right === 0)
		{
			return sliced;
		}

		// Create new node.
		var newA = {
			ctor: '_Array',
			height: a.height,
			table: a.table.slice(0, right),
			lengths: a.lengths.slice(0, right)
		};
		if (sliced.table.length > 0)
		{
			newA.table[right] = sliced;
			newA.lengths[right] = length(sliced) + (right > 0 ? newA.lengths[right - 1] : 0);
		}
		return newA;
	}

	function sliceLeft(from, a)
	{
		if (from === 0)
		{
			return a;
		}

		// Handle leaf level.
		if (a.height === 0)
		{
			var newA = { ctor:'_Array', height:0 };
			newA.table = a.table.slice(from, a.table.length + 1);
			return newA;
		}

		// Slice the left recursively.
		var left = getSlot(from, a);
		var sliced = sliceLeft(from - (left > 0 ? a.lengths[left - 1] : 0), a.table[left]);

		// Maybe the a node is not even needed, as sliced contains the whole slice.
		if (left === a.table.length - 1)
		{
			return sliced;
		}

		// Create new node.
		var newA = {
			ctor: '_Array',
			height: a.height,
			table: a.table.slice(left, a.table.length + 1),
			lengths: new Array(a.table.length - left)
		};
		newA.table[0] = sliced;
		var len = 0;
		for (var i = 0; i < newA.table.length; i++)
		{
			len += length(newA.table[i]);
			newA.lengths[i] = len;
		}

		return newA;
	}

	// Appends two trees.
	function append(a,b)
	{
		if (a.table.length === 0)
		{
			return b;
		}
		if (b.table.length === 0)
		{
			return a;
		}

		var c = append_(a, b);

		// Check if both nodes can be crunshed together.
		if (c[0].table.length + c[1].table.length <= M)
		{
			if (c[0].table.length === 0)
			{
				return c[1];
			}
			if (c[1].table.length === 0)
			{
				return c[0];
			}

			// Adjust .table and .lengths
			c[0].table = c[0].table.concat(c[1].table);
			if (c[0].height > 0)
			{
				var len = length(c[0]);
				for (var i = 0; i < c[1].lengths.length; i++)
				{
					c[1].lengths[i] += len;
				}
				c[0].lengths = c[0].lengths.concat(c[1].lengths);
			}

			return c[0];
		}

		if (c[0].height > 0)
		{
			var toRemove = calcToRemove(a, b);
			if (toRemove > E)
			{
				c = shuffle(c[0], c[1], toRemove);
			}
		}

		return siblise(c[0], c[1]);
	}

	// Returns an array of two nodes; right and left. One node _may_ be empty.
	function append_(a, b)
	{
		if (a.height === 0 && b.height === 0)
		{
			return [a, b];
		}

		if (a.height !== 1 || b.height !== 1)
		{
			if (a.height === b.height)
			{
				a = nodeCopy(a);
				b = nodeCopy(b);
				var appended = append_(botRight(a), botLeft(b));

				insertRight(a, appended[1]);
				insertLeft(b, appended[0]);
			}
			else if (a.height > b.height)
			{
				a = nodeCopy(a);
				var appended = append_(botRight(a), b);

				insertRight(a, appended[0]);
				b = parentise(appended[1], appended[1].height + 1);
			}
			else
			{
				b = nodeCopy(b);
				var appended = append_(a, botLeft(b));

				var left = appended[0].table.length === 0 ? 0 : 1;
				var right = left === 0 ? 1 : 0;
				insertLeft(b, appended[left]);
				a = parentise(appended[right], appended[right].height + 1);
			}
		}

		// Check if balancing is needed and return based on that.
		if (a.table.length === 0 || b.table.length === 0)
		{
			return [a, b];
		}

		var toRemove = calcToRemove(a, b);
		if (toRemove <= E)
		{
			return [a, b];
		}
		return shuffle(a, b, toRemove);
	}

	// Helperfunctions for append_. Replaces a child node at the side of the parent.
	function insertRight(parent, node)
	{
		var index = parent.table.length - 1;
		parent.table[index] = node;
		parent.lengths[index] = length(node);
		parent.lengths[index] += index > 0 ? parent.lengths[index - 1] : 0;
	}

	function insertLeft(parent, node)
	{
		if (node.table.length > 0)
		{
			parent.table[0] = node;
			parent.lengths[0] = length(node);

			var len = length(parent.table[0]);
			for (var i = 1; i < parent.lengths.length; i++)
			{
				len += length(parent.table[i]);
				parent.lengths[i] = len;
			}
		}
		else
		{
			parent.table.shift();
			for (var i = 1; i < parent.lengths.length; i++)
			{
				parent.lengths[i] = parent.lengths[i] - parent.lengths[0];
			}
			parent.lengths.shift();
		}
	}

	// Returns the extra search steps for E. Refer to the paper.
	function calcToRemove(a, b)
	{
		var subLengths = 0;
		for (var i = 0; i < a.table.length; i++)
		{
			subLengths += a.table[i].table.length;
		}
		for (var i = 0; i < b.table.length; i++)
		{
			subLengths += b.table[i].table.length;
		}

		var toRemove = a.table.length + b.table.length;
		return toRemove - (Math.floor((subLengths - 1) / M) + 1);
	}

	// get2, set2 and saveSlot are helpers for accessing elements over two arrays.
	function get2(a, b, index)
	{
		return index < a.length
			? a[index]
			: b[index - a.length];
	}

	function set2(a, b, index, value)
	{
		if (index < a.length)
		{
			a[index] = value;
		}
		else
		{
			b[index - a.length] = value;
		}
	}

	function saveSlot(a, b, index, slot)
	{
		set2(a.table, b.table, index, slot);

		var l = (index === 0 || index === a.lengths.length)
			? 0
			: get2(a.lengths, a.lengths, index - 1);

		set2(a.lengths, b.lengths, index, l + length(slot));
	}

	// Creates a node or leaf with a given length at their arrays for perfomance.
	// Is only used by shuffle.
	function createNode(h, length)
	{
		if (length < 0)
		{
			length = 0;
		}
		var a = {
			ctor: '_Array',
			height: h,
			table: new Array(length)
		};
		if (h > 0)
		{
			a.lengths = new Array(length);
		}
		return a;
	}

	// Returns an array of two balanced nodes.
	function shuffle(a, b, toRemove)
	{
		var newA = createNode(a.height, Math.min(M, a.table.length + b.table.length - toRemove));
		var newB = createNode(a.height, newA.table.length - (a.table.length + b.table.length - toRemove));

		// Skip the slots with size M. More precise: copy the slot references
		// to the new node
		var read = 0;
		while (get2(a.table, b.table, read).table.length % M === 0)
		{
			set2(newA.table, newB.table, read, get2(a.table, b.table, read));
			set2(newA.lengths, newB.lengths, read, get2(a.lengths, b.lengths, read));
			read++;
		}

		// Pulling items from left to right, caching in a slot before writing
		// it into the new nodes.
		var write = read;
		var slot = new createNode(a.height - 1, 0);
		var from = 0;

		// If the current slot is still containing data, then there will be at
		// least one more write, so we do not break this loop yet.
		while (read - write - (slot.table.length > 0 ? 1 : 0) < toRemove)
		{
			// Find out the max possible items for copying.
			var source = get2(a.table, b.table, read);
			var to = Math.min(M - slot.table.length, source.table.length);

			// Copy and adjust size table.
			slot.table = slot.table.concat(source.table.slice(from, to));
			if (slot.height > 0)
			{
				var len = slot.lengths.length;
				for (var i = len; i < len + to - from; i++)
				{
					slot.lengths[i] = length(slot.table[i]);
					slot.lengths[i] += (i > 0 ? slot.lengths[i - 1] : 0);
				}
			}

			from += to;

			// Only proceed to next slots[i] if the current one was
			// fully copied.
			if (source.table.length <= to)
			{
				read++; from = 0;
			}

			// Only create a new slot if the current one is filled up.
			if (slot.table.length === M)
			{
				saveSlot(newA, newB, write, slot);
				slot = createNode(a.height - 1, 0);
				write++;
			}
		}

		// Cleanup after the loop. Copy the last slot into the new nodes.
		if (slot.table.length > 0)
		{
			saveSlot(newA, newB, write, slot);
			write++;
		}

		// Shift the untouched slots to the left
		while (read < a.table.length + b.table.length )
		{
			saveSlot(newA, newB, write, get2(a.table, b.table, read));
			read++;
			write++;
		}

		return [newA, newB];
	}

	// Navigation functions
	function botRight(a)
	{
		return a.table[a.table.length - 1];
	}
	function botLeft(a)
	{
		return a.table[0];
	}

	// Copies a node for updating. Note that you should not use this if
	// only updating only one of "table" or "lengths" for performance reasons.
	function nodeCopy(a)
	{
		var newA = {
			ctor: '_Array',
			height: a.height,
			table: a.table.slice()
		};
		if (a.height > 0)
		{
			newA.lengths = a.lengths.slice();
		}
		return newA;
	}

	// Returns how many items are in the tree.
	function length(array)
	{
		if (array.height === 0)
		{
			return array.table.length;
		}
		else
		{
			return array.lengths[array.lengths.length - 1];
		}
	}

	// Calculates in which slot of "table" the item probably is, then
	// find the exact slot via forward searching in  "lengths". Returns the index.
	function getSlot(i, a)
	{
		var slot = i >> (5 * a.height);
		while (a.lengths[slot] <= i)
		{
			slot++;
		}
		return slot;
	}

	// Recursively creates a tree with a given height containing
	// only the given item.
	function create(item, h)
	{
		if (h === 0)
		{
			return {
				ctor: '_Array',
				height: 0,
				table: [item]
			};
		}
		return {
			ctor: '_Array',
			height: h,
			table: [create(item, h - 1)],
			lengths: [1]
		};
	}

	// Recursively creates a tree that contains the given tree.
	function parentise(tree, h)
	{
		if (h === tree.height)
		{
			return tree;
		}

		return {
			ctor: '_Array',
			height: h,
			table: [parentise(tree, h - 1)],
			lengths: [length(tree)]
		};
	}

	// Emphasizes blood brotherhood beneath two trees.
	function siblise(a, b)
	{
		return {
			ctor: '_Array',
			height: a.height + 1,
			table: [a, b],
			lengths: [length(a), length(a) + length(b)]
		};
	}

	function toJSArray(a)
	{
		var jsArray = new Array(length(a));
		toJSArray_(jsArray, 0, a);
		return jsArray;
	}

	function toJSArray_(jsArray, i, a)
	{
		for (var t = 0; t < a.table.length; t++)
		{
			if (a.height === 0)
			{
				jsArray[i + t] = a.table[t];
			}
			else
			{
				var inc = t === 0 ? 0 : a.lengths[t - 1];
				toJSArray_(jsArray, i + inc, a.table[t]);
			}
		}
	}

	function fromJSArray(jsArray)
	{
		if (jsArray.length === 0)
		{
			return empty;
		}
		var h = Math.floor(Math.log(jsArray.length) / Math.log(M));
		return fromJSArray_(jsArray, h, 0, jsArray.length);
	}

	function fromJSArray_(jsArray, h, from, to)
	{
		if (h === 0)
		{
			return {
				ctor: '_Array',
				height: 0,
				table: jsArray.slice(from, to)
			};
		}

		var step = Math.pow(M, h);
		var table = new Array(Math.ceil((to - from) / step));
		var lengths = new Array(table.length);
		for (var i = 0; i < table.length; i++)
		{
			table[i] = fromJSArray_(jsArray, h - 1, from + (i * step), Math.min(from + ((i + 1) * step), to));
			lengths[i] = length(table[i]) + (i > 0 ? lengths[i - 1] : 0);
		}
		return {
			ctor: '_Array',
			height: h,
			table: table,
			lengths: lengths
		};
	}

	Elm.Native.Array.values = {
		empty: empty,
		fromList: fromList,
		toList: toList,
		initialize: F2(initialize),
		append: F2(append),
		push: F2(push),
		slice: F3(slice),
		get: F2(get),
		set: F3(set),
		map: F2(map),
		indexedMap: F2(indexedMap),
		foldl: F3(foldl),
		foldr: F3(foldr),
		length: length,

		toJSArray: toJSArray,
		fromJSArray: fromJSArray
	};

	return localRuntime.Native.Array.values = Elm.Native.Array.values;
};

Elm.Array = Elm.Array || {};
Elm.Array.make = function (_elm) {
   "use strict";
   _elm.Array = _elm.Array || {};
   if (_elm.Array.values) return _elm.Array.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Array = Elm.Native.Array.make(_elm);
   var _op = {};
   var append = $Native$Array.append;
   var length = $Native$Array.length;
   var isEmpty = function (array) {    return _U.eq(length(array),0);};
   var slice = $Native$Array.slice;
   var set = $Native$Array.set;
   var get = F2(function (i,array) {
      return _U.cmp(0,i) < 1 && _U.cmp(i,$Native$Array.length(array)) < 0 ? $Maybe.Just(A2($Native$Array.get,i,array)) : $Maybe.Nothing;
   });
   var push = $Native$Array.push;
   var empty = $Native$Array.empty;
   var filter = F2(function (isOkay,arr) {
      var update = F2(function (x,xs) {    return isOkay(x) ? A2($Native$Array.push,x,xs) : xs;});
      return A3($Native$Array.foldl,update,$Native$Array.empty,arr);
   });
   var foldr = $Native$Array.foldr;
   var foldl = $Native$Array.foldl;
   var indexedMap = $Native$Array.indexedMap;
   var map = $Native$Array.map;
   var toIndexedList = function (array) {
      return A3($List.map2,
      F2(function (v0,v1) {    return {ctor: "_Tuple2",_0: v0,_1: v1};}),
      _U.range(0,$Native$Array.length(array) - 1),
      $Native$Array.toList(array));
   };
   var toList = $Native$Array.toList;
   var fromList = $Native$Array.fromList;
   var initialize = $Native$Array.initialize;
   var repeat = F2(function (n,e) {    return A2(initialize,n,$Basics.always(e));});
   var Array = {ctor: "Array"};
   return _elm.Array.values = {_op: _op
                              ,empty: empty
                              ,repeat: repeat
                              ,initialize: initialize
                              ,fromList: fromList
                              ,isEmpty: isEmpty
                              ,length: length
                              ,push: push
                              ,append: append
                              ,get: get
                              ,set: set
                              ,slice: slice
                              ,toList: toList
                              ,toIndexedList: toIndexedList
                              ,map: map
                              ,indexedMap: indexedMap
                              ,filter: filter
                              ,foldl: foldl
                              ,foldr: foldr};
};
Elm.Native.Char = {};
Elm.Native.Char.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Char = localRuntime.Native.Char || {};
	if (localRuntime.Native.Char.values)
	{
		return localRuntime.Native.Char.values;
	}

	var Utils = Elm.Native.Utils.make(localRuntime);

	return localRuntime.Native.Char.values = {
		fromCode: function(c) { return Utils.chr(String.fromCharCode(c)); },
		toCode: function(c) { return c.charCodeAt(0); },
		toUpper: function(c) { return Utils.chr(c.toUpperCase()); },
		toLower: function(c) { return Utils.chr(c.toLowerCase()); },
		toLocaleUpper: function(c) { return Utils.chr(c.toLocaleUpperCase()); },
		toLocaleLower: function(c) { return Utils.chr(c.toLocaleLowerCase()); }
	};
};

Elm.Char = Elm.Char || {};
Elm.Char.make = function (_elm) {
   "use strict";
   _elm.Char = _elm.Char || {};
   if (_elm.Char.values) return _elm.Char.values;
   var _U = Elm.Native.Utils.make(_elm),$Basics = Elm.Basics.make(_elm),$Native$Char = Elm.Native.Char.make(_elm);
   var _op = {};
   var fromCode = $Native$Char.fromCode;
   var toCode = $Native$Char.toCode;
   var toLocaleLower = $Native$Char.toLocaleLower;
   var toLocaleUpper = $Native$Char.toLocaleUpper;
   var toLower = $Native$Char.toLower;
   var toUpper = $Native$Char.toUpper;
   var isBetween = F3(function (low,high,$char) {    var code = toCode($char);return _U.cmp(code,toCode(low)) > -1 && _U.cmp(code,toCode(high)) < 1;});
   var isUpper = A2(isBetween,_U.chr("A"),_U.chr("Z"));
   var isLower = A2(isBetween,_U.chr("a"),_U.chr("z"));
   var isDigit = A2(isBetween,_U.chr("0"),_U.chr("9"));
   var isOctDigit = A2(isBetween,_U.chr("0"),_U.chr("7"));
   var isHexDigit = function ($char) {
      return isDigit($char) || (A3(isBetween,_U.chr("a"),_U.chr("f"),$char) || A3(isBetween,_U.chr("A"),_U.chr("F"),$char));
   };
   return _elm.Char.values = {_op: _op
                             ,isUpper: isUpper
                             ,isLower: isLower
                             ,isDigit: isDigit
                             ,isOctDigit: isOctDigit
                             ,isHexDigit: isHexDigit
                             ,toUpper: toUpper
                             ,toLower: toLower
                             ,toLocaleUpper: toLocaleUpper
                             ,toLocaleLower: toLocaleLower
                             ,toCode: toCode
                             ,fromCode: fromCode};
};
Elm.Native.String = {};

Elm.Native.String.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.String = localRuntime.Native.String || {};
	if (localRuntime.Native.String.values)
	{
		return localRuntime.Native.String.values;
	}
	if ('values' in Elm.Native.String)
	{
		return localRuntime.Native.String.values = Elm.Native.String.values;
	}


	var Char = Elm.Char.make(localRuntime);
	var List = Elm.Native.List.make(localRuntime);
	var Maybe = Elm.Maybe.make(localRuntime);
	var Result = Elm.Result.make(localRuntime);
	var Utils = Elm.Native.Utils.make(localRuntime);

	function isEmpty(str)
	{
		return str.length === 0;
	}
	function cons(chr, str)
	{
		return chr + str;
	}
	function uncons(str)
	{
		var hd = str[0];
		if (hd)
		{
			return Maybe.Just(Utils.Tuple2(Utils.chr(hd), str.slice(1)));
		}
		return Maybe.Nothing;
	}
	function append(a, b)
	{
		return a + b;
	}
	function concat(strs)
	{
		return List.toArray(strs).join('');
	}
	function length(str)
	{
		return str.length;
	}
	function map(f, str)
	{
		var out = str.split('');
		for (var i = out.length; i--; )
		{
			out[i] = f(Utils.chr(out[i]));
		}
		return out.join('');
	}
	function filter(pred, str)
	{
		return str.split('').map(Utils.chr).filter(pred).join('');
	}
	function reverse(str)
	{
		return str.split('').reverse().join('');
	}
	function foldl(f, b, str)
	{
		var len = str.length;
		for (var i = 0; i < len; ++i)
		{
			b = A2(f, Utils.chr(str[i]), b);
		}
		return b;
	}
	function foldr(f, b, str)
	{
		for (var i = str.length; i--; )
		{
			b = A2(f, Utils.chr(str[i]), b);
		}
		return b;
	}
	function split(sep, str)
	{
		return List.fromArray(str.split(sep));
	}
	function join(sep, strs)
	{
		return List.toArray(strs).join(sep);
	}
	function repeat(n, str)
	{
		var result = '';
		while (n > 0)
		{
			if (n & 1)
			{
				result += str;
			}
			n >>= 1, str += str;
		}
		return result;
	}
	function slice(start, end, str)
	{
		return str.slice(start, end);
	}
	function left(n, str)
	{
		return n < 1 ? '' : str.slice(0, n);
	}
	function right(n, str)
	{
		return n < 1 ? '' : str.slice(-n);
	}
	function dropLeft(n, str)
	{
		return n < 1 ? str : str.slice(n);
	}
	function dropRight(n, str)
	{
		return n < 1 ? str : str.slice(0, -n);
	}
	function pad(n, chr, str)
	{
		var half = (n - str.length) / 2;
		return repeat(Math.ceil(half), chr) + str + repeat(half | 0, chr);
	}
	function padRight(n, chr, str)
	{
		return str + repeat(n - str.length, chr);
	}
	function padLeft(n, chr, str)
	{
		return repeat(n - str.length, chr) + str;
	}

	function trim(str)
	{
		return str.trim();
	}
	function trimLeft(str)
	{
		return str.replace(/^\s+/, '');
	}
	function trimRight(str)
	{
		return str.replace(/\s+$/, '');
	}

	function words(str)
	{
		return List.fromArray(str.trim().split(/\s+/g));
	}
	function lines(str)
	{
		return List.fromArray(str.split(/\r\n|\r|\n/g));
	}

	function toUpper(str)
	{
		return str.toUpperCase();
	}
	function toLower(str)
	{
		return str.toLowerCase();
	}

	function any(pred, str)
	{
		for (var i = str.length; i--; )
		{
			if (pred(Utils.chr(str[i])))
			{
				return true;
			}
		}
		return false;
	}
	function all(pred, str)
	{
		for (var i = str.length; i--; )
		{
			if (!pred(Utils.chr(str[i])))
			{
				return false;
			}
		}
		return true;
	}

	function contains(sub, str)
	{
		return str.indexOf(sub) > -1;
	}
	function startsWith(sub, str)
	{
		return str.indexOf(sub) === 0;
	}
	function endsWith(sub, str)
	{
		return str.length >= sub.length &&
			str.lastIndexOf(sub) === str.length - sub.length;
	}
	function indexes(sub, str)
	{
		var subLen = sub.length;
		var i = 0;
		var is = [];
		while ((i = str.indexOf(sub, i)) > -1)
		{
			is.push(i);
			i = i + subLen;
		}
		return List.fromArray(is);
	}

	function toInt(s)
	{
		var len = s.length;
		if (len === 0)
		{
			return Result.Err("could not convert string '" + s + "' to an Int" );
		}
		var start = 0;
		if (s[0] === '-')
		{
			if (len === 1)
			{
				return Result.Err("could not convert string '" + s + "' to an Int" );
			}
			start = 1;
		}
		for (var i = start; i < len; ++i)
		{
			if (!Char.isDigit(s[i]))
			{
				return Result.Err("could not convert string '" + s + "' to an Int" );
			}
		}
		return Result.Ok(parseInt(s, 10));
	}

	function toFloat(s)
	{
		var len = s.length;
		if (len === 0)
		{
			return Result.Err("could not convert string '" + s + "' to a Float" );
		}
		var start = 0;
		if (s[0] === '-')
		{
			if (len === 1)
			{
				return Result.Err("could not convert string '" + s + "' to a Float" );
			}
			start = 1;
		}
		var dotCount = 0;
		for (var i = start; i < len; ++i)
		{
			if (Char.isDigit(s[i]))
			{
				continue;
			}
			if (s[i] === '.')
			{
				dotCount += 1;
				if (dotCount <= 1)
				{
					continue;
				}
			}
			return Result.Err("could not convert string '" + s + "' to a Float" );
		}
		return Result.Ok(parseFloat(s));
	}

	function toList(str)
	{
		return List.fromArray(str.split('').map(Utils.chr));
	}
	function fromList(chars)
	{
		return List.toArray(chars).join('');
	}

	return Elm.Native.String.values = {
		isEmpty: isEmpty,
		cons: F2(cons),
		uncons: uncons,
		append: F2(append),
		concat: concat,
		length: length,
		map: F2(map),
		filter: F2(filter),
		reverse: reverse,
		foldl: F3(foldl),
		foldr: F3(foldr),

		split: F2(split),
		join: F2(join),
		repeat: F2(repeat),

		slice: F3(slice),
		left: F2(left),
		right: F2(right),
		dropLeft: F2(dropLeft),
		dropRight: F2(dropRight),

		pad: F3(pad),
		padLeft: F3(padLeft),
		padRight: F3(padRight),

		trim: trim,
		trimLeft: trimLeft,
		trimRight: trimRight,

		words: words,
		lines: lines,

		toUpper: toUpper,
		toLower: toLower,

		any: F2(any),
		all: F2(all),

		contains: F2(contains),
		startsWith: F2(startsWith),
		endsWith: F2(endsWith),
		indexes: F2(indexes),

		toInt: toInt,
		toFloat: toFloat,
		toList: toList,
		fromList: fromList
	};
};

Elm.String = Elm.String || {};
Elm.String.make = function (_elm) {
   "use strict";
   _elm.String = _elm.String || {};
   if (_elm.String.values) return _elm.String.values;
   var _U = Elm.Native.Utils.make(_elm),$Maybe = Elm.Maybe.make(_elm),$Native$String = Elm.Native.String.make(_elm),$Result = Elm.Result.make(_elm);
   var _op = {};
   var fromList = $Native$String.fromList;
   var toList = $Native$String.toList;
   var toFloat = $Native$String.toFloat;
   var toInt = $Native$String.toInt;
   var indices = $Native$String.indexes;
   var indexes = $Native$String.indexes;
   var endsWith = $Native$String.endsWith;
   var startsWith = $Native$String.startsWith;
   var contains = $Native$String.contains;
   var all = $Native$String.all;
   var any = $Native$String.any;
   var toLower = $Native$String.toLower;
   var toUpper = $Native$String.toUpper;
   var lines = $Native$String.lines;
   var words = $Native$String.words;
   var trimRight = $Native$String.trimRight;
   var trimLeft = $Native$String.trimLeft;
   var trim = $Native$String.trim;
   var padRight = $Native$String.padRight;
   var padLeft = $Native$String.padLeft;
   var pad = $Native$String.pad;
   var dropRight = $Native$String.dropRight;
   var dropLeft = $Native$String.dropLeft;
   var right = $Native$String.right;
   var left = $Native$String.left;
   var slice = $Native$String.slice;
   var repeat = $Native$String.repeat;
   var join = $Native$String.join;
   var split = $Native$String.split;
   var foldr = $Native$String.foldr;
   var foldl = $Native$String.foldl;
   var reverse = $Native$String.reverse;
   var filter = $Native$String.filter;
   var map = $Native$String.map;
   var length = $Native$String.length;
   var concat = $Native$String.concat;
   var append = $Native$String.append;
   var uncons = $Native$String.uncons;
   var cons = $Native$String.cons;
   var fromChar = function ($char) {    return A2(cons,$char,"");};
   var isEmpty = $Native$String.isEmpty;
   return _elm.String.values = {_op: _op
                               ,isEmpty: isEmpty
                               ,length: length
                               ,reverse: reverse
                               ,repeat: repeat
                               ,cons: cons
                               ,uncons: uncons
                               ,fromChar: fromChar
                               ,append: append
                               ,concat: concat
                               ,split: split
                               ,join: join
                               ,words: words
                               ,lines: lines
                               ,slice: slice
                               ,left: left
                               ,right: right
                               ,dropLeft: dropLeft
                               ,dropRight: dropRight
                               ,contains: contains
                               ,startsWith: startsWith
                               ,endsWith: endsWith
                               ,indexes: indexes
                               ,indices: indices
                               ,toInt: toInt
                               ,toFloat: toFloat
                               ,toList: toList
                               ,fromList: fromList
                               ,toUpper: toUpper
                               ,toLower: toLower
                               ,pad: pad
                               ,padLeft: padLeft
                               ,padRight: padRight
                               ,trim: trim
                               ,trimLeft: trimLeft
                               ,trimRight: trimRight
                               ,map: map
                               ,filter: filter
                               ,foldl: foldl
                               ,foldr: foldr
                               ,any: any
                               ,all: all};
};
Elm.Dict = Elm.Dict || {};
Elm.Dict.make = function (_elm) {
   "use strict";
   _elm.Dict = _elm.Dict || {};
   if (_elm.Dict.values) return _elm.Dict.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Debug = Elm.Native.Debug.make(_elm),
   $String = Elm.String.make(_elm);
   var _op = {};
   var foldr = F3(function (f,acc,t) {
      foldr: while (true) {
         var _p0 = t;
         if (_p0.ctor === "RBEmpty_elm_builtin") {
               return acc;
            } else {
               var _v1 = f,_v2 = A3(f,_p0._1,_p0._2,A3(foldr,f,acc,_p0._4)),_v3 = _p0._3;
               f = _v1;
               acc = _v2;
               t = _v3;
               continue foldr;
            }
      }
   });
   var keys = function (dict) {    return A3(foldr,F3(function (key,value,keyList) {    return A2($List._op["::"],key,keyList);}),_U.list([]),dict);};
   var values = function (dict) {    return A3(foldr,F3(function (key,value,valueList) {    return A2($List._op["::"],value,valueList);}),_U.list([]),dict);};
   var toList = function (dict) {
      return A3(foldr,F3(function (key,value,list) {    return A2($List._op["::"],{ctor: "_Tuple2",_0: key,_1: value},list);}),_U.list([]),dict);
   };
   var foldl = F3(function (f,acc,dict) {
      foldl: while (true) {
         var _p1 = dict;
         if (_p1.ctor === "RBEmpty_elm_builtin") {
               return acc;
            } else {
               var _v5 = f,_v6 = A3(f,_p1._1,_p1._2,A3(foldl,f,acc,_p1._3)),_v7 = _p1._4;
               f = _v5;
               acc = _v6;
               dict = _v7;
               continue foldl;
            }
      }
   });
   var reportRemBug = F4(function (msg,c,lgot,rgot) {
      return $Native$Debug.crash($String.concat(_U.list(["Internal red-black tree invariant violated, expected "
                                                        ,msg
                                                        ," and got "
                                                        ,$Basics.toString(c)
                                                        ,"/"
                                                        ,lgot
                                                        ,"/"
                                                        ,rgot
                                                        ,"\nPlease report this bug to <https://github.com/elm-lang/core/issues>"])));
   });
   var isBBlack = function (dict) {
      var _p2 = dict;
      _v8_2: do {
         if (_p2.ctor === "RBNode_elm_builtin") {
               if (_p2._0.ctor === "BBlack") {
                     return true;
                  } else {
                     break _v8_2;
                  }
            } else {
               if (_p2._0.ctor === "LBBlack") {
                     return true;
                  } else {
                     break _v8_2;
                  }
            }
      } while (false);
      return false;
   };
   var Same = {ctor: "Same"};
   var Remove = {ctor: "Remove"};
   var Insert = {ctor: "Insert"};
   var sizeHelp = F2(function (n,dict) {
      sizeHelp: while (true) {
         var _p3 = dict;
         if (_p3.ctor === "RBEmpty_elm_builtin") {
               return n;
            } else {
               var _v10 = A2(sizeHelp,n + 1,_p3._4),_v11 = _p3._3;
               n = _v10;
               dict = _v11;
               continue sizeHelp;
            }
      }
   });
   var size = function (dict) {    return A2(sizeHelp,0,dict);};
   var get = F2(function (targetKey,dict) {
      get: while (true) {
         var _p4 = dict;
         if (_p4.ctor === "RBEmpty_elm_builtin") {
               return $Maybe.Nothing;
            } else {
               var _p5 = A2($Basics.compare,targetKey,_p4._1);
               switch (_p5.ctor)
               {case "LT": var _v14 = targetKey,_v15 = _p4._3;
                    targetKey = _v14;
                    dict = _v15;
                    continue get;
                  case "EQ": return $Maybe.Just(_p4._2);
                  default: var _v16 = targetKey,_v17 = _p4._4;
                    targetKey = _v16;
                    dict = _v17;
                    continue get;}
            }
      }
   });
   var member = F2(function (key,dict) {    var _p6 = A2(get,key,dict);if (_p6.ctor === "Just") {    return true;} else {    return false;}});
   var maxWithDefault = F3(function (k,v,r) {
      maxWithDefault: while (true) {
         var _p7 = r;
         if (_p7.ctor === "RBEmpty_elm_builtin") {
               return {ctor: "_Tuple2",_0: k,_1: v};
            } else {
               var _v20 = _p7._1,_v21 = _p7._2,_v22 = _p7._4;
               k = _v20;
               v = _v21;
               r = _v22;
               continue maxWithDefault;
            }
      }
   });
   var RBEmpty_elm_builtin = function (a) {    return {ctor: "RBEmpty_elm_builtin",_0: a};};
   var RBNode_elm_builtin = F5(function (a,b,c,d,e) {    return {ctor: "RBNode_elm_builtin",_0: a,_1: b,_2: c,_3: d,_4: e};});
   var LBBlack = {ctor: "LBBlack"};
   var LBlack = {ctor: "LBlack"};
   var empty = RBEmpty_elm_builtin(LBlack);
   var isEmpty = function (dict) {    return _U.eq(dict,empty);};
   var map = F2(function (f,dict) {
      var _p8 = dict;
      if (_p8.ctor === "RBEmpty_elm_builtin") {
            return RBEmpty_elm_builtin(LBlack);
         } else {
            var _p9 = _p8._1;
            return A5(RBNode_elm_builtin,_p8._0,_p9,A2(f,_p9,_p8._2),A2(map,f,_p8._3),A2(map,f,_p8._4));
         }
   });
   var NBlack = {ctor: "NBlack"};
   var BBlack = {ctor: "BBlack"};
   var Black = {ctor: "Black"};
   var ensureBlackRoot = function (dict) {
      var _p10 = dict;
      if (_p10.ctor === "RBNode_elm_builtin" && _p10._0.ctor === "Red") {
            return A5(RBNode_elm_builtin,Black,_p10._1,_p10._2,_p10._3,_p10._4);
         } else {
            return dict;
         }
   };
   var blackish = function (t) {
      var _p11 = t;
      if (_p11.ctor === "RBNode_elm_builtin") {
            var _p12 = _p11._0;
            return _U.eq(_p12,Black) || _U.eq(_p12,BBlack);
         } else {
            return true;
         }
   };
   var blacken = function (t) {
      var _p13 = t;
      if (_p13.ctor === "RBEmpty_elm_builtin") {
            return RBEmpty_elm_builtin(LBlack);
         } else {
            return A5(RBNode_elm_builtin,Black,_p13._1,_p13._2,_p13._3,_p13._4);
         }
   };
   var Red = {ctor: "Red"};
   var moreBlack = function (color) {
      var _p14 = color;
      switch (_p14.ctor)
      {case "Black": return BBlack;
         case "Red": return Black;
         case "NBlack": return Red;
         default: return $Native$Debug.crash("Can\'t make a double black node more black!");}
   };
   var lessBlack = function (color) {
      var _p15 = color;
      switch (_p15.ctor)
      {case "BBlack": return Black;
         case "Black": return Red;
         case "Red": return NBlack;
         default: return $Native$Debug.crash("Can\'t make a negative black node less black!");}
   };
   var lessBlackTree = function (dict) {
      var _p16 = dict;
      if (_p16.ctor === "RBNode_elm_builtin") {
            return A5(RBNode_elm_builtin,lessBlack(_p16._0),_p16._1,_p16._2,_p16._3,_p16._4);
         } else {
            return RBEmpty_elm_builtin(LBlack);
         }
   };
   var balancedTree = function (col) {
      return function (xk) {
         return function (xv) {
            return function (yk) {
               return function (yv) {
                  return function (zk) {
                     return function (zv) {
                        return function (a) {
                           return function (b) {
                              return function (c) {
                                 return function (d) {
                                    return A5(RBNode_elm_builtin,
                                    lessBlack(col),
                                    yk,
                                    yv,
                                    A5(RBNode_elm_builtin,Black,xk,xv,a,b),
                                    A5(RBNode_elm_builtin,Black,zk,zv,c,d));
                                 };
                              };
                           };
                        };
                     };
                  };
               };
            };
         };
      };
   };
   var redden = function (t) {
      var _p17 = t;
      if (_p17.ctor === "RBEmpty_elm_builtin") {
            return $Native$Debug.crash("can\'t make a Leaf red");
         } else {
            return A5(RBNode_elm_builtin,Red,_p17._1,_p17._2,_p17._3,_p17._4);
         }
   };
   var balanceHelp = function (tree) {
      var _p18 = tree;
      _v31_6: do {
         _v31_5: do {
            _v31_4: do {
               _v31_3: do {
                  _v31_2: do {
                     _v31_1: do {
                        _v31_0: do {
                           if (_p18.ctor === "RBNode_elm_builtin") {
                                 if (_p18._3.ctor === "RBNode_elm_builtin") {
                                       if (_p18._4.ctor === "RBNode_elm_builtin") {
                                             switch (_p18._3._0.ctor)
                                             {case "Red": switch (_p18._4._0.ctor)
                                                  {case "Red": if (_p18._3._3.ctor === "RBNode_elm_builtin" && _p18._3._3._0.ctor === "Red") {
                                                             break _v31_0;
                                                          } else {
                                                             if (_p18._3._4.ctor === "RBNode_elm_builtin" && _p18._3._4._0.ctor === "Red") {
                                                                   break _v31_1;
                                                                } else {
                                                                   if (_p18._4._3.ctor === "RBNode_elm_builtin" && _p18._4._3._0.ctor === "Red") {
                                                                         break _v31_2;
                                                                      } else {
                                                                         if (_p18._4._4.ctor === "RBNode_elm_builtin" && _p18._4._4._0.ctor === "Red") {
                                                                               break _v31_3;
                                                                            } else {
                                                                               break _v31_6;
                                                                            }
                                                                      }
                                                                }
                                                          }
                                                     case "NBlack": if (_p18._3._3.ctor === "RBNode_elm_builtin" && _p18._3._3._0.ctor === "Red") {
                                                             break _v31_0;
                                                          } else {
                                                             if (_p18._3._4.ctor === "RBNode_elm_builtin" && _p18._3._4._0.ctor === "Red") {
                                                                   break _v31_1;
                                                                } else {
                                                                   if (_p18._0.ctor === "BBlack" && _p18._4._3.ctor === "RBNode_elm_builtin" && _p18._4._3._0.ctor === "Black" && _p18._4._4.ctor === "RBNode_elm_builtin" && _p18._4._4._0.ctor === "Black")
                                                                   {
                                                                         break _v31_4;
                                                                      } else {
                                                                         break _v31_6;
                                                                      }
                                                                }
                                                          }
                                                     default: if (_p18._3._3.ctor === "RBNode_elm_builtin" && _p18._3._3._0.ctor === "Red") {
                                                             break _v31_0;
                                                          } else {
                                                             if (_p18._3._4.ctor === "RBNode_elm_builtin" && _p18._3._4._0.ctor === "Red") {
                                                                   break _v31_1;
                                                                } else {
                                                                   break _v31_6;
                                                                }
                                                          }}
                                                case "NBlack": switch (_p18._4._0.ctor)
                                                  {case "Red": if (_p18._4._3.ctor === "RBNode_elm_builtin" && _p18._4._3._0.ctor === "Red") {
                                                             break _v31_2;
                                                          } else {
                                                             if (_p18._4._4.ctor === "RBNode_elm_builtin" && _p18._4._4._0.ctor === "Red") {
                                                                   break _v31_3;
                                                                } else {
                                                                   if (_p18._0.ctor === "BBlack" && _p18._3._3.ctor === "RBNode_elm_builtin" && _p18._3._3._0.ctor === "Black" && _p18._3._4.ctor === "RBNode_elm_builtin" && _p18._3._4._0.ctor === "Black")
                                                                   {
                                                                         break _v31_5;
                                                                      } else {
                                                                         break _v31_6;
                                                                      }
                                                                }
                                                          }
                                                     case "NBlack": if (_p18._0.ctor === "BBlack") {
                                                             if (_p18._4._3.ctor === "RBNode_elm_builtin" && _p18._4._3._0.ctor === "Black" && _p18._4._4.ctor === "RBNode_elm_builtin" && _p18._4._4._0.ctor === "Black")
                                                             {
                                                                   break _v31_4;
                                                                } else {
                                                                   if (_p18._3._3.ctor === "RBNode_elm_builtin" && _p18._3._3._0.ctor === "Black" && _p18._3._4.ctor === "RBNode_elm_builtin" && _p18._3._4._0.ctor === "Black")
                                                                   {
                                                                         break _v31_5;
                                                                      } else {
                                                                         break _v31_6;
                                                                      }
                                                                }
                                                          } else {
                                                             break _v31_6;
                                                          }
                                                     default:
                                                     if (_p18._0.ctor === "BBlack" && _p18._3._3.ctor === "RBNode_elm_builtin" && _p18._3._3._0.ctor === "Black" && _p18._3._4.ctor === "RBNode_elm_builtin" && _p18._3._4._0.ctor === "Black")
                                                       {
                                                             break _v31_5;
                                                          } else {
                                                             break _v31_6;
                                                          }}
                                                default: switch (_p18._4._0.ctor)
                                                  {case "Red": if (_p18._4._3.ctor === "RBNode_elm_builtin" && _p18._4._3._0.ctor === "Red") {
                                                             break _v31_2;
                                                          } else {
                                                             if (_p18._4._4.ctor === "RBNode_elm_builtin" && _p18._4._4._0.ctor === "Red") {
                                                                   break _v31_3;
                                                                } else {
                                                                   break _v31_6;
                                                                }
                                                          }
                                                     case "NBlack":
                                                     if (_p18._0.ctor === "BBlack" && _p18._4._3.ctor === "RBNode_elm_builtin" && _p18._4._3._0.ctor === "Black" && _p18._4._4.ctor === "RBNode_elm_builtin" && _p18._4._4._0.ctor === "Black")
                                                       {
                                                             break _v31_4;
                                                          } else {
                                                             break _v31_6;
                                                          }
                                                     default: break _v31_6;}}
                                          } else {
                                             switch (_p18._3._0.ctor)
                                             {case "Red": if (_p18._3._3.ctor === "RBNode_elm_builtin" && _p18._3._3._0.ctor === "Red") {
                                                        break _v31_0;
                                                     } else {
                                                        if (_p18._3._4.ctor === "RBNode_elm_builtin" && _p18._3._4._0.ctor === "Red") {
                                                              break _v31_1;
                                                           } else {
                                                              break _v31_6;
                                                           }
                                                     }
                                                case "NBlack":
                                                if (_p18._0.ctor === "BBlack" && _p18._3._3.ctor === "RBNode_elm_builtin" && _p18._3._3._0.ctor === "Black" && _p18._3._4.ctor === "RBNode_elm_builtin" && _p18._3._4._0.ctor === "Black")
                                                  {
                                                        break _v31_5;
                                                     } else {
                                                        break _v31_6;
                                                     }
                                                default: break _v31_6;}
                                          }
                                    } else {
                                       if (_p18._4.ctor === "RBNode_elm_builtin") {
                                             switch (_p18._4._0.ctor)
                                             {case "Red": if (_p18._4._3.ctor === "RBNode_elm_builtin" && _p18._4._3._0.ctor === "Red") {
                                                        break _v31_2;
                                                     } else {
                                                        if (_p18._4._4.ctor === "RBNode_elm_builtin" && _p18._4._4._0.ctor === "Red") {
                                                              break _v31_3;
                                                           } else {
                                                              break _v31_6;
                                                           }
                                                     }
                                                case "NBlack":
                                                if (_p18._0.ctor === "BBlack" && _p18._4._3.ctor === "RBNode_elm_builtin" && _p18._4._3._0.ctor === "Black" && _p18._4._4.ctor === "RBNode_elm_builtin" && _p18._4._4._0.ctor === "Black")
                                                  {
                                                        break _v31_4;
                                                     } else {
                                                        break _v31_6;
                                                     }
                                                default: break _v31_6;}
                                          } else {
                                             break _v31_6;
                                          }
                                    }
                              } else {
                                 break _v31_6;
                              }
                        } while (false);
                        return balancedTree(_p18._0)(_p18._3._3._1)(_p18._3._3._2)(_p18._3._1)(_p18._3._2)(_p18._1)(_p18._2)(_p18._3._3._3)(_p18._3._3._4)(_p18._3._4)(_p18._4);
                     } while (false);
                     return balancedTree(_p18._0)(_p18._3._1)(_p18._3._2)(_p18._3._4._1)(_p18._3._4._2)(_p18._1)(_p18._2)(_p18._3._3)(_p18._3._4._3)(_p18._3._4._4)(_p18._4);
                  } while (false);
                  return balancedTree(_p18._0)(_p18._1)(_p18._2)(_p18._4._3._1)(_p18._4._3._2)(_p18._4._1)(_p18._4._2)(_p18._3)(_p18._4._3._3)(_p18._4._3._4)(_p18._4._4);
               } while (false);
               return balancedTree(_p18._0)(_p18._1)(_p18._2)(_p18._4._1)(_p18._4._2)(_p18._4._4._1)(_p18._4._4._2)(_p18._3)(_p18._4._3)(_p18._4._4._3)(_p18._4._4._4);
            } while (false);
            return A5(RBNode_elm_builtin,
            Black,
            _p18._4._3._1,
            _p18._4._3._2,
            A5(RBNode_elm_builtin,Black,_p18._1,_p18._2,_p18._3,_p18._4._3._3),
            A5(balance,Black,_p18._4._1,_p18._4._2,_p18._4._3._4,redden(_p18._4._4)));
         } while (false);
         return A5(RBNode_elm_builtin,
         Black,
         _p18._3._4._1,
         _p18._3._4._2,
         A5(balance,Black,_p18._3._1,_p18._3._2,redden(_p18._3._3),_p18._3._4._3),
         A5(RBNode_elm_builtin,Black,_p18._1,_p18._2,_p18._3._4._4,_p18._4));
      } while (false);
      return tree;
   };
   var balance = F5(function (c,k,v,l,r) {    var tree = A5(RBNode_elm_builtin,c,k,v,l,r);return blackish(tree) ? balanceHelp(tree) : tree;});
   var bubble = F5(function (c,k,v,l,r) {
      return isBBlack(l) || isBBlack(r) ? A5(balance,moreBlack(c),k,v,lessBlackTree(l),lessBlackTree(r)) : A5(RBNode_elm_builtin,c,k,v,l,r);
   });
   var removeMax = F5(function (c,k,v,l,r) {
      var _p19 = r;
      if (_p19.ctor === "RBEmpty_elm_builtin") {
            return A3(rem,c,l,r);
         } else {
            return A5(bubble,c,k,v,l,A5(removeMax,_p19._0,_p19._1,_p19._2,_p19._3,_p19._4));
         }
   });
   var rem = F3(function (c,l,r) {
      var _p20 = {ctor: "_Tuple2",_0: l,_1: r};
      if (_p20._0.ctor === "RBEmpty_elm_builtin") {
            if (_p20._1.ctor === "RBEmpty_elm_builtin") {
                  var _p21 = c;
                  switch (_p21.ctor)
                  {case "Red": return RBEmpty_elm_builtin(LBlack);
                     case "Black": return RBEmpty_elm_builtin(LBBlack);
                     default: return $Native$Debug.crash("cannot have bblack or nblack nodes at this point");}
               } else {
                  var _p24 = _p20._1._0;
                  var _p23 = _p20._0._0;
                  var _p22 = {ctor: "_Tuple3",_0: c,_1: _p23,_2: _p24};
                  if (_p22.ctor === "_Tuple3" && _p22._0.ctor === "Black" && _p22._1.ctor === "LBlack" && _p22._2.ctor === "Red") {
                        return A5(RBNode_elm_builtin,Black,_p20._1._1,_p20._1._2,_p20._1._3,_p20._1._4);
                     } else {
                        return A4(reportRemBug,"Black/LBlack/Red",c,$Basics.toString(_p23),$Basics.toString(_p24));
                     }
               }
         } else {
            if (_p20._1.ctor === "RBEmpty_elm_builtin") {
                  var _p27 = _p20._1._0;
                  var _p26 = _p20._0._0;
                  var _p25 = {ctor: "_Tuple3",_0: c,_1: _p26,_2: _p27};
                  if (_p25.ctor === "_Tuple3" && _p25._0.ctor === "Black" && _p25._1.ctor === "Red" && _p25._2.ctor === "LBlack") {
                        return A5(RBNode_elm_builtin,Black,_p20._0._1,_p20._0._2,_p20._0._3,_p20._0._4);
                     } else {
                        return A4(reportRemBug,"Black/Red/LBlack",c,$Basics.toString(_p26),$Basics.toString(_p27));
                     }
               } else {
                  var _p31 = _p20._0._2;
                  var _p30 = _p20._0._4;
                  var _p29 = _p20._0._1;
                  var l$ = A5(removeMax,_p20._0._0,_p29,_p31,_p20._0._3,_p30);
                  var _p28 = A3(maxWithDefault,_p29,_p31,_p30);
                  var k = _p28._0;
                  var v = _p28._1;
                  return A5(bubble,c,k,v,l$,r);
               }
         }
   });
   var update = F3(function (k,alter,dict) {
      var up = function (dict) {
         var _p32 = dict;
         if (_p32.ctor === "RBEmpty_elm_builtin") {
               var _p33 = alter($Maybe.Nothing);
               if (_p33.ctor === "Nothing") {
                     return {ctor: "_Tuple2",_0: Same,_1: empty};
                  } else {
                     return {ctor: "_Tuple2",_0: Insert,_1: A5(RBNode_elm_builtin,Red,k,_p33._0,empty,empty)};
                  }
            } else {
               var _p44 = _p32._2;
               var _p43 = _p32._4;
               var _p42 = _p32._3;
               var _p41 = _p32._1;
               var _p40 = _p32._0;
               var _p34 = A2($Basics.compare,k,_p41);
               switch (_p34.ctor)
               {case "EQ": var _p35 = alter($Maybe.Just(_p44));
                    if (_p35.ctor === "Nothing") {
                          return {ctor: "_Tuple2",_0: Remove,_1: A3(rem,_p40,_p42,_p43)};
                       } else {
                          return {ctor: "_Tuple2",_0: Same,_1: A5(RBNode_elm_builtin,_p40,_p41,_p35._0,_p42,_p43)};
                       }
                  case "LT": var _p36 = up(_p42);
                    var flag = _p36._0;
                    var newLeft = _p36._1;
                    var _p37 = flag;
                    switch (_p37.ctor)
                    {case "Same": return {ctor: "_Tuple2",_0: Same,_1: A5(RBNode_elm_builtin,_p40,_p41,_p44,newLeft,_p43)};
                       case "Insert": return {ctor: "_Tuple2",_0: Insert,_1: A5(balance,_p40,_p41,_p44,newLeft,_p43)};
                       default: return {ctor: "_Tuple2",_0: Remove,_1: A5(bubble,_p40,_p41,_p44,newLeft,_p43)};}
                  default: var _p38 = up(_p43);
                    var flag = _p38._0;
                    var newRight = _p38._1;
                    var _p39 = flag;
                    switch (_p39.ctor)
                    {case "Same": return {ctor: "_Tuple2",_0: Same,_1: A5(RBNode_elm_builtin,_p40,_p41,_p44,_p42,newRight)};
                       case "Insert": return {ctor: "_Tuple2",_0: Insert,_1: A5(balance,_p40,_p41,_p44,_p42,newRight)};
                       default: return {ctor: "_Tuple2",_0: Remove,_1: A5(bubble,_p40,_p41,_p44,_p42,newRight)};}}
            }
      };
      var _p45 = up(dict);
      var flag = _p45._0;
      var updatedDict = _p45._1;
      var _p46 = flag;
      switch (_p46.ctor)
      {case "Same": return updatedDict;
         case "Insert": return ensureBlackRoot(updatedDict);
         default: return blacken(updatedDict);}
   });
   var insert = F3(function (key,value,dict) {    return A3(update,key,$Basics.always($Maybe.Just(value)),dict);});
   var singleton = F2(function (key,value) {    return A3(insert,key,value,empty);});
   var union = F2(function (t1,t2) {    return A3(foldl,insert,t2,t1);});
   var fromList = function (assocs) {
      return A3($List.foldl,F2(function (_p47,dict) {    var _p48 = _p47;return A3(insert,_p48._0,_p48._1,dict);}),empty,assocs);
   };
   var filter = F2(function (predicate,dictionary) {
      var add = F3(function (key,value,dict) {    return A2(predicate,key,value) ? A3(insert,key,value,dict) : dict;});
      return A3(foldl,add,empty,dictionary);
   });
   var intersect = F2(function (t1,t2) {    return A2(filter,F2(function (k,_p49) {    return A2(member,k,t2);}),t1);});
   var partition = F2(function (predicate,dict) {
      var add = F3(function (key,value,_p50) {
         var _p51 = _p50;
         var _p53 = _p51._1;
         var _p52 = _p51._0;
         return A2(predicate,key,value) ? {ctor: "_Tuple2",_0: A3(insert,key,value,_p52),_1: _p53} : {ctor: "_Tuple2",_0: _p52,_1: A3(insert,key,value,_p53)};
      });
      return A3(foldl,add,{ctor: "_Tuple2",_0: empty,_1: empty},dict);
   });
   var remove = F2(function (key,dict) {    return A3(update,key,$Basics.always($Maybe.Nothing),dict);});
   var diff = F2(function (t1,t2) {    return A3(foldl,F3(function (k,v,t) {    return A2(remove,k,t);}),t1,t2);});
   return _elm.Dict.values = {_op: _op
                             ,empty: empty
                             ,singleton: singleton
                             ,insert: insert
                             ,update: update
                             ,isEmpty: isEmpty
                             ,get: get
                             ,remove: remove
                             ,member: member
                             ,size: size
                             ,filter: filter
                             ,partition: partition
                             ,foldl: foldl
                             ,foldr: foldr
                             ,map: map
                             ,union: union
                             ,intersect: intersect
                             ,diff: diff
                             ,keys: keys
                             ,values: values
                             ,toList: toList
                             ,fromList: fromList};
};
// setup
Elm.Native = Elm.Native || {};
Elm.Native.Graphics = Elm.Native.Graphics || {};
Elm.Native.Graphics.Input = Elm.Native.Graphics.Input || {};

// definition
Elm.Native.Graphics.Input.make = function(localRuntime) {
	'use strict';

	// attempt to short-circuit
	if ('values' in Elm.Native.Graphics.Input) {
		return Elm.Native.Graphics.Input.values;
	}

	var Color = Elm.Native.Color.make(localRuntime);
	var List = Elm.Native.List.make(localRuntime);
	var Signal = Elm.Native.Signal.make(localRuntime);
	var Text = Elm.Native.Text.make(localRuntime);
	var Utils = Elm.Native.Utils.make(localRuntime);

	var Element = Elm.Native.Graphics.Element.make(localRuntime);


	function renderDropDown(model)
	{
		var drop = Element.createNode('select');
		drop.style.border = '0 solid';
		drop.style.pointerEvents = 'auto';
		drop.style.display = 'block';

		drop.elm_values = List.toArray(model.values);
		drop.elm_handler = model.handler;
		var values = drop.elm_values;

		for (var i = 0; i < values.length; ++i)
		{
			var option = Element.createNode('option');
			var name = values[i]._0;
			option.value = name;
			option.innerHTML = name;
			drop.appendChild(option);
		}
		drop.addEventListener('change', function() {
			Signal.sendMessage(drop.elm_handler(drop.elm_values[drop.selectedIndex]._1));
		});

		return drop;
	}

	function updateDropDown(node, oldModel, newModel)
	{
		node.elm_values = List.toArray(newModel.values);
		node.elm_handler = newModel.handler;

		var values = node.elm_values;
		var kids = node.childNodes;
		var kidsLength = kids.length;

		var i = 0;
		for (; i < kidsLength && i < values.length; ++i)
		{
			var option = kids[i];
			var name = values[i]._0;
			option.value = name;
			option.innerHTML = name;
		}
		for (; i < kidsLength; ++i)
		{
			node.removeChild(node.lastChild);
		}
		for (; i < values.length; ++i)
		{
			var option = Element.createNode('option');
			var name = values[i]._0;
			option.value = name;
			option.innerHTML = name;
			node.appendChild(option);
		}
		return node;
	}

	function dropDown(handler, values)
	{
		return A3(Element.newElement, 100, 24, {
			ctor: 'Custom',
			type: 'DropDown',
			render: renderDropDown,
			update: updateDropDown,
			model: {
				values: values,
				handler: handler
			}
		});
	}

	function renderButton(model)
	{
		var node = Element.createNode('button');
		node.style.display = 'block';
		node.style.pointerEvents = 'auto';
		node.elm_message = model.message;
		function click()
		{
			Signal.sendMessage(node.elm_message);
		}
		node.addEventListener('click', click);
		node.innerHTML = model.text;
		return node;
	}

	function updateButton(node, oldModel, newModel)
	{
		node.elm_message = newModel.message;
		var txt = newModel.text;
		if (oldModel.text !== txt)
		{
			node.innerHTML = txt;
		}
		return node;
	}

	function button(message, text)
	{
		return A3(Element.newElement, 100, 40, {
			ctor: 'Custom',
			type: 'Button',
			render: renderButton,
			update: updateButton,
			model: {
				message: message,
				text: text
			}
		});
	}

	function renderCustomButton(model)
	{
		var btn = Element.createNode('div');
		btn.style.pointerEvents = 'auto';
		btn.elm_message = model.message;

		btn.elm_up    = Element.render(model.up);
		btn.elm_hover = Element.render(model.hover);
		btn.elm_down  = Element.render(model.down);

		btn.elm_up.style.display = 'block';
		btn.elm_hover.style.display = 'none';
		btn.elm_down.style.display = 'none';

		btn.appendChild(btn.elm_up);
		btn.appendChild(btn.elm_hover);
		btn.appendChild(btn.elm_down);

		function swap(visibleNode, hiddenNode1, hiddenNode2)
		{
			visibleNode.style.display = 'block';
			hiddenNode1.style.display = 'none';
			hiddenNode2.style.display = 'none';
		}

		var overCount = 0;
		function over(e)
		{
			if (overCount++ > 0) return;
			swap(btn.elm_hover, btn.elm_down, btn.elm_up);
		}
		function out(e)
		{
			if (btn.contains(e.toElement || e.relatedTarget)) return;
			overCount = 0;
			swap(btn.elm_up, btn.elm_down, btn.elm_hover);
		}
		function up()
		{
			swap(btn.elm_hover, btn.elm_down, btn.elm_up);
			Signal.sendMessage(btn.elm_message);
		}
		function down()
		{
			swap(btn.elm_down, btn.elm_hover, btn.elm_up);
		}

		btn.addEventListener('mouseover', over);
		btn.addEventListener('mouseout', out);
		btn.addEventListener('mousedown', down);
		btn.addEventListener('mouseup', up);

		return btn;
	}

	function updateCustomButton(node, oldModel, newModel)
	{
		node.elm_message = newModel.message;

		var kids = node.childNodes;
		var styleUp    = kids[0].style.display;
		var styleHover = kids[1].style.display;
		var styleDown  = kids[2].style.display;

		Element.updateAndReplace(kids[0], oldModel.up, newModel.up);
		Element.updateAndReplace(kids[1], oldModel.hover, newModel.hover);
		Element.updateAndReplace(kids[2], oldModel.down, newModel.down);

		var kids = node.childNodes;
		kids[0].style.display = styleUp;
		kids[1].style.display = styleHover;
		kids[2].style.display = styleDown;

		return node;
	}

	function max3(a, b, c)
	{
		var ab = a > b ? a : b;
		return ab > c ? ab : c;
	}

	function customButton(message, up, hover, down)
	{
		return A3(Element.newElement,
				  max3(up._0.props.width, hover._0.props.width, down._0.props.width),
				  max3(up._0.props.height, hover._0.props.height, down._0.props.height),
				  { ctor: 'Custom',
					type: 'CustomButton',
					render: renderCustomButton,
					update: updateCustomButton,
					model: {
						message: message,
						up: up,
						hover: hover,
						down: down
					}
				  });
	}

	function renderCheckbox(model)
	{
		var node = Element.createNode('input');
		node.type = 'checkbox';
		node.checked = model.checked;
		node.style.display = 'block';
		node.style.pointerEvents = 'auto';
		node.elm_handler = model.handler;
		function change()
		{
			Signal.sendMessage(node.elm_handler(node.checked));
		}
		node.addEventListener('change', change);
		return node;
	}

	function updateCheckbox(node, oldModel, newModel)
	{
		node.elm_handler = newModel.handler;
		node.checked = newModel.checked;
		return node;
	}

	function checkbox(handler, checked)
	{
		return A3(Element.newElement, 13, 13, {
			ctor: 'Custom',
			type: 'CheckBox',
			render: renderCheckbox,
			update: updateCheckbox,
			model: { handler: handler, checked: checked }
		});
	}

	function setRange(node, start, end, dir)
	{
		if (node.parentNode)
		{
			node.setSelectionRange(start, end, dir);
		}
		else
		{
			setTimeout(function() {node.setSelectionRange(start, end, dir); }, 0);
		}
	}

	function updateIfNeeded(css, attribute, latestAttribute)
	{
		if (css[attribute] !== latestAttribute)
		{
			css[attribute] = latestAttribute;
		}
	}
	function cssDimensions(dimensions)
	{
		return dimensions.top    + 'px ' +
			   dimensions.right  + 'px ' +
			   dimensions.bottom + 'px ' +
			   dimensions.left   + 'px';
	}
	function updateFieldStyle(css, style)
	{
		updateIfNeeded(css, 'padding', cssDimensions(style.padding));

		var outline = style.outline;
		updateIfNeeded(css, 'border-width', cssDimensions(outline.width));
		updateIfNeeded(css, 'border-color', Color.toCss(outline.color));
		updateIfNeeded(css, 'border-radius', outline.radius + 'px');

		var highlight = style.highlight;
		if (highlight.width === 0)
		{
			css.outline = 'none';
		}
		else
		{
			updateIfNeeded(css, 'outline-width', highlight.width + 'px');
			updateIfNeeded(css, 'outline-color', Color.toCss(highlight.color));
		}

		var textStyle = style.style;
		updateIfNeeded(css, 'color', Color.toCss(textStyle.color));
		if (textStyle.typeface.ctor !== '[]')
		{
			updateIfNeeded(css, 'font-family', Text.toTypefaces(textStyle.typeface));
		}
		if (textStyle.height.ctor !== 'Nothing')
		{
			updateIfNeeded(css, 'font-size', textStyle.height._0 + 'px');
		}
		updateIfNeeded(css, 'font-weight', textStyle.bold ? 'bold' : 'normal');
		updateIfNeeded(css, 'font-style', textStyle.italic ? 'italic' : 'normal');
		if (textStyle.line.ctor !== 'Nothing')
		{
			updateIfNeeded(css, 'text-decoration', Text.toLine(textStyle.line._0));
		}
	}

	function renderField(model)
	{
		var field = Element.createNode('input');
		updateFieldStyle(field.style, model.style);
		field.style.borderStyle = 'solid';
		field.style.pointerEvents = 'auto';

		field.type = model.type;
		field.placeholder = model.placeHolder;
		field.value = model.content.string;

		field.elm_handler = model.handler;
		field.elm_old_value = field.value;

		function inputUpdate(event)
		{
			var curr = field.elm_old_value;
			var next = field.value;
			if (curr === next)
			{
				return;
			}

			var direction = field.selectionDirection === 'forward' ? 'Forward' : 'Backward';
			var start = field.selectionStart;
			var end = field.selectionEnd;
			field.value = field.elm_old_value;

			Signal.sendMessage(field.elm_handler({
				string: next,
				selection: {
					start: start,
					end: end,
					direction: { ctor: direction }
				}
			}));
		}

		field.addEventListener('input', inputUpdate);
		field.addEventListener('focus', function() {
			field.elm_hasFocus = true;
		});
		field.addEventListener('blur', function() {
			field.elm_hasFocus = false;
		});

		return field;
	}

	function updateField(field, oldModel, newModel)
	{
		if (oldModel.style !== newModel.style)
		{
			updateFieldStyle(field.style, newModel.style);
		}
		field.elm_handler = newModel.handler;

		field.type = newModel.type;
		field.placeholder = newModel.placeHolder;
		var value = newModel.content.string;
		field.value = value;
		field.elm_old_value = value;
		if (field.elm_hasFocus)
		{
			var selection = newModel.content.selection;
			var direction = selection.direction.ctor === 'Forward' ? 'forward' : 'backward';
			setRange(field, selection.start, selection.end, direction);
		}
		return field;
	}

	function mkField(type)
	{
		function field(style, handler, placeHolder, content)
		{
			var padding = style.padding;
			var outline = style.outline.width;
			var adjustWidth = padding.left + padding.right + outline.left + outline.right;
			var adjustHeight = padding.top + padding.bottom + outline.top + outline.bottom;
			return A3(Element.newElement, 200, 30, {
				ctor: 'Custom',
				type: type + 'Field',
				adjustWidth: adjustWidth,
				adjustHeight: adjustHeight,
				render: renderField,
				update: updateField,
				model: {
					handler: handler,
					placeHolder: placeHolder,
					content: content,
					style: style,
					type: type
				}
			});
		}
		return F4(field);
	}

	function hoverable(handler, wrappedElement)
	{
		function onHover(bool)
		{
			Signal.sendMessage(handler(bool));
		}
		var element = wrappedElement._0;
		var newProps = Utils.update(element.props, { hover: onHover });
		return {
			ctor: wrappedElement.ctor,
			_0: {
				props: newProps,
				element: element.element
			}
		};
	}

	function clickable(message, wrappedElement)
	{
		function onClick()
		{
			Signal.sendMessage(message);
		}
		var element = wrappedElement._0;
		var newProps = Utils.update(element.props, { click: onClick });
		return {
			ctor: wrappedElement.ctor,
			_0: {
				props: newProps,
				element: element.element
			}
		};
	}

	return Elm.Native.Graphics.Input.values = {
		button: F2(button),
		customButton: F4(customButton),
		checkbox: F2(checkbox),
		dropDown: F2(dropDown),
		field: mkField('text'),
		email: mkField('email'),
		password: mkField('password'),
		hoverable: F2(hoverable),
		clickable: F2(clickable)
	};
};

Elm.Graphics = Elm.Graphics || {};
Elm.Graphics.Input = Elm.Graphics.Input || {};
Elm.Graphics.Input.make = function (_elm) {
   "use strict";
   _elm.Graphics = _elm.Graphics || {};
   _elm.Graphics.Input = _elm.Graphics.Input || {};
   if (_elm.Graphics.Input.values) return _elm.Graphics.Input.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $Native$Graphics$Input = Elm.Native.Graphics.Input.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var clickable = $Native$Graphics$Input.clickable;
   var hoverable = $Native$Graphics$Input.hoverable;
   var dropDown = $Native$Graphics$Input.dropDown;
   var checkbox = $Native$Graphics$Input.checkbox;
   var customButton = $Native$Graphics$Input.customButton;
   var button = $Native$Graphics$Input.button;
   return _elm.Graphics.Input.values = {_op: _op
                                       ,button: button
                                       ,customButton: customButton
                                       ,checkbox: checkbox
                                       ,dropDown: dropDown
                                       ,hoverable: hoverable
                                       ,clickable: clickable};
};
Elm.Graphics = Elm.Graphics || {};
Elm.Graphics.Input = Elm.Graphics.Input || {};
Elm.Graphics.Input.Field = Elm.Graphics.Input.Field || {};
Elm.Graphics.Input.Field.make = function (_elm) {
   "use strict";
   _elm.Graphics = _elm.Graphics || {};
   _elm.Graphics.Input = _elm.Graphics.Input || {};
   _elm.Graphics.Input.Field = _elm.Graphics.Input.Field || {};
   if (_elm.Graphics.Input.Field.values) return _elm.Graphics.Input.Field.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Color = Elm.Color.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $Native$Graphics$Input = Elm.Native.Graphics.Input.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Text = Elm.Text.make(_elm);
   var _op = {};
   var email = $Native$Graphics$Input.email;
   var password = $Native$Graphics$Input.password;
   var field = $Native$Graphics$Input.field;
   var Backward = {ctor: "Backward"};
   var Forward = {ctor: "Forward"};
   var Selection = F3(function (a,b,c) {    return {start: a,end: b,direction: c};});
   var Content = F2(function (a,b) {    return {string: a,selection: b};});
   var noContent = A2(Content,"",A3(Selection,0,0,Forward));
   var Style = F4(function (a,b,c,d) {    return {padding: a,outline: b,highlight: c,style: d};});
   var Highlight = F2(function (a,b) {    return {color: a,width: b};});
   var noHighlight = A2(Highlight,$Color.blue,0);
   var Outline = F3(function (a,b,c) {    return {color: a,width: b,radius: c};});
   var Dimensions = F4(function (a,b,c,d) {    return {left: a,right: b,top: c,bottom: d};});
   var uniformly = function (n) {    return A4(Dimensions,n,n,n,n);};
   var noOutline = A3(Outline,$Color.grey,uniformly(0),0);
   var defaultStyle = {padding: uniformly(4),outline: A3(Outline,$Color.grey,uniformly(1),2),highlight: A2(Highlight,$Color.blue,1),style: $Text.defaultStyle};
   return _elm.Graphics.Input.Field.values = {_op: _op
                                             ,field: field
                                             ,password: password
                                             ,email: email
                                             ,noContent: noContent
                                             ,defaultStyle: defaultStyle
                                             ,noOutline: noOutline
                                             ,noHighlight: noHighlight
                                             ,uniformly: uniformly
                                             ,Content: Content
                                             ,Selection: Selection
                                             ,Style: Style
                                             ,Outline: Outline
                                             ,Highlight: Highlight
                                             ,Dimensions: Dimensions
                                             ,Forward: Forward
                                             ,Backward: Backward};
};
Elm.Native.Json = {};

Elm.Native.Json.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Json = localRuntime.Native.Json || {};
	if (localRuntime.Native.Json.values) {
		return localRuntime.Native.Json.values;
	}

	var ElmArray = Elm.Native.Array.make(localRuntime);
	var List = Elm.Native.List.make(localRuntime);
	var Maybe = Elm.Maybe.make(localRuntime);
	var Result = Elm.Result.make(localRuntime);
	var Utils = Elm.Native.Utils.make(localRuntime);


	function crash(expected, actual) {
		throw new Error(
			'expecting ' + expected + ' but got ' + JSON.stringify(actual)
		);
	}


	// PRIMITIVE VALUES

	function decodeNull(successValue) {
		return function(value) {
			if (value === null) {
				return successValue;
			}
			crash('null', value);
		};
	}


	function decodeString(value) {
		if (typeof value === 'string' || value instanceof String) {
			return value;
		}
		crash('a String', value);
	}


	function decodeFloat(value) {
		if (typeof value === 'number') {
			return value;
		}
		crash('a Float', value);
	}


	function decodeInt(value) {
		if (typeof value !== 'number') {
			crash('an Int', value);
		}

		if (value < 2147483647 && value > -2147483647 && (value | 0) === value) {
			return value;
		}

		if (isFinite(value) && !(value % 1)) {
			return value;
		}

		crash('an Int', value);
	}


	function decodeBool(value) {
		if (typeof value === 'boolean') {
			return value;
		}
		crash('a Bool', value);
	}


	// ARRAY

	function decodeArray(decoder) {
		return function(value) {
			if (value instanceof Array) {
				var len = value.length;
				var array = new Array(len);
				for (var i = len; i--; ) {
					array[i] = decoder(value[i]);
				}
				return ElmArray.fromJSArray(array);
			}
			crash('an Array', value);
		};
	}


	// LIST

	function decodeList(decoder) {
		return function(value) {
			if (value instanceof Array) {
				var len = value.length;
				var list = List.Nil;
				for (var i = len; i--; ) {
					list = List.Cons( decoder(value[i]), list );
				}
				return list;
			}
			crash('a List', value);
		};
	}


	// MAYBE

	function decodeMaybe(decoder) {
		return function(value) {
			try {
				return Maybe.Just(decoder(value));
			} catch(e) {
				return Maybe.Nothing;
			}
		};
	}


	// FIELDS

	function decodeField(field, decoder) {
		return function(value) {
			var subValue = value[field];
			if (subValue !== undefined) {
				return decoder(subValue);
			}
			crash("an object with field '" + field + "'", value);
		};
	}


	// OBJECTS

	function decodeKeyValuePairs(decoder) {
		return function(value) {
			var isObject =
				typeof value === 'object'
					&& value !== null
					&& !(value instanceof Array);

			if (isObject) {
				var keyValuePairs = List.Nil;
				for (var key in value)
				{
					var elmValue = decoder(value[key]);
					var pair = Utils.Tuple2(key, elmValue);
					keyValuePairs = List.Cons(pair, keyValuePairs);
				}
				return keyValuePairs;
			}

			crash('an object', value);
		};
	}

	function decodeObject1(f, d1) {
		return function(value) {
			return f(d1(value));
		};
	}

	function decodeObject2(f, d1, d2) {
		return function(value) {
			return A2( f, d1(value), d2(value) );
		};
	}

	function decodeObject3(f, d1, d2, d3) {
		return function(value) {
			return A3( f, d1(value), d2(value), d3(value) );
		};
	}

	function decodeObject4(f, d1, d2, d3, d4) {
		return function(value) {
			return A4( f, d1(value), d2(value), d3(value), d4(value) );
		};
	}

	function decodeObject5(f, d1, d2, d3, d4, d5) {
		return function(value) {
			return A5( f, d1(value), d2(value), d3(value), d4(value), d5(value) );
		};
	}

	function decodeObject6(f, d1, d2, d3, d4, d5, d6) {
		return function(value) {
			return A6( f,
				d1(value),
				d2(value),
				d3(value),
				d4(value),
				d5(value),
				d6(value)
			);
		};
	}

	function decodeObject7(f, d1, d2, d3, d4, d5, d6, d7) {
		return function(value) {
			return A7( f,
				d1(value),
				d2(value),
				d3(value),
				d4(value),
				d5(value),
				d6(value),
				d7(value)
			);
		};
	}

	function decodeObject8(f, d1, d2, d3, d4, d5, d6, d7, d8) {
		return function(value) {
			return A8( f,
				d1(value),
				d2(value),
				d3(value),
				d4(value),
				d5(value),
				d6(value),
				d7(value),
				d8(value)
			);
		};
	}


	// TUPLES

	function decodeTuple1(f, d1) {
		return function(value) {
			if ( !(value instanceof Array) || value.length !== 1 ) {
				crash('a Tuple of length 1', value);
			}
			return f( d1(value[0]) );
		};
	}

	function decodeTuple2(f, d1, d2) {
		return function(value) {
			if ( !(value instanceof Array) || value.length !== 2 ) {
				crash('a Tuple of length 2', value);
			}
			return A2( f, d1(value[0]), d2(value[1]) );
		};
	}

	function decodeTuple3(f, d1, d2, d3) {
		return function(value) {
			if ( !(value instanceof Array) || value.length !== 3 ) {
				crash('a Tuple of length 3', value);
			}
			return A3( f, d1(value[0]), d2(value[1]), d3(value[2]) );
		};
	}


	function decodeTuple4(f, d1, d2, d3, d4) {
		return function(value) {
			if ( !(value instanceof Array) || value.length !== 4 ) {
				crash('a Tuple of length 4', value);
			}
			return A4( f, d1(value[0]), d2(value[1]), d3(value[2]), d4(value[3]) );
		};
	}


	function decodeTuple5(f, d1, d2, d3, d4, d5) {
		return function(value) {
			if ( !(value instanceof Array) || value.length !== 5 ) {
				crash('a Tuple of length 5', value);
			}
			return A5( f,
				d1(value[0]),
				d2(value[1]),
				d3(value[2]),
				d4(value[3]),
				d5(value[4])
			);
		};
	}


	function decodeTuple6(f, d1, d2, d3, d4, d5, d6) {
		return function(value) {
			if ( !(value instanceof Array) || value.length !== 6 ) {
				crash('a Tuple of length 6', value);
			}
			return A6( f,
				d1(value[0]),
				d2(value[1]),
				d3(value[2]),
				d4(value[3]),
				d5(value[4]),
				d6(value[5])
			);
		};
	}

	function decodeTuple7(f, d1, d2, d3, d4, d5, d6, d7) {
		return function(value) {
			if ( !(value instanceof Array) || value.length !== 7 ) {
				crash('a Tuple of length 7', value);
			}
			return A7( f,
				d1(value[0]),
				d2(value[1]),
				d3(value[2]),
				d4(value[3]),
				d5(value[4]),
				d6(value[5]),
				d7(value[6])
			);
		};
	}


	function decodeTuple8(f, d1, d2, d3, d4, d5, d6, d7, d8) {
		return function(value) {
			if ( !(value instanceof Array) || value.length !== 8 ) {
				crash('a Tuple of length 8', value);
			}
			return A8( f,
				d1(value[0]),
				d2(value[1]),
				d3(value[2]),
				d4(value[3]),
				d5(value[4]),
				d6(value[5]),
				d7(value[6]),
				d8(value[7])
			);
		};
	}


	// CUSTOM DECODERS

	function decodeValue(value) {
		return value;
	}

	function runDecoderValue(decoder, value) {
		try {
			return Result.Ok(decoder(value));
		} catch(e) {
			return Result.Err(e.message);
		}
	}

	function customDecoder(decoder, callback) {
		return function(value) {
			var result = callback(decoder(value));
			if (result.ctor === 'Err') {
				throw new Error('custom decoder failed: ' + result._0);
			}
			return result._0;
		};
	}

	function andThen(decode, callback) {
		return function(value) {
			var result = decode(value);
			return callback(result)(value);
		};
	}

	function fail(msg) {
		return function(value) {
			throw new Error(msg);
		};
	}

	function succeed(successValue) {
		return function(value) {
			return successValue;
		};
	}


	// ONE OF MANY

	function oneOf(decoders) {
		return function(value) {
			var errors = [];
			var temp = decoders;
			while (temp.ctor !== '[]') {
				try {
					return temp._0(value);
				} catch(e) {
					errors.push(e.message);
				}
				temp = temp._1;
			}
			throw new Error('expecting one of the following:\n    ' + errors.join('\n    '));
		};
	}

	function get(decoder, value) {
		try {
			return Result.Ok(decoder(value));
		} catch(e) {
			return Result.Err(e.message);
		}
	}


	// ENCODE / DECODE

	function runDecoderString(decoder, string) {
		try {
			return Result.Ok(decoder(JSON.parse(string)));
		} catch(e) {
			return Result.Err(e.message);
		}
	}

	function encode(indentLevel, value) {
		return JSON.stringify(value, null, indentLevel);
	}

	function identity(value) {
		return value;
	}

	function encodeObject(keyValuePairs) {
		var obj = {};
		while (keyValuePairs.ctor !== '[]') {
			var pair = keyValuePairs._0;
			obj[pair._0] = pair._1;
			keyValuePairs = keyValuePairs._1;
		}
		return obj;
	}

	return localRuntime.Native.Json.values = {
		encode: F2(encode),
		runDecoderString: F2(runDecoderString),
		runDecoderValue: F2(runDecoderValue),

		get: F2(get),
		oneOf: oneOf,

		decodeNull: decodeNull,
		decodeInt: decodeInt,
		decodeFloat: decodeFloat,
		decodeString: decodeString,
		decodeBool: decodeBool,

		decodeMaybe: decodeMaybe,

		decodeList: decodeList,
		decodeArray: decodeArray,

		decodeField: F2(decodeField),

		decodeObject1: F2(decodeObject1),
		decodeObject2: F3(decodeObject2),
		decodeObject3: F4(decodeObject3),
		decodeObject4: F5(decodeObject4),
		decodeObject5: F6(decodeObject5),
		decodeObject6: F7(decodeObject6),
		decodeObject7: F8(decodeObject7),
		decodeObject8: F9(decodeObject8),
		decodeKeyValuePairs: decodeKeyValuePairs,

		decodeTuple1: F2(decodeTuple1),
		decodeTuple2: F3(decodeTuple2),
		decodeTuple3: F4(decodeTuple3),
		decodeTuple4: F5(decodeTuple4),
		decodeTuple5: F6(decodeTuple5),
		decodeTuple6: F7(decodeTuple6),
		decodeTuple7: F8(decodeTuple7),
		decodeTuple8: F9(decodeTuple8),

		andThen: F2(andThen),
		decodeValue: decodeValue,
		customDecoder: F2(customDecoder),
		fail: fail,
		succeed: succeed,

		identity: identity,
		encodeNull: null,
		encodeArray: ElmArray.toJSArray,
		encodeList: List.toArray,
		encodeObject: encodeObject

	};
};

Elm.Json = Elm.Json || {};
Elm.Json.Encode = Elm.Json.Encode || {};
Elm.Json.Encode.make = function (_elm) {
   "use strict";
   _elm.Json = _elm.Json || {};
   _elm.Json.Encode = _elm.Json.Encode || {};
   if (_elm.Json.Encode.values) return _elm.Json.Encode.values;
   var _U = Elm.Native.Utils.make(_elm),$Array = Elm.Array.make(_elm),$Native$Json = Elm.Native.Json.make(_elm);
   var _op = {};
   var list = $Native$Json.encodeList;
   var array = $Native$Json.encodeArray;
   var object = $Native$Json.encodeObject;
   var $null = $Native$Json.encodeNull;
   var bool = $Native$Json.identity;
   var $float = $Native$Json.identity;
   var $int = $Native$Json.identity;
   var string = $Native$Json.identity;
   var encode = $Native$Json.encode;
   var Value = {ctor: "Value"};
   return _elm.Json.Encode.values = {_op: _op
                                    ,encode: encode
                                    ,string: string
                                    ,$int: $int
                                    ,$float: $float
                                    ,bool: bool
                                    ,$null: $null
                                    ,list: list
                                    ,array: array
                                    ,object: object};
};
Elm.Json = Elm.Json || {};
Elm.Json.Decode = Elm.Json.Decode || {};
Elm.Json.Decode.make = function (_elm) {
   "use strict";
   _elm.Json = _elm.Json || {};
   _elm.Json.Decode = _elm.Json.Decode || {};
   if (_elm.Json.Decode.values) return _elm.Json.Decode.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Array = Elm.Array.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Json$Encode = Elm.Json.Encode.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Json = Elm.Native.Json.make(_elm),
   $Result = Elm.Result.make(_elm);
   var _op = {};
   var tuple8 = $Native$Json.decodeTuple8;
   var tuple7 = $Native$Json.decodeTuple7;
   var tuple6 = $Native$Json.decodeTuple6;
   var tuple5 = $Native$Json.decodeTuple5;
   var tuple4 = $Native$Json.decodeTuple4;
   var tuple3 = $Native$Json.decodeTuple3;
   var tuple2 = $Native$Json.decodeTuple2;
   var tuple1 = $Native$Json.decodeTuple1;
   var succeed = $Native$Json.succeed;
   var fail = $Native$Json.fail;
   var andThen = $Native$Json.andThen;
   var customDecoder = $Native$Json.customDecoder;
   var decodeValue = $Native$Json.runDecoderValue;
   var value = $Native$Json.decodeValue;
   var maybe = $Native$Json.decodeMaybe;
   var $null = $Native$Json.decodeNull;
   var array = $Native$Json.decodeArray;
   var list = $Native$Json.decodeList;
   var bool = $Native$Json.decodeBool;
   var $int = $Native$Json.decodeInt;
   var $float = $Native$Json.decodeFloat;
   var string = $Native$Json.decodeString;
   var oneOf = $Native$Json.oneOf;
   var keyValuePairs = $Native$Json.decodeKeyValuePairs;
   var object8 = $Native$Json.decodeObject8;
   var object7 = $Native$Json.decodeObject7;
   var object6 = $Native$Json.decodeObject6;
   var object5 = $Native$Json.decodeObject5;
   var object4 = $Native$Json.decodeObject4;
   var object3 = $Native$Json.decodeObject3;
   var object2 = $Native$Json.decodeObject2;
   var object1 = $Native$Json.decodeObject1;
   _op[":="] = $Native$Json.decodeField;
   var at = F2(function (fields,decoder) {    return A3($List.foldr,F2(function (x,y) {    return A2(_op[":="],x,y);}),decoder,fields);});
   var decodeString = $Native$Json.runDecoderString;
   var map = $Native$Json.decodeObject1;
   var dict = function (decoder) {    return A2(map,$Dict.fromList,keyValuePairs(decoder));};
   var Decoder = {ctor: "Decoder"};
   return _elm.Json.Decode.values = {_op: _op
                                    ,decodeString: decodeString
                                    ,decodeValue: decodeValue
                                    ,string: string
                                    ,$int: $int
                                    ,$float: $float
                                    ,bool: bool
                                    ,$null: $null
                                    ,list: list
                                    ,array: array
                                    ,tuple1: tuple1
                                    ,tuple2: tuple2
                                    ,tuple3: tuple3
                                    ,tuple4: tuple4
                                    ,tuple5: tuple5
                                    ,tuple6: tuple6
                                    ,tuple7: tuple7
                                    ,tuple8: tuple8
                                    ,at: at
                                    ,object1: object1
                                    ,object2: object2
                                    ,object3: object3
                                    ,object4: object4
                                    ,object5: object5
                                    ,object6: object6
                                    ,object7: object7
                                    ,object8: object8
                                    ,keyValuePairs: keyValuePairs
                                    ,dict: dict
                                    ,maybe: maybe
                                    ,oneOf: oneOf
                                    ,map: map
                                    ,fail: fail
                                    ,succeed: succeed
                                    ,andThen: andThen
                                    ,value: value
                                    ,customDecoder: customDecoder};
};
Elm.Set = Elm.Set || {};
Elm.Set.make = function (_elm) {
   "use strict";
   _elm.Set = _elm.Set || {};
   if (_elm.Set.values) return _elm.Set.values;
   var _U = Elm.Native.Utils.make(_elm),$Basics = Elm.Basics.make(_elm),$Dict = Elm.Dict.make(_elm),$List = Elm.List.make(_elm);
   var _op = {};
   var foldr = F3(function (f,b,_p0) {    var _p1 = _p0;return A3($Dict.foldr,F3(function (k,_p2,b) {    return A2(f,k,b);}),b,_p1._0);});
   var foldl = F3(function (f,b,_p3) {    var _p4 = _p3;return A3($Dict.foldl,F3(function (k,_p5,b) {    return A2(f,k,b);}),b,_p4._0);});
   var toList = function (_p6) {    var _p7 = _p6;return $Dict.keys(_p7._0);};
   var size = function (_p8) {    var _p9 = _p8;return $Dict.size(_p9._0);};
   var member = F2(function (k,_p10) {    var _p11 = _p10;return A2($Dict.member,k,_p11._0);});
   var isEmpty = function (_p12) {    var _p13 = _p12;return $Dict.isEmpty(_p13._0);};
   var Set_elm_builtin = function (a) {    return {ctor: "Set_elm_builtin",_0: a};};
   var empty = Set_elm_builtin($Dict.empty);
   var singleton = function (k) {    return Set_elm_builtin(A2($Dict.singleton,k,{ctor: "_Tuple0"}));};
   var insert = F2(function (k,_p14) {    var _p15 = _p14;return Set_elm_builtin(A3($Dict.insert,k,{ctor: "_Tuple0"},_p15._0));});
   var fromList = function (xs) {    return A3($List.foldl,insert,empty,xs);};
   var map = F2(function (f,s) {    return fromList(A2($List.map,f,toList(s)));});
   var remove = F2(function (k,_p16) {    var _p17 = _p16;return Set_elm_builtin(A2($Dict.remove,k,_p17._0));});
   var union = F2(function (_p19,_p18) {    var _p20 = _p19;var _p21 = _p18;return Set_elm_builtin(A2($Dict.union,_p20._0,_p21._0));});
   var intersect = F2(function (_p23,_p22) {    var _p24 = _p23;var _p25 = _p22;return Set_elm_builtin(A2($Dict.intersect,_p24._0,_p25._0));});
   var diff = F2(function (_p27,_p26) {    var _p28 = _p27;var _p29 = _p26;return Set_elm_builtin(A2($Dict.diff,_p28._0,_p29._0));});
   var filter = F2(function (p,_p30) {    var _p31 = _p30;return Set_elm_builtin(A2($Dict.filter,F2(function (k,_p32) {    return p(k);}),_p31._0));});
   var partition = F2(function (p,_p33) {
      var _p34 = _p33;
      var _p35 = A2($Dict.partition,F2(function (k,_p36) {    return p(k);}),_p34._0);
      var p1 = _p35._0;
      var p2 = _p35._1;
      return {ctor: "_Tuple2",_0: Set_elm_builtin(p1),_1: Set_elm_builtin(p2)};
   });
   return _elm.Set.values = {_op: _op
                            ,empty: empty
                            ,singleton: singleton
                            ,insert: insert
                            ,remove: remove
                            ,isEmpty: isEmpty
                            ,member: member
                            ,size: size
                            ,foldl: foldl
                            ,foldr: foldr
                            ,map: map
                            ,filter: filter
                            ,partition: partition
                            ,union: union
                            ,intersect: intersect
                            ,diff: diff
                            ,toList: toList
                            ,fromList: fromList};
};
Elm.Native.Keyboard = {};

Elm.Native.Keyboard.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Keyboard = localRuntime.Native.Keyboard || {};
	if (localRuntime.Native.Keyboard.values)
	{
		return localRuntime.Native.Keyboard.values;
	}

	var NS = Elm.Native.Signal.make(localRuntime);


	function keyEvent(event)
	{
		return {
			alt: event.altKey,
			meta: event.metaKey,
			keyCode: event.keyCode
		};
	}


	function keyStream(node, eventName, handler)
	{
		var stream = NS.input(eventName, { alt: false, meta: false, keyCode: 0 });

		localRuntime.addListener([stream.id], node, eventName, function(e) {
			localRuntime.notify(stream.id, handler(e));
		});

		return stream;
	}

	var downs = keyStream(document, 'keydown', keyEvent);
	var ups = keyStream(document, 'keyup', keyEvent);
	var presses = keyStream(document, 'keypress', keyEvent);
	var blurs = keyStream(window, 'blur', function() { return null; });


	return localRuntime.Native.Keyboard.values = {
		downs: downs,
		ups: ups,
		blurs: blurs,
		presses: presses
	};
};

Elm.Keyboard = Elm.Keyboard || {};
Elm.Keyboard.make = function (_elm) {
   "use strict";
   _elm.Keyboard = _elm.Keyboard || {};
   if (_elm.Keyboard.values) return _elm.Keyboard.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Char = Elm.Char.make(_elm),
   $Native$Keyboard = Elm.Native.Keyboard.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var presses = A2($Signal.map,function (_) {    return _.keyCode;},$Native$Keyboard.presses);
   var toXY = F2(function (_p0,keyCodes) {
      var _p1 = _p0;
      var is = function (keyCode) {    return A2($Set.member,keyCode,keyCodes) ? 1 : 0;};
      return {x: is(_p1.right) - is(_p1.left),y: is(_p1.up) - is(_p1.down)};
   });
   var Directions = F4(function (a,b,c,d) {    return {up: a,down: b,left: c,right: d};});
   var dropMap = F2(function (f,signal) {    return $Signal.dropRepeats(A2($Signal.map,f,signal));});
   var EventInfo = F3(function (a,b,c) {    return {alt: a,meta: b,keyCode: c};});
   var Blur = {ctor: "Blur"};
   var Down = function (a) {    return {ctor: "Down",_0: a};};
   var Up = function (a) {    return {ctor: "Up",_0: a};};
   var rawEvents = $Signal.mergeMany(_U.list([A2($Signal.map,Up,$Native$Keyboard.ups)
                                             ,A2($Signal.map,Down,$Native$Keyboard.downs)
                                             ,A2($Signal.map,$Basics.always(Blur),$Native$Keyboard.blurs)]));
   var empty = {alt: false,meta: false,keyCodes: $Set.empty};
   var update = F2(function (event,model) {
      var _p2 = event;
      switch (_p2.ctor)
      {case "Down": var _p3 = _p2._0;
           return {alt: _p3.alt,meta: _p3.meta,keyCodes: A2($Set.insert,_p3.keyCode,model.keyCodes)};
         case "Up": var _p4 = _p2._0;
           return {alt: _p4.alt,meta: _p4.meta,keyCodes: A2($Set.remove,_p4.keyCode,model.keyCodes)};
         default: return empty;}
   });
   var model = A3($Signal.foldp,update,empty,rawEvents);
   var alt = A2(dropMap,function (_) {    return _.alt;},model);
   var meta = A2(dropMap,function (_) {    return _.meta;},model);
   var keysDown = A2(dropMap,function (_) {    return _.keyCodes;},model);
   var arrows = A2(dropMap,toXY({up: 38,down: 40,left: 37,right: 39}),keysDown);
   var wasd = A2(dropMap,toXY({up: 87,down: 83,left: 65,right: 68}),keysDown);
   var isDown = function (keyCode) {    return A2(dropMap,$Set.member(keyCode),keysDown);};
   var ctrl = isDown(17);
   var shift = isDown(16);
   var space = isDown(32);
   var enter = isDown(13);
   var Model = F3(function (a,b,c) {    return {alt: a,meta: b,keyCodes: c};});
   return _elm.Keyboard.values = {_op: _op
                                 ,arrows: arrows
                                 ,wasd: wasd
                                 ,enter: enter
                                 ,space: space
                                 ,ctrl: ctrl
                                 ,shift: shift
                                 ,alt: alt
                                 ,meta: meta
                                 ,isDown: isDown
                                 ,keysDown: keysDown
                                 ,presses: presses};
};
Elm.Native = Elm.Native || {};
Elm.Native.Mouse = {};
Elm.Native.Mouse.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Mouse = localRuntime.Native.Mouse || {};
	if (localRuntime.Native.Mouse.values)
	{
		return localRuntime.Native.Mouse.values;
	}

	var NS = Elm.Native.Signal.make(localRuntime);
	var Utils = Elm.Native.Utils.make(localRuntime);

	var position = NS.input('Mouse.position', Utils.Tuple2(0, 0));

	var isDown = NS.input('Mouse.isDown', false);

	var clicks = NS.input('Mouse.clicks', Utils.Tuple0);

	var node = localRuntime.isFullscreen()
		? document
		: localRuntime.node;

	localRuntime.addListener([clicks.id], node, 'click', function click() {
		localRuntime.notify(clicks.id, Utils.Tuple0);
	});
	localRuntime.addListener([isDown.id], node, 'mousedown', function down() {
		localRuntime.notify(isDown.id, true);
	});
	localRuntime.addListener([isDown.id], node, 'mouseup', function up() {
		localRuntime.notify(isDown.id, false);
	});
	localRuntime.addListener([position.id], node, 'mousemove', function move(e) {
		localRuntime.notify(position.id, Utils.getXY(e));
	});

	return localRuntime.Native.Mouse.values = {
		position: position,
		isDown: isDown,
		clicks: clicks
	};
};

Elm.Mouse = Elm.Mouse || {};
Elm.Mouse.make = function (_elm) {
   "use strict";
   _elm.Mouse = _elm.Mouse || {};
   if (_elm.Mouse.values) return _elm.Mouse.values;
   var _U = Elm.Native.Utils.make(_elm),$Basics = Elm.Basics.make(_elm),$Native$Mouse = Elm.Native.Mouse.make(_elm),$Signal = Elm.Signal.make(_elm);
   var _op = {};
   var clicks = $Native$Mouse.clicks;
   var isDown = $Native$Mouse.isDown;
   var position = $Native$Mouse.position;
   var x = A2($Signal.map,$Basics.fst,position);
   var y = A2($Signal.map,$Basics.snd,position);
   return _elm.Mouse.values = {_op: _op,position: position,x: x,y: y,isDown: isDown,clicks: clicks};
};
Elm.Native.Regex = {};
Elm.Native.Regex.make = function(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Regex = localRuntime.Native.Regex || {};
	if (localRuntime.Native.Regex.values)
	{
		return localRuntime.Native.Regex.values;
	}
	if ('values' in Elm.Native.Regex)
	{
		return localRuntime.Native.Regex.values = Elm.Native.Regex.values;
	}

	var List = Elm.Native.List.make(localRuntime);
	var Maybe = Elm.Maybe.make(localRuntime);

	function escape(str)
	{
		return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}
	function caseInsensitive(re)
	{
		return new RegExp(re.source, 'gi');
	}
	function regex(raw)
	{
		return new RegExp(raw, 'g');
	}

	function contains(re, string)
	{
		return string.match(re) !== null;
	}

	function find(n, re, str)
	{
		n = n.ctor === 'All' ? Infinity : n._0;
		var out = [];
		var number = 0;
		var string = str;
		var lastIndex = re.lastIndex;
		var prevLastIndex = -1;
		var result;
		while (number++ < n && (result = re.exec(string)))
		{
			if (prevLastIndex === re.lastIndex) break;
			var i = result.length - 1;
			var subs = new Array(i);
			while (i > 0)
			{
				var submatch = result[i];
				subs[--i] = submatch === undefined
					? Maybe.Nothing
					: Maybe.Just(submatch);
			}
			out.push({
				match: result[0],
				submatches: List.fromArray(subs),
				index: result.index,
				number: number
			});
			prevLastIndex = re.lastIndex;
		}
		re.lastIndex = lastIndex;
		return List.fromArray(out);
	}

	function replace(n, re, replacer, string)
	{
		n = n.ctor === 'All' ? Infinity : n._0;
		var count = 0;
		function jsReplacer(match)
		{
			if (count++ >= n)
			{
				return match;
			}
			var i = arguments.length - 3;
			var submatches = new Array(i);
			while (i > 0)
			{
				var submatch = arguments[i];
				submatches[--i] = submatch === undefined
					? Maybe.Nothing
					: Maybe.Just(submatch);
			}
			return replacer({
				match: match,
				submatches: List.fromArray(submatches),
				index: arguments[i - 1],
				number: count
			});
		}
		return string.replace(re, jsReplacer);
	}

	function split(n, re, str)
	{
		n = n.ctor === 'All' ? Infinity : n._0;
		if (n === Infinity)
		{
			return List.fromArray(str.split(re));
		}
		var string = str;
		var result;
		var out = [];
		var start = re.lastIndex;
		while (n--)
		{
			if (!(result = re.exec(string))) break;
			out.push(string.slice(start, result.index));
			start = re.lastIndex;
		}
		out.push(string.slice(start));
		return List.fromArray(out);
	}

	return Elm.Native.Regex.values = {
		regex: regex,
		caseInsensitive: caseInsensitive,
		escape: escape,

		contains: F2(contains),
		find: F3(find),
		replace: F4(replace),
		split: F3(split)
	};
};

Elm.Native = Elm.Native || {};
Elm.Native.Window = {};
Elm.Native.Window.make = function make(localRuntime) {
	localRuntime.Native = localRuntime.Native || {};
	localRuntime.Native.Window = localRuntime.Native.Window || {};
	if (localRuntime.Native.Window.values)
	{
		return localRuntime.Native.Window.values;
	}

	var NS = Elm.Native.Signal.make(localRuntime);
	var Tuple2 = Elm.Native.Utils.make(localRuntime).Tuple2;


	function getWidth()
	{
		return localRuntime.node.clientWidth;
	}


	function getHeight()
	{
		if (localRuntime.isFullscreen())
		{
			return window.innerHeight;
		}
		return localRuntime.node.clientHeight;
	}


	var dimensions = NS.input('Window.dimensions', Tuple2(getWidth(), getHeight()));


	function resizeIfNeeded()
	{
		// Do not trigger event if the dimensions have not changed.
		// This should be most of the time.
		var w = getWidth();
		var h = getHeight();
		if (dimensions.value._0 === w && dimensions.value._1 === h)
		{
			return;
		}

		setTimeout(function() {
			// Check again to see if the dimensions have changed.
			// It is conceivable that the dimensions have changed
			// again while some other event was being processed.
			w = getWidth();
			h = getHeight();
			if (dimensions.value._0 === w && dimensions.value._1 === h)
			{
				return;
			}
			localRuntime.notify(dimensions.id, Tuple2(w, h));
		}, 0);
	}


	localRuntime.addListener([dimensions.id], window, 'resize', resizeIfNeeded);


	return localRuntime.Native.Window.values = {
		dimensions: dimensions,
		resizeIfNeeded: resizeIfNeeded
	};
};

Elm.Regex = Elm.Regex || {};
Elm.Regex.make = function (_elm) {
   "use strict";
   _elm.Regex = _elm.Regex || {};
   if (_elm.Regex.values) return _elm.Regex.values;
   var _U = Elm.Native.Utils.make(_elm),$Maybe = Elm.Maybe.make(_elm),$Native$Regex = Elm.Native.Regex.make(_elm);
   var _op = {};
   var split = $Native$Regex.split;
   var replace = $Native$Regex.replace;
   var find = $Native$Regex.find;
   var AtMost = function (a) {    return {ctor: "AtMost",_0: a};};
   var All = {ctor: "All"};
   var Match = F4(function (a,b,c,d) {    return {match: a,submatches: b,index: c,number: d};});
   var contains = $Native$Regex.contains;
   var caseInsensitive = $Native$Regex.caseInsensitive;
   var regex = $Native$Regex.regex;
   var escape = $Native$Regex.escape;
   var Regex = {ctor: "Regex"};
   return _elm.Regex.values = {_op: _op
                              ,regex: regex
                              ,escape: escape
                              ,caseInsensitive: caseInsensitive
                              ,contains: contains
                              ,find: find
                              ,replace: replace
                              ,split: split
                              ,Match: Match
                              ,All: All
                              ,AtMost: AtMost};
};
Elm.Window = Elm.Window || {};
Elm.Window.make = function (_elm) {
   "use strict";
   _elm.Window = _elm.Window || {};
   if (_elm.Window.values) return _elm.Window.values;
   var _U = Elm.Native.Utils.make(_elm),$Basics = Elm.Basics.make(_elm),$Native$Window = Elm.Native.Window.make(_elm),$Signal = Elm.Signal.make(_elm);
   var _op = {};
   var dimensions = $Native$Window.dimensions;
   var width = A2($Signal.map,$Basics.fst,dimensions);
   var height = A2($Signal.map,$Basics.snd,dimensions);
   return _elm.Window.values = {_op: _op,dimensions: dimensions,width: width,height: height};
};
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"min-document":1}],3:[function(require,module,exports){
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

},{}],4:[function(require,module,exports){
var nativeIsArray = Array.isArray
var toString = Object.prototype.toString

module.exports = nativeIsArray || isArray

function isArray(obj) {
    return toString.call(obj) === "[object Array]"
}

},{}],5:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook.js")

module.exports = applyProperties

function applyProperties(node, props, previous) {
    for (var propName in props) {
        var propValue = props[propName]

        if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
        } else if (isHook(propValue)) {
            removeProperty(node, propName, propValue, previous)
            if (propValue.hook) {
                propValue.hook(node,
                    propName,
                    previous ? previous[propName] : undefined)
            }
        } else {
            if (isObject(propValue)) {
                patchObject(node, props, previous, propName, propValue);
            } else {
                node[propName] = propValue
            }
        }
    }
}

function removeProperty(node, propName, propValue, previous) {
    if (previous) {
        var previousValue = previous[propName]

        if (!isHook(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName)
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = ""
                }
            } else if (typeof previousValue === "string") {
                node[propName] = ""
            } else {
                node[propName] = null
            }
        } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue)
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName]

            if (attrValue === undefined) {
                node.removeAttribute(attrName)
            } else {
                node.setAttribute(attrName, attrValue)
            }
        }

        return
    }

    if(previousValue && isObject(previousValue) &&
        getPrototype(previousValue) !== getPrototype(propValue)) {
        node[propName] = propValue
        return
    }

    if (!isObject(node[propName])) {
        node[propName] = {}
    }

    var replacer = propName === "style" ? "" : undefined

    for (var k in propValue) {
        var value = propValue[k]
        node[propName][k] = (value === undefined) ? replacer : value
    }
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

},{"../vnode/is-vhook.js":13,"is-object":3}],6:[function(require,module,exports){
var document = require("global/document")

var applyProperties = require("./apply-properties")

var isVNode = require("../vnode/is-vnode.js")
var isVText = require("../vnode/is-vtext.js")
var isWidget = require("../vnode/is-widget.js")
var handleThunk = require("../vnode/handle-thunk.js")

module.exports = createElement

function createElement(vnode, opts) {
    var doc = opts ? opts.document || document : document
    var warn = opts ? opts.warn : null

    vnode = handleThunk(vnode).a

    if (isWidget(vnode)) {
        return vnode.init()
    } else if (isVText(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode)
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName) :
        doc.createElementNS(vnode.namespace, vnode.tagName)

    var props = vnode.properties
    applyProperties(node, props)

    var children = vnode.children

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts)
        if (childNode) {
            node.appendChild(childNode)
        }
    }

    return node
}

},{"../vnode/handle-thunk.js":11,"../vnode/is-vnode.js":14,"../vnode/is-vtext.js":15,"../vnode/is-widget.js":16,"./apply-properties":5,"global/document":2}],7:[function(require,module,exports){
// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {}

module.exports = domIndex

function domIndex(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode
        }

        var vChildren = tree.children

        if (vChildren) {

            var childNodes = rootNode.childNodes

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i] || noChild
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],8:[function(require,module,exports){
var applyProperties = require("./apply-properties")

var isWidget = require("../vnode/is-widget.js")
var VPatch = require("../vnode/vpatch.js")

var render = require("./create-element")
var updateWidget = require("./update-widget")

module.exports = applyPatch

function applyPatch(vpatch, domNode, renderOptions) {
    var type = vpatch.type
    var vNode = vpatch.vNode
    var patch = vpatch.patch

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch.ORDER:
            reorderChildren(domNode, patch)
            return domNode
        case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties)
            return domNode
        case VPatch.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode

    if (parentNode) {
        parentNode.removeChild(domNode)
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = render(vNode, renderOptions)

    if (parentNode) {
        parentNode.appendChild(newNode)
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text)
        newNode = domNode
    } else {
        var parentNode = domNode.parentNode
        newNode = render(vText, renderOptions)

        if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode)
        }
    }

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    var updating = updateWidget(leftVNode, widget)
    var newNode

    if (updating) {
        newNode = widget.update(leftVNode, domNode) || domNode
    } else {
        newNode = render(widget, renderOptions)
    }

    var parentNode = domNode.parentNode

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    if (!updating) {
        destroyWidget(domNode, leftVNode)
    }

    return newNode
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode
    var newNode = render(vNode, renderOptions)

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget(w)) {
        w.destroy(domNode)
    }
}

function reorderChildren(domNode, moves) {
    var childNodes = domNode.childNodes
    var keyMap = {}
    var node
    var remove
    var insert

    for (var i = 0; i < moves.removes.length; i++) {
        remove = moves.removes[i]
        node = childNodes[remove.from]
        if (remove.key) {
            keyMap[remove.key] = node
        }
        domNode.removeChild(node)
    }

    var length = childNodes.length
    for (var j = 0; j < moves.inserts.length; j++) {
        insert = moves.inserts[j]
        node = keyMap[insert.key]
        // this is the weirdest bug i've ever seen in webkit
        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
    }

    return newRoot;
}

},{"../vnode/is-widget.js":16,"../vnode/vpatch.js":19,"./apply-properties":5,"./create-element":6,"./update-widget":10}],9:[function(require,module,exports){
var document = require("global/document")
var isArray = require("x-is-array")

var domIndex = require("./dom-index")
var patchOp = require("./patch-op")
module.exports = patch

function patch(rootNode, patches) {
    return patchRecursive(rootNode, patches)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches)

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices)
    var ownerDocument = rootNode.ownerDocument

    if (!renderOptions) {
        renderOptions = { patch: patchRecursive }
        if (ownerDocument !== document) {
            renderOptions.document = ownerDocument
        }
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i]
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions)
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode

    if (isArray(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions)

            if (domNode === rootNode) {
                rootNode = newNode
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions)

        if (domNode === rootNode) {
            rootNode = newNode
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = []

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key))
        }
    }

    return indices
}

},{"./dom-index":7,"./patch-op":8,"global/document":2,"x-is-array":4}],10:[function(require,module,exports){
var isWidget = require("../vnode/is-widget.js")

module.exports = updateWidget

function updateWidget(a, b) {
    if (isWidget(a) && isWidget(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

},{"../vnode/is-widget.js":16}],11:[function(require,module,exports){
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")

module.exports = handleThunk

function handleThunk(a, b) {
    var renderedA = a
    var renderedB = b

    if (isThunk(b)) {
        renderedB = renderThunk(b, a)
    }

    if (isThunk(a)) {
        renderedA = renderThunk(a, null)
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous)
    }

    if (!(isVNode(renderedThunk) ||
            isVText(renderedThunk) ||
            isWidget(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

},{"./is-thunk":12,"./is-vnode":14,"./is-vtext":15,"./is-widget":16}],12:[function(require,module,exports){
module.exports = isThunk

function isThunk(t) {
    return t && t.type === "Thunk"
}

},{}],13:[function(require,module,exports){
module.exports = isHook

function isHook(hook) {
    return hook &&
      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
}

},{}],14:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualNode

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version
}

},{"./version":17}],15:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualText

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version
}

},{"./version":17}],16:[function(require,module,exports){
module.exports = isWidget

function isWidget(w) {
    return w && w.type === "Widget"
}

},{}],17:[function(require,module,exports){
module.exports = "2"

},{}],18:[function(require,module,exports){
var version = require("./version")
var isVNode = require("./is-vnode")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")
var isVHook = require("./is-vhook")

module.exports = VirtualNode

var noProperties = {}
var noChildren = []

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName
    this.properties = properties || noProperties
    this.children = children || noChildren
    this.key = key != null ? String(key) : undefined
    this.namespace = (typeof namespace === "string") ? namespace : null

    var count = (children && children.length) || 0
    var descendants = 0
    var hasWidgets = false
    var hasThunks = false
    var descendantHooks = false
    var hooks

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName]
            if (isVHook(property) && property.unhook) {
                if (!hooks) {
                    hooks = {}
                }

                hooks[propName] = property
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i]
        if (isVNode(child)) {
            descendants += child.count || 0

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true
            }

            if (!hasThunks && child.hasThunks) {
                hasThunks = true
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true
            }
        } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true
            }
        } else if (!hasThunks && isThunk(child)) {
            hasThunks = true;
        }
    }

    this.count = count + descendants
    this.hasWidgets = hasWidgets
    this.hasThunks = hasThunks
    this.hooks = hooks
    this.descendantHooks = descendantHooks
}

VirtualNode.prototype.version = version
VirtualNode.prototype.type = "VirtualNode"

},{"./is-thunk":12,"./is-vhook":13,"./is-vnode":14,"./is-widget":16,"./version":17}],19:[function(require,module,exports){
var version = require("./version")

VirtualPatch.NONE = 0
VirtualPatch.VTEXT = 1
VirtualPatch.VNODE = 2
VirtualPatch.WIDGET = 3
VirtualPatch.PROPS = 4
VirtualPatch.ORDER = 5
VirtualPatch.INSERT = 6
VirtualPatch.REMOVE = 7
VirtualPatch.THUNK = 8

module.exports = VirtualPatch

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type)
    this.vNode = vNode
    this.patch = patch
}

VirtualPatch.prototype.version = version
VirtualPatch.prototype.type = "VirtualPatch"

},{"./version":17}],20:[function(require,module,exports){
var version = require("./version")

module.exports = VirtualText

function VirtualText(text) {
    this.text = String(text)
}

VirtualText.prototype.version = version
VirtualText.prototype.type = "VirtualText"

},{"./version":17}],21:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook")

module.exports = diffProps

function diffProps(a, b) {
    var diff

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {}
            diff[aKey] = undefined
        }

        var aValue = a[aKey]
        var bValue = b[aKey]

        if (aValue === bValue) {
            continue
        } else if (isObject(aValue) && isObject(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
                diff = diff || {}
                diff[aKey] = bValue
            } else if (isHook(bValue)) {
                 diff = diff || {}
                 diff[aKey] = bValue
            } else {
                var objectDiff = diffProps(aValue, bValue)
                if (objectDiff) {
                    diff = diff || {}
                    diff[aKey] = objectDiff
                }
            }
        } else {
            diff = diff || {}
            diff[aKey] = bValue
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {}
            diff[bKey] = b[bKey]
        }
    }

    return diff
}

function getPrototype(value) {
  if (Object.getPrototypeOf) {
    return Object.getPrototypeOf(value)
  } else if (value.__proto__) {
    return value.__proto__
  } else if (value.constructor) {
    return value.constructor.prototype
  }
}

},{"../vnode/is-vhook":13,"is-object":3}],22:[function(require,module,exports){
var isArray = require("x-is-array")

var VPatch = require("../vnode/vpatch")
var isVNode = require("../vnode/is-vnode")
var isVText = require("../vnode/is-vtext")
var isWidget = require("../vnode/is-widget")
var isThunk = require("../vnode/is-thunk")
var handleThunk = require("../vnode/handle-thunk")

var diffProps = require("./diff-props")

module.exports = diff

function diff(a, b) {
    var patch = { a: a }
    walk(a, b, patch, 0)
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        return
    }

    var apply = patch[index]
    var applyClear = false

    if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index)
    } else if (b == null) {

        // If a is a widget we will add a remove patch for it
        // Otherwise any child widgets/hooks must be destroyed.
        // This prevents adding two remove patches for a widget.
        if (!isWidget(a)) {
            clearState(a, patch, index)
            apply = patch[index]
        }

        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties)
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch))
                }
                apply = diffChildren(a, b, patch, apply, index)
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
                applyClear = true
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
            applyClear = true
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
            applyClear = true
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
        }
    } else if (isWidget(b)) {
        if (!isWidget(a)) {
            applyClear = true
        }

        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))
    }

    if (apply) {
        patch[index] = apply
    }

    if (applyClear) {
        clearState(a, patch, index)
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children
    var orderedSet = reorder(aChildren, b.children)
    var bChildren = orderedSet.children

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i]
        var rightNode = bChildren[i]
        index += 1

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode))
            }
        } else {
            walk(leftNode, rightNode, patch, index)
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count
        }
    }

    if (orderedSet.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(
            VPatch.ORDER,
            a,
            orderedSet.moves
        ))
    }

    return apply
}

function clearState(vNode, patch, index) {
    // TODO: Make this a single walk, not two
    unhook(vNode, patch, index)
    destroyWidgets(vNode, patch, index)
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(VPatch.REMOVE, vNode, null)
            )
        }
    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
        var children = vNode.children
        var len = children.length
        for (var i = 0; i < len; i++) {
            var child = children[i]
            index += 1

            destroyWidgets(child, patch, index)

            if (isVNode(child) && child.count) {
                index += child.count
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b)
    var thunkPatch = diff(nodes.a, nodes.b)
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true
        }
    }

    return false
}

// Execute hooks when two nodes are identical
function unhook(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(
                    VPatch.PROPS,
                    vNode,
                    undefinedKeys(vNode.hooks)
                )
            )
        }

        if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children
            var len = children.length
            for (var i = 0; i < len; i++) {
                var child = children[i]
                index += 1

                unhook(child, patch, index)

                if (isVNode(child) && child.count) {
                    index += child.count
                }
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

function undefinedKeys(obj) {
    var result = {}

    for (var key in obj) {
        result[key] = undefined
    }

    return result
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {
    // O(M) time, O(M) memory
    var bChildIndex = keyIndex(bChildren)
    var bKeys = bChildIndex.keys
    var bFree = bChildIndex.free

    if (bFree.length === bChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(N) time, O(N) memory
    var aChildIndex = keyIndex(aChildren)
    var aKeys = aChildIndex.keys
    var aFree = aChildIndex.free

    if (aFree.length === aChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(MAX(N, M)) memory
    var newChildren = []

    var freeIndex = 0
    var freeCount = bFree.length
    var deletedItems = 0

    // Iterate through a and match a node in b
    // O(N) time,
    for (var i = 0 ; i < aChildren.length; i++) {
        var aItem = aChildren[i]
        var itemIndex

        if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
                // Match up the old keys
                itemIndex = bKeys[aItem.key]
                newChildren.push(bChildren[itemIndex])

            } else {
                // Remove old keyed items
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        } else {
            // Match the item in a with the next free item in b
            if (freeIndex < freeCount) {
                itemIndex = bFree[freeIndex++]
                newChildren.push(bChildren[itemIndex])
            } else {
                // There are no free items in b to match with
                // the free items in a, so the extra free nodes
                // are deleted.
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        }
    }

    var lastFreeIndex = freeIndex >= bFree.length ?
        bChildren.length :
        bFree[freeIndex]

    // Iterate through b and append any new keys
    // O(M) time
    for (var j = 0; j < bChildren.length; j++) {
        var newItem = bChildren[j]

        if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
                // Add any new keyed items
                // We are adding new items to the end and then sorting them
                // in place. In future we should insert new items in place.
                newChildren.push(newItem)
            }
        } else if (j >= lastFreeIndex) {
            // Add any leftover non-keyed items
            newChildren.push(newItem)
        }
    }

    var simulate = newChildren.slice()
    var simulateIndex = 0
    var removes = []
    var inserts = []
    var simulateItem

    for (var k = 0; k < bChildren.length;) {
        var wantedItem = bChildren[k]
        simulateItem = simulate[simulateIndex]

        // remove items
        while (simulateItem === null && simulate.length) {
            removes.push(remove(simulate, simulateIndex, null))
            simulateItem = simulate[simulateIndex]
        }

        if (!simulateItem || simulateItem.key !== wantedItem.key) {
            // if we need a key in this position...
            if (wantedItem.key) {
                if (simulateItem && simulateItem.key) {
                    // if an insert doesn't put this key in place, it needs to move
                    if (bKeys[simulateItem.key] !== k + 1) {
                        removes.push(remove(simulate, simulateIndex, simulateItem.key))
                        simulateItem = simulate[simulateIndex]
                        // if the remove didn't put the wanted item in place, we need to insert it
                        if (!simulateItem || simulateItem.key !== wantedItem.key) {
                            inserts.push({key: wantedItem.key, to: k})
                        }
                        // items are matching, so skip ahead
                        else {
                            simulateIndex++
                        }
                    }
                    else {
                        inserts.push({key: wantedItem.key, to: k})
                    }
                }
                else {
                    inserts.push({key: wantedItem.key, to: k})
                }
                k++
            }
            // a key in simulate has no matching wanted key, remove it
            else if (simulateItem && simulateItem.key) {
                removes.push(remove(simulate, simulateIndex, simulateItem.key))
            }
        }
        else {
            simulateIndex++
            k++
        }
    }

    // remove all the remaining nodes from simulate
    while(simulateIndex < simulate.length) {
        simulateItem = simulate[simulateIndex]
        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))
    }

    // If the only moves we have are deletes then we can just
    // let the delete patch remove these items.
    if (removes.length === deletedItems && !inserts.length) {
        return {
            children: newChildren,
            moves: null
        }
    }

    return {
        children: newChildren,
        moves: {
            removes: removes,
            inserts: inserts
        }
    }
}

function remove(arr, index, key) {
    arr.splice(index, 1)

    return {
        from: index,
        key: key
    }
}

function keyIndex(children) {
    var keys = {}
    var free = []
    var length = children.length

    for (var i = 0; i < length; i++) {
        var child = children[i]

        if (child.key) {
            keys[child.key] = i
        } else {
            free.push(i)
        }
    }

    return {
        keys: keys,     // A hash of key name to index
        free: free,     // An array of unkeyed item indices
    }
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray(apply)) {
            apply.push(patch)
        } else {
            apply = [apply, patch]
        }

        return apply
    } else {
        return patch
    }
}

},{"../vnode/handle-thunk":11,"../vnode/is-thunk":12,"../vnode/is-vnode":14,"../vnode/is-vtext":15,"../vnode/is-widget":16,"../vnode/vpatch":19,"./diff-props":21,"x-is-array":4}],23:[function(require,module,exports){
var VNode = require('virtual-dom/vnode/vnode');
var VText = require('virtual-dom/vnode/vtext');
var diff = require('virtual-dom/vtree/diff');
var patch = require('virtual-dom/vdom/patch');
var createElement = require('virtual-dom/vdom/create-element');
var isHook = require("virtual-dom/vnode/is-vhook");


Elm.Native.VirtualDom = {};
Elm.Native.VirtualDom.make = function(elm)
{
	elm.Native = elm.Native || {};
	elm.Native.VirtualDom = elm.Native.VirtualDom || {};
	if (elm.Native.VirtualDom.values)
	{
		return elm.Native.VirtualDom.values;
	}

	var Element = Elm.Native.Graphics.Element.make(elm);
	var Json = Elm.Native.Json.make(elm);
	var List = Elm.Native.List.make(elm);
	var Signal = Elm.Native.Signal.make(elm);
	var Utils = Elm.Native.Utils.make(elm);

	var ATTRIBUTE_KEY = 'UniqueNameThatOthersAreVeryUnlikelyToUse';



	// VIRTUAL DOM NODES


	function text(string)
	{
		return new VText(string);
	}

	function node(name)
	{
		return F2(function(propertyList, contents) {
			return makeNode(name, propertyList, contents);
		});
	}


	// BUILD VIRTUAL DOME NODES


	function makeNode(name, propertyList, contents)
	{
		var props = listToProperties(propertyList);

		var key, namespace;
		// support keys
		if (props.key !== undefined)
		{
			key = props.key;
			props.key = undefined;
		}

		// support namespace
		if (props.namespace !== undefined)
		{
			namespace = props.namespace;
			props.namespace = undefined;
		}

		// ensure that setting text of an input does not move the cursor
		var useSoftSet =
			(name === 'input' || name === 'textarea')
			&& props.value !== undefined
			&& !isHook(props.value);

		if (useSoftSet)
		{
			props.value = SoftSetHook(props.value);
		}

		return new VNode(name, props, List.toArray(contents), key, namespace);
	}

	function listToProperties(list)
	{
		var object = {};
		while (list.ctor !== '[]')
		{
			var entry = list._0;
			if (entry.key === ATTRIBUTE_KEY)
			{
				object.attributes = object.attributes || {};
				object.attributes[entry.value.attrKey] = entry.value.attrValue;
			}
			else
			{
				object[entry.key] = entry.value;
			}
			list = list._1;
		}
		return object;
	}



	// PROPERTIES AND ATTRIBUTES


	function property(key, value)
	{
		return {
			key: key,
			value: value
		};
	}

	function attribute(key, value)
	{
		return {
			key: ATTRIBUTE_KEY,
			value: {
				attrKey: key,
				attrValue: value
			}
		};
	}



	// NAMESPACED ATTRIBUTES


	function attributeNS(namespace, key, value)
	{
		return {
			key: key,
			value: new AttributeHook(namespace, key, value)
		};
	}

	function AttributeHook(namespace, key, value)
	{
		if (!(this instanceof AttributeHook))
		{
			return new AttributeHook(namespace, key, value);
		}

		this.namespace = namespace;
		this.key = key;
		this.value = value;
	}

	AttributeHook.prototype.hook = function (node, prop, prev)
	{
		if (prev
			&& prev.type === 'AttributeHook'
			&& prev.value === this.value
			&& prev.namespace === this.namespace)
		{
			return;
		}

		node.setAttributeNS(this.namespace, prop, this.value);
	};

	AttributeHook.prototype.unhook = function (node, prop, next)
	{
		if (next
			&& next.type === 'AttributeHook'
			&& next.namespace === this.namespace)
		{
			return;
		}

		node.removeAttributeNS(this.namespace, this.key);
	};

	AttributeHook.prototype.type = 'AttributeHook';



	// EVENTS


	function on(name, options, decoder, createMessage)
	{
		function eventHandler(event)
		{
			var value = A2(Json.runDecoderValue, decoder, event);
			if (value.ctor === 'Ok')
			{
				if (options.stopPropagation)
				{
					event.stopPropagation();
				}
				if (options.preventDefault)
				{
					event.preventDefault();
				}
				Signal.sendMessage(createMessage(value._0));
			}
		}
		return property('on' + name, eventHandler);
	}

	function SoftSetHook(value)
	{
		if (!(this instanceof SoftSetHook))
		{
			return new SoftSetHook(value);
		}

		this.value = value;
	}

	SoftSetHook.prototype.hook = function (node, propertyName)
	{
		if (node[propertyName] !== this.value)
		{
			node[propertyName] = this.value;
		}
	};



	// INTEGRATION WITH ELEMENTS


	function ElementWidget(element)
	{
		this.element = element;
	}

	ElementWidget.prototype.type = "Widget";

	ElementWidget.prototype.init = function init()
	{
		return Element.render(this.element);
	};

	ElementWidget.prototype.update = function update(previous, node)
	{
		return Element.update(node, previous.element, this.element);
	};

	function fromElement(element)
	{
		return new ElementWidget(element);
	}

	function toElement(width, height, html)
	{
		return A3(Element.newElement, width, height, {
			ctor: 'Custom',
			type: 'evancz/elm-html',
			render: render,
			update: update,
			model: html
		});
	}



	// RENDER AND UPDATE


	function render(model)
	{
		var element = Element.createNode('div');
		element.appendChild(createElement(model));
		return element;
	}

	function update(node, oldModel, newModel)
	{
		updateAndReplace(node.firstChild, oldModel, newModel);
		return node;
	}

	function updateAndReplace(node, oldModel, newModel)
	{
		var patches = diff(oldModel, newModel);
		var newNode = patch(node, patches);
		return newNode;
	}



	// LAZINESS


	function lazyRef(fn, a)
	{
		function thunk()
		{
			return fn(a);
		}
		return new Thunk(fn, [a], thunk);
	}

	function lazyRef2(fn, a, b)
	{
		function thunk()
		{
			return A2(fn, a, b);
		}
		return new Thunk(fn, [a,b], thunk);
	}

	function lazyRef3(fn, a, b, c)
	{
		function thunk()
		{
			return A3(fn, a, b, c);
		}
		return new Thunk(fn, [a,b,c], thunk);
	}

	function Thunk(fn, args, thunk)
	{
		/* public (used by VirtualDom.js) */
		this.vnode = null;
		this.key = undefined;

		/* private */
		this.fn = fn;
		this.args = args;
		this.thunk = thunk;
	}

	Thunk.prototype.type = "Thunk";
	Thunk.prototype.render = renderThunk;

	function shouldUpdate(current, previous)
	{
		if (current.fn !== previous.fn)
		{
			return true;
		}

		// if it's the same function, we know the number of args must match
		var cargs = current.args;
		var pargs = previous.args;

		for (var i = cargs.length; i--; )
		{
			if (cargs[i] !== pargs[i])
			{
				return true;
			}
		}

		return false;
	}

	function renderThunk(previous)
	{
		if (previous == null || shouldUpdate(this, previous))
		{
			return this.thunk();
		}
		else
		{
			return previous.vnode;
		}
	}


	return elm.Native.VirtualDom.values = Elm.Native.VirtualDom.values = {
		node: node,
		text: text,
		on: F4(on),

		property: F2(property),
		attribute: F2(attribute),
		attributeNS: F3(attributeNS),

		lazy: F2(lazyRef),
		lazy2: F3(lazyRef2),
		lazy3: F4(lazyRef3),

		toElement: F3(toElement),
		fromElement: fromElement,

		render: createElement,
		updateAndReplace: updateAndReplace
	};
};

},{"virtual-dom/vdom/create-element":6,"virtual-dom/vdom/patch":9,"virtual-dom/vnode/is-vhook":13,"virtual-dom/vnode/vnode":18,"virtual-dom/vnode/vtext":20,"virtual-dom/vtree/diff":22}]},{},[23]);

Elm.VirtualDom = Elm.VirtualDom || {};
Elm.VirtualDom.make = function (_elm) {
   "use strict";
   _elm.VirtualDom = _elm.VirtualDom || {};
   if (_elm.VirtualDom.values) return _elm.VirtualDom.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $Json$Decode = Elm.Json.Decode.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$VirtualDom = Elm.Native.VirtualDom.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var lazy3 = $Native$VirtualDom.lazy3;
   var lazy2 = $Native$VirtualDom.lazy2;
   var lazy = $Native$VirtualDom.lazy;
   var defaultOptions = {stopPropagation: false,preventDefault: false};
   var Options = F2(function (a,b) {    return {stopPropagation: a,preventDefault: b};});
   var onWithOptions = $Native$VirtualDom.on;
   var on = F3(function (eventName,decoder,toMessage) {    return A4($Native$VirtualDom.on,eventName,defaultOptions,decoder,toMessage);});
   var attributeNS = $Native$VirtualDom.attributeNS;
   var attribute = $Native$VirtualDom.attribute;
   var property = $Native$VirtualDom.property;
   var Property = {ctor: "Property"};
   var fromElement = $Native$VirtualDom.fromElement;
   var toElement = $Native$VirtualDom.toElement;
   var text = $Native$VirtualDom.text;
   var node = $Native$VirtualDom.node;
   var Node = {ctor: "Node"};
   return _elm.VirtualDom.values = {_op: _op
                                   ,text: text
                                   ,node: node
                                   ,toElement: toElement
                                   ,fromElement: fromElement
                                   ,property: property
                                   ,attribute: attribute
                                   ,attributeNS: attributeNS
                                   ,on: on
                                   ,onWithOptions: onWithOptions
                                   ,defaultOptions: defaultOptions
                                   ,lazy: lazy
                                   ,lazy2: lazy2
                                   ,lazy3: lazy3
                                   ,Options: Options};
};
Elm.Html = Elm.Html || {};
Elm.Html.make = function (_elm) {
   "use strict";
   _elm.Html = _elm.Html || {};
   if (_elm.Html.values) return _elm.Html.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var fromElement = $VirtualDom.fromElement;
   var toElement = $VirtualDom.toElement;
   var text = $VirtualDom.text;
   var node = $VirtualDom.node;
   var body = node("body");
   var section = node("section");
   var nav = node("nav");
   var article = node("article");
   var aside = node("aside");
   var h1 = node("h1");
   var h2 = node("h2");
   var h3 = node("h3");
   var h4 = node("h4");
   var h5 = node("h5");
   var h6 = node("h6");
   var header = node("header");
   var footer = node("footer");
   var address = node("address");
   var main$ = node("main");
   var p = node("p");
   var hr = node("hr");
   var pre = node("pre");
   var blockquote = node("blockquote");
   var ol = node("ol");
   var ul = node("ul");
   var li = node("li");
   var dl = node("dl");
   var dt = node("dt");
   var dd = node("dd");
   var figure = node("figure");
   var figcaption = node("figcaption");
   var div = node("div");
   var a = node("a");
   var em = node("em");
   var strong = node("strong");
   var small = node("small");
   var s = node("s");
   var cite = node("cite");
   var q = node("q");
   var dfn = node("dfn");
   var abbr = node("abbr");
   var time = node("time");
   var code = node("code");
   var $var = node("var");
   var samp = node("samp");
   var kbd = node("kbd");
   var sub = node("sub");
   var sup = node("sup");
   var i = node("i");
   var b = node("b");
   var u = node("u");
   var mark = node("mark");
   var ruby = node("ruby");
   var rt = node("rt");
   var rp = node("rp");
   var bdi = node("bdi");
   var bdo = node("bdo");
   var span = node("span");
   var br = node("br");
   var wbr = node("wbr");
   var ins = node("ins");
   var del = node("del");
   var img = node("img");
   var iframe = node("iframe");
   var embed = node("embed");
   var object = node("object");
   var param = node("param");
   var video = node("video");
   var audio = node("audio");
   var source = node("source");
   var track = node("track");
   var canvas = node("canvas");
   var svg = node("svg");
   var math = node("math");
   var table = node("table");
   var caption = node("caption");
   var colgroup = node("colgroup");
   var col = node("col");
   var tbody = node("tbody");
   var thead = node("thead");
   var tfoot = node("tfoot");
   var tr = node("tr");
   var td = node("td");
   var th = node("th");
   var form = node("form");
   var fieldset = node("fieldset");
   var legend = node("legend");
   var label = node("label");
   var input = node("input");
   var button = node("button");
   var select = node("select");
   var datalist = node("datalist");
   var optgroup = node("optgroup");
   var option = node("option");
   var textarea = node("textarea");
   var keygen = node("keygen");
   var output = node("output");
   var progress = node("progress");
   var meter = node("meter");
   var details = node("details");
   var summary = node("summary");
   var menuitem = node("menuitem");
   var menu = node("menu");
   return _elm.Html.values = {_op: _op
                             ,node: node
                             ,text: text
                             ,toElement: toElement
                             ,fromElement: fromElement
                             ,body: body
                             ,section: section
                             ,nav: nav
                             ,article: article
                             ,aside: aside
                             ,h1: h1
                             ,h2: h2
                             ,h3: h3
                             ,h4: h4
                             ,h5: h5
                             ,h6: h6
                             ,header: header
                             ,footer: footer
                             ,address: address
                             ,main$: main$
                             ,p: p
                             ,hr: hr
                             ,pre: pre
                             ,blockquote: blockquote
                             ,ol: ol
                             ,ul: ul
                             ,li: li
                             ,dl: dl
                             ,dt: dt
                             ,dd: dd
                             ,figure: figure
                             ,figcaption: figcaption
                             ,div: div
                             ,a: a
                             ,em: em
                             ,strong: strong
                             ,small: small
                             ,s: s
                             ,cite: cite
                             ,q: q
                             ,dfn: dfn
                             ,abbr: abbr
                             ,time: time
                             ,code: code
                             ,$var: $var
                             ,samp: samp
                             ,kbd: kbd
                             ,sub: sub
                             ,sup: sup
                             ,i: i
                             ,b: b
                             ,u: u
                             ,mark: mark
                             ,ruby: ruby
                             ,rt: rt
                             ,rp: rp
                             ,bdi: bdi
                             ,bdo: bdo
                             ,span: span
                             ,br: br
                             ,wbr: wbr
                             ,ins: ins
                             ,del: del
                             ,img: img
                             ,iframe: iframe
                             ,embed: embed
                             ,object: object
                             ,param: param
                             ,video: video
                             ,audio: audio
                             ,source: source
                             ,track: track
                             ,canvas: canvas
                             ,svg: svg
                             ,math: math
                             ,table: table
                             ,caption: caption
                             ,colgroup: colgroup
                             ,col: col
                             ,tbody: tbody
                             ,thead: thead
                             ,tfoot: tfoot
                             ,tr: tr
                             ,td: td
                             ,th: th
                             ,form: form
                             ,fieldset: fieldset
                             ,legend: legend
                             ,label: label
                             ,input: input
                             ,button: button
                             ,select: select
                             ,datalist: datalist
                             ,optgroup: optgroup
                             ,option: option
                             ,textarea: textarea
                             ,keygen: keygen
                             ,output: output
                             ,progress: progress
                             ,meter: meter
                             ,details: details
                             ,summary: summary
                             ,menuitem: menuitem
                             ,menu: menu};
};
Elm.Html = Elm.Html || {};
Elm.Html.Attributes = Elm.Html.Attributes || {};
Elm.Html.Attributes.make = function (_elm) {
   "use strict";
   _elm.Html = _elm.Html || {};
   _elm.Html.Attributes = _elm.Html.Attributes || {};
   if (_elm.Html.Attributes.values) return _elm.Html.Attributes.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Html = Elm.Html.make(_elm),
   $Json$Encode = Elm.Json.Encode.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var attribute = $VirtualDom.attribute;
   var contextmenu = function (value) {    return A2(attribute,"contextmenu",value);};
   var property = $VirtualDom.property;
   var stringProperty = F2(function (name,string) {    return A2(property,name,$Json$Encode.string(string));});
   var $class = function (name) {    return A2(stringProperty,"className",name);};
   var id = function (name) {    return A2(stringProperty,"id",name);};
   var title = function (name) {    return A2(stringProperty,"title",name);};
   var accesskey = function ($char) {    return A2(stringProperty,"accessKey",$String.fromChar($char));};
   var dir = function (value) {    return A2(stringProperty,"dir",value);};
   var draggable = function (value) {    return A2(stringProperty,"draggable",value);};
   var dropzone = function (value) {    return A2(stringProperty,"dropzone",value);};
   var itemprop = function (value) {    return A2(stringProperty,"itemprop",value);};
   var lang = function (value) {    return A2(stringProperty,"lang",value);};
   var tabindex = function (n) {    return A2(stringProperty,"tabIndex",$Basics.toString(n));};
   var charset = function (value) {    return A2(stringProperty,"charset",value);};
   var content = function (value) {    return A2(stringProperty,"content",value);};
   var httpEquiv = function (value) {    return A2(stringProperty,"httpEquiv",value);};
   var language = function (value) {    return A2(stringProperty,"language",value);};
   var src = function (value) {    return A2(stringProperty,"src",value);};
   var height = function (value) {    return A2(stringProperty,"height",$Basics.toString(value));};
   var width = function (value) {    return A2(stringProperty,"width",$Basics.toString(value));};
   var alt = function (value) {    return A2(stringProperty,"alt",value);};
   var preload = function (value) {    return A2(stringProperty,"preload",value);};
   var poster = function (value) {    return A2(stringProperty,"poster",value);};
   var kind = function (value) {    return A2(stringProperty,"kind",value);};
   var srclang = function (value) {    return A2(stringProperty,"srclang",value);};
   var sandbox = function (value) {    return A2(stringProperty,"sandbox",value);};
   var srcdoc = function (value) {    return A2(stringProperty,"srcdoc",value);};
   var type$ = function (value) {    return A2(stringProperty,"type",value);};
   var value = function (value) {    return A2(stringProperty,"value",value);};
   var placeholder = function (value) {    return A2(stringProperty,"placeholder",value);};
   var accept = function (value) {    return A2(stringProperty,"accept",value);};
   var acceptCharset = function (value) {    return A2(stringProperty,"acceptCharset",value);};
   var action = function (value) {    return A2(stringProperty,"action",value);};
   var autocomplete = function (bool) {    return A2(stringProperty,"autocomplete",bool ? "on" : "off");};
   var autosave = function (value) {    return A2(stringProperty,"autosave",value);};
   var enctype = function (value) {    return A2(stringProperty,"enctype",value);};
   var formaction = function (value) {    return A2(stringProperty,"formAction",value);};
   var list = function (value) {    return A2(stringProperty,"list",value);};
   var minlength = function (n) {    return A2(stringProperty,"minLength",$Basics.toString(n));};
   var maxlength = function (n) {    return A2(stringProperty,"maxLength",$Basics.toString(n));};
   var method = function (value) {    return A2(stringProperty,"method",value);};
   var name = function (value) {    return A2(stringProperty,"name",value);};
   var pattern = function (value) {    return A2(stringProperty,"pattern",value);};
   var size = function (n) {    return A2(stringProperty,"size",$Basics.toString(n));};
   var $for = function (value) {    return A2(stringProperty,"htmlFor",value);};
   var form = function (value) {    return A2(stringProperty,"form",value);};
   var max = function (value) {    return A2(stringProperty,"max",value);};
   var min = function (value) {    return A2(stringProperty,"min",value);};
   var step = function (n) {    return A2(stringProperty,"step",n);};
   var cols = function (n) {    return A2(stringProperty,"cols",$Basics.toString(n));};
   var rows = function (n) {    return A2(stringProperty,"rows",$Basics.toString(n));};
   var wrap = function (value) {    return A2(stringProperty,"wrap",value);};
   var usemap = function (value) {    return A2(stringProperty,"useMap",value);};
   var shape = function (value) {    return A2(stringProperty,"shape",value);};
   var coords = function (value) {    return A2(stringProperty,"coords",value);};
   var challenge = function (value) {    return A2(stringProperty,"challenge",value);};
   var keytype = function (value) {    return A2(stringProperty,"keytype",value);};
   var align = function (value) {    return A2(stringProperty,"align",value);};
   var cite = function (value) {    return A2(stringProperty,"cite",value);};
   var href = function (value) {    return A2(stringProperty,"href",value);};
   var target = function (value) {    return A2(stringProperty,"target",value);};
   var downloadAs = function (value) {    return A2(stringProperty,"download",value);};
   var hreflang = function (value) {    return A2(stringProperty,"hreflang",value);};
   var media = function (value) {    return A2(stringProperty,"media",value);};
   var ping = function (value) {    return A2(stringProperty,"ping",value);};
   var rel = function (value) {    return A2(stringProperty,"rel",value);};
   var datetime = function (value) {    return A2(stringProperty,"datetime",value);};
   var pubdate = function (value) {    return A2(stringProperty,"pubdate",value);};
   var start = function (n) {    return A2(stringProperty,"start",$Basics.toString(n));};
   var colspan = function (n) {    return A2(stringProperty,"colSpan",$Basics.toString(n));};
   var headers = function (value) {    return A2(stringProperty,"headers",value);};
   var rowspan = function (n) {    return A2(stringProperty,"rowSpan",$Basics.toString(n));};
   var scope = function (value) {    return A2(stringProperty,"scope",value);};
   var manifest = function (value) {    return A2(stringProperty,"manifest",value);};
   var boolProperty = F2(function (name,bool) {    return A2(property,name,$Json$Encode.bool(bool));});
   var hidden = function (bool) {    return A2(boolProperty,"hidden",bool);};
   var contenteditable = function (bool) {    return A2(boolProperty,"contentEditable",bool);};
   var spellcheck = function (bool) {    return A2(boolProperty,"spellcheck",bool);};
   var async = function (bool) {    return A2(boolProperty,"async",bool);};
   var defer = function (bool) {    return A2(boolProperty,"defer",bool);};
   var scoped = function (bool) {    return A2(boolProperty,"scoped",bool);};
   var autoplay = function (bool) {    return A2(boolProperty,"autoplay",bool);};
   var controls = function (bool) {    return A2(boolProperty,"controls",bool);};
   var loop = function (bool) {    return A2(boolProperty,"loop",bool);};
   var $default = function (bool) {    return A2(boolProperty,"default",bool);};
   var seamless = function (bool) {    return A2(boolProperty,"seamless",bool);};
   var checked = function (bool) {    return A2(boolProperty,"checked",bool);};
   var selected = function (bool) {    return A2(boolProperty,"selected",bool);};
   var autofocus = function (bool) {    return A2(boolProperty,"autofocus",bool);};
   var disabled = function (bool) {    return A2(boolProperty,"disabled",bool);};
   var multiple = function (bool) {    return A2(boolProperty,"multiple",bool);};
   var novalidate = function (bool) {    return A2(boolProperty,"noValidate",bool);};
   var readonly = function (bool) {    return A2(boolProperty,"readOnly",bool);};
   var required = function (bool) {    return A2(boolProperty,"required",bool);};
   var ismap = function (value) {    return A2(boolProperty,"isMap",value);};
   var download = function (bool) {    return A2(boolProperty,"download",bool);};
   var reversed = function (bool) {    return A2(boolProperty,"reversed",bool);};
   var classList = function (list) {    return $class(A2($String.join," ",A2($List.map,$Basics.fst,A2($List.filter,$Basics.snd,list))));};
   var style = function (props) {
      return A2(property,
      "style",
      $Json$Encode.object(A2($List.map,function (_p0) {    var _p1 = _p0;return {ctor: "_Tuple2",_0: _p1._0,_1: $Json$Encode.string(_p1._1)};},props)));
   };
   var key = function (k) {    return A2(stringProperty,"key",k);};
   return _elm.Html.Attributes.values = {_op: _op
                                        ,key: key
                                        ,style: style
                                        ,$class: $class
                                        ,classList: classList
                                        ,id: id
                                        ,title: title
                                        ,hidden: hidden
                                        ,type$: type$
                                        ,value: value
                                        ,checked: checked
                                        ,placeholder: placeholder
                                        ,selected: selected
                                        ,accept: accept
                                        ,acceptCharset: acceptCharset
                                        ,action: action
                                        ,autocomplete: autocomplete
                                        ,autofocus: autofocus
                                        ,autosave: autosave
                                        ,disabled: disabled
                                        ,enctype: enctype
                                        ,formaction: formaction
                                        ,list: list
                                        ,maxlength: maxlength
                                        ,minlength: minlength
                                        ,method: method
                                        ,multiple: multiple
                                        ,name: name
                                        ,novalidate: novalidate
                                        ,pattern: pattern
                                        ,readonly: readonly
                                        ,required: required
                                        ,size: size
                                        ,$for: $for
                                        ,form: form
                                        ,max: max
                                        ,min: min
                                        ,step: step
                                        ,cols: cols
                                        ,rows: rows
                                        ,wrap: wrap
                                        ,href: href
                                        ,target: target
                                        ,download: download
                                        ,downloadAs: downloadAs
                                        ,hreflang: hreflang
                                        ,media: media
                                        ,ping: ping
                                        ,rel: rel
                                        ,ismap: ismap
                                        ,usemap: usemap
                                        ,shape: shape
                                        ,coords: coords
                                        ,src: src
                                        ,height: height
                                        ,width: width
                                        ,alt: alt
                                        ,autoplay: autoplay
                                        ,controls: controls
                                        ,loop: loop
                                        ,preload: preload
                                        ,poster: poster
                                        ,$default: $default
                                        ,kind: kind
                                        ,srclang: srclang
                                        ,sandbox: sandbox
                                        ,seamless: seamless
                                        ,srcdoc: srcdoc
                                        ,reversed: reversed
                                        ,start: start
                                        ,align: align
                                        ,colspan: colspan
                                        ,rowspan: rowspan
                                        ,headers: headers
                                        ,scope: scope
                                        ,async: async
                                        ,charset: charset
                                        ,content: content
                                        ,defer: defer
                                        ,httpEquiv: httpEquiv
                                        ,language: language
                                        ,scoped: scoped
                                        ,accesskey: accesskey
                                        ,contenteditable: contenteditable
                                        ,contextmenu: contextmenu
                                        ,dir: dir
                                        ,draggable: draggable
                                        ,dropzone: dropzone
                                        ,itemprop: itemprop
                                        ,lang: lang
                                        ,spellcheck: spellcheck
                                        ,tabindex: tabindex
                                        ,challenge: challenge
                                        ,keytype: keytype
                                        ,cite: cite
                                        ,datetime: datetime
                                        ,pubdate: pubdate
                                        ,manifest: manifest
                                        ,property: property
                                        ,attribute: attribute};
};
Elm.Html = Elm.Html || {};
Elm.Html.Events = Elm.Html.Events || {};
Elm.Html.Events.make = function (_elm) {
   "use strict";
   _elm.Html = _elm.Html || {};
   _elm.Html.Events = _elm.Html.Events || {};
   if (_elm.Html.Events.values) return _elm.Html.Events.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Html = Elm.Html.make(_elm),
   $Json$Decode = Elm.Json.Decode.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var keyCode = A2($Json$Decode._op[":="],"keyCode",$Json$Decode.$int);
   var targetChecked = A2($Json$Decode.at,_U.list(["target","checked"]),$Json$Decode.bool);
   var targetValue = A2($Json$Decode.at,_U.list(["target","value"]),$Json$Decode.string);
   var defaultOptions = $VirtualDom.defaultOptions;
   var Options = F2(function (a,b) {    return {stopPropagation: a,preventDefault: b};});
   var onWithOptions = $VirtualDom.onWithOptions;
   var on = $VirtualDom.on;
   var messageOn = F3(function (name,addr,msg) {    return A3(on,name,$Json$Decode.value,function (_p0) {    return A2($Signal.message,addr,msg);});});
   var onClick = messageOn("click");
   var onDoubleClick = messageOn("dblclick");
   var onMouseMove = messageOn("mousemove");
   var onMouseDown = messageOn("mousedown");
   var onMouseUp = messageOn("mouseup");
   var onMouseEnter = messageOn("mouseenter");
   var onMouseLeave = messageOn("mouseleave");
   var onMouseOver = messageOn("mouseover");
   var onMouseOut = messageOn("mouseout");
   var onBlur = messageOn("blur");
   var onFocus = messageOn("focus");
   var onSubmit = messageOn("submit");
   var onKey = F3(function (name,addr,handler) {    return A3(on,name,keyCode,function (code) {    return A2($Signal.message,addr,handler(code));});});
   var onKeyUp = onKey("keyup");
   var onKeyDown = onKey("keydown");
   var onKeyPress = onKey("keypress");
   return _elm.Html.Events.values = {_op: _op
                                    ,onBlur: onBlur
                                    ,onFocus: onFocus
                                    ,onSubmit: onSubmit
                                    ,onKeyUp: onKeyUp
                                    ,onKeyDown: onKeyDown
                                    ,onKeyPress: onKeyPress
                                    ,onClick: onClick
                                    ,onDoubleClick: onDoubleClick
                                    ,onMouseMove: onMouseMove
                                    ,onMouseDown: onMouseDown
                                    ,onMouseUp: onMouseUp
                                    ,onMouseEnter: onMouseEnter
                                    ,onMouseLeave: onMouseLeave
                                    ,onMouseOver: onMouseOver
                                    ,onMouseOut: onMouseOut
                                    ,on: on
                                    ,onWithOptions: onWithOptions
                                    ,defaultOptions: defaultOptions
                                    ,targetValue: targetValue
                                    ,targetChecked: targetChecked
                                    ,keyCode: keyCode
                                    ,Options: Options};
};
Elm.Html = Elm.Html || {};
Elm.Html.Lazy = Elm.Html.Lazy || {};
Elm.Html.Lazy.make = function (_elm) {
   "use strict";
   _elm.Html = _elm.Html || {};
   _elm.Html.Lazy = _elm.Html.Lazy || {};
   if (_elm.Html.Lazy.values) return _elm.Html.Lazy.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Html = Elm.Html.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var lazy3 = $VirtualDom.lazy3;
   var lazy2 = $VirtualDom.lazy2;
   var lazy = $VirtualDom.lazy;
   return _elm.Html.Lazy.values = {_op: _op,lazy: lazy,lazy2: lazy2,lazy3: lazy3};
};
Elm.Svg = Elm.Svg || {};
Elm.Svg.make = function (_elm) {
   "use strict";
   _elm.Svg = _elm.Svg || {};
   if (_elm.Svg.values) return _elm.Svg.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Html = Elm.Html.make(_elm),
   $Json$Encode = Elm.Json.Encode.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var text = $VirtualDom.text;
   var svgNamespace = A2($VirtualDom.property,"namespace",$Json$Encode.string("http://www.w3.org/2000/svg"));
   var node = F3(function (name,attributes,children) {    return A3($VirtualDom.node,name,A2($List._op["::"],svgNamespace,attributes),children);});
   var svg = node("svg");
   var foreignObject = node("foreignObject");
   var animate = node("animate");
   var animateColor = node("animateColor");
   var animateMotion = node("animateMotion");
   var animateTransform = node("animateTransform");
   var mpath = node("mpath");
   var set = node("set");
   var a = node("a");
   var defs = node("defs");
   var g = node("g");
   var marker = node("marker");
   var mask = node("mask");
   var missingGlyph = node("missingGlyph");
   var pattern = node("pattern");
   var $switch = node("switch");
   var symbol = node("symbol");
   var desc = node("desc");
   var metadata = node("metadata");
   var title = node("title");
   var feBlend = node("feBlend");
   var feColorMatrix = node("feColorMatrix");
   var feComponentTransfer = node("feComponentTransfer");
   var feComposite = node("feComposite");
   var feConvolveMatrix = node("feConvolveMatrix");
   var feDiffuseLighting = node("feDiffuseLighting");
   var feDisplacementMap = node("feDisplacementMap");
   var feFlood = node("feFlood");
   var feFuncA = node("feFuncA");
   var feFuncB = node("feFuncB");
   var feFuncG = node("feFuncG");
   var feFuncR = node("feFuncR");
   var feGaussianBlur = node("feGaussianBlur");
   var feImage = node("feImage");
   var feMerge = node("feMerge");
   var feMergeNode = node("feMergeNode");
   var feMorphology = node("feMorphology");
   var feOffset = node("feOffset");
   var feSpecularLighting = node("feSpecularLighting");
   var feTile = node("feTile");
   var feTurbulence = node("feTurbulence");
   var font = node("font");
   var fontFace = node("fontFace");
   var fontFaceFormat = node("fontFaceFormat");
   var fontFaceName = node("fontFaceName");
   var fontFaceSrc = node("fontFaceSrc");
   var fontFaceUri = node("fontFaceUri");
   var hkern = node("hkern");
   var vkern = node("vkern");
   var linearGradient = node("linearGradient");
   var radialGradient = node("radialGradient");
   var stop = node("stop");
   var circle = node("circle");
   var ellipse = node("ellipse");
   var image = node("image");
   var line = node("line");
   var path = node("path");
   var polygon = node("polygon");
   var polyline = node("polyline");
   var rect = node("rect");
   var use = node("use");
   var feDistantLight = node("feDistantLight");
   var fePointLight = node("fePointLight");
   var feSpotLight = node("feSpotLight");
   var altGlyph = node("altGlyph");
   var altGlyphDef = node("altGlyphDef");
   var altGlyphItem = node("altGlyphItem");
   var glyph = node("glyph");
   var glyphRef = node("glyphRef");
   var textPath = node("textPath");
   var text$ = node("text");
   var tref = node("tref");
   var tspan = node("tspan");
   var clipPath = node("clipPath");
   var colorProfile = node("colorProfile");
   var cursor = node("cursor");
   var filter = node("filter");
   var script = node("script");
   var style = node("style");
   var view = node("view");
   return _elm.Svg.values = {_op: _op
                            ,text: text
                            ,node: node
                            ,svg: svg
                            ,foreignObject: foreignObject
                            ,circle: circle
                            ,ellipse: ellipse
                            ,image: image
                            ,line: line
                            ,path: path
                            ,polygon: polygon
                            ,polyline: polyline
                            ,rect: rect
                            ,use: use
                            ,animate: animate
                            ,animateColor: animateColor
                            ,animateMotion: animateMotion
                            ,animateTransform: animateTransform
                            ,mpath: mpath
                            ,set: set
                            ,desc: desc
                            ,metadata: metadata
                            ,title: title
                            ,a: a
                            ,defs: defs
                            ,g: g
                            ,marker: marker
                            ,mask: mask
                            ,missingGlyph: missingGlyph
                            ,pattern: pattern
                            ,$switch: $switch
                            ,symbol: symbol
                            ,altGlyph: altGlyph
                            ,altGlyphDef: altGlyphDef
                            ,altGlyphItem: altGlyphItem
                            ,glyph: glyph
                            ,glyphRef: glyphRef
                            ,textPath: textPath
                            ,text$: text$
                            ,tref: tref
                            ,tspan: tspan
                            ,font: font
                            ,fontFace: fontFace
                            ,fontFaceFormat: fontFaceFormat
                            ,fontFaceName: fontFaceName
                            ,fontFaceSrc: fontFaceSrc
                            ,fontFaceUri: fontFaceUri
                            ,hkern: hkern
                            ,vkern: vkern
                            ,linearGradient: linearGradient
                            ,radialGradient: radialGradient
                            ,stop: stop
                            ,feBlend: feBlend
                            ,feColorMatrix: feColorMatrix
                            ,feComponentTransfer: feComponentTransfer
                            ,feComposite: feComposite
                            ,feConvolveMatrix: feConvolveMatrix
                            ,feDiffuseLighting: feDiffuseLighting
                            ,feDisplacementMap: feDisplacementMap
                            ,feFlood: feFlood
                            ,feFuncA: feFuncA
                            ,feFuncB: feFuncB
                            ,feFuncG: feFuncG
                            ,feFuncR: feFuncR
                            ,feGaussianBlur: feGaussianBlur
                            ,feImage: feImage
                            ,feMerge: feMerge
                            ,feMergeNode: feMergeNode
                            ,feMorphology: feMorphology
                            ,feOffset: feOffset
                            ,feSpecularLighting: feSpecularLighting
                            ,feTile: feTile
                            ,feTurbulence: feTurbulence
                            ,feDistantLight: feDistantLight
                            ,fePointLight: fePointLight
                            ,feSpotLight: feSpotLight
                            ,clipPath: clipPath
                            ,colorProfile: colorProfile
                            ,cursor: cursor
                            ,filter: filter
                            ,script: script
                            ,style: style
                            ,view: view};
};
Elm.Svg = Elm.Svg || {};
Elm.Svg.Attributes = Elm.Svg.Attributes || {};
Elm.Svg.Attributes.make = function (_elm) {
   "use strict";
   _elm.Svg = _elm.Svg || {};
   _elm.Svg.Attributes = _elm.Svg.Attributes || {};
   if (_elm.Svg.Attributes.values) return _elm.Svg.Attributes.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Svg = Elm.Svg.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var writingMode = $VirtualDom.attribute("writing-mode");
   var wordSpacing = $VirtualDom.attribute("word-spacing");
   var visibility = $VirtualDom.attribute("visibility");
   var unicodeBidi = $VirtualDom.attribute("unicode-bidi");
   var textRendering = $VirtualDom.attribute("text-rendering");
   var textDecoration = $VirtualDom.attribute("text-decoration");
   var textAnchor = $VirtualDom.attribute("text-anchor");
   var stroke = $VirtualDom.attribute("stroke");
   var strokeWidth = $VirtualDom.attribute("stroke-width");
   var strokeOpacity = $VirtualDom.attribute("stroke-opacity");
   var strokeMiterlimit = $VirtualDom.attribute("stroke-miterlimit");
   var strokeLinejoin = $VirtualDom.attribute("stroke-linejoin");
   var strokeLinecap = $VirtualDom.attribute("stroke-linecap");
   var strokeDashoffset = $VirtualDom.attribute("stroke-dashoffset");
   var strokeDasharray = $VirtualDom.attribute("stroke-dasharray");
   var stopOpacity = $VirtualDom.attribute("stop-opacity");
   var stopColor = $VirtualDom.attribute("stop-color");
   var shapeRendering = $VirtualDom.attribute("shape-rendering");
   var pointerEvents = $VirtualDom.attribute("pointer-events");
   var overflow = $VirtualDom.attribute("overflow");
   var opacity = $VirtualDom.attribute("opacity");
   var mask = $VirtualDom.attribute("mask");
   var markerStart = $VirtualDom.attribute("marker-start");
   var markerMid = $VirtualDom.attribute("marker-mid");
   var markerEnd = $VirtualDom.attribute("marker-end");
   var lightingColor = $VirtualDom.attribute("lighting-color");
   var letterSpacing = $VirtualDom.attribute("letter-spacing");
   var kerning = $VirtualDom.attribute("kerning");
   var imageRendering = $VirtualDom.attribute("image-rendering");
   var glyphOrientationVertical = $VirtualDom.attribute("glyph-orientation-vertical");
   var glyphOrientationHorizontal = $VirtualDom.attribute("glyph-orientation-horizontal");
   var fontWeight = $VirtualDom.attribute("font-weight");
   var fontVariant = $VirtualDom.attribute("font-variant");
   var fontStyle = $VirtualDom.attribute("font-style");
   var fontStretch = $VirtualDom.attribute("font-stretch");
   var fontSize = $VirtualDom.attribute("font-size");
   var fontSizeAdjust = $VirtualDom.attribute("font-size-adjust");
   var fontFamily = $VirtualDom.attribute("font-family");
   var floodOpacity = $VirtualDom.attribute("flood-opacity");
   var floodColor = $VirtualDom.attribute("flood-color");
   var filter = $VirtualDom.attribute("filter");
   var fill = $VirtualDom.attribute("fill");
   var fillRule = $VirtualDom.attribute("fill-rule");
   var fillOpacity = $VirtualDom.attribute("fill-opacity");
   var enableBackground = $VirtualDom.attribute("enable-background");
   var dominantBaseline = $VirtualDom.attribute("dominant-baseline");
   var display = $VirtualDom.attribute("display");
   var direction = $VirtualDom.attribute("direction");
   var cursor = $VirtualDom.attribute("cursor");
   var color = $VirtualDom.attribute("color");
   var colorRendering = $VirtualDom.attribute("color-rendering");
   var colorProfile = $VirtualDom.attribute("color-profile");
   var colorInterpolation = $VirtualDom.attribute("color-interpolation");
   var colorInterpolationFilters = $VirtualDom.attribute("color-interpolation-filters");
   var clip = $VirtualDom.attribute("clip");
   var clipRule = $VirtualDom.attribute("clip-rule");
   var clipPath = $VirtualDom.attribute("clip-path");
   var baselineShift = $VirtualDom.attribute("baseline-shift");
   var alignmentBaseline = $VirtualDom.attribute("alignment-baseline");
   var zoomAndPan = $VirtualDom.attribute("zoomAndPan");
   var z = $VirtualDom.attribute("z");
   var yChannelSelector = $VirtualDom.attribute("yChannelSelector");
   var y2 = $VirtualDom.attribute("y2");
   var y1 = $VirtualDom.attribute("y1");
   var y = $VirtualDom.attribute("y");
   var xmlSpace = A2($VirtualDom.attributeNS,"http://www.w3.org/XML/1998/namespace","xml:space");
   var xmlLang = A2($VirtualDom.attributeNS,"http://www.w3.org/XML/1998/namespace","xml:lang");
   var xmlBase = A2($VirtualDom.attributeNS,"http://www.w3.org/XML/1998/namespace","xml:base");
   var xlinkType = A2($VirtualDom.attributeNS,"http://www.w3.org/1999/xlink","xlink:type");
   var xlinkTitle = A2($VirtualDom.attributeNS,"http://www.w3.org/1999/xlink","xlink:title");
   var xlinkShow = A2($VirtualDom.attributeNS,"http://www.w3.org/1999/xlink","xlink:show");
   var xlinkRole = A2($VirtualDom.attributeNS,"http://www.w3.org/1999/xlink","xlink:role");
   var xlinkHref = A2($VirtualDom.attributeNS,"http://www.w3.org/1999/xlink","xlink:href");
   var xlinkArcrole = A2($VirtualDom.attributeNS,"http://www.w3.org/1999/xlink","xlink:arcrole");
   var xlinkActuate = A2($VirtualDom.attributeNS,"http://www.w3.org/1999/xlink","xlink:actuate");
   var xChannelSelector = $VirtualDom.attribute("xChannelSelector");
   var x2 = $VirtualDom.attribute("x2");
   var x1 = $VirtualDom.attribute("x1");
   var xHeight = $VirtualDom.attribute("x-height");
   var x = $VirtualDom.attribute("x");
   var widths = $VirtualDom.attribute("widths");
   var width = $VirtualDom.attribute("width");
   var viewTarget = $VirtualDom.attribute("viewTarget");
   var viewBox = $VirtualDom.attribute("viewBox");
   var vertOriginY = $VirtualDom.attribute("vert-origin-y");
   var vertOriginX = $VirtualDom.attribute("vert-origin-x");
   var vertAdvY = $VirtualDom.attribute("vert-adv-y");
   var version = $VirtualDom.attribute("version");
   var values = $VirtualDom.attribute("values");
   var vMathematical = $VirtualDom.attribute("v-mathematical");
   var vIdeographic = $VirtualDom.attribute("v-ideographic");
   var vHanging = $VirtualDom.attribute("v-hanging");
   var vAlphabetic = $VirtualDom.attribute("v-alphabetic");
   var unitsPerEm = $VirtualDom.attribute("units-per-em");
   var unicodeRange = $VirtualDom.attribute("unicode-range");
   var unicode = $VirtualDom.attribute("unicode");
   var underlineThickness = $VirtualDom.attribute("underline-thickness");
   var underlinePosition = $VirtualDom.attribute("underline-position");
   var u2 = $VirtualDom.attribute("u2");
   var u1 = $VirtualDom.attribute("u1");
   var type$ = $VirtualDom.attribute("type");
   var transform = $VirtualDom.attribute("transform");
   var to = $VirtualDom.attribute("to");
   var title = $VirtualDom.attribute("title");
   var textLength = $VirtualDom.attribute("textLength");
   var targetY = $VirtualDom.attribute("targetY");
   var targetX = $VirtualDom.attribute("targetX");
   var target = $VirtualDom.attribute("target");
   var tableValues = $VirtualDom.attribute("tableValues");
   var systemLanguage = $VirtualDom.attribute("systemLanguage");
   var surfaceScale = $VirtualDom.attribute("surfaceScale");
   var style = $VirtualDom.attribute("style");
   var string = $VirtualDom.attribute("string");
   var strikethroughThickness = $VirtualDom.attribute("strikethrough-thickness");
   var strikethroughPosition = $VirtualDom.attribute("strikethrough-position");
   var stitchTiles = $VirtualDom.attribute("stitchTiles");
   var stemv = $VirtualDom.attribute("stemv");
   var stemh = $VirtualDom.attribute("stemh");
   var stdDeviation = $VirtualDom.attribute("stdDeviation");
   var startOffset = $VirtualDom.attribute("startOffset");
   var spreadMethod = $VirtualDom.attribute("spreadMethod");
   var speed = $VirtualDom.attribute("speed");
   var specularExponent = $VirtualDom.attribute("specularExponent");
   var specularConstant = $VirtualDom.attribute("specularConstant");
   var spacing = $VirtualDom.attribute("spacing");
   var slope = $VirtualDom.attribute("slope");
   var seed = $VirtualDom.attribute("seed");
   var scale = $VirtualDom.attribute("scale");
   var ry = $VirtualDom.attribute("ry");
   var rx = $VirtualDom.attribute("rx");
   var rotate = $VirtualDom.attribute("rotate");
   var result = $VirtualDom.attribute("result");
   var restart = $VirtualDom.attribute("restart");
   var requiredFeatures = $VirtualDom.attribute("requiredFeatures");
   var requiredExtensions = $VirtualDom.attribute("requiredExtensions");
   var repeatDur = $VirtualDom.attribute("repeatDur");
   var repeatCount = $VirtualDom.attribute("repeatCount");
   var renderingIntent = $VirtualDom.attribute("rendering-intent");
   var refY = $VirtualDom.attribute("refY");
   var refX = $VirtualDom.attribute("refX");
   var radius = $VirtualDom.attribute("radius");
   var r = $VirtualDom.attribute("r");
   var primitiveUnits = $VirtualDom.attribute("primitiveUnits");
   var preserveAspectRatio = $VirtualDom.attribute("preserveAspectRatio");
   var preserveAlpha = $VirtualDom.attribute("preserveAlpha");
   var pointsAtZ = $VirtualDom.attribute("pointsAtZ");
   var pointsAtY = $VirtualDom.attribute("pointsAtY");
   var pointsAtX = $VirtualDom.attribute("pointsAtX");
   var points = $VirtualDom.attribute("points");
   var pointOrder = $VirtualDom.attribute("point-order");
   var patternUnits = $VirtualDom.attribute("patternUnits");
   var patternTransform = $VirtualDom.attribute("patternTransform");
   var patternContentUnits = $VirtualDom.attribute("patternContentUnits");
   var pathLength = $VirtualDom.attribute("pathLength");
   var path = $VirtualDom.attribute("path");
   var panose1 = $VirtualDom.attribute("panose-1");
   var overlineThickness = $VirtualDom.attribute("overline-thickness");
   var overlinePosition = $VirtualDom.attribute("overline-position");
   var origin = $VirtualDom.attribute("origin");
   var orientation = $VirtualDom.attribute("orientation");
   var orient = $VirtualDom.attribute("orient");
   var order = $VirtualDom.attribute("order");
   var operator = $VirtualDom.attribute("operator");
   var offset = $VirtualDom.attribute("offset");
   var numOctaves = $VirtualDom.attribute("numOctaves");
   var name = $VirtualDom.attribute("name");
   var mode = $VirtualDom.attribute("mode");
   var min = $VirtualDom.attribute("min");
   var method = $VirtualDom.attribute("method");
   var media = $VirtualDom.attribute("media");
   var max = $VirtualDom.attribute("max");
   var mathematical = $VirtualDom.attribute("mathematical");
   var maskUnits = $VirtualDom.attribute("maskUnits");
   var maskContentUnits = $VirtualDom.attribute("maskContentUnits");
   var markerWidth = $VirtualDom.attribute("markerWidth");
   var markerUnits = $VirtualDom.attribute("markerUnits");
   var markerHeight = $VirtualDom.attribute("markerHeight");
   var local = $VirtualDom.attribute("local");
   var limitingConeAngle = $VirtualDom.attribute("limitingConeAngle");
   var lengthAdjust = $VirtualDom.attribute("lengthAdjust");
   var lang = $VirtualDom.attribute("lang");
   var keyTimes = $VirtualDom.attribute("keyTimes");
   var keySplines = $VirtualDom.attribute("keySplines");
   var keyPoints = $VirtualDom.attribute("keyPoints");
   var kernelUnitLength = $VirtualDom.attribute("kernelUnitLength");
   var kernelMatrix = $VirtualDom.attribute("kernelMatrix");
   var k4 = $VirtualDom.attribute("k4");
   var k3 = $VirtualDom.attribute("k3");
   var k2 = $VirtualDom.attribute("k2");
   var k1 = $VirtualDom.attribute("k1");
   var k = $VirtualDom.attribute("k");
   var intercept = $VirtualDom.attribute("intercept");
   var in2 = $VirtualDom.attribute("in2");
   var in$ = $VirtualDom.attribute("in");
   var ideographic = $VirtualDom.attribute("ideographic");
   var id = $VirtualDom.attribute("id");
   var horizOriginY = $VirtualDom.attribute("horiz-origin-y");
   var horizOriginX = $VirtualDom.attribute("horiz-origin-x");
   var horizAdvX = $VirtualDom.attribute("horiz-adv-x");
   var height = $VirtualDom.attribute("height");
   var hanging = $VirtualDom.attribute("hanging");
   var gradientUnits = $VirtualDom.attribute("gradientUnits");
   var gradientTransform = $VirtualDom.attribute("gradientTransform");
   var glyphRef = $VirtualDom.attribute("glyphRef");
   var glyphName = $VirtualDom.attribute("glyph-name");
   var g2 = $VirtualDom.attribute("g2");
   var g1 = $VirtualDom.attribute("g1");
   var fy = $VirtualDom.attribute("fy");
   var fx = $VirtualDom.attribute("fx");
   var from = $VirtualDom.attribute("from");
   var format = $VirtualDom.attribute("format");
   var filterUnits = $VirtualDom.attribute("filterUnits");
   var filterRes = $VirtualDom.attribute("filterRes");
   var externalResourcesRequired = $VirtualDom.attribute("externalResourcesRequired");
   var exponent = $VirtualDom.attribute("exponent");
   var end = $VirtualDom.attribute("end");
   var elevation = $VirtualDom.attribute("elevation");
   var edgeMode = $VirtualDom.attribute("edgeMode");
   var dy = $VirtualDom.attribute("dy");
   var dx = $VirtualDom.attribute("dx");
   var dur = $VirtualDom.attribute("dur");
   var divisor = $VirtualDom.attribute("divisor");
   var diffuseConstant = $VirtualDom.attribute("diffuseConstant");
   var descent = $VirtualDom.attribute("descent");
   var decelerate = $VirtualDom.attribute("decelerate");
   var d = $VirtualDom.attribute("d");
   var cy = $VirtualDom.attribute("cy");
   var cx = $VirtualDom.attribute("cx");
   var contentStyleType = $VirtualDom.attribute("contentStyleType");
   var contentScriptType = $VirtualDom.attribute("contentScriptType");
   var clipPathUnits = $VirtualDom.attribute("clipPathUnits");
   var $class = $VirtualDom.attribute("class");
   var capHeight = $VirtualDom.attribute("cap-height");
   var calcMode = $VirtualDom.attribute("calcMode");
   var by = $VirtualDom.attribute("by");
   var bias = $VirtualDom.attribute("bias");
   var begin = $VirtualDom.attribute("begin");
   var bbox = $VirtualDom.attribute("bbox");
   var baseProfile = $VirtualDom.attribute("baseProfile");
   var baseFrequency = $VirtualDom.attribute("baseFrequency");
   var azimuth = $VirtualDom.attribute("azimuth");
   var autoReverse = $VirtualDom.attribute("autoReverse");
   var attributeType = $VirtualDom.attribute("attributeType");
   var attributeName = $VirtualDom.attribute("attributeName");
   var ascent = $VirtualDom.attribute("ascent");
   var arabicForm = $VirtualDom.attribute("arabic-form");
   var amplitude = $VirtualDom.attribute("amplitude");
   var allowReorder = $VirtualDom.attribute("allowReorder");
   var alphabetic = $VirtualDom.attribute("alphabetic");
   var additive = $VirtualDom.attribute("additive");
   var accumulate = $VirtualDom.attribute("accumulate");
   var accelerate = $VirtualDom.attribute("accelerate");
   var accentHeight = $VirtualDom.attribute("accent-height");
   return _elm.Svg.Attributes.values = {_op: _op
                                       ,accentHeight: accentHeight
                                       ,accelerate: accelerate
                                       ,accumulate: accumulate
                                       ,additive: additive
                                       ,alphabetic: alphabetic
                                       ,allowReorder: allowReorder
                                       ,amplitude: amplitude
                                       ,arabicForm: arabicForm
                                       ,ascent: ascent
                                       ,attributeName: attributeName
                                       ,attributeType: attributeType
                                       ,autoReverse: autoReverse
                                       ,azimuth: azimuth
                                       ,baseFrequency: baseFrequency
                                       ,baseProfile: baseProfile
                                       ,bbox: bbox
                                       ,begin: begin
                                       ,bias: bias
                                       ,by: by
                                       ,calcMode: calcMode
                                       ,capHeight: capHeight
                                       ,$class: $class
                                       ,clipPathUnits: clipPathUnits
                                       ,contentScriptType: contentScriptType
                                       ,contentStyleType: contentStyleType
                                       ,cx: cx
                                       ,cy: cy
                                       ,d: d
                                       ,decelerate: decelerate
                                       ,descent: descent
                                       ,diffuseConstant: diffuseConstant
                                       ,divisor: divisor
                                       ,dur: dur
                                       ,dx: dx
                                       ,dy: dy
                                       ,edgeMode: edgeMode
                                       ,elevation: elevation
                                       ,end: end
                                       ,exponent: exponent
                                       ,externalResourcesRequired: externalResourcesRequired
                                       ,filterRes: filterRes
                                       ,filterUnits: filterUnits
                                       ,format: format
                                       ,from: from
                                       ,fx: fx
                                       ,fy: fy
                                       ,g1: g1
                                       ,g2: g2
                                       ,glyphName: glyphName
                                       ,glyphRef: glyphRef
                                       ,gradientTransform: gradientTransform
                                       ,gradientUnits: gradientUnits
                                       ,hanging: hanging
                                       ,height: height
                                       ,horizAdvX: horizAdvX
                                       ,horizOriginX: horizOriginX
                                       ,horizOriginY: horizOriginY
                                       ,id: id
                                       ,ideographic: ideographic
                                       ,in$: in$
                                       ,in2: in2
                                       ,intercept: intercept
                                       ,k: k
                                       ,k1: k1
                                       ,k2: k2
                                       ,k3: k3
                                       ,k4: k4
                                       ,kernelMatrix: kernelMatrix
                                       ,kernelUnitLength: kernelUnitLength
                                       ,keyPoints: keyPoints
                                       ,keySplines: keySplines
                                       ,keyTimes: keyTimes
                                       ,lang: lang
                                       ,lengthAdjust: lengthAdjust
                                       ,limitingConeAngle: limitingConeAngle
                                       ,local: local
                                       ,markerHeight: markerHeight
                                       ,markerUnits: markerUnits
                                       ,markerWidth: markerWidth
                                       ,maskContentUnits: maskContentUnits
                                       ,maskUnits: maskUnits
                                       ,mathematical: mathematical
                                       ,max: max
                                       ,media: media
                                       ,method: method
                                       ,min: min
                                       ,mode: mode
                                       ,name: name
                                       ,numOctaves: numOctaves
                                       ,offset: offset
                                       ,operator: operator
                                       ,order: order
                                       ,orient: orient
                                       ,orientation: orientation
                                       ,origin: origin
                                       ,overlinePosition: overlinePosition
                                       ,overlineThickness: overlineThickness
                                       ,panose1: panose1
                                       ,path: path
                                       ,pathLength: pathLength
                                       ,patternContentUnits: patternContentUnits
                                       ,patternTransform: patternTransform
                                       ,patternUnits: patternUnits
                                       ,pointOrder: pointOrder
                                       ,points: points
                                       ,pointsAtX: pointsAtX
                                       ,pointsAtY: pointsAtY
                                       ,pointsAtZ: pointsAtZ
                                       ,preserveAlpha: preserveAlpha
                                       ,preserveAspectRatio: preserveAspectRatio
                                       ,primitiveUnits: primitiveUnits
                                       ,r: r
                                       ,radius: radius
                                       ,refX: refX
                                       ,refY: refY
                                       ,renderingIntent: renderingIntent
                                       ,repeatCount: repeatCount
                                       ,repeatDur: repeatDur
                                       ,requiredExtensions: requiredExtensions
                                       ,requiredFeatures: requiredFeatures
                                       ,restart: restart
                                       ,result: result
                                       ,rotate: rotate
                                       ,rx: rx
                                       ,ry: ry
                                       ,scale: scale
                                       ,seed: seed
                                       ,slope: slope
                                       ,spacing: spacing
                                       ,specularConstant: specularConstant
                                       ,specularExponent: specularExponent
                                       ,speed: speed
                                       ,spreadMethod: spreadMethod
                                       ,startOffset: startOffset
                                       ,stdDeviation: stdDeviation
                                       ,stemh: stemh
                                       ,stemv: stemv
                                       ,stitchTiles: stitchTiles
                                       ,strikethroughPosition: strikethroughPosition
                                       ,strikethroughThickness: strikethroughThickness
                                       ,string: string
                                       ,style: style
                                       ,surfaceScale: surfaceScale
                                       ,systemLanguage: systemLanguage
                                       ,tableValues: tableValues
                                       ,target: target
                                       ,targetX: targetX
                                       ,targetY: targetY
                                       ,textLength: textLength
                                       ,title: title
                                       ,to: to
                                       ,transform: transform
                                       ,type$: type$
                                       ,u1: u1
                                       ,u2: u2
                                       ,underlinePosition: underlinePosition
                                       ,underlineThickness: underlineThickness
                                       ,unicode: unicode
                                       ,unicodeRange: unicodeRange
                                       ,unitsPerEm: unitsPerEm
                                       ,vAlphabetic: vAlphabetic
                                       ,vHanging: vHanging
                                       ,vIdeographic: vIdeographic
                                       ,vMathematical: vMathematical
                                       ,values: values
                                       ,version: version
                                       ,vertAdvY: vertAdvY
                                       ,vertOriginX: vertOriginX
                                       ,vertOriginY: vertOriginY
                                       ,viewBox: viewBox
                                       ,viewTarget: viewTarget
                                       ,width: width
                                       ,widths: widths
                                       ,x: x
                                       ,xHeight: xHeight
                                       ,x1: x1
                                       ,x2: x2
                                       ,xChannelSelector: xChannelSelector
                                       ,xlinkActuate: xlinkActuate
                                       ,xlinkArcrole: xlinkArcrole
                                       ,xlinkHref: xlinkHref
                                       ,xlinkRole: xlinkRole
                                       ,xlinkShow: xlinkShow
                                       ,xlinkTitle: xlinkTitle
                                       ,xlinkType: xlinkType
                                       ,xmlBase: xmlBase
                                       ,xmlLang: xmlLang
                                       ,xmlSpace: xmlSpace
                                       ,y: y
                                       ,y1: y1
                                       ,y2: y2
                                       ,yChannelSelector: yChannelSelector
                                       ,z: z
                                       ,zoomAndPan: zoomAndPan
                                       ,alignmentBaseline: alignmentBaseline
                                       ,baselineShift: baselineShift
                                       ,clipPath: clipPath
                                       ,clipRule: clipRule
                                       ,clip: clip
                                       ,colorInterpolationFilters: colorInterpolationFilters
                                       ,colorInterpolation: colorInterpolation
                                       ,colorProfile: colorProfile
                                       ,colorRendering: colorRendering
                                       ,color: color
                                       ,cursor: cursor
                                       ,direction: direction
                                       ,display: display
                                       ,dominantBaseline: dominantBaseline
                                       ,enableBackground: enableBackground
                                       ,fillOpacity: fillOpacity
                                       ,fillRule: fillRule
                                       ,fill: fill
                                       ,filter: filter
                                       ,floodColor: floodColor
                                       ,floodOpacity: floodOpacity
                                       ,fontFamily: fontFamily
                                       ,fontSizeAdjust: fontSizeAdjust
                                       ,fontSize: fontSize
                                       ,fontStretch: fontStretch
                                       ,fontStyle: fontStyle
                                       ,fontVariant: fontVariant
                                       ,fontWeight: fontWeight
                                       ,glyphOrientationHorizontal: glyphOrientationHorizontal
                                       ,glyphOrientationVertical: glyphOrientationVertical
                                       ,imageRendering: imageRendering
                                       ,kerning: kerning
                                       ,letterSpacing: letterSpacing
                                       ,lightingColor: lightingColor
                                       ,markerEnd: markerEnd
                                       ,markerMid: markerMid
                                       ,markerStart: markerStart
                                       ,mask: mask
                                       ,opacity: opacity
                                       ,overflow: overflow
                                       ,pointerEvents: pointerEvents
                                       ,shapeRendering: shapeRendering
                                       ,stopColor: stopColor
                                       ,stopOpacity: stopOpacity
                                       ,strokeDasharray: strokeDasharray
                                       ,strokeDashoffset: strokeDashoffset
                                       ,strokeLinecap: strokeLinecap
                                       ,strokeLinejoin: strokeLinejoin
                                       ,strokeMiterlimit: strokeMiterlimit
                                       ,strokeOpacity: strokeOpacity
                                       ,strokeWidth: strokeWidth
                                       ,stroke: stroke
                                       ,textAnchor: textAnchor
                                       ,textDecoration: textDecoration
                                       ,textRendering: textRendering
                                       ,unicodeBidi: unicodeBidi
                                       ,visibility: visibility
                                       ,wordSpacing: wordSpacing
                                       ,writingMode: writingMode};
};
Elm.Svg = Elm.Svg || {};
Elm.Svg.Events = Elm.Svg.Events || {};
Elm.Svg.Events.make = function (_elm) {
   "use strict";
   _elm.Svg = _elm.Svg || {};
   _elm.Svg.Events = _elm.Svg.Events || {};
   if (_elm.Svg.Events.values) return _elm.Svg.Events.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Json$Decode = Elm.Json.Decode.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Svg = Elm.Svg.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var on = $VirtualDom.on;
   var messageOn = F2(function (name,msg) {    return A3(on,name,$Json$Decode.value,$Basics.always(msg));});
   var onBegin = messageOn("begin");
   var onEnd = messageOn("end");
   var onRepeat = messageOn("repeat");
   var onAbort = messageOn("abort");
   var onError = messageOn("error");
   var onResize = messageOn("resize");
   var onScroll = messageOn("scroll");
   var onLoad = messageOn("load");
   var onUnload = messageOn("unload");
   var onZoom = messageOn("zoom");
   var onActivate = messageOn("activate");
   var onClick = messageOn("click");
   var onFocusIn = messageOn("focusin");
   var onFocusOut = messageOn("focusout");
   var onMouseDown = messageOn("mousedown");
   var onMouseMove = messageOn("mousemove");
   var onMouseOut = messageOn("mouseout");
   var onMouseOver = messageOn("mouseover");
   var onMouseUp = messageOn("mouseup");
   return _elm.Svg.Events.values = {_op: _op
                                   ,onBegin: onBegin
                                   ,onEnd: onEnd
                                   ,onRepeat: onRepeat
                                   ,onAbort: onAbort
                                   ,onError: onError
                                   ,onResize: onResize
                                   ,onScroll: onScroll
                                   ,onLoad: onLoad
                                   ,onUnload: onUnload
                                   ,onZoom: onZoom
                                   ,onActivate: onActivate
                                   ,onClick: onClick
                                   ,onFocusIn: onFocusIn
                                   ,onFocusOut: onFocusOut
                                   ,onMouseDown: onMouseDown
                                   ,onMouseMove: onMouseMove
                                   ,onMouseOut: onMouseOut
                                   ,onMouseOver: onMouseOver
                                   ,onMouseUp: onMouseUp};
};
Elm.Svg = Elm.Svg || {};
Elm.Svg.Lazy = Elm.Svg.Lazy || {};
Elm.Svg.Lazy.make = function (_elm) {
   "use strict";
   _elm.Svg = _elm.Svg || {};
   _elm.Svg.Lazy = _elm.Svg.Lazy || {};
   if (_elm.Svg.Lazy.values) return _elm.Svg.Lazy.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Svg = Elm.Svg.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var lazy3 = $VirtualDom.lazy3;
   var lazy2 = $VirtualDom.lazy2;
   var lazy = $VirtualDom.lazy;
   return _elm.Svg.Lazy.values = {_op: _op,lazy: lazy,lazy2: lazy2,lazy3: lazy3};
};
Elm.Native.Lazy = {};
Elm.Native.Lazy.make = function(localRuntime) {

    localRuntime.Native = localRuntime.Native || {};
    localRuntime.Native.Lazy = localRuntime.Native.Lazy || {};
    if (localRuntime.Native.Lazy.values) {
        return localRuntime.Native.Lazy.values;
    }

    function memoize(thunk) {
        var value;
        var isForced = false;
        return function(tuple0) {
            if (!isForced) {
                value = thunk(tuple0);
                isForced = true;
            }
            return value;
        };
    }

    return localRuntime.Native.Lazy.values = {
        memoize: memoize
    };
};

Elm.Lazy = Elm.Lazy || {};
Elm.Lazy.make = function (_elm) {
   "use strict";
   _elm.Lazy = _elm.Lazy || {};
   if (_elm.Lazy.values) return _elm.Lazy.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Lazy = Elm.Native.Lazy.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var force = function (_p0) {    var _p1 = _p0;return _p1._0({ctor: "_Tuple0"});};
   var Lazy = function (a) {    return {ctor: "Lazy",_0: a};};
   var lazy = function (thunk) {    return Lazy($Native$Lazy.memoize(thunk));};
   var map = F2(function (f,a) {    return lazy(function (_p2) {    var _p3 = _p2;return f(force(a));});});
   var map2 = F3(function (f,a,b) {    return lazy(function (_p4) {    var _p5 = _p4;return A2(f,force(a),force(b));});});
   var map3 = F4(function (f,a,b,c) {    return lazy(function (_p6) {    var _p7 = _p6;return A3(f,force(a),force(b),force(c));});});
   var map4 = F5(function (f,a,b,c,d) {    return lazy(function (_p8) {    var _p9 = _p8;return A4(f,force(a),force(b),force(c),force(d));});});
   var map5 = F6(function (f,a,b,c,d,e) {    return lazy(function (_p10) {    var _p11 = _p10;return A5(f,force(a),force(b),force(c),force(d),force(e));});});
   var apply = F2(function (f,x) {    return lazy(function (_p12) {    var _p13 = _p12;return A2(force,f,force(x));});});
   var andThen = F2(function (a,callback) {    return lazy(function (_p14) {    var _p15 = _p14;return force(callback(force(a)));});});
   return _elm.Lazy.values = {_op: _op,force: force,lazy: lazy,map: map,map2: map2,map3: map3,map4: map4,map5: map5,apply: apply,andThen: andThen};
};
Elm.Ace = Elm.Ace || {};
Elm.Ace.make = function (_elm) {
   "use strict";
   _elm.Ace = _elm.Ace || {};
   if (_elm.Ace.values) return _elm.Ace.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var Range = F2(function (a,b) {    return {start: a,end: b};});
   var Pos = F2(function (a,b) {    return {row: a,column: b};});
   var Highlight = F2(function (a,b) {
      return {range: a,color: b};
   });
   var Tooltip = F3(function (a,b,c) {
      return {row: a,col: b,text: c};
   });
   var Annotation = F3(function (a,b,c) {
      return {row: a,type_: b,text: c};
   });
   return _elm.Ace.values = {_op: _op
                            ,Annotation: Annotation
                            ,Tooltip: Tooltip
                            ,Highlight: Highlight
                            ,Pos: Pos
                            ,Range: Range};
};
Elm.Utils = Elm.Utils || {};
Elm.Utils.make = function (_elm) {
   "use strict";
   _elm.Utils = _elm.Utils || {};
   if (_elm.Utils.values) return _elm.Utils.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm);
   var _op = {};
   var unwrap7 = function (xs) {
      var _p0 = xs;
      if (_p0.ctor === "::" && _p0._1.ctor === "::" && _p0._1._1.ctor === "::" && _p0._1._1._1.ctor === "::" && _p0._1._1._1._1.ctor === "::" && _p0._1._1._1._1._1.ctor === "::" && _p0._1._1._1._1._1._1.ctor === "::" && _p0._1._1._1._1._1._1._1.ctor === "[]")
      {
            return {ctor: "_Tuple7"
                   ,_0: _p0._0
                   ,_1: _p0._1._0
                   ,_2: _p0._1._1._0
                   ,_3: _p0._1._1._1._0
                   ,_4: _p0._1._1._1._1._0
                   ,_5: _p0._1._1._1._1._1._0
                   ,_6: _p0._1._1._1._1._1._1._0};
         } else {
            return _U.crashCase("Utils",
            {start: {line: 514,column: 14},end: {line: 516,column: 29}},
            _p0)("unwrap7");
         }
   };
   var unwrap6 = function (xs) {
      var _p2 = xs;
      if (_p2.ctor === "::" && _p2._1.ctor === "::" && _p2._1._1.ctor === "::" && _p2._1._1._1.ctor === "::" && _p2._1._1._1._1.ctor === "::" && _p2._1._1._1._1._1.ctor === "::" && _p2._1._1._1._1._1._1.ctor === "[]")
      {
            return {ctor: "_Tuple6"
                   ,_0: _p2._0
                   ,_1: _p2._1._0
                   ,_2: _p2._1._1._0
                   ,_3: _p2._1._1._1._0
                   ,_4: _p2._1._1._1._1._0
                   ,_5: _p2._1._1._1._1._1._0};
         } else {
            return _U.crashCase("Utils",
            {start: {line: 510,column: 14},end: {line: 512,column: 29}},
            _p2)("unwrap6");
         }
   };
   var unwrap5 = function (xs) {
      var _p4 = xs;
      if (_p4.ctor === "::" && _p4._1.ctor === "::" && _p4._1._1.ctor === "::" && _p4._1._1._1.ctor === "::" && _p4._1._1._1._1.ctor === "::" && _p4._1._1._1._1._1.ctor === "[]")
      {
            return {ctor: "_Tuple5"
                   ,_0: _p4._0
                   ,_1: _p4._1._0
                   ,_2: _p4._1._1._0
                   ,_3: _p4._1._1._1._0
                   ,_4: _p4._1._1._1._1._0};
         } else {
            return _U.crashCase("Utils",
            {start: {line: 506,column: 14},end: {line: 508,column: 29}},
            _p4)("unwrap5");
         }
   };
   var unwrap4 = function (xs) {
      var _p6 = xs;
      if (_p6.ctor === "::" && _p6._1.ctor === "::" && _p6._1._1.ctor === "::" && _p6._1._1._1.ctor === "::" && _p6._1._1._1._1.ctor === "[]")
      {
            return {ctor: "_Tuple4"
                   ,_0: _p6._0
                   ,_1: _p6._1._0
                   ,_2: _p6._1._1._0
                   ,_3: _p6._1._1._1._0};
         } else {
            return _U.crashCase("Utils",
            {start: {line: 502,column: 14},end: {line: 504,column: 29}},
            _p6)("unwrap4");
         }
   };
   var unwrap3 = function (xs) {
      var _p8 = xs;
      if (_p8.ctor === "::" && _p8._1.ctor === "::" && _p8._1._1.ctor === "::" && _p8._1._1._1.ctor === "[]")
      {
            return {ctor: "_Tuple3"
                   ,_0: _p8._0
                   ,_1: _p8._1._0
                   ,_2: _p8._1._1._0};
         } else {
            return _U.crashCase("Utils",
            {start: {line: 498,column: 14},end: {line: 500,column: 29}},
            _p8)("unwrap3");
         }
   };
   var unwrap2 = function (xs) {
      var _p10 = xs;
      if (_p10.ctor === "::" && _p10._1.ctor === "::" && _p10._1._1.ctor === "[]")
      {
            return {ctor: "_Tuple2",_0: _p10._0,_1: _p10._1._0};
         } else {
            return _U.crashCase("Utils",
            {start: {line: 494,column: 14},end: {line: 496,column: 29}},
            _p10)("unwrap2");
         }
   };
   var unwrap1 = function (xs) {
      var _p12 = xs;
      if (_p12.ctor === "::" && _p12._1.ctor === "[]") {
            return _p12._0;
         } else {
            return _U.crashCase("Utils",
            {start: {line: 490,column: 14},end: {line: 492,column: 29}},
            _p12)("unwrap1");
         }
   };
   var uniPlusMinus = "±";
   var uniDelta = "Δ";
   var uniLambda = "λ";
   var uniCamera = "📷";
   var uniReload = "⎋";
   var uniRedo = "▶";
   var uniUndo = "◀";
   var uniSave = "💾";
   var uniEnter = "↵";
   var uniRight = "→";
   var uniLeft = "←";
   var radiansToDegrees = function (rad) {
      return rad / $Basics.pi * 180;
   };
   var numToColor_ = function (val) {
      var min = 55;
      var max = 200;
      var diff = max - min;
      var n = $Basics.toFloat(A2($Basics._op["%"],val,360));
      var i = $Basics.floor(n) / 60 | 0;
      var _p14 = i;
      switch (_p14)
      {case 0: return {ctor: "_Tuple3"
                      ,_0: max
                      ,_1: $Basics.round(min + diff * (1 - (60 - n) / 60))
                      ,_2: min};
         case 1: return {ctor: "_Tuple3"
                        ,_0: $Basics.round(max - diff * (1 - (120 - n) / 60))
                        ,_1: max
                        ,_2: min};
         case 2: return {ctor: "_Tuple3"
                        ,_0: min
                        ,_1: max
                        ,_2: $Basics.round(min + diff * (1 - (180 - n) / 60))};
         case 3: return {ctor: "_Tuple3"
                        ,_0: min
                        ,_1: $Basics.round(max - diff * (1 - (240 - n) / 60))
                        ,_2: max};
         case 4: return {ctor: "_Tuple3"
                        ,_0: $Basics.round(min + diff * (1 - (300 - n) / 60))
                        ,_1: min
                        ,_2: max};
         case 5: return {ctor: "_Tuple3"
                        ,_0: max
                        ,_1: min
                        ,_2: $Basics.round(max - diff * (1 - (360 - n) / 60))};
         default: return _U.crashCase("Utils",
           {start: {line: 453,column: 6},end: {line: 460,column: 37}},
           _p14)("numToColor");}
   };
   var nothing = _U.list([]);
   var distance = F2(function (_p17,_p16) {
      var _p18 = _p17;
      var _p19 = _p16;
      return $Basics.sqrt(Math.pow(_p19._0 - _p18._0,
      2) + Math.pow(_p19._1 - _p18._1,2));
   });
   var distanceInt = F2(function (_p21,_p20) {
      var _p22 = _p21;
      var _p23 = _p20;
      return A2(distance,
      {ctor: "_Tuple2"
      ,_0: $Basics.toFloat(_p22._0)
      ,_1: $Basics.toFloat(_p22._1)},
      {ctor: "_Tuple2"
      ,_0: $Basics.toFloat(_p23._0)
      ,_1: $Basics.toFloat(_p23._1)});
   });
   var between = F2(function (x,_p24) {
      var _p25 = _p24;
      return _U.cmp(_p25._0,x) < 1 && _U.cmp(x,_p25._1) < 0;
   });
   var numToColor = F2(function (n,i) {
      var j = $Basics.round(i / n * 500);
      if (A2(between,j,{ctor: "_Tuple2",_0: 0,_1: 360}))
      return numToColor_(j); else if (A2(between,
         j,
         {ctor: "_Tuple2",_0: 360,_1: 380})) return {ctor: "_Tuple3"
                                                    ,_0: 0
                                                    ,_1: 0
                                                    ,_2: 0}; else if (A2(between,
            j,
            {ctor: "_Tuple2",_0: 480,_1: 500})) return {ctor: "_Tuple3"
                                                       ,_0: 255
                                                       ,_1: 255
                                                       ,_2: 255}; else {
                  var x = $Basics.round(255 * (($Basics.toFloat(j) - 380) / 100));
                  return {ctor: "_Tuple3",_0: x,_1: x,_2: x};
               }
   });
   var commonPrefix2 = F2(function (l1,l2) {
      var _p26 = {ctor: "_Tuple2",_0: l1,_1: l2};
      if (_p26.ctor === "_Tuple2" && _p26._0.ctor === "::" && _p26._1.ctor === "::")
      {
            var _p27 = _p26._0._0;
            return _U.eq(_p27,_p26._1._0) ? A2($List._op["::"],
            _p27,
            A2(commonPrefix2,_p26._0._1,_p26._1._1)) : _U.list([]);
         } else {
            return _U.list([]);
         }
   });
   var commonPrefix = function (lists) {
      var _p28 = lists;
      if (_p28.ctor === "::") {
            return A3($List.foldl,commonPrefix2,_p28._0,_p28._1);
         } else {
            return _U.list([]);
         }
   };
   var setCardinal = function (_p29) {
      return $List.length($Set.toList(_p29));
   };
   var dictIsEmpty = function (_p30) {
      return A2(F2(function (x,y) {    return _U.eq(x,y);}),
      _U.list([]),
      $Dict.toList(_p30));
   };
   var setIsEmpty = function (_p31) {
      return A2(F2(function (x,y) {    return _U.eq(x,y);}),
      _U.list([]),
      $Set.toList(_p31));
   };
   var bindResult = F2(function (res,f) {
      var _p32 = res;
      if (_p32.ctor === "Err") {
            return $Result.Err(_p32._0);
         } else {
            return f(_p32._0);
         }
   });
   var fourth4 = function (_p33) {
      var _p34 = _p33;
      return _p34._3;
   };
   var mapThd3 = F2(function (f,_p35) {
      var _p36 = _p35;
      return {ctor: "_Tuple3",_0: _p36._0,_1: _p36._1,_2: f(_p36._2)};
   });
   var thd3 = function (_p37) {
      var _p38 = _p37;
      return _p38._2;
   };
   var snd3 = function (_p39) {
      var _p40 = _p39;
      return _p40._1;
   };
   var fst3 = function (_p41) {
      var _p42 = _p41;
      return _p42._0;
   };
   var mapSnd = F2(function (f,_p43) {
      var _p44 = _p43;
      return {ctor: "_Tuple2",_0: _p44._0,_1: f(_p44._1)};
   });
   var mapFst = F2(function (f,_p45) {
      var _p46 = _p45;
      return {ctor: "_Tuple2",_0: f(_p46._0),_1: _p46._1};
   });
   var projOk = function (list) {
      return A3($List.foldr,
      F2(function (res,out) {
         var _p47 = {ctor: "_Tuple2",_0: res,_1: out};
         if (_p47._1.ctor === "Err") {
               return out;
            } else {
               if (_p47._0.ctor === "Ok") {
                     return $Result.Ok(A2($List._op["::"],_p47._0._0,_p47._1._0));
                  } else {
                     return $Result.Err(_p47._0._0);
                  }
            }
      }),
      $Result.Ok(_U.list([])),
      list);
   };
   var filterJusts = function (mxs) {
      filterJusts: while (true) {
         var _p48 = mxs;
         if (_p48.ctor === "[]") {
               return _U.list([]);
            } else {
               if (_p48._0.ctor === "Just") {
                     return A2($List._op["::"],_p48._0._0,filterJusts(_p48._1));
                  } else {
                     var _v25 = _p48._1;
                     mxs = _v25;
                     continue filterJusts;
                  }
            }
      }
   };
   var projJusts = A2($List.foldr,
   F2(function (mx,acc) {
      var _p49 = {ctor: "_Tuple2",_0: mx,_1: acc};
      if (_p49.ctor === "_Tuple2" && _p49._0.ctor === "Just" && _p49._1.ctor === "Just")
      {
            return $Maybe.Just(A2($List._op["::"],
            _p49._0._0,
            _p49._1._0));
         } else {
            return $Maybe.Nothing;
         }
   }),
   $Maybe.Just(_U.list([])));
   var elseMaybe = F2(function (mx,$default) {
      var _p50 = mx;
      if (_p50.ctor === "Just") {
            return _p50._0;
         } else {
            return $default;
         }
   });
   var plusMaybe = F2(function (mx,my) {
      var _p51 = mx;
      if (_p51.ctor === "Just") {
            return mx;
         } else {
            return my;
         }
   });
   var bindMaybe = F2(function (f,mx) {
      var _p52 = mx;
      if (_p52.ctor === "Just") {
            return f(_p52._0);
         } else {
            return $Maybe.Nothing;
         }
   });
   var bindMaybe2 = F3(function (f,mx,my) {
      return A2(bindMaybe,
      function (x) {
         return A2(bindMaybe,f(x),my);
      },
      mx);
   });
   var bindMaybe3 = F4(function (f,mx,my,mz) {
      return A3(bindMaybe2,
      F2(function (x,y) {    return A2(bindMaybe,A2(f,x,y),mz);}),
      mx,
      my);
   });
   var mapMaybe = F2(function (f,mx) {
      var _p53 = mx;
      if (_p53.ctor === "Just") {
            return $Maybe.Just(f(_p53._0));
         } else {
            return $Maybe.Nothing;
         }
   });
   var uncons = function (xs) {
      var _p54 = xs;
      if (_p54.ctor === "::") {
            return {ctor: "_Tuple2",_0: _p54._0,_1: _p54._1};
         } else {
            return _U.crashCase("Utils",
            {start: {line: 323,column: 13},end: {line: 325,column: 32}},
            _p54)("uncons");
         }
   };
   var toggleDict = F2(function (_p56,dict) {
      var _p57 = _p56;
      var _p58 = _p57._0;
      return A2($Dict.member,_p58,dict) ? A2($Dict.remove,
      _p58,
      dict) : A3($Dict.insert,_p58,_p57._1,dict);
   });
   var toggleSet = F2(function (x,set) {
      return A2($Set.member,x,set) ? A2($Set.remove,
      x,
      set) : A2($Set.insert,x,set);
   });
   var getWithDefault = F3(function (key,$default,dict) {
      var _p59 = A2($Dict.get,key,dict);
      if (_p59.ctor === "Just") {
            return _p59._0;
         } else {
            return $default;
         }
   });
   var fromOk = F2(function (s,mx) {
      var _p60 = mx;
      if (_p60.ctor === "Ok") {
            return _p60._0;
         } else {
            return _U.crashCase("Utils",
            {start: {line: 296,column: 15},end: {line: 298,column: 60}},
            _p60)(A2($Basics._op["++"],
            "fromOk [",
            A2($Basics._op["++"],s,A2($Basics._op["++"],"]: ",_p60._0))));
         }
   });
   var fromOk_ = fromOk("");
   var parseInt = function (_p62) {
      return fromOk_($String.toInt(_p62));
   };
   var parseFloat = function (_p63) {
      return fromOk_($String.toFloat(_p63));
   };
   var fromOkay = F2(function (s,mx) {
      var _p64 = mx;
      if (_p64.ctor === "Ok") {
            return _p64._0;
         } else {
            return _U.crashCase("Utils",
            {start: {line: 289,column: 17},end: {line: 291,column: 53}},
            _p64)(A2($Basics._op["++"],
            "fromOkay [",
            A2($Basics._op["++"],s,"]: ")));
         }
   });
   var fromJust_ = F2(function (s,mx) {
      var _p66 = mx;
      if (_p66.ctor === "Just") {
            return _p66._0;
         } else {
            return _U.crashCase("Utils",
            {start: {line: 284,column: 18},end: {line: 286,column: 53}},
            _p66)(A2($Basics._op["++"],"Utils.fromJust_: ",s));
         }
   });
   var justGet = F2(function (k,d) {
      return A2(fromJust_,"Utils.justGet",A2($Dict.get,k,d));
   });
   var justGet_ = F3(function (s,k,d) {
      return A2(fromJust_,
      A2($Basics._op["++"],"Utils.justGet ",s),
      A2($Dict.get,k,d));
   });
   var head_ = function (_p68) {
      return A2(fromJust_,"Utils.head_",$List.head(_p68));
   };
   var last_ = function (_p69) {
      return head_($List.reverse(_p69));
   };
   var tail_ = function (_p70) {
      return A2(fromJust_,"Utils.tail_",$List.tail(_p70));
   };
   var fromJust = function (m) {
      var _p71 = m;
      if (_p71.ctor === "Just") {
            return _p71._0;
         } else {
            return _U.crashCase("Utils",
            {start: {line: 280,column: 14},end: {line: 282,column: 54}},
            _p71)("Utils.fromJust: Nothing");
         }
   };
   var assert = F2(function (s,b) {
      return b ? {ctor: "_Tuple0"} : _U.crash("Utils",
      {start: {line: 278,column: 32}
      ,end: {line: 278,column: 43}})(A2($Basics._op["++"],
      "assert error: ",
      s));
   });
   var lift_2_2 = F3(function (f,_p74,_p73) {
      var _p75 = _p74;
      var _p76 = _p73;
      return {ctor: "_Tuple2"
             ,_0: A2(f,_p75._0,_p76._0)
             ,_1: A2(f,_p75._1,_p76._1)};
   });
   var avg = function (ns) {
      return $List.sum(ns) / $Basics.toFloat($List.length(ns));
   };
   var sum = A2($List.foldl,
   F2(function (x,y) {    return x + y;}),
   0);
   var lines = $String.join("\n");
   var commas = $String.join(", ");
   var spaces = $String.join(" ");
   var delimit = F3(function (a,b,s) {
      return $String.concat(_U.list([a,s,b]));
   });
   var parens = A2(delimit,"(",")");
   var bracks = A2(delimit,"[","]");
   var ibracks = A2(delimit,"[|","|]");
   var braces = A2(delimit,"{","}");
   var count = F2(function (pred,list) {
      return $List.length(A2($List.filter,pred,list));
   });
   var removeDupes = function (_p77) {
      return $Set.toList($Set.fromList(_p77));
   };
   var allSame = function (list) {
      var _p78 = list;
      if (_p78.ctor === "[]") {
            return false;
         } else {
            return _U.eq(A2($List.filter,
            F2(function (x,y) {    return !_U.eq(x,y);})(_p78._0),
            _p78._1),
            _U.list([]));
         }
   };
   var replacei = F3(function (i,xi$,xs) {
      return A2($Basics._op["++"],
      A2($List.take,i - 1,xs),
      A2($Basics._op["++"],_U.list([xi$]),A2($List.drop,i,xs)));
   });
   var geti = function (i) {
      return function (_p79) {
         return A2(fromJust_,
         "Utils.geti",
         $List.head(A2($List.drop,i - 1,_p79)));
      };
   };
   var adjacentPairs = F2(function (includeLast,list) {
      var _p80 = list;
      if (_p80.ctor === "[]") {
            return _U.list([]);
         } else {
            var _p84 = _p80._0;
            var f = F2(function (xi,_p81) {
               var _p82 = _p81;
               return {ctor: "_Tuple2"
                      ,_0: xi
                      ,_1: A2($List._op["::"],
                      {ctor: "_Tuple2",_0: _p82._0,_1: xi},
                      _p82._1)};
            });
            var _p83 = A3($List.foldl,
            f,
            {ctor: "_Tuple2",_0: _p84,_1: _U.list([])},
            _p80._1);
            var xn = _p83._0;
            var pairs = _p83._1;
            return includeLast ? $List.reverse(A2($List._op["::"],
            {ctor: "_Tuple2",_0: xn,_1: _p84},
            pairs)) : $List.reverse(pairs);
         }
   });
   var removeLastElement = function (list) {
      return A2($List.take,$List.length(list) - 1,list);
   };
   var maybeRemoveFirst = F2(function (x,ys) {
      var _p85 = ys;
      if (_p85.ctor === "[]") {
            return $Maybe.Nothing;
         } else {
            var _p89 = _p85._1;
            var _p88 = _p85._0._1;
            var _p87 = _p85._0._0;
            if (_U.eq(x,_p87)) return $Maybe.Just({ctor: "_Tuple2"
                                                  ,_0: _p88
                                                  ,_1: _p89}); else {
                  var _p86 = A2(maybeRemoveFirst,x,_p89);
                  if (_p86.ctor === "Nothing") {
                        return $Maybe.Nothing;
                     } else {
                        return $Maybe.Just({ctor: "_Tuple2"
                                           ,_0: _p86._0._0
                                           ,_1: A2($List._op["::"],
                                           {ctor: "_Tuple2",_0: _p87,_1: _p88},
                                           _p86._0._1)});
                     }
               }
         }
   });
   var removeFirst = F2(function (x,ys) {
      var _p90 = ys;
      if (_p90.ctor === "[]") {
            return _U.list([]);
         } else {
            var _p92 = _p90._1;
            var _p91 = _p90._0;
            return _U.eq(x,_p91) ? _p92 : A2($List._op["::"],
            _p91,
            A2(removeFirst,x,_p92));
         }
   });
   var findFirst = F2(function (p,xs) {
      findFirst: while (true) {
         var _p93 = xs;
         if (_p93.ctor === "[]") {
               return $Maybe.Nothing;
            } else {
               var _p94 = _p93._0;
               if (p(_p94)) return $Maybe.Just(_p94); else {
                     var _v47 = p,_v48 = _p93._1;
                     p = _v47;
                     xs = _v48;
                     continue findFirst;
                  }
            }
      }
   });
   var intersectMany = function (list) {
      var _p95 = list;
      if (_p95.ctor === "::") {
            return A3($List.foldl,$Set.intersect,_p95._0,_p95._1);
         } else {
            return _U.crashCase("Utils",
            {start: {line: 189,column: 22},end: {line: 191,column: 43}},
            _p95)("intersectMany");
         }
   };
   var oneOfEach = function (xss) {
      var _p97 = xss;
      if (_p97.ctor === "[]") {
            return _U.list([_U.list([])]);
         } else {
            return A2($List.concatMap,
            function (x) {
               return A2($List.map,
               F2(function (x,y) {    return A2($List._op["::"],x,y);})(x),
               oneOfEach(_p97._1));
            },
            _p97._0);
         }
   };
   var takeNLines = F2(function (n,s) {
      return A2($String.join,
      "\n",
      A2($List.take,n,$String.lines(s)));
   });
   var splitString = F2(function (n,s) {
      return {ctor: "_Tuple2"
             ,_0: A2($String.left,n,s)
             ,_1: A2($String.dropLeft,n,s)};
   });
   var munchString = F2(function (prefix,s) {
      var _p98 = A2(splitString,$String.length(prefix),s);
      var pre = _p98._0;
      var suf = _p98._1;
      return _U.eq(pre,prefix) ? $Maybe.Just(suf) : $Maybe.Nothing;
   });
   var split = F2(function (n,xs) {
      return {ctor: "_Tuple2"
             ,_0: A2($List.take,n,xs)
             ,_1: A2($List.drop,n,xs)};
   });
   var singleton = function (x) {    return _U.list([x]);};
   var just = singleton;
   var maybeToMaybeOne = function (mx) {
      var _p99 = mx;
      if (_p99.ctor === "Nothing") {
            return nothing;
         } else {
            return just(_p99._0);
         }
   };
   var clamp = F3(function (i,j,n) {
      return _U.cmp(n,i) < 0 ? i : _U.cmp(j,n) < 0 ? j : n;
   });
   var oneToOneMappingExists = F2(function (l1,l2) {
      var numericRepresentation = function (list) {
         return $Basics.snd(A3($List.foldl,
         F2(function (x,_p100) {
            var _p101 = _p100;
            var _p104 = _p101._1;
            var _p103 = _p101._0;
            var _p102 = A2($Dict.get,x,_p103);
            if (_p102.ctor === "Just") {
                  return {ctor: "_Tuple2"
                         ,_0: _p103
                         ,_1: A2($Basics._op["++"],_p104,_U.list([_p102._0]))};
               } else {
                  var n = $Dict.size(_p103);
                  var dict$ = A3($Dict.insert,x,n,_p103);
                  return {ctor: "_Tuple2"
                         ,_0: dict$
                         ,_1: A2($Basics._op["++"],_p104,_U.list([n]))};
               }
         }),
         {ctor: "_Tuple2",_0: $Dict.empty,_1: _U.list([])},
         list));
      };
      return _U.eq(numericRepresentation(l1),
      numericRepresentation(l2));
   });
   var dedup_ = F2(function (f,xs) {
      var _p105 = A3($List.foldl,
      F2(function (x,_p106) {
         var _p107 = _p106;
         var _p109 = _p107._1;
         var _p108 = _p107._0;
         return A2($Set.member,f(x),_p109) ? {ctor: "_Tuple2"
                                             ,_0: _p108
                                             ,_1: _p109} : {ctor: "_Tuple2"
                                                           ,_0: A2($List.append,_p108,_U.list([x]))
                                                           ,_1: A2($Set.insert,f(x),_p109)};
      }),
      {ctor: "_Tuple2",_0: _U.list([]),_1: $Set.empty},
      xs);
      var deduped = _p105._0;
      return deduped;
   });
   var dedup = function (xs) {
      return A2(dedup_,$Basics.toString,xs);
   };
   var reverse2 = function (_p110) {
      var _p111 = _p110;
      return {ctor: "_Tuple2"
             ,_0: $List.reverse(_p111._0)
             ,_1: $List.reverse(_p111._1)};
   };
   var oneElement = function (xs) {
      var _p112 = xs;
      if (_p112.ctor === "::" && _p112._1.ctor === "[]") {
            return true;
         } else {
            return false;
         }
   };
   var zeroElements = function (xs) {
      var _p113 = xs;
      if (_p113.ctor === "[]") {
            return true;
         } else {
            return false;
         }
   };
   var maybeZipN = function (lists) {
      if (A2($List.all,zeroElements,lists))
      return $Maybe.Just(_U.list([])); else if (A2($List.all,
         oneElement,
         lists)) return $Maybe.Just(_U.list([$List.concat(lists)]));
         else {
               var maybeHeads = projJusts(A2($List.map,$List.head,lists));
               var maybeTails = projJusts(A2($List.map,$List.tail,lists));
               var _p114 = {ctor: "_Tuple2",_0: maybeHeads,_1: maybeTails};
               if (_p114.ctor === "_Tuple2" && _p114._0.ctor === "Just" && _p114._1.ctor === "Just")
               {
                     return A2(mapMaybe,
                     F2(function (x,y) {
                        return A2($List._op["::"],x,y);
                     })(_p114._0._0),
                     maybeZipN(_p114._1._0));
                  } else {
                     return $Maybe.Nothing;
                  }
            }
   };
   var listsEqualBy = F3(function (elementEqualityFunc,xs,ys) {
      var _p115 = {ctor: "_Tuple2",_0: xs,_1: ys};
      _v59_2: do {
         if (_p115.ctor === "_Tuple2") {
               if (_p115._0.ctor === "[]") {
                     if (_p115._1.ctor === "[]") {
                           return true;
                        } else {
                           break _v59_2;
                        }
                  } else {
                     if (_p115._1.ctor === "::") {
                           return A2(elementEqualityFunc,
                           _p115._0._0,
                           _p115._1._0) && A3(listsEqualBy,
                           elementEqualityFunc,
                           _p115._0._1,
                           _p115._1._1);
                        } else {
                           break _v59_2;
                        }
                  }
            } else {
               break _v59_2;
            }
      } while (false);
      return false;
   });
   var maybeZipDicts = F2(function (d1,d2) {
      return !_U.eq($Dict.keys(d1),
      $Dict.keys(d2)) ? $Maybe.Nothing : $Maybe.Just(A2($Dict.map,
      F2(function (k,v1) {
         return {ctor: "_Tuple2",_0: v1,_1: A2(justGet,k,d2)};
      }),
      d1));
   });
   var maybeZip = F2(function (xs,ys) {
      var _p116 = {ctor: "_Tuple2",_0: xs,_1: ys};
      _v60_2: do {
         if (_p116.ctor === "_Tuple2") {
               if (_p116._0.ctor === "::") {
                     if (_p116._1.ctor === "::") {
                           var _p117 = A2(maybeZip,_p116._0._1,_p116._1._1);
                           if (_p117.ctor === "Nothing") {
                                 return $Maybe.Nothing;
                              } else {
                                 return $Maybe.Just(A2($List._op["::"],
                                 {ctor: "_Tuple2",_0: _p116._0._0,_1: _p116._1._0},
                                 _p117._0));
                              }
                        } else {
                           break _v60_2;
                        }
                  } else {
                     if (_p116._1.ctor === "[]") {
                           return $Maybe.Just(_U.list([]));
                        } else {
                           break _v60_2;
                        }
                  }
            } else {
               break _v60_2;
            }
      } while (false);
      return $Maybe.Nothing;
   });
   var zip = F2(function (xs,ys) {
      var _p118 = {ctor: "_Tuple2",_0: xs,_1: ys};
      if (_p118.ctor === "_Tuple2" && _p118._0.ctor === "::" && _p118._1.ctor === "::")
      {
            return A2($List._op["::"],
            {ctor: "_Tuple2",_0: _p118._0._0,_1: _p118._1._0},
            A2(zip,_p118._0._1,_p118._1._1));
         } else {
            return _U.list([]);
         }
   });
   var mapi = F2(function (f,xs) {
      var n = $List.length(xs);
      return A2($List.map,f,A2(zip,_U.range(1,n),xs));
   });
   var foldli = F3(function (f,init,xs) {
      var n = $List.length(xs);
      return A3($List.foldl,f,init,A2(zip,_U.range(1,n),xs));
   });
   var foldri = F3(function (f,init,xs) {
      return $List.reverse(A3(foldli,f,init,xs));
   });
   var manySetDiffs = function (sets) {
      return A2(mapi,
      function (_p119) {
         var _p120 = _p119;
         return A3(foldli,
         F2(function (_p121,acc) {
            var _p122 = _p121;
            return _U.eq(_p120._0,_p122._0) ? acc : A2($Set.diff,
            acc,
            _p122._1);
         }),
         _p120._1,
         sets);
      },
      sets);
   };
   var cartProdWithDiff = function (_p123) {
      return oneOfEach(A2($List.map,
      $Set.toList,
      manySetDiffs(_p123)));
   };
   var filteri = F2(function (f,xs) {
      var n = $List.length(xs);
      return A2($List.map,
      $Basics.snd,
      A2($List.filter,f,A2(zip,_U.range(1,n),xs)));
   });
   var selfZipCircConsecPairs = function (list) {
      var shiftList = function () {
         var _p124 = list;
         if (_p124.ctor === "::") {
               return A2($Basics._op["++"],_p124._1,_U.list([_p124._0]));
            } else {
               return _U.list([]);
            }
      }();
      return A2(zip,list,shiftList);
   };
   var update = F2(function (_p125,vals) {
      var _p126 = _p125;
      var _p131 = _p126._1;
      var _p130 = _p126._0;
      var _p127 = vals;
      if (_p127.ctor === "[]") {
            return _U.list([]);
         } else {
            var _p129 = _p127._1;
            var _p128 = _p127._0._0;
            return _U.eq(_p128,_p130) ? A2($List._op["::"],
            {ctor: "_Tuple2",_0: _p128,_1: _p131},
            _p129) : A2($List._op["::"],
            {ctor: "_Tuple2",_0: _p128,_1: _p127._0._1},
            A2(update,{ctor: "_Tuple2",_0: _p130,_1: _p131},_p129));
         }
   });
   var maybeFind = F2(function (k,l) {
      maybeFind: while (true) {
         var _p132 = l;
         if (_p132.ctor === "[]") {
               return $Maybe.Nothing;
            } else {
               if (_U.eq(k,_p132._0._0)) return $Maybe.Just(_p132._0._1);
               else {
                     var _v69 = k,_v70 = _p132._1;
                     k = _v69;
                     l = _v70;
                     continue maybeFind;
                  }
            }
      }
   });
   var find = F3(function (err,d,k) {
      var _p133 = A2(maybeFind,k,d);
      if (_p133.ctor === "Just") {
            return _p133._0;
         } else {
            return _U.crashCase("Utils",
            {start: {line: 16,column: 3},end: {line: 18,column: 52}},
            _p133)(A2($Basics._op["++"],"Utils.find: ",err));
         }
   });
   var find_ = F2(function (d,k) {
      return A3(find,
      A2($Basics._op["++"],
      "[",
      A2($Basics._op["++"],$Basics.toString(k),"]")),
      d,
      k);
   });
   return _elm.Utils.values = {_op: _op
                              ,maybeFind: maybeFind
                              ,find: find
                              ,find_: find_
                              ,update: update
                              ,zip: zip
                              ,maybeZip: maybeZip
                              ,maybeZipDicts: maybeZipDicts
                              ,listsEqualBy: listsEqualBy
                              ,zeroElements: zeroElements
                              ,oneElement: oneElement
                              ,maybeZipN: maybeZipN
                              ,mapi: mapi
                              ,foldli: foldli
                              ,foldri: foldri
                              ,filteri: filteri
                              ,reverse2: reverse2
                              ,selfZipCircConsecPairs: selfZipCircConsecPairs
                              ,dedup: dedup
                              ,dedup_: dedup_
                              ,oneToOneMappingExists: oneToOneMappingExists
                              ,clamp: clamp
                              ,singleton: singleton
                              ,split: split
                              ,splitString: splitString
                              ,munchString: munchString
                              ,takeNLines: takeNLines
                              ,oneOfEach: oneOfEach
                              ,cartProdWithDiff: cartProdWithDiff
                              ,intersectMany: intersectMany
                              ,manySetDiffs: manySetDiffs
                              ,findFirst: findFirst
                              ,removeFirst: removeFirst
                              ,maybeRemoveFirst: maybeRemoveFirst
                              ,removeLastElement: removeLastElement
                              ,adjacentPairs: adjacentPairs
                              ,geti: geti
                              ,replacei: replacei
                              ,allSame: allSame
                              ,removeDupes: removeDupes
                              ,count: count
                              ,delimit: delimit
                              ,parens: parens
                              ,bracks: bracks
                              ,ibracks: ibracks
                              ,braces: braces
                              ,spaces: spaces
                              ,commas: commas
                              ,lines: lines
                              ,sum: sum
                              ,avg: avg
                              ,lift_2_2: lift_2_2
                              ,assert: assert
                              ,fromJust: fromJust
                              ,fromJust_: fromJust_
                              ,fromOkay: fromOkay
                              ,fromOk: fromOk
                              ,fromOk_: fromOk_
                              ,justGet: justGet
                              ,justGet_: justGet_
                              ,getWithDefault: getWithDefault
                              ,toggleSet: toggleSet
                              ,toggleDict: toggleDict
                              ,head_: head_
                              ,tail_: tail_
                              ,last_: last_
                              ,uncons: uncons
                              ,mapMaybe: mapMaybe
                              ,bindMaybe: bindMaybe
                              ,plusMaybe: plusMaybe
                              ,elseMaybe: elseMaybe
                              ,projJusts: projJusts
                              ,filterJusts: filterJusts
                              ,bindMaybe2: bindMaybe2
                              ,bindMaybe3: bindMaybe3
                              ,projOk: projOk
                              ,mapFst: mapFst
                              ,mapSnd: mapSnd
                              ,fst3: fst3
                              ,snd3: snd3
                              ,thd3: thd3
                              ,mapThd3: mapThd3
                              ,fourth4: fourth4
                              ,bindResult: bindResult
                              ,setIsEmpty: setIsEmpty
                              ,dictIsEmpty: dictIsEmpty
                              ,setCardinal: setCardinal
                              ,parseInt: parseInt
                              ,parseFloat: parseFloat
                              ,commonPrefix: commonPrefix
                              ,commonPrefix2: commonPrefix2
                              ,between: between
                              ,distance: distance
                              ,distanceInt: distanceInt
                              ,nothing: nothing
                              ,just: just
                              ,maybeToMaybeOne: maybeToMaybeOne
                              ,numToColor: numToColor
                              ,numToColor_: numToColor_
                              ,radiansToDegrees: radiansToDegrees
                              ,uniLeft: uniLeft
                              ,uniRight: uniRight
                              ,uniEnter: uniEnter
                              ,uniSave: uniSave
                              ,uniUndo: uniUndo
                              ,uniRedo: uniRedo
                              ,uniReload: uniReload
                              ,uniCamera: uniCamera
                              ,uniLambda: uniLambda
                              ,uniDelta: uniDelta
                              ,uniPlusMinus: uniPlusMinus
                              ,unwrap1: unwrap1
                              ,unwrap2: unwrap2
                              ,unwrap3: unwrap3
                              ,unwrap4: unwrap4
                              ,unwrap5: unwrap5
                              ,unwrap6: unwrap6
                              ,unwrap7: unwrap7};
};
Elm.OurParser2 = Elm.OurParser2 || {};
Elm.OurParser2.make = function (_elm) {
   "use strict";
   _elm.OurParser2 = _elm.OurParser2 || {};
   if (_elm.OurParser2.values) return _elm.OurParser2.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Ace = Elm.Ace.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Lazy = Elm.Lazy.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var runParser = function (p) {
      var _p0 = p;
      if (_p0.ctor === "P") {
            return _p0._0;
         } else {
            return $Lazy.force(_p0._0);
         }
   };
   var LazyP = function (a) {    return {ctor: "LazyP",_0: a};};
   var recursively = function (thunk) {
      return LazyP($Lazy.lazy(function (_p1) {
         return runParser(thunk({ctor: "_Tuple0"}));
      }));
   };
   var P = function (a) {    return {ctor: "P",_0: a};};
   var lookahead = function (looker) {
      return P(function (s) {
         var parses = A2(runParser,looker,s);
         return A2($List.map,
         function (_p2) {
            var _p3 = _p2;
            return {ctor: "_Tuple2",_0: _p3._0,_1: s};
         },
         parses);
      });
   };
   var lookafter = F2(function (p,looker) {
      return P(function (s) {
         return A2($List.filter,
         function (_p4) {
            var _p5 = _p4;
            return $Basics.not($List.isEmpty(A2(runParser,looker,_p5._1)));
         },
         A2(runParser,p,s));
      });
   });
   var fail = P($Basics.always(_U.list([])));
   var bind = F2(function (pa,f) {
      return P(function (s) {
         return A2($List.concatMap,
         function (_p6) {
            var _p7 = _p6;
            return A2(runParser,f(_p7._0),_p7._1);
         },
         A2(runParser,pa,s));
      });
   });
   var sequence = F2(function (p1,p2) {
      return A2(bind,p1,$Basics.always(p2));
   });
   _op[">>>"] = sequence;
   _op[">>="] = bind;
   var or = F2(function (p1,p2) {
      return P(function (s) {
         return A2($Basics._op["++"],
         A2(runParser,p1,s),
         A2(runParser,p2,s));
      });
   });
   var choice = function (ps) {
      var _p8 = ps;
      if (_p8.ctor === "[]") {
            return fail;
         } else {
            return A2(or,_p8._0,choice(_p8._1));
         }
   };
   _op["+++"] = or;
   var left_or = F2(function (p1,p2) {
      return P(function (s) {
         var _p9 = A2(runParser,p1,s);
         if (_p9.ctor === "[]") {
               return A2(runParser,p2,s);
            } else {
               return _p9;
            }
      });
   });
   _op["<++"] = left_or;
   var addOneChar = F2(function (c,start) {
      return _U.eq(c,_U.chr("\n")) ? {line: 1 + start.line
                                     ,col: 1} : _U.update(start,{col: 1 + start.col});
   });
   var offsetBy = F2(function (start,s) {
      return A3($List.foldl,addOneChar,start,$String.toList(s));
   });
   var strPos = function (p) {
      var _p10 = {ctor: "_Tuple2"
                 ,_0: $Basics.toString(p.line)
                 ,_1: $Basics.toString(p.col)};
      var i = _p10._0;
      var j = _p10._1;
      return A2($Basics._op["++"],
      "(Line:",
      A2($Basics._op["++"],
      i,
      A2($Basics._op["++"]," Col:",A2($Basics._op["++"],j,")"))));
   };
   var dummyPos = {line: -1,col: -1};
   var startPos = {line: 1,col: 1};
   var WithInfo = F3(function (a,b,c) {
      return {val: a,start: b,end: c};
   });
   var $return = function (x) {
      return P(function (s) {
         return _U.list([{ctor: "_Tuple2"
                         ,_0: A3(WithInfo,x,s.pos,s.pos)
                         ,_1: s}]);
      });
   };
   var option = F2(function ($default,p) {
      return A2(_op["<++"],p,$return($default));
   });
   var optional = function (p) {
      return A2(_op["<++"],
      A2(_op[">>>"],p,$return({ctor: "_Tuple0"})),
      $return({ctor: "_Tuple0"}));
   };
   var returnWithInfo = F3(function (x,start,end) {
      return P(function (s) {
         return _U.list([{ctor: "_Tuple2"
                         ,_0: A3(WithInfo,x,start,end)
                         ,_1: s}]);
      });
   });
   var between = F3(function (p1,p2,p) {
      return A2(_op[">>="],
      p1,
      function (a) {
         return A2(_op[">>="],
         p,
         function (x) {
            return A2(_op[">>="],
            p2,
            function (b) {
               return A3(returnWithInfo,x.val,a.start,b.end);
            });
         });
      });
   });
   var some = function (p) {
      return A2(_op[">>="],
      p,
      function (x) {
         return A2(_op[">>="],
         many(p),
         function (xs) {
            return A3(returnWithInfo,
            A2($List._op["::"],x,xs.val),
            x.start,
            xs.end);
         });
      });
   };
   var many = function (p) {
      return A2(_op["<++"],some(p),$return(_U.list([])));
   };
   var sepBy1 = F2(function (p,sep) {
      return A2(_op[">>="],
      p,
      function (x) {
         return A2(_op[">>="],
         many(A2(_op[">>>"],sep,p)),
         function (xs) {
            return A3(returnWithInfo,
            A2($List._op["::"],x,xs.val),
            x.start,
            xs.end);
         });
      });
   });
   var sepBy = F2(function (p,sep) {
      return A2(_op["<++"],A2(sepBy1,p,sep),$return(_U.list([])));
   });
   var map = F2(function (f,p) {
      return P(function (s) {
         return A2($List.map,
         function (_p11) {
            var _p12 = _p11;
            var _p13 = _p12._0;
            return {ctor: "_Tuple2"
                   ,_0: A3(WithInfo,f(_p13.val),_p13.start,_p13.end)
                   ,_1: _p12._1};
         },
         A2(runParser,p,s));
      });
   });
   _op["<$>"] = map;
   var WithPos = F2(function (a,b) {    return {val: a,pos: b};});
   var parse = F2(function (p,s) {
      var _p14 = A2(runParser,p,A2(WithPos,s,startPos));
      if (_p14.ctor === "::") {
            if (_p14._0.ctor === "_Tuple2" && _p14._1.ctor === "[]") {
                  var _p16 = _p14._0._1.val;
                  var _p15 = _p14._0._0;
                  if (_U.eq(_p16,"")) return $Result.Ok(_p15); else {
                        var previewSuffix = A2($Utils.takeNLines,10,_p16);
                        var err = A2($Basics._op["++"],
                        "incomplete parse, next unparsed: \n",
                        previewSuffix);
                        var text = $Utils.lines(_U.list([A2($Basics._op["++"],
                                                        "Successfully parsed up until: ",
                                                        A2($Basics._op["++"],strPos(_p15.end),"\n"))
                                                        ,"Here\'s where things start to go wrong:\n"
                                                        ,previewSuffix
                                                        ,"\n..."]));
                        return $Result.Err({ctor: "_Tuple2"
                                           ,_0: err
                                           ,_1: {row: _p15.end.line - 1,type_: "error",text: text}});
                     }
               } else {
                  var err = A2($Basics._op["++"],
                  "ambiguous parse\n\n",
                  $Basics.toString(A2($List.map,
                  function (_p17) {
                     return function (_) {
                        return _.val;
                     }($Basics.fst(_p17));
                  },
                  _p14)));
                  return $Result.Err({ctor: "_Tuple2"
                                     ,_0: err
                                     ,_1: {row: 0
                                          ,type_: "error"
                                          ,text: "Parse Error... ambiguous..."}});
               }
         } else {
            var err = A2($Basics._op["++"],"no parse\n\n",s);
            return $Result.Err({ctor: "_Tuple2"
                               ,_0: err
                               ,_1: {row: 0,type_: "error",text: "Parse Error..."}});
         }
   });
   var satisfy = function (f) {
      return P(function (s) {
         var _p18 = $String.uncons(s.val);
         if (_p18.ctor === "Just") {
               var _p19 = _p18._0._0;
               if ($Basics.not(f(_p19))) return _U.list([]); else {
                     var start = s.pos;
                     var end = A2(offsetBy,start,$String.fromChar(_p19));
                     return _U.list([{ctor: "_Tuple2"
                                     ,_0: A3(WithInfo,_p19,start,end)
                                     ,_1: A2(WithPos,_p18._0._1,end)}]);
                  }
            } else {
               return _U.list([]);
            }
      });
   };
   var $char = function (c) {
      return satisfy(F2(function (x,y) {
         return _U.eq(x,y);
      })(c));
   };
   var string = function (str) {
      return P(function (s) {
         if ($Basics.not(A2($String.startsWith,str,s.val)))
         return _U.list([]); else {
               var n = $String.length(str);
               var start = s.pos;
               var end = A2(offsetBy,start,str);
               return _U.list([{ctor: "_Tuple2"
                               ,_0: A3(WithInfo,str,start,end)
                               ,_1: A2(WithPos,A2($String.dropLeft,n,s.val),end)}]);
            }
      });
   };
   var token = function (_p20) {
      return A2(map,
      $Basics.always({ctor: "_Tuple0"}),
      string(_p20));
   };
   var end = token("");
   var munch = function (f) {
      return P(function (s) {
         var walk = F2(function (acc,s) {
            walk: while (true) {
               var _p21 = $String.uncons(s);
               if (_p21.ctor === "Nothing") {
                     return {ctor: "_Tuple2",_0: $String.reverse(acc),_1: s};
                  } else {
                     var _p22 = _p21._0._0;
                     if (f(_p22)) {
                           var _v10 = A2($String.cons,_p22,acc),_v11 = _p21._0._1;
                           acc = _v10;
                           s = _v11;
                           continue walk;
                        } else return {ctor: "_Tuple2",_0: $String.reverse(acc),_1: s};
                  }
            }
         });
         var _p23 = A2(walk,"",s.val);
         var pre = _p23._0;
         var suf = _p23._1;
         var start = s.pos;
         var end = A2(offsetBy,start,pre);
         return _U.list([{ctor: "_Tuple2"
                         ,_0: A3(WithInfo,pre,start,end)
                         ,_1: A2(WithPos,suf,end)}]);
      });
   };
   var munch1 = function (f) {
      return P(function (s) {
         var _p24 = A2(runParser,munch(f),s);
         if (_p24.ctor === "::" && _p24._0.ctor === "_Tuple2" && _p24._1.ctor === "[]")
         {
               var _p25 = _p24._0._1;
               return _U.eq(s,_p25) ? _U.list([]) : _U.list([{ctor: "_Tuple2"
                                                             ,_0: _p24._0._0
                                                             ,_1: _p25}]);
            } else {
               return _U.crashCase("OurParser2",
               {start: {line: 144,column: 3},end: {line: 150,column: 27}},
               _p24)("munch1");
            }
      });
   };
   var Pos = F2(function (a,b) {    return {line: a,col: b};});
   return _elm.OurParser2.values = {_op: _op
                                   ,Pos: Pos
                                   ,WithPos: WithPos
                                   ,WithInfo: WithInfo
                                   ,startPos: startPos
                                   ,dummyPos: dummyPos
                                   ,strPos: strPos
                                   ,offsetBy: offsetBy
                                   ,addOneChar: addOneChar
                                   ,P: P
                                   ,LazyP: LazyP
                                   ,recursively: recursively
                                   ,runParser: runParser
                                   ,parse: parse
                                   ,satisfy: satisfy
                                   ,$char: $char
                                   ,lookahead: lookahead
                                   ,lookafter: lookafter
                                   ,string: string
                                   ,token: token
                                   ,end: end
                                   ,fail: fail
                                   ,munch: munch
                                   ,munch1: munch1
                                   ,choice: choice
                                   ,between: between
                                   ,option: option
                                   ,optional: optional
                                   ,many: many
                                   ,some: some
                                   ,sepBy: sepBy
                                   ,sepBy1: sepBy1
                                   ,$return: $return
                                   ,returnWithInfo: returnWithInfo
                                   ,bind: bind
                                   ,sequence: sequence
                                   ,or: or
                                   ,left_or: left_or
                                   ,map: map};
};
Elm.Lang = Elm.Lang || {};
Elm.Lang.make = function (_elm) {
   "use strict";
   _elm.Lang = _elm.Lang || {};
   if (_elm.Lang.values) return _elm.Lang.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $OurParser2 = Elm.OurParser2.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var maxNumTr = F2(function (_p1,_p0) {
      var _p2 = _p1;
      var _p5 = _p2._0;
      var _p3 = _p0;
      var _p4 = _p3._0;
      return _U.cmp(_p5,_p4) > -1 ? {ctor: "_Tuple2"
                                    ,_0: _p5
                                    ,_1: _p2._1} : {ctor: "_Tuple2",_0: _p4,_1: _p3._1};
   });
   var minNumTr = F2(function (_p7,_p6) {
      var _p8 = _p7;
      var _p11 = _p8._0;
      var _p9 = _p6;
      var _p10 = _p9._0;
      return _U.cmp(_p11,_p10) < 1 ? {ctor: "_Tuple2"
                                     ,_0: _p11
                                     ,_1: _p8._1} : {ctor: "_Tuple2",_0: _p10,_1: _p9._1};
   });
   var minMaxNumTr = F2(function (nt1,nt2) {
      return {ctor: "_Tuple2"
             ,_0: A2(minNumTr,nt1,nt2)
             ,_1: A2(maxNumTr,nt1,nt2)};
   });
   var minMax = F2(function (x,y) {
      return {ctor: "_Tuple2"
             ,_0: A2($Basics.min,x,y)
             ,_1: A2($Basics.max,x,y)};
   });
   var unwrapVBaseString_ = F2(function (s,v_) {
      var _p12 = v_;
      if (_p12.ctor === "VBase" && _p12._0.ctor === "VString") {
            return _p12._0._0;
         } else {
            return _U.crashCase("Lang",
            {start: {line: 662,column: 27},end: {line: 664,column: 66}},
            _p12)(A2($Basics._op["++"],"unwrapVBaseString_: ",s));
         }
   });
   var unwrapVList_ = F2(function (s,v) {
      var _p14 = v.v_;
      if (_p14.ctor === "VList") {
            return A2($List.map,function (_) {    return _.v_;},_p14._0);
         } else {
            return _U.crashCase("Lang",
            {start: {line: 657,column: 20},end: {line: 659,column: 51}},
            _p14)(A2($Basics._op["++"],"unwrapVList_: ",s));
         }
   });
   var unwrapVList = function (v) {
      var _p16 = v.v_;
      if (_p16.ctor === "VList") {
            return $Maybe.Just(A2($List.map,
            function (_) {
               return _.v_;
            },
            _p16._0));
         } else {
            return $Maybe.Nothing;
         }
   };
   var dummyLoc_ = function (b) {
      return {ctor: "_Tuple3",_0: 0,_1: b,_2: ""};
   };
   var replaceE__ = F2(function (e,e__) {
      var e_ = e.val;
      return _U.update(e,{val: _U.update(e_,{e__: e__})});
   });
   var withDummyRange = function (x) {
      return A3($OurParser2.WithInfo,
      x,
      $OurParser2.dummyPos,
      $OurParser2.dummyPos);
   };
   var rangeSlider = F3(function (kind,a,b) {
      return withDummyRange(A4(kind,
      withDummyRange(a),
      withDummyRange("-"),
      withDummyRange(b),
      $Maybe.Nothing));
   });
   var strPos = $OurParser2.strPos;
   var errorPrefix = "[Little Error]";
   var crashWithMsg = function (s) {
      return _U.crash("Lang",
      {start: {line: 558,column: 19}
      ,end: {line: 558,column: 30}})(A2($Basics._op["++"],
      errorPrefix,
      A2($Basics._op["++"],"\n\n",s)));
   };
   var errorMsg = function (s) {
      return $Result.Err(A2($Basics._op["++"],
      errorPrefix,
      A2($Basics._op["++"],"\n\n",s)));
   };
   var getOptions = function (e) {
      getOptions: while (true) {
         var _p17 = e.val.e__;
         switch (_p17.ctor)
         {case "EOption": return A2($List._op["::"],
              {ctor: "_Tuple2",_0: _p17._1.val,_1: _p17._3.val},
              getOptions(_p17._4));
            case "EComment": var _v8 = _p17._2;
              e = _v8;
              continue getOptions;
            default: return _U.list([]);}
      }
   };
   var varsOfPat = function (pat) {
      var _p18 = pat.val;
      switch (_p18.ctor)
      {case "PConst": return _U.list([]);
         case "PBase": return _U.list([]);
         case "PVar": return _U.list([_p18._1]);
         case "PList": if (_p18._3.ctor === "Nothing") {
                 return A2($List.concatMap,varsOfPat,_p18._1);
              } else {
                 return A2($List.concatMap,
                 varsOfPat,
                 A2($List._op["::"],_p18._3._0,_p18._1));
              }
         default: return A2($List._op["::"],_p18._1,varsOfPat(_p18._3));}
   };
   var isScope = F2(function (maybeParent,exp) {
      var isObviouslyScope = function () {
         var _p19 = exp.val.e__;
         switch (_p19.ctor)
         {case "ELet": return true;
            case "EFun": return true;
            default: return false;}
      }();
      var _p20 = maybeParent;
      if (_p20.ctor === "Just") {
            var _p21 = _p20._0.val.e__;
            if (_p21.ctor === "ECase") {
                  return !_U.eq(_p21._1,exp);
               } else {
                  return isObviouslyScope;
               }
         } else {
            return isObviouslyScope;
         }
   });
   var branchPats = function (branches) {
      return A2($List.map,
      function (b) {
         var _p22 = b.val;
         var pat = _p22._1;
         return pat;
      },
      branches);
   };
   var tbranchExps = function (tbranches) {
      return A2($List.map,
      function (b) {
         var _p23 = b.val;
         var exp = _p23._2;
         return exp;
      },
      tbranches);
   };
   var branchExps = function (branches) {
      return A2($List.map,
      function (b) {
         var _p24 = b.val;
         var exp = _p24._2;
         return exp;
      },
      branches);
   };
   var TwoSubsts = F2(function (a,b) {
      return {lsubst: a,esubst: b};
   });
   var valToTrace = function (v) {
      var _p25 = v.v_;
      if (_p25.ctor === "VConst" && _p25._0.ctor === "_Tuple2") {
            return _p25._0._1;
         } else {
            return _U.crashCase("Lang",
            {start: {line: 427,column: 16},end: {line: 429,column: 48}},
            _p25)("valToTrace");
         }
   };
   var childExps = function (e) {
      var _p27 = e.val.e__;
      switch (_p27.ctor)
      {case "EConst": return _U.list([]);
         case "EBase": return _U.list([]);
         case "EVar": return _U.list([]);
         case "EFun": return _U.list([_p27._2]);
         case "EOp": return _p27._2;
         case "EList": var _p29 = _p27._1;
           var _p28 = _p27._3;
           if (_p28.ctor === "Just") {
                 return A2($Basics._op["++"],_p29,_U.list([_p28._0]));
              } else {
                 return _p29;
              }
         case "EApp": return A2($List._op["::"],_p27._1,_p27._2);
         case "ELet": return _U.list([_p27._4,_p27._5]);
         case "EIf": return _U.list([_p27._1,_p27._2,_p27._3]);
         case "ECase": return A2($List._op["::"],
           _p27._1,
           branchExps(_p27._2));
         case "ETypeCase": return tbranchExps(_p27._2);
         case "EComment": return _U.list([_p27._2]);
         case "EOption": return _U.list([_p27._4]);
         case "ETyp": return _U.list([_p27._3]);
         case "EColonType": return _U.list([_p27._1]);
         default: return _U.list([_p27._3]);}
   };
   var findAllWithAncestors_ = F3(function (predicate,
   ancestors,
   exp) {
      var ancestorsAndThis = A2($Basics._op["++"],
      ancestors,
      _U.list([exp]));
      var thisResult = predicate(exp) ? _U.list([ancestorsAndThis]) : _U.list([]);
      var recurse = function (exp) {
         return A3(findAllWithAncestors_,
         predicate,
         ancestorsAndThis,
         exp);
      };
      return A2($Basics._op["++"],
      thisResult,
      A2($List.concatMap,recurse,childExps(exp)));
   });
   var findAllWithAncestors = F2(function (predicate,exp) {
      return A3(findAllWithAncestors_,predicate,_U.list([]),exp);
   });
   var flattenExpTree = function (exp) {
      return A2($List._op["::"],
      exp,
      A2($List.concatMap,flattenExpTree,childExps(exp)));
   };
   var foldType = F3(function (f,tipe,acc) {
      var foldTypes = F3(function (f,tipes,acc) {
         return A3($List.foldl,
         F2(function (t,acc) {    return A3(foldType,f,t,acc);}),
         acc,
         tipes);
      });
      var _p30 = tipe.val;
      switch (_p30.ctor)
      {case "TNum": return A2(f,tipe,acc);
         case "TBool": return A2(f,tipe,acc);
         case "TString": return A2(f,tipe,acc);
         case "TNull": return A2(f,tipe,acc);
         case "TNamed": return A2(f,tipe,acc);
         case "TVar": return A2(f,tipe,acc);
         case "TWildcard": return A2(f,tipe,acc);
         case "TList": return A2(f,tipe,A3(foldType,f,_p30._1,acc));
         case "TDict": return A2(f,
           tipe,
           A3(foldType,f,_p30._2,A3(foldType,f,_p30._1,acc)));
         case "TForall": return A2(f,tipe,A3(foldType,f,_p30._2,acc));
         case "TArrow": return A2(f,tipe,A3(foldTypes,f,_p30._1,acc));
         case "TUnion": return A2(f,tipe,A3(foldTypes,f,_p30._1,acc));
         default: if (_p30._3.ctor === "Nothing") {
                 return A2(f,tipe,A3(foldTypes,f,_p30._1,acc));
              } else {
                 return A2(f,
                 tipe,
                 A3(foldTypes,
                 f,
                 A2($Basics._op["++"],_p30._1,_U.list([_p30._3._0])),
                 acc));
              }}
   });
   var foldExp = F3(function (f,acc,exp) {
      return A3($List.foldl,f,acc,flattenExpTree(exp));
   });
   var foldExpViaE__ = F3(function (f,acc,exp) {
      var f$ = function (exp) {    return f(exp.val.e__);};
      return A3(foldExp,f$,acc,exp);
   });
   var foldVal = F3(function (f,v,a) {
      var _p31 = v.v_;
      switch (_p31.ctor)
      {case "VList": return A2(f,
           v,
           A3($List.foldl,foldVal(f),a,_p31._0));
         case "VDict": return A2(f,
           v,
           A3($List.foldl,foldVal(f),a,$Dict.values(_p31._0)));
         case "VConst": return A2(f,v,a);
         case "VBase": return A2(f,v,a);
         default: return A2(f,v,a);}
   });
   var mapValField = F2(function (f,r) {
      return _U.update(r,{val: f(r.val)});
   });
   var isLet = function (e) {
      isLet: while (true) {
         var _p32 = e.val.e__;
         switch (_p32.ctor)
         {case "ELet": return true;
            case "EComment": var _v19 = _p32._2;
              e = _v19;
              continue isLet;
            default: return false;}
      }
   };
   var fitsOnLine = function (s) {
      return _U.cmp($String.length(s),
      70) > 0 ? false : A2($List.member,
      _U.chr("\n"),
      $String.toList(s)) ? false : true;
   };
   var tab = function (k) {    return A2($String.repeat,k,"  ");};
   var strLoc = function (_p33) {
      var _p34 = _p33;
      var _p35 = _p34._2;
      return A2($Basics._op["++"],
      "k",
      A2($Basics._op["++"],
      $Basics.toString(_p34._0),
      A2($Basics._op["++"],
      _U.eq(_p35,"") ? "" : A2($Basics._op["++"],"_",_p35),
      _p34._1)));
   };
   var strOp = function (op) {
      var _p36 = op;
      switch (_p36.ctor)
      {case "Plus": return "+";
         case "Minus": return "-";
         case "Mult": return "*";
         case "Div": return "/";
         case "Lt": return "<";
         case "Eq": return "=";
         case "Pi": return "pi";
         case "Cos": return "cos";
         case "Sin": return "sin";
         case "ArcCos": return "arccos";
         case "ArcSin": return "arcsin";
         case "ArcTan2": return "arctan2";
         case "Floor": return "floor";
         case "Ceil": return "ceiling";
         case "Round": return "round";
         case "ToStr": return "toString";
         case "Explode": return "explode";
         case "Sqrt": return "sqrt";
         case "Mod": return "mod";
         case "Pow": return "pow";
         case "DictEmpty": return "empty";
         case "DictInsert": return "insert";
         case "DictGet": return "get";
         case "DictRemove": return "remove";
         default: return "debug";}
   };
   var strTrace = function (tr) {
      var _p37 = tr;
      if (_p37.ctor === "TrLoc") {
            return strLoc(_p37._0);
         } else {
            return $Utils.parens($String.concat(_U.list([strOp(_p37._0)
                                                        ," "
                                                        ,A2($String.join," ",A2($List.map,strTrace,_p37._1))])));
         }
   };
   var strNum = $Basics.toString;
   var strNumTrunc = function (k) {
      return function (_p38) {
         return function (s) {
            return _U.cmp($String.length(s),
            k) > 0 ? A2($Basics._op["++"],A2($String.left,k,s),"..") : s;
         }(strNum(_p38));
      };
   };
   var strBaseVal = function (v) {
      var _p39 = v;
      switch (_p39.ctor)
      {case "VBool": if (_p39._0 === true) {
                 return "true";
              } else {
                 return "false";
              }
         case "VString": return A2($Basics._op["++"],
           "\'",
           A2($Basics._op["++"],_p39._0,"\'"));
         default: return "null";}
   };
   var strVal_ = F2(function (showTraces,v) {
      var foo = strVal_(showTraces);
      var sTrace = showTraces ? $Utils.braces($Basics.toString(v.vtrace)) : "";
      return A2($Basics._op["++"],
      sTrace,
      function () {
         var _p40 = v.v_;
         switch (_p40.ctor)
         {case "VConst": return A2($Basics._op["++"],
              strNum(_p40._0._0),
              showTraces ? $Utils.braces(strTrace(_p40._0._1)) : "");
            case "VBase": return strBaseVal(_p40._0);
            case "VClosure": return "<fun>";
            case "VList": return $Utils.bracks(A2($String.join,
              " ",
              A2($List.map,foo,_p40._0)));
            default: return A2($Basics._op["++"],
              "<dict ",
              A2($Basics._op["++"],
              A2($String.join,
              " ",
              A2($List.map,
              function (_p41) {
                 var _p42 = _p41;
                 return A2($Basics._op["++"],
                 $Basics.toString(_p42._0),
                 A2($Basics._op["++"],":",foo(_p42._1)));
              },
              $Dict.toList(_p40._0))),
              ">"));}
      }());
   });
   var strVal = strVal_(false);
   var strValLocs = strVal_(true);
   var TrOp = F2(function (a,b) {
      return {ctor: "TrOp",_0: a,_1: b};
   });
   var TrLoc = function (a) {    return {ctor: "TrLoc",_0: a};};
   var dummyTrace_ = function (b) {
      return TrLoc(dummyLoc_(b));
   };
   var ENull = {ctor: "ENull"};
   var EString = F2(function (a,b) {
      return {ctor: "EString",_0: a,_1: b};
   });
   var EBool = function (a) {    return {ctor: "EBool",_0: a};};
   var VNull = {ctor: "VNull"};
   var VString = function (a) {
      return {ctor: "VString",_0: a};
   };
   var VBool = function (a) {    return {ctor: "VBool",_0: a};};
   var defaultQuoteChar = "\'";
   var VDict = function (a) {    return {ctor: "VDict",_0: a};};
   var VList = function (a) {    return {ctor: "VList",_0: a};};
   var mapVal = F2(function (f,v) {
      var _p43 = v.v_;
      switch (_p43.ctor)
      {case "VList": return f(_U.update(v,
           {v_: VList(A2($List.map,mapVal(f),_p43._0))}));
         case "VDict": return f(_U.update(v,
           {v_: VDict(A2($Dict.map,
           F2(function (_p44,v) {    return A2(mapVal,f,v);}),
           _p43._0))}));
         case "VConst": return f(v);
         case "VBase": return f(v);
         default: return f(v);}
   });
   var VClosure = F4(function (a,b,c,d) {
      return {ctor: "VClosure",_0: a,_1: b,_2: c,_3: d};
   });
   var VBase = function (a) {    return {ctor: "VBase",_0: a};};
   var VConst = function (a) {    return {ctor: "VConst",_0: a};};
   var Val = F2(function (a,b) {    return {v_: a,vtrace: b};});
   var val = A2($Basics.flip,Val,_U.list([-1]));
   var vBool = function (_p45) {
      return val(VBase(VBool(_p45)));
   };
   var vTrue = vBool(true);
   var vFalse = vBool(false);
   var vStr = function (_p46) {
      return val(VBase(VString(_p46)));
   };
   var vConst = function (_p47) {    return val(VConst(_p47));};
   var vBase = function (_p48) {    return val(VBase(_p48));};
   var vList = function (_p49) {    return val(VList(_p49));};
   var vDict = function (_p50) {    return val(VDict(_p50));};
   var WPointSlider = F2(function (a,b) {
      return {ctor: "WPointSlider",_0: a,_1: b};
   });
   var WNumSlider = F5(function (a,b,c,d,e) {
      return {ctor: "WNumSlider",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var WIntSlider = F5(function (a,b,c,d,e) {
      return {ctor: "WIntSlider",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var NoWidgetDecl = {ctor: "NoWidgetDecl"};
   var noWidgetDecl = withDummyRange(NoWidgetDecl);
   var NumSlider = F4(function (a,b,c,d) {
      return {ctor: "NumSlider",_0: a,_1: b,_2: c,_3: d};
   });
   var numSlider = rangeSlider(NumSlider);
   var IntSlider = F4(function (a,b,c,d) {
      return {ctor: "IntSlider",_0: a,_1: b,_2: c,_3: d};
   });
   var intSlider = rangeSlider(IntSlider);
   var colorNumberSlider = A2(intSlider,0,499);
   var Def = {ctor: "Def"};
   var Let = {ctor: "Let"};
   var TBranch_ = F4(function (a,b,c,d) {
      return {ctor: "TBranch_",_0: a,_1: b,_2: c,_3: d};
   });
   var Branch_ = F4(function (a,b,c,d) {
      return {ctor: "Branch_",_0: a,_1: b,_2: c,_3: d};
   });
   var Many = F3(function (a,b,c) {
      return {ctor: "Many",_0: a,_1: b,_2: c};
   });
   var One = function (a) {    return {ctor: "One",_0: a};};
   var TWildcard = function (a) {
      return {ctor: "TWildcard",_0: a};
   };
   var TForall = F4(function (a,b,c,d) {
      return {ctor: "TForall",_0: a,_1: b,_2: c,_3: d};
   });
   var TVar = F2(function (a,b) {
      return {ctor: "TVar",_0: a,_1: b};
   });
   var TNamed = F2(function (a,b) {
      return {ctor: "TNamed",_0: a,_1: b};
   });
   var TUnion = F3(function (a,b,c) {
      return {ctor: "TUnion",_0: a,_1: b,_2: c};
   });
   var TArrow = F3(function (a,b,c) {
      return {ctor: "TArrow",_0: a,_1: b,_2: c};
   });
   var TTuple = F5(function (a,b,c,d,e) {
      return {ctor: "TTuple",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var TDict = F4(function (a,b,c,d) {
      return {ctor: "TDict",_0: a,_1: b,_2: c,_3: d};
   });
   var TList = F3(function (a,b,c) {
      return {ctor: "TList",_0: a,_1: b,_2: c};
   });
   var mapType = F2(function (f,tipe) {
      var recurse = mapType(f);
      var wrap = function (t_) {
         return A3($OurParser2.WithInfo,t_,tipe.start,tipe.end);
      };
      var _p51 = tipe.val;
      switch (_p51.ctor)
      {case "TNum": return f(tipe);
         case "TBool": return f(tipe);
         case "TString": return f(tipe);
         case "TNull": return f(tipe);
         case "TNamed": return f(tipe);
         case "TVar": return f(tipe);
         case "TWildcard": return f(tipe);
         case "TList": return f(wrap(A3(TList,
           _p51._0,
           recurse(_p51._1),
           _p51._2)));
         case "TDict": return f(wrap(A4(TDict,
           _p51._0,
           recurse(_p51._1),
           recurse(_p51._2),
           _p51._3)));
         case "TArrow": return f(wrap(A3(TArrow,
           _p51._0,
           A2($List.map,recurse,_p51._1),
           _p51._2)));
         case "TUnion": return f(wrap(A3(TUnion,
           _p51._0,
           A2($List.map,recurse,_p51._1),
           _p51._2)));
         case "TForall": return f(wrap(A4(TForall,
           _p51._0,
           _p51._1,
           recurse(_p51._2),
           _p51._3)));
         default: return f(wrap(A5(TTuple,
           _p51._0,
           A2($List.map,recurse,_p51._1),
           _p51._2,
           A2($Utils.mapMaybe,recurse,_p51._3),
           _p51._4)));}
   });
   var TNull = function (a) {    return {ctor: "TNull",_0: a};};
   var TString = function (a) {
      return {ctor: "TString",_0: a};
   };
   var TBool = function (a) {    return {ctor: "TBool",_0: a};};
   var TNum = function (a) {    return {ctor: "TNum",_0: a};};
   var ETypeAlias = F5(function (a,b,c,d,e) {
      return {ctor: "ETypeAlias",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var EColonType = F5(function (a,b,c,d,e) {
      return {ctor: "EColonType",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var ETyp = F5(function (a,b,c,d,e) {
      return {ctor: "ETyp",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var EOption = F5(function (a,b,c,d,e) {
      return {ctor: "EOption",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var EComment = F3(function (a,b,c) {
      return {ctor: "EComment",_0: a,_1: b,_2: c};
   });
   var ELet = F7(function (a,b,c,d,e,f,g) {
      return {ctor: "ELet"
             ,_0: a
             ,_1: b
             ,_2: c
             ,_3: d
             ,_4: e
             ,_5: f
             ,_6: g};
   });
   var ETypeCase = F4(function (a,b,c,d) {
      return {ctor: "ETypeCase",_0: a,_1: b,_2: c,_3: d};
   });
   var ECase = F4(function (a,b,c,d) {
      return {ctor: "ECase",_0: a,_1: b,_2: c,_3: d};
   });
   var EIf = F5(function (a,b,c,d,e) {
      return {ctor: "EIf",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var EList = F5(function (a,b,c,d,e) {
      return {ctor: "EList",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var EOp = F4(function (a,b,c,d) {
      return {ctor: "EOp",_0: a,_1: b,_2: c,_3: d};
   });
   var EApp = F4(function (a,b,c,d) {
      return {ctor: "EApp",_0: a,_1: b,_2: c,_3: d};
   });
   var EFun = F4(function (a,b,c,d) {
      return {ctor: "EFun",_0: a,_1: b,_2: c,_3: d};
   });
   var EVar = F2(function (a,b) {
      return {ctor: "EVar",_0: a,_1: b};
   });
   var eRaw__ = EVar;
   var EBase = F2(function (a,b) {
      return {ctor: "EBase",_0: a,_1: b};
   });
   var EConst = F4(function (a,b,c,d) {
      return {ctor: "EConst",_0: a,_1: b,_2: c,_3: d};
   });
   var Exp_ = F2(function (a,b) {    return {e__: a,eid: b};});
   var mapExp = F2(function (f,e) {
      var recurse = mapExp(f);
      var wrap = function (e__) {
         return A3($OurParser2.WithInfo,
         A2(Exp_,e__,e.val.eid),
         e.start,
         e.end);
      };
      var wrapAndMap = function (_p52) {    return f(wrap(_p52));};
      var _p53 = e.val.e__;
      switch (_p53.ctor)
      {case "EConst": return f(e);
         case "EBase": return f(e);
         case "EVar": return f(e);
         case "EFun": return wrapAndMap(A4(EFun,
           _p53._0,
           _p53._1,
           recurse(_p53._2),
           _p53._3));
         case "EApp": return wrapAndMap(A4(EApp,
           _p53._0,
           recurse(_p53._1),
           A2($List.map,recurse,_p53._2),
           _p53._3));
         case "EOp": return wrapAndMap(A4(EOp,
           _p53._0,
           _p53._1,
           A2($List.map,recurse,_p53._2),
           _p53._3));
         case "EList": return wrapAndMap(A5(EList,
           _p53._0,
           A2($List.map,recurse,_p53._1),
           _p53._2,
           A2($Utils.mapMaybe,recurse,_p53._3),
           _p53._4));
         case "EIf": return wrapAndMap(A5(EIf,
           _p53._0,
           recurse(_p53._1),
           recurse(_p53._2),
           recurse(_p53._3),
           _p53._4));
         case "ECase": var newE1 = recurse(_p53._1);
           var newBranches = A2($List.map,
           mapValField(function (_p54) {
              var _p55 = _p54;
              return A4(Branch_,_p55._0,_p55._1,recurse(_p55._2),_p55._3);
           }),
           _p53._2);
           return wrapAndMap(A4(ECase,_p53._0,newE1,newBranches,_p53._3));
         case "ETypeCase": var newBranches = A2($List.map,
           mapValField(function (_p56) {
              var _p57 = _p56;
              return A4(TBranch_,_p57._0,_p57._1,recurse(_p57._2),_p57._3);
           }),
           _p53._2);
           return wrapAndMap(A4(ETypeCase,
           _p53._0,
           _p53._1,
           newBranches,
           _p53._3));
         case "EComment": return wrapAndMap(A3(EComment,
           _p53._0,
           _p53._1,
           recurse(_p53._2)));
         case "EOption": return wrapAndMap(A5(EOption,
           _p53._0,
           _p53._1,
           _p53._2,
           _p53._3,
           recurse(_p53._4)));
         case "ELet": return wrapAndMap(A7(ELet,
           _p53._0,
           _p53._1,
           _p53._2,
           _p53._3,
           recurse(_p53._4),
           recurse(_p53._5),
           _p53._6));
         case "ETyp": return wrapAndMap(A5(ETyp,
           _p53._0,
           _p53._1,
           _p53._2,
           recurse(_p53._3),
           _p53._4));
         case "EColonType": return wrapAndMap(A5(EColonType,
           _p53._0,
           recurse(_p53._1),
           _p53._2,
           _p53._3,
           _p53._4));
         default: return wrapAndMap(A5(ETypeAlias,
           _p53._0,
           _p53._1,
           _p53._2,
           recurse(_p53._3),
           _p53._4));}
   });
   var mapExpViaExp__ = F2(function (f,e) {
      var wrap = function (e__) {
         return A3($OurParser2.WithInfo,
         A2(Exp_,e__,e.val.eid),
         e.start,
         e.end);
      };
      var f$ = function (exp) {    return wrap(f(exp.val.e__));};
      return A2(mapExp,f$,e);
   });
   var applySubst = F2(function (subst,exp) {
      var replacer = function (e) {
         var e__ = e.val.e__;
         var e__ConstReplaced = function () {
            var _p58 = e__;
            if (_p58.ctor === "EConst") {
                  var _p60 = _p58._2;
                  var locId = $Utils.fst3(_p60);
                  var _p59 = A2($Dict.get,locId,subst.lsubst);
                  if (_p59.ctor === "Just") {
                        return A4(EConst,_p58._0,_p59._0,_p60,_p58._3);
                     } else {
                        return e__;
                     }
               } else {
                  return e__;
               }
         }();
         var e__$ = function () {
            var _p61 = A2($Dict.get,e.val.eid,subst.esubst);
            if (_p61.ctor === "Just") {
                  return _p61._0;
               } else {
                  return e__ConstReplaced;
               }
         }();
         return A3($OurParser2.WithInfo,
         A2(Exp_,e__$,e.val.eid),
         e.start,
         e.end);
      };
      return A2(mapExp,replacer,exp);
   });
   var applyLocSubst = function (s) {
      return applySubst({lsubst: s,esubst: $Dict.empty});
   };
   var applyESubst = function (s) {
      return applySubst({lsubst: $Dict.empty,esubst: s});
   };
   var replaceExpNode = F3(function (oldNode,newNode,root) {
      var esubst = A2($Dict.singleton,
      oldNode.val.eid,
      newNode.val.e__);
      return A2(applyESubst,esubst,root);
   });
   var exp_ = A2($Basics.flip,Exp_,-1);
   var withDummyPos = function (e__) {
      return A3($OurParser2.WithInfo,
      exp_(e__),
      $OurParser2.dummyPos,
      $OurParser2.dummyPos);
   };
   var eBool = function (_p62) {
      return withDummyPos(A2(EBase," ",EBool(_p62)));
   };
   var eTrue = eBool(true);
   var eFalse = eBool(false);
   var eStr = function (_p63) {
      return withDummyPos(A2(EBase,
      " ",
      A2(EString,defaultQuoteChar,_p63)));
   };
   var eStr0 = function (_p64) {
      return withDummyPos(A2(EBase,
      "",
      A2(EString,defaultQuoteChar,_p64)));
   };
   var eApp = F2(function (e,es) {
      eApp: while (true) {
         var _p65 = es;
         if (_p65.ctor === "[]") {
               return _U.crashCase("Lang",
               {start: {line: 596,column: 13},end: {line: 599,column: 59}},
               _p65)("eApp");
            } else {
               if (_p65._1.ctor === "[]") {
                     return withDummyPos(A4(EApp,"\n",e,_U.list([_p65._0]),""));
                  } else {
                     var _v35 = withDummyPos(A4(EApp,
                     " ",
                     e,
                     _U.list([_p65._0]),
                     "")),
                     _v36 = _p65._1;
                     e = _v35;
                     es = _v36;
                     continue eApp;
                  }
            }
      }
   });
   var eFun = F2(function (ps,e) {
      var _p67 = ps;
      if (_p67.ctor === "[]") {
            return _U.crashCase("Lang",
            {start: {line: 601,column: 13},end: {line: 604,column: 58}},
            _p67)("eFun");
         } else {
            if (_p67._1.ctor === "[]") {
                  return withDummyPos(A4(EFun," ",_U.list([_p67._0]),e,""));
               } else {
                  return withDummyPos(A4(EFun,
                  " ",
                  _U.list([_p67._0]),
                  A2(eFun,_p67._1,e),
                  ""));
               }
         }
   });
   var ePair = F2(function (e1,e2) {
      return withDummyPos(A5(EList,
      " ",
      _U.list([e1,e2]),
      "",
      $Maybe.Nothing,
      ""));
   });
   var eVar0 = function (a) {
      return withDummyPos(A2(EVar,"",a));
   };
   var eRaw0 = eVar0;
   var eVar = function (a) {
      return withDummyPos(A2(EVar," ",a));
   };
   var eRaw = eVar;
   var listOfVars = function (xs) {
      var _p69 = xs;
      if (_p69.ctor === "[]") {
            return _U.list([]);
         } else {
            return A2($List._op["::"],
            eVar0(_p69._0),
            A2($List.map,eVar,_p69._1));
         }
   };
   var listOfRaw = listOfVars;
   var eConst0 = F2(function (a,b) {
      return withDummyPos(A4(EConst,"",a,b,noWidgetDecl));
   });
   var eConst = F2(function (a,b) {
      return withDummyPos(A4(EConst," ",a,b,noWidgetDecl));
   });
   var eList0 = F2(function (a,b) {
      return withDummyPos(A5(EList,"",a,"",b,""));
   });
   var eList = F2(function (a,b) {
      return withDummyPos(A5(EList," ",a,"",b,""));
   });
   var eComment = F2(function (a,b) {
      return withDummyPos(A3(EComment," ",a,b));
   });
   var listOfAnnotatedNums1 = $List.map(function (_p70) {
      var _p71 = _p70;
      return withDummyPos(A4(EConst,
      " ",
      _p71._0,
      dummyLoc_(_p71._1),
      _p71._2));
   });
   var listOfAnnotatedNums = function (list) {
      var _p72 = list;
      if (_p72.ctor === "[]") {
            return _U.list([]);
         } else {
            return A2($List._op["::"],
            withDummyPos(A4(EConst,
            "",
            _p72._0._0,
            dummyLoc_(_p72._0._1),
            _p72._0._2)),
            listOfAnnotatedNums1(_p72._1));
         }
   };
   var DictInsert = {ctor: "DictInsert"};
   var DictRemove = {ctor: "DictRemove"};
   var DictGet = {ctor: "DictGet"};
   var ArcTan2 = {ctor: "ArcTan2"};
   var Pow = {ctor: "Pow"};
   var Mod = {ctor: "Mod"};
   var Eq = {ctor: "Eq"};
   var Lt = {ctor: "Lt"};
   var Div = {ctor: "Div"};
   var Mult = {ctor: "Mult"};
   var Minus = {ctor: "Minus"};
   var minusNumTr = F2(function (_p74,_p73) {
      var _p75 = _p74;
      var _p76 = _p73;
      return {ctor: "_Tuple2"
             ,_0: _p75._0 + _p76._0
             ,_1: A2(TrOp,Minus,_U.list([_p75._1,_p76._1]))};
   });
   var Plus = {ctor: "Plus"};
   var ePlus = F2(function (e1,e2) {
      return withDummyPos(A4(EOp,
      "",
      withDummyRange(Plus),
      _U.list([e1,e2]),
      ""));
   });
   var plusNumTr = F2(function (_p78,_p77) {
      var _p79 = _p78;
      var _p80 = _p77;
      return {ctor: "_Tuple2"
             ,_0: _p79._0 + _p80._0
             ,_1: A2(TrOp,Plus,_U.list([_p79._1,_p80._1]))};
   });
   var DebugLog = {ctor: "DebugLog"};
   var Explode = {ctor: "Explode"};
   var Sqrt = {ctor: "Sqrt"};
   var ToStr = {ctor: "ToStr"};
   var Round = {ctor: "Round"};
   var Ceil = {ctor: "Ceil"};
   var Floor = {ctor: "Floor"};
   var ArcSin = {ctor: "ArcSin"};
   var ArcCos = {ctor: "ArcCos"};
   var Sin = {ctor: "Sin"};
   var Cos = {ctor: "Cos"};
   var DictEmpty = {ctor: "DictEmpty"};
   var Pi = {ctor: "Pi"};
   var PAs = F4(function (a,b,c,d) {
      return {ctor: "PAs",_0: a,_1: b,_2: c,_3: d};
   });
   var pAs = F2(function (x,p) {
      return withDummyRange(A4(PAs," ",x," ",p));
   });
   var PList = F5(function (a,b,c,d,e) {
      return {ctor: "PList",_0: a,_1: b,_2: c,_3: d,_4: e};
   });
   var pList0 = function (ps) {
      return withDummyRange(A5(PList,"",ps,"",$Maybe.Nothing,""));
   };
   var pList = function (ps) {
      return withDummyRange(A5(PList," ",ps,"",$Maybe.Nothing,""));
   };
   var PBase = F2(function (a,b) {
      return {ctor: "PBase",_0: a,_1: b};
   });
   var PConst = F2(function (a,b) {
      return {ctor: "PConst",_0: a,_1: b};
   });
   var PVar = F3(function (a,b,c) {
      return {ctor: "PVar",_0: a,_1: b,_2: c};
   });
   var eLets = F2(function (xes,eBody) {
      var _p81 = xes;
      if (_p81.ctor === "::") {
            return withDummyPos(A7(ELet,
            "\n",
            Let,
            false,
            withDummyRange(A3(PVar," ",_p81._0._0,noWidgetDecl)),
            _p81._0._1,
            A2(eLets,_p81._1,eBody),
            ""));
         } else {
            return eBody;
         }
   });
   var pVar0 = function (a) {
      return withDummyRange(A3(PVar,"",a,noWidgetDecl));
   };
   var pVar = function (a) {
      return withDummyRange(A3(PVar," ",a,noWidgetDecl));
   };
   var listOfPVars = function (xs) {
      var _p82 = xs;
      if (_p82.ctor === "[]") {
            return _U.list([]);
         } else {
            return A2($List._op["::"],
            pVar0(_p82._0),
            A2($List.map,pVar,_p82._1));
         }
   };
   var _p83 = {ctor: "_Tuple4",_0: "!",_1: "",_2: "?",_3: "~"};
   var frozen = _p83._0;
   var unann = _p83._1;
   var thawed = _p83._2;
   var assignOnlyOnce = _p83._3;
   var dummyLoc = dummyLoc_(unann);
   var listOfNums = function (ns) {
      var _p84 = ns;
      if (_p84.ctor === "[]") {
            return _U.list([]);
         } else {
            return A2($List._op["::"],
            A2(eConst0,_p84._0,dummyLoc),
            A2($List.map,A2($Basics.flip,eConst,dummyLoc),_p84._1));
         }
   };
   var dummyTrace = dummyTrace_(unann);
   return _elm.Lang.values = {_op: _op
                             ,assignOnlyOnce: assignOnlyOnce
                             ,frozen: frozen
                             ,thawed: thawed
                             ,unann: unann
                             ,PVar: PVar
                             ,PConst: PConst
                             ,PBase: PBase
                             ,PList: PList
                             ,PAs: PAs
                             ,Pi: Pi
                             ,DictEmpty: DictEmpty
                             ,Cos: Cos
                             ,Sin: Sin
                             ,ArcCos: ArcCos
                             ,ArcSin: ArcSin
                             ,Floor: Floor
                             ,Ceil: Ceil
                             ,Round: Round
                             ,ToStr: ToStr
                             ,Sqrt: Sqrt
                             ,Explode: Explode
                             ,DebugLog: DebugLog
                             ,Plus: Plus
                             ,Minus: Minus
                             ,Mult: Mult
                             ,Div: Div
                             ,Lt: Lt
                             ,Eq: Eq
                             ,Mod: Mod
                             ,Pow: Pow
                             ,ArcTan2: ArcTan2
                             ,DictGet: DictGet
                             ,DictRemove: DictRemove
                             ,DictInsert: DictInsert
                             ,Exp_: Exp_
                             ,EConst: EConst
                             ,EBase: EBase
                             ,EVar: EVar
                             ,EFun: EFun
                             ,EApp: EApp
                             ,EOp: EOp
                             ,EList: EList
                             ,EIf: EIf
                             ,ECase: ECase
                             ,ETypeCase: ETypeCase
                             ,ELet: ELet
                             ,EComment: EComment
                             ,EOption: EOption
                             ,ETyp: ETyp
                             ,EColonType: EColonType
                             ,ETypeAlias: ETypeAlias
                             ,TNum: TNum
                             ,TBool: TBool
                             ,TString: TString
                             ,TNull: TNull
                             ,TList: TList
                             ,TDict: TDict
                             ,TTuple: TTuple
                             ,TArrow: TArrow
                             ,TUnion: TUnion
                             ,TNamed: TNamed
                             ,TVar: TVar
                             ,TForall: TForall
                             ,TWildcard: TWildcard
                             ,One: One
                             ,Many: Many
                             ,Branch_: Branch_
                             ,TBranch_: TBranch_
                             ,Let: Let
                             ,Def: Def
                             ,IntSlider: IntSlider
                             ,NumSlider: NumSlider
                             ,NoWidgetDecl: NoWidgetDecl
                             ,WIntSlider: WIntSlider
                             ,WNumSlider: WNumSlider
                             ,WPointSlider: WPointSlider
                             ,Val: Val
                             ,VConst: VConst
                             ,VBase: VBase
                             ,VClosure: VClosure
                             ,VList: VList
                             ,VDict: VDict
                             ,defaultQuoteChar: defaultQuoteChar
                             ,VBool: VBool
                             ,VString: VString
                             ,VNull: VNull
                             ,EBool: EBool
                             ,EString: EString
                             ,ENull: ENull
                             ,TrLoc: TrLoc
                             ,TrOp: TrOp
                             ,strBaseVal: strBaseVal
                             ,strVal: strVal
                             ,strValLocs: strValLocs
                             ,strNum: strNum
                             ,strNumTrunc: strNumTrunc
                             ,strVal_: strVal_
                             ,strOp: strOp
                             ,strLoc: strLoc
                             ,strTrace: strTrace
                             ,tab: tab
                             ,fitsOnLine: fitsOnLine
                             ,isLet: isLet
                             ,mapValField: mapValField
                             ,mapExp: mapExp
                             ,mapExpViaExp__: mapExpViaExp__
                             ,mapVal: mapVal
                             ,foldVal: foldVal
                             ,foldExp: foldExp
                             ,foldExpViaE__: foldExpViaE__
                             ,replaceExpNode: replaceExpNode
                             ,mapType: mapType
                             ,foldType: foldType
                             ,flattenExpTree: flattenExpTree
                             ,findAllWithAncestors: findAllWithAncestors
                             ,findAllWithAncestors_: findAllWithAncestors_
                             ,childExps: childExps
                             ,valToTrace: valToTrace
                             ,TwoSubsts: TwoSubsts
                             ,applyLocSubst: applyLocSubst
                             ,applyESubst: applyESubst
                             ,applySubst: applySubst
                             ,branchExps: branchExps
                             ,tbranchExps: tbranchExps
                             ,branchPats: branchPats
                             ,isScope: isScope
                             ,varsOfPat: varsOfPat
                             ,getOptions: getOptions
                             ,errorPrefix: errorPrefix
                             ,crashWithMsg: crashWithMsg
                             ,errorMsg: errorMsg
                             ,strPos: strPos
                             ,val: val
                             ,exp_: exp_
                             ,withDummyRange: withDummyRange
                             ,withDummyPos: withDummyPos
                             ,replaceE__: replaceE__
                             ,dummyLoc_: dummyLoc_
                             ,dummyTrace_: dummyTrace_
                             ,dummyLoc: dummyLoc
                             ,dummyTrace: dummyTrace
                             ,ePlus: ePlus
                             ,eBool: eBool
                             ,eStr: eStr
                             ,eStr0: eStr0
                             ,eTrue: eTrue
                             ,eFalse: eFalse
                             ,eApp: eApp
                             ,eFun: eFun
                             ,ePair: ePair
                             ,noWidgetDecl: noWidgetDecl
                             ,rangeSlider: rangeSlider
                             ,intSlider: intSlider
                             ,numSlider: numSlider
                             ,colorNumberSlider: colorNumberSlider
                             ,eLets: eLets
                             ,eVar0: eVar0
                             ,eVar: eVar
                             ,eConst0: eConst0
                             ,eConst: eConst
                             ,eList0: eList0
                             ,eList: eList
                             ,eComment: eComment
                             ,pVar0: pVar0
                             ,pVar: pVar
                             ,pList0: pList0
                             ,pList: pList
                             ,pAs: pAs
                             ,vTrue: vTrue
                             ,vFalse: vFalse
                             ,vBool: vBool
                             ,vStr: vStr
                             ,vConst: vConst
                             ,vBase: vBase
                             ,vList: vList
                             ,vDict: vDict
                             ,unwrapVList: unwrapVList
                             ,unwrapVList_: unwrapVList_
                             ,unwrapVBaseString_: unwrapVBaseString_
                             ,eRaw__: eRaw__
                             ,eRaw0: eRaw0
                             ,eRaw: eRaw
                             ,listOfRaw: listOfRaw
                             ,listOfVars: listOfVars
                             ,listOfPVars: listOfPVars
                             ,listOfNums: listOfNums
                             ,listOfAnnotatedNums: listOfAnnotatedNums
                             ,listOfAnnotatedNums1: listOfAnnotatedNums1
                             ,minMax: minMax
                             ,minNumTr: minNumTr
                             ,maxNumTr: maxNumTr
                             ,minMaxNumTr: minMaxNumTr
                             ,plusNumTr: plusNumTr
                             ,minusNumTr: minusNumTr};
};
Elm.Config = Elm.Config || {};
Elm.Config.make = function (_elm) {
   "use strict";
   _elm.Config = _elm.Config || {};
   if (_elm.Config.values) return _elm.Config.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var params = {strVersion: "v0.5.2"
                ,debugLayout: false
                ,wGut: 10
                ,topSection: {h: 38,wLogo: 25,wBtnO: 180,hBtnO: 25,wJunk: 250}
                ,botSection: {h: 15}
                ,mainSection: {widgets: {wBtn: 120
                                        ,wBtnWide: 140
                                        ,hBtn: 25
                                        ,font: "Helvetica, sans-serif"
                                        ,fontSize: "10pt"}
                              ,vertical: {hExtra: 6,wGut: 10}
                              ,horizontal: {wExtra: 15,hGut: 10}
                              ,canvas: {border: "0px solid darkGray",hZoneInfo: 40}
                              ,codebox: {border: "none"
                                        ,font: "Courier, monospace"
                                        ,fontSize: "12pt"}
                              ,uiWidgets: {pad: 5
                                          ,wSlider: 100
                                          ,hSlider: 25
                                          ,wCaption: 100
                                          ,rBall: "10px"
                                          ,fontSize: "11pt"
                                          ,font: "Tahoma, sans-serif"}}};
   var debugLog = F3(function (b,s,x) {
      return b ? A2($Debug.log,s,x) : x;
   });
   var debugTypeChecker = true;
   var debugStorage = false;
   var debugSync = false;
   var debugController = false;
   var debugView = false;
   var debugParser = false;
   return _elm.Config.values = {_op: _op
                               ,debugParser: debugParser
                               ,debugView: debugView
                               ,debugController: debugController
                               ,debugSync: debugSync
                               ,debugStorage: debugStorage
                               ,debugTypeChecker: debugTypeChecker
                               ,debugLog: debugLog
                               ,params: params};
};
Elm.LangUnparser = Elm.LangUnparser || {};
Elm.LangUnparser.make = function (_elm) {
   "use strict";
   _elm.LangUnparser = _elm.LangUnparser || {};
   if (_elm.LangUnparser.values) return _elm.LangUnparser.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $OurParser2 = Elm.OurParser2.make(_elm),
   $Regex = Elm.Regex.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var traceToLittle = F2(function (substStr,trace) {
      var _p0 = trace;
      if (_p0.ctor === "TrLoc") {
            var _p1 = A2($Dict.get,_p0._0._0,substStr);
            if (_p1.ctor === "Just") {
                  return _p1._0;
               } else {
                  return "?";
               }
         } else {
            var childLittleStrs = A2($List.map,
            traceToLittle(substStr),
            _p0._1);
            return A2($Basics._op["++"],
            "(",
            A2($Basics._op["++"],
            $Lang.strOp(_p0._0),
            A2($Basics._op["++"],
            " ",
            A2($Basics._op["++"],
            A2($String.join," ",childLittleStrs),
            ")"))));
         }
   });
   var unparseType = function (tipe) {
      var _p2 = tipe.val;
      switch (_p2.ctor)
      {case "TNum": return A2($Basics._op["++"],_p2._0,"Num");
         case "TBool": return A2($Basics._op["++"],_p2._0,"Bool");
         case "TString": return A2($Basics._op["++"],_p2._0,"String");
         case "TNull": return A2($Basics._op["++"],_p2._0,"Null");
         case "TList": return A2($Basics._op["++"],
           _p2._0,
           A2($Basics._op["++"],
           "(List",
           A2($Basics._op["++"],
           unparseType(_p2._1),
           A2($Basics._op["++"],_p2._2,")"))));
         case "TDict": return A2($Basics._op["++"],
           _p2._0,
           A2($Basics._op["++"],
           "(Dict",
           A2($Basics._op["++"],
           unparseType(_p2._1),
           A2($Basics._op["++"],
           unparseType(_p2._2),
           A2($Basics._op["++"],_p2._3,")")))));
         case "TTuple": var _p6 = _p2._4;
           var _p5 = _p2._0;
           var _p4 = _p2._1;
           var _p3 = _p2._3;
           if (_p3.ctor === "Just") {
                 return A2($Basics._op["++"],
                 _p5,
                 A2($Basics._op["++"],
                 "[",
                 A2($Basics._op["++"],
                 $String.concat(A2($List.map,unparseType,_p4)),
                 A2($Basics._op["++"],
                 _p2._2,
                 A2($Basics._op["++"],
                 "|",
                 A2($Basics._op["++"],
                 unparseType(_p3._0),
                 A2($Basics._op["++"],_p6,"]")))))));
              } else {
                 return A2($Basics._op["++"],
                 _p5,
                 A2($Basics._op["++"],
                 "[",
                 A2($Basics._op["++"],
                 $String.concat(A2($List.map,unparseType,_p4)),
                 A2($Basics._op["++"],_p6,"]"))));
              }
         case "TArrow": return A2($Basics._op["++"],
           _p2._0,
           A2($Basics._op["++"],
           "(->",
           A2($Basics._op["++"],
           $String.concat(A2($List.map,unparseType,_p2._1)),
           A2($Basics._op["++"],_p2._2,")"))));
         case "TUnion": return A2($Basics._op["++"],
           _p2._0,
           A2($Basics._op["++"],
           "(union",
           A2($Basics._op["++"],
           $String.concat(A2($List.map,unparseType,_p2._1)),
           A2($Basics._op["++"],_p2._2,")"))));
         case "TNamed": switch (_p2._1)
           {case "Num": return A2($Basics._op["++"],_p2._0,"Bad_NUM");
              case "Bool": return A2($Basics._op["++"],_p2._0,"Bad_BOOL");
              case "String": return A2($Basics._op["++"],_p2._0,"Bad_STRING");
              case "Null": return A2($Basics._op["++"],_p2._0,"Bad_NULL");
              default: return A2($Basics._op["++"],_p2._0,_p2._1);}
         case "TVar": return A2($Basics._op["++"],_p2._0,_p2._1);
         case "TWildcard": return A2($Basics._op["++"],_p2._0,"_");
         default: var strVar = function (_p7) {
              var _p8 = _p7;
              return A2($Basics._op["++"],_p8._0,_p8._1);
           };
           var sVars = function () {
              var _p9 = _p2._1;
              if (_p9.ctor === "One") {
                    return strVar(_p9._0);
                 } else {
                    return A2($Basics._op["++"],
                    _p9._0,
                    $Utils.parens(A2($Basics._op["++"],
                    $String.concat(A2($List.map,strVar,_p9._1)),
                    _p9._2)));
                 }
           }();
           return A2($Basics._op["++"],
           _p2._0,
           $Utils.parens(A2($Basics._op["++"],
           "forall",
           A2($Basics._op["++"],
           sVars,
           A2($Basics._op["++"],unparseType(_p2._2),_p2._3)))));}
   };
   var unparseWD = function (wd) {
      var _p10 = wd.val;
      switch (_p10.ctor)
      {case "NoWidgetDecl": return "";
         case "IntSlider": return A2($Basics._op["++"],
           "{",
           A2($Basics._op["++"],
           $Basics.toString(_p10._0.val),
           A2($Basics._op["++"],
           _p10._1.val,
           A2($Basics._op["++"],$Basics.toString(_p10._2.val),"}"))));
         default: return A2($Basics._op["++"],
           "{",
           A2($Basics._op["++"],
           $Basics.toString(_p10._0.val),
           A2($Basics._op["++"],
           _p10._1.val,
           A2($Basics._op["++"],$Basics.toString(_p10._2.val),"}"))));}
   };
   var escapeQuotes = F2(function (quoteChar,string) {
      return A4($Regex.replace,
      $Regex.All,
      $Regex.regex(quoteChar),
      function (_p11) {
         return A2($Basics._op["++"],"\\",quoteChar);
      },
      A4($Regex.replace,
      $Regex.All,
      $Regex.regex($Regex.escape("\\")),
      function (_p12) {
         return "\\\\";
      },
      string));
   });
   var unparseBaseVal = function (bv) {
      var _p13 = bv;
      switch (_p13.ctor)
      {case "EBool": if (_p13._0 === true) {
                 return "true";
              } else {
                 return "false";
              }
         case "EString": var _p14 = _p13._0;
           return A2($Basics._op["++"],
           _p14,
           A2($Basics._op["++"],A2(escapeQuotes,_p14,_p13._1),_p14));
         default: return "null";}
   };
   var unparsePat = function (pat) {
      var _p15 = pat.val;
      switch (_p15.ctor)
      {case "PVar": return A2($Basics._op["++"],
           _p15._0,
           A2($Basics._op["++"],_p15._1,unparseWD(_p15._2)));
         case "PList": if (_p15._3.ctor === "Nothing") {
                 return A2($Basics._op["++"],
                 _p15._0,
                 A2($Basics._op["++"],
                 "[",
                 A2($Basics._op["++"],
                 $String.concat(A2($List.map,unparsePat,_p15._1)),
                 A2($Basics._op["++"],_p15._4,"]"))));
              } else {
                 return A2($Basics._op["++"],
                 _p15._0,
                 A2($Basics._op["++"],
                 "[",
                 A2($Basics._op["++"],
                 $String.concat(A2($List.map,unparsePat,_p15._1)),
                 A2($Basics._op["++"],
                 _p15._2,
                 A2($Basics._op["++"],
                 "|",
                 A2($Basics._op["++"],
                 unparsePat(_p15._3._0),
                 A2($Basics._op["++"],_p15._4,"]")))))));
              }
         case "PConst": return A2($Basics._op["++"],
           _p15._0,
           $Lang.strNum(_p15._1));
         case "PBase": return A2($Basics._op["++"],
           _p15._0,
           unparseBaseVal(_p15._1));
         default: return A2($Basics._op["++"],
           _p15._0,
           A2($Basics._op["++"],
           _p15._1,
           A2($Basics._op["++"],
           _p15._2,
           A2($Basics._op["++"],"@",unparsePat(_p15._3)))));}
   };
   var unparse = function (e) {
      var _p16 = e.val.e__;
      switch (_p16.ctor)
      {case "EBase": return A2($Basics._op["++"],
           _p16._0,
           unparseBaseVal(_p16._1));
         case "EConst": var _p17 = _p16._2;
           var b = _p17._1;
           return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           $Basics.toString(_p16._1),
           A2($Basics._op["++"],b,unparseWD(_p16._3))));
         case "EVar": return A2($Basics._op["++"],_p16._0,_p16._1);
         case "EFun":
         if (_p16._1.ctor === "::" && _p16._1._1.ctor === "[]") {
                 return A2($Basics._op["++"],
                 _p16._0,
                 A2($Basics._op["++"],
                 "(\\",
                 A2($Basics._op["++"],
                 unparsePat(_p16._1._0),
                 A2($Basics._op["++"],
                 unparse(_p16._2),
                 A2($Basics._op["++"],_p16._3,")")))));
              } else {
                 return A2($Basics._op["++"],
                 _p16._0,
                 A2($Basics._op["++"],
                 "(\\(",
                 A2($Basics._op["++"],
                 $String.concat(A2($List.map,unparsePat,_p16._1)),
                 A2($Basics._op["++"],
                 ")",
                 A2($Basics._op["++"],
                 unparse(_p16._2),
                 A2($Basics._op["++"],_p16._3,")"))))));
              }
         case "EApp": return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "(",
           A2($Basics._op["++"],
           unparse(_p16._1),
           A2($Basics._op["++"],
           $String.concat(A2($List.map,unparse,_p16._2)),
           A2($Basics._op["++"],_p16._3,")")))));
         case "EList": if (_p16._3.ctor === "Nothing") {
                 return A2($Basics._op["++"],
                 _p16._0,
                 A2($Basics._op["++"],
                 "[",
                 A2($Basics._op["++"],
                 $String.concat(A2($List.map,unparse,_p16._1)),
                 A2($Basics._op["++"],_p16._4,"]"))));
              } else {
                 return A2($Basics._op["++"],
                 _p16._0,
                 A2($Basics._op["++"],
                 "[",
                 A2($Basics._op["++"],
                 $String.concat(A2($List.map,unparse,_p16._1)),
                 A2($Basics._op["++"],
                 _p16._2,
                 A2($Basics._op["++"],
                 "|",
                 A2($Basics._op["++"],
                 unparse(_p16._3._0),
                 A2($Basics._op["++"],_p16._4,"]")))))));
              }
         case "EOp": return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "(",
           A2($Basics._op["++"],
           $Lang.strOp(_p16._1.val),
           A2($Basics._op["++"],
           $String.concat(A2($List.map,unparse,_p16._2)),
           A2($Basics._op["++"],_p16._3,")")))));
         case "EIf": return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "(if",
           A2($Basics._op["++"],
           unparse(_p16._1),
           A2($Basics._op["++"],
           unparse(_p16._2),
           A2($Basics._op["++"],
           unparse(_p16._3),
           A2($Basics._op["++"],_p16._4,")"))))));
         case "ELet": if (_p16._1.ctor === "Let") {
                 var tok = _p16._2 ? "letrec" : "let";
                 return A2($Basics._op["++"],
                 _p16._0,
                 A2($Basics._op["++"],
                 "(",
                 A2($Basics._op["++"],
                 tok,
                 A2($Basics._op["++"],
                 unparsePat(_p16._3),
                 A2($Basics._op["++"],
                 unparse(_p16._4),
                 A2($Basics._op["++"],
                 unparse(_p16._5),
                 A2($Basics._op["++"],_p16._6,")")))))));
              } else {
                 var tok = _p16._2 ? "defrec" : "def";
                 return A2($Basics._op["++"],
                 _p16._0,
                 A2($Basics._op["++"],
                 "(",
                 A2($Basics._op["++"],
                 tok,
                 A2($Basics._op["++"],
                 unparsePat(_p16._3),
                 A2($Basics._op["++"],
                 unparse(_p16._4),
                 A2($Basics._op["++"],
                 _p16._6,
                 A2($Basics._op["++"],")",unparse(_p16._5))))))));
              }
         case "ECase": var branchesStr = $String.concat(A2($List.map,
           function (_p18) {
              var _p19 = _p18;
              return A2($Basics._op["++"],
              _p19._0,
              A2($Basics._op["++"],
              "(",
              A2($Basics._op["++"],
              unparsePat(_p19._1),
              A2($Basics._op["++"],
              unparse(_p19._2),
              A2($Basics._op["++"],_p19._3,")")))));
           },
           A2($List.map,function (_) {    return _.val;},_p16._2)));
           return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "(case",
           A2($Basics._op["++"],
           unparse(_p16._1),
           A2($Basics._op["++"],
           branchesStr,
           A2($Basics._op["++"],_p16._3,")")))));
         case "ETypeCase":
         var tbranchesStr = $String.concat(A2($List.map,
           function (_p20) {
              var _p21 = _p20;
              return A2($Basics._op["++"],
              _p21._0,
              A2($Basics._op["++"],
              "(",
              A2($Basics._op["++"],
              unparseType(_p21._1),
              A2($Basics._op["++"],
              unparse(_p21._2),
              A2($Basics._op["++"],_p21._3,")")))));
           },
           A2($List.map,function (_) {    return _.val;},_p16._2)));
           return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "(typecase",
           A2($Basics._op["++"],
           unparsePat(_p16._1),
           A2($Basics._op["++"],
           tbranchesStr,
           A2($Basics._op["++"],_p16._3,")")))));
         case "EComment": return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           ";",
           A2($Basics._op["++"],
           _p16._1,
           A2($Basics._op["++"],"\n",unparse(_p16._2)))));
         case "EOption": return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "# ",
           A2($Basics._op["++"],
           _p16._1.val,
           A2($Basics._op["++"],
           ":",
           A2($Basics._op["++"],
           _p16._2,
           A2($Basics._op["++"],
           _p16._3.val,
           A2($Basics._op["++"],"\n",unparse(_p16._4))))))));
         case "ETyp": return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "(typ",
           A2($Basics._op["++"],
           unparsePat(_p16._1),
           A2($Basics._op["++"],
           unparseType(_p16._2),
           A2($Basics._op["++"],
           _p16._4,
           A2($Basics._op["++"],")",unparse(_p16._3)))))));
         case "EColonType": return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "(",
           A2($Basics._op["++"],
           unparse(_p16._1),
           A2($Basics._op["++"],
           _p16._2,
           A2($Basics._op["++"],
           ":",
           A2($Basics._op["++"],
           unparseType(_p16._3),
           A2($Basics._op["++"],_p16._4,")")))))));
         default: return A2($Basics._op["++"],
           _p16._0,
           A2($Basics._op["++"],
           "(def",
           A2($Basics._op["++"],
           unparsePat(_p16._1),
           A2($Basics._op["++"],
           unparseType(_p16._2),
           A2($Basics._op["++"],
           _p16._4,
           A2($Basics._op["++"],")",unparse(_p16._3)))))));}
   };
   var mapPrecedingWhitespacePat = F2(function (mapWs,pat) {
      var pat_$ = function () {
         var _p22 = pat.val;
         switch (_p22.ctor)
         {case "PVar": return A3($Lang.PVar,
              mapWs(_p22._0),
              _p22._1,
              _p22._2);
            case "PConst": return A2($Lang.PConst,mapWs(_p22._0),_p22._1);
            case "PBase": return A2($Lang.PBase,mapWs(_p22._0),_p22._1);
            case "PList": return A5($Lang.PList,
              mapWs(_p22._0),
              _p22._1,
              _p22._2,
              _p22._3,
              _p22._4);
            default: return A4($Lang.PAs,
              mapWs(_p22._0),
              _p22._1,
              _p22._2,
              _p22._3);}
      }();
      return _U.update(pat,{val: pat_$});
   });
   var indent = F2(function (spaces,e) {
      var recurse = indent(spaces);
      var wrap = function (e__) {
         return A3($OurParser2.WithInfo,
         A2($Lang.Exp_,e__,e.val.eid),
         e.start,
         e.end);
      };
      var processWS = function (ws) {
         return $String.reverse(A4($Regex.replace,
         $Regex.AtMost(1),
         $Regex.regex("\n"),
         function (_p23) {
            return A2($Basics._op["++"],spaces,"\n");
         },
         $String.reverse(ws)));
      };
      var _p24 = e.val.e__;
      switch (_p24.ctor)
      {case "EConst": return e;
         case "EBase": return e;
         case "EVar": return e;
         case "EFun": return wrap(A4($Lang.EFun,
           processWS(_p24._0),
           _p24._1,
           recurse(_p24._2),
           _p24._3));
         case "EApp": return wrap(A4($Lang.EApp,
           processWS(_p24._0),
           recurse(_p24._1),
           A2($List.map,recurse,_p24._2),
           _p24._3));
         case "EOp": return wrap(A4($Lang.EOp,
           processWS(_p24._0),
           _p24._1,
           A2($List.map,recurse,_p24._2),
           _p24._3));
         case "EList": return wrap(A5($Lang.EList,
           processWS(_p24._0),
           A2($List.map,recurse,_p24._1),
           _p24._2,
           A2($Utils.mapMaybe,recurse,_p24._3),
           _p24._4));
         case "EIf": return wrap(A5($Lang.EIf,
           processWS(_p24._0),
           recurse(_p24._1),
           recurse(_p24._2),
           recurse(_p24._3),
           _p24._4));
         case "ECase": var newE1 = recurse(_p24._1);
           var newBranches = A2($List.map,
           $Lang.mapValField(function (_p25) {
              var _p26 = _p25;
              return A4($Lang.Branch_,
              _p26._0,
              _p26._1,
              recurse(_p26._2),
              _p26._3);
           }),
           _p24._2);
           return wrap(A4($Lang.ECase,
           processWS(_p24._0),
           newE1,
           newBranches,
           _p24._3));
         case "ETypeCase": var newBranches = A2($List.map,
           $Lang.mapValField(function (_p27) {
              var _p28 = _p27;
              return A4($Lang.TBranch_,
              _p28._0,
              _p28._1,
              recurse(_p28._2),
              _p28._3);
           }),
           _p24._2);
           return wrap(A4($Lang.ETypeCase,
           processWS(_p24._0),
           _p24._1,
           newBranches,
           _p24._3));
         case "EComment": return wrap(A3($Lang.EComment,
           processWS(_p24._0),
           _p24._1,
           recurse(_p24._2)));
         case "EOption": return wrap(A5($Lang.EOption,
           processWS(_p24._0),
           _p24._1,
           _p24._2,
           _p24._3,
           recurse(_p24._4)));
         case "ELet": return wrap(A7($Lang.ELet,
           processWS(_p24._0),
           _p24._1,
           _p24._2,
           _p24._3,
           recurse(_p24._4),
           recurse(_p24._5),
           _p24._6));
         case "ETyp": return wrap(A5($Lang.ETyp,
           processWS(_p24._0),
           _p24._1,
           _p24._2,
           recurse(_p24._3),
           _p24._4));
         case "EColonType": return wrap(A5($Lang.EColonType,
           processWS(_p24._0),
           recurse(_p24._1),
           _p24._2,
           _p24._3,
           _p24._4));
         default: return wrap(A5($Lang.ETypeAlias,
           processWS(_p24._0),
           _p24._1,
           _p24._2,
           recurse(_p24._3),
           _p24._4));}
   });
   var mapPrecedingWhitespace = F2(function (mapWs,exp) {
      var e__$ = function () {
         var _p29 = exp.val.e__;
         switch (_p29.ctor)
         {case "EBase": return A2($Lang.EBase,mapWs(_p29._0),_p29._1);
            case "EConst": return A4($Lang.EConst,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3);
            case "EVar": return A2($Lang.EVar,mapWs(_p29._0),_p29._1);
            case "EFun": return A4($Lang.EFun,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3);
            case "EApp": return A4($Lang.EApp,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3);
            case "EList": return A5($Lang.EList,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3,
              _p29._4);
            case "EOp": return A4($Lang.EOp,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3);
            case "EIf": return A5($Lang.EIf,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3,
              _p29._4);
            case "ELet": return A7($Lang.ELet,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3,
              _p29._4,
              _p29._5,
              _p29._6);
            case "ECase": return A4($Lang.ECase,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3);
            case "ETypeCase": return A4($Lang.ETypeCase,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3);
            case "EComment": return A3($Lang.EComment,
              mapWs(_p29._0),
              _p29._1,
              _p29._2);
            case "EOption": return A5($Lang.EOption,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3,
              _p29._4);
            case "ETyp": return A5($Lang.ETyp,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3,
              _p29._4);
            case "EColonType": return A5($Lang.EColonType,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3,
              _p29._4);
            default: return A5($Lang.ETypeAlias,
              mapWs(_p29._0),
              _p29._1,
              _p29._2,
              _p29._3,
              _p29._4);}
      }();
      var val = exp.val;
      return _U.update(exp,{val: _U.update(val,{e__: e__$})});
   });
   var replacePrecedingWhitespacePat = F2(function (newWs,pat) {
      return A2(mapPrecedingWhitespacePat,
      function (oldWs) {
         return newWs;
      },
      pat);
   });
   var replacePrecedingWhitespace = F2(function (newWs,exp) {
      return A2(mapPrecedingWhitespace,
      function (oldWs) {
         return newWs;
      },
      exp);
   });
   var addPrecedingWhitespace = F2(function (newWs,exp) {
      return A2(mapPrecedingWhitespace,
      function (oldWs) {
         return A2($Basics._op["++"],oldWs,newWs);
      },
      exp);
   });
   var precedingWhitespaceExp__ = function (e__) {
      var _p30 = e__;
      switch (_p30.ctor)
      {case "EBase": return _p30._0;
         case "EConst": return _p30._0;
         case "EVar": return _p30._0;
         case "EFun": return _p30._0;
         case "EApp": return _p30._0;
         case "EList": return _p30._0;
         case "EOp": return _p30._0;
         case "EIf": return _p30._0;
         case "ELet": return _p30._0;
         case "ECase": return _p30._0;
         case "ETypeCase": return _p30._0;
         case "EComment": return _p30._0;
         case "EOption": return _p30._0;
         case "ETyp": return _p30._0;
         case "EColonType": return _p30._0;
         default: return _p30._0;}
   };
   var precedingWhitespacePat = function (pat) {
      var _p31 = pat.val;
      switch (_p31.ctor)
      {case "PVar": return _p31._0;
         case "PConst": return _p31._0;
         case "PBase": return _p31._0;
         case "PList": return _p31._0;
         default: return _p31._0;}
   };
   var precedingWhitespace = function (exp) {
      return precedingWhitespaceExp__(exp.val.e__);
   };
   var bumpCol = F2(function (n,pos) {
      return _U.update(pos,{col: n + pos.col});
   });
   var incCol = bumpCol(1);
   var debugLog = $Config.debugLog($Config.debugParser);
   return _elm.LangUnparser.values = {_op: _op
                                     ,unparse: unparse
                                     ,unparsePat: unparsePat
                                     ,unparseWD: unparseWD
                                     ,unparseType: unparseType
                                     ,traceToLittle: traceToLittle
                                     ,bumpCol: bumpCol
                                     ,incCol: incCol
                                     ,precedingWhitespace: precedingWhitespace
                                     ,precedingWhitespaceExp__: precedingWhitespaceExp__
                                     ,addPrecedingWhitespace: addPrecedingWhitespace
                                     ,replacePrecedingWhitespace: replacePrecedingWhitespace
                                     ,replacePrecedingWhitespacePat: replacePrecedingWhitespacePat
                                     ,indent: indent};
};
Elm.Blobs = Elm.Blobs || {};
Elm.Blobs.make = function (_elm) {
   "use strict";
   _elm.Blobs = _elm.Blobs || {};
   if (_elm.Blobs.values) return _elm.Blobs.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var fromBlobExp = function (be) {
      var _p0 = be;
      if (_p0.ctor === "OtherBlob") {
            return _p0._0;
         } else {
            return _p0._0;
         }
   };
   var fromMainExp = function (me) {
      var _p1 = me;
      switch (_p1.ctor)
      {case "SvgConcat": return _p1._1(_p1._0);
         case "Blobs": return _p1._1(_p1._0);
         default: return _p1._0;}
   };
   var fuseExp = function (_p2) {
      var _p3 = _p2;
      var recurse = function (defs) {
         var _p4 = defs;
         if (_p4.ctor === "[]") {
               return fromMainExp(_p3._1);
            } else {
               return $Lang.withDummyPos(A7($Lang.ELet,
               _p4._0._0,
               $Lang.Def,
               false,
               _p4._0._1,
               _p4._0._2,
               recurse(_p4._1),
               _p4._0._3));
            }
      };
      return recurse(_p3._0);
   };
   var WithAnchorBlob = function (a) {
      return {ctor: "WithAnchorBlob",_0: a};
   };
   var WithBoundsBlob = function (a) {
      return {ctor: "WithBoundsBlob",_0: a};
   };
   var CallBlob = function (a) {
      return {ctor: "CallBlob",_0: a};
   };
   var VarBlob = function (a) {
      return {ctor: "VarBlob",_0: a};
   };
   var NiceBlob = F2(function (a,b) {
      return {ctor: "NiceBlob",_0: a,_1: b};
   });
   var varBlob = F2(function (e,x) {
      return A2(NiceBlob,e,VarBlob(x));
   });
   var callBlob = F2(function (e,tuple) {
      return A2(NiceBlob,e,CallBlob(tuple));
   });
   var withBoundsBlob = F2(function (e,tuple) {
      return A2(NiceBlob,e,WithBoundsBlob(tuple));
   });
   var withAnchorBlob = F2(function (e,tuple) {
      return A2(NiceBlob,e,WithAnchorBlob(tuple));
   });
   var OtherBlob = function (a) {
      return {ctor: "OtherBlob",_0: a};
   };
   var toBlobExp = function (e) {
      var _p5 = e.val.e__;
      switch (_p5.ctor)
      {case "EVar": return A2(varBlob,e,_p5._1);
         case "EApp":
         if (_p5._2.ctor === "::" && _p5._2._1.ctor === "::" && _p5._2._1._1.ctor === "[]")
           {
                 var _p15 = _p5._2._0;
                 var _p6 = _p5._1.val.e__;
                 if (_p6.ctor === "EVar") {
                       var _p14 = _p6._1;
                       var _p7 = _p5._2._1._0.val.e__;
                       switch (_p7.ctor)
                       {case "EVar": var _p9 = _p7._1;
                            var _p8 = _p14;
                            switch (_p8)
                            {case "withBounds": return A2(NiceBlob,
                                 e,
                                 WithBoundsBlob({ctor: "_Tuple3"
                                                ,_0: _p15
                                                ,_1: _p9
                                                ,_2: _U.list([])}));
                               case "withAnchor": return A2(NiceBlob,
                                 e,
                                 WithAnchorBlob({ctor: "_Tuple3"
                                                ,_0: _p15
                                                ,_1: _p9
                                                ,_2: _U.list([])}));
                               default: return OtherBlob(e);}
                          case "EApp": var _p13 = _p7._2;
                            var _p10 = _p7._1.val.e__;
                            if (_p10.ctor === "EVar") {
                                  var _p12 = _p10._1;
                                  var _p11 = _p14;
                                  switch (_p11)
                                  {case "withBounds": return A2(NiceBlob,
                                       e,
                                       WithBoundsBlob({ctor: "_Tuple3",_0: _p15,_1: _p12,_2: _p13}));
                                     case "withAnchor": return A2(NiceBlob,
                                       e,
                                       WithAnchorBlob({ctor: "_Tuple3",_0: _p15,_1: _p12,_2: _p13}));
                                     default: return OtherBlob(e);}
                               } else {
                                  return OtherBlob(e);
                               }
                          default: return OtherBlob(e);}
                    } else {
                       return OtherBlob(e);
                    }
              } else {
                 var _p16 = _p5._1.val.e__;
                 if (_p16.ctor === "EVar") {
                       return A2(NiceBlob,
                       e,
                       CallBlob({ctor: "_Tuple2",_0: _p16._1,_1: _p5._2}));
                    } else {
                       return OtherBlob(e);
                    }
              }
         default: return OtherBlob(e);}
   };
   var OtherExp = function (a) {
      return {ctor: "OtherExp",_0: a};
   };
   var Blobs = F2(function (a,b) {
      return {ctor: "Blobs",_0: a,_1: b};
   });
   var maybeBlobs = function (main) {
      var _p17 = main.val.e__;
      if (_p17.ctor === "EApp" && _p17._2.ctor === "::" && _p17._2._1.ctor === "[]")
      {
            var _p21 = _p17._0;
            var _p20 = _p17._1;
            var _p19 = _p17._2._0;
            var _p18 = {ctor: "_Tuple2",_0: _p20.val.e__,_1: _p19.val.e__};
            if (_p18.ctor === "_Tuple2" && _p18._0.ctor === "EVar" && _p18._0._1 === "blobs" && _p18._1.ctor === "EList" && _p18._1._3.ctor === "Nothing")
            {
                  var rebuildExp = function (newBlobExpList) {
                     var newExpList = A2($List.map,fromBlobExp,newBlobExpList);
                     var eArgs$ = A2($Lang.replaceE__,
                     _p19,
                     A5($Lang.EList,
                     _p18._1._0,
                     newExpList,
                     _p18._1._2,
                     $Maybe.Nothing,
                     _p18._1._4));
                     var main$ = A2($Lang.replaceE__,
                     main,
                     A4($Lang.EApp,_p21,_p20,_U.list([eArgs$]),_p17._3));
                     return _U.eq(_p21,"") ? A2($LangUnparser.addPrecedingWhitespace,
                     "\n\n",
                     main$) : _U.eq(_p21,
                     "\n") ? A2($LangUnparser.addPrecedingWhitespace,
                     "\n",
                     main$) : main$;
                  };
                  var blobs = A2($List.map,toBlobExp,_p18._1._1);
                  return $Maybe.Just(A2(Blobs,blobs,rebuildExp));
               } else {
                  return $Maybe.Nothing;
               }
         } else {
            return $Maybe.Nothing;
         }
   };
   var SvgConcat = F2(function (a,b) {
      return {ctor: "SvgConcat",_0: a,_1: b};
   });
   var maybeSvgConcat = function (main) {
      var _p22 = main.val.e__;
      if (_p22.ctor === "EApp" && _p22._2.ctor === "::" && _p22._2._1.ctor === "[]")
      {
            var _p29 = _p22._0;
            var _p28 = _p22._2._0;
            var _p27 = _p22._1;
            var _p23 = {ctor: "_Tuple2",_0: _p27.val.e__,_1: _p28.val.e__};
            if (_p23.ctor === "_Tuple2" && _p23._0.ctor === "EVar" && _p23._0._1 === "svg" && _p23._1.ctor === "EApp" && _p23._1._2.ctor === "::" && _p23._1._2._1.ctor === "[]")
            {
                  var _p26 = _p23._1._1;
                  var _p25 = _p23._1._2._0;
                  var _p24 = {ctor: "_Tuple2",_0: _p26.val.e__,_1: _p25.val.e__};
                  if (_p24.ctor === "_Tuple2" && _p24._0.ctor === "EVar" && _p24._0._1 === "concat" && _p24._1.ctor === "EList" && _p24._1._3.ctor === "Nothing")
                  {
                        var updateExpressionList = function (newList) {
                           var e2$ = A2($Lang.replaceE__,
                           _p25,
                           A5($Lang.EList,
                           _p24._1._0,
                           newList,
                           _p24._1._2,
                           $Maybe.Nothing,
                           _p24._1._4));
                           var eAppConcat$ = A2($Lang.replaceE__,
                           _p28,
                           A4($Lang.EApp,_p23._1._0,_p26,_U.list([e2$]),_p23._1._3));
                           var main$ = A2($Lang.replaceE__,
                           main,
                           A4($Lang.EApp,_p29,_p27,_U.list([eAppConcat$]),_p22._3));
                           return _U.eq(_p29,"") ? A2($LangUnparser.addPrecedingWhitespace,
                           "\n\n",
                           main$) : _U.eq(_p29,
                           "\n") ? A2($LangUnparser.addPrecedingWhitespace,
                           "\n",
                           main$) : main$;
                        };
                        return $Maybe.Just(A2(SvgConcat,
                        _p24._1._1,
                        updateExpressionList));
                     } else {
                        return $Maybe.Nothing;
                     }
               } else {
                  return $Maybe.Nothing;
               }
         } else {
            return $Maybe.Nothing;
         }
   };
   var toMainExp = function (e) {
      return A2($Utils.elseMaybe,
      A2($Utils.plusMaybe,maybeSvgConcat(e),maybeBlobs(e)),
      OtherExp(e));
   };
   var splitExp = function (e) {
      var _p30 = e.val.e__;
      if (_p30.ctor === "ELet" && _p30._1.ctor === "Def" && _p30._2 === false)
      {
            var _p31 = splitExp(_p30._5);
            var defs = _p31._0;
            var main = _p31._1;
            return {ctor: "_Tuple2"
                   ,_0: A2($List._op["::"],
                   {ctor: "_Tuple4"
                   ,_0: _p30._0
                   ,_1: _p30._3
                   ,_2: _p30._4
                   ,_3: _p30._6},
                   defs)
                   ,_1: main};
         } else {
            return {ctor: "_Tuple2",_0: _U.list([]),_1: toMainExp(e)};
         }
   };
   var isSimpleProgram = function (e) {
      var _p32 = splitExp(e);
      var defs = _p32._0;
      var mainExp = _p32._1;
      var _p33 = mainExp;
      switch (_p33.ctor)
      {case "SvgConcat": return $Maybe.Nothing;
         case "OtherExp": return $Maybe.Nothing;
         default: return $Maybe.Just({ctor: "_Tuple3"
                                     ,_0: defs
                                     ,_1: _p33._0
                                     ,_2: _p33._1});}
   };
   return _elm.Blobs.values = {_op: _op
                              ,SvgConcat: SvgConcat
                              ,Blobs: Blobs
                              ,OtherExp: OtherExp
                              ,OtherBlob: OtherBlob
                              ,NiceBlob: NiceBlob
                              ,VarBlob: VarBlob
                              ,CallBlob: CallBlob
                              ,WithBoundsBlob: WithBoundsBlob
                              ,WithAnchorBlob: WithAnchorBlob
                              ,varBlob: varBlob
                              ,callBlob: callBlob
                              ,withBoundsBlob: withBoundsBlob
                              ,withAnchorBlob: withAnchorBlob
                              ,isSimpleProgram: isSimpleProgram
                              ,splitExp: splitExp
                              ,fuseExp: fuseExp
                              ,toMainExp: toMainExp
                              ,fromMainExp: fromMainExp
                              ,maybeSvgConcat: maybeSvgConcat
                              ,maybeBlobs: maybeBlobs
                              ,toBlobExp: toBlobExp
                              ,fromBlobExp: fromBlobExp};
};
Elm.PreludeGenerated = Elm.PreludeGenerated || {};
Elm.PreludeGenerated.make = function (_elm) {
   "use strict";
   _elm.PreludeGenerated = _elm.PreludeGenerated || {};
   if (_elm.PreludeGenerated.values)
   return _elm.PreludeGenerated.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var prelude = "\n; prelude.little\n;\n; This little library is accessible by every program.\n; This is not an example that generates an SVG canvas,\n; but we include it here for reference.\n\n;; The identity function - given a value, returns exactly that value\n(typ id (forall a (-> a a)))\n(def id (\\x x))\n\n;; A function that always returns the same value a, regardless of b\n(typ always (forall (a b) (-> a b a)))\n(def always (\\(x _) x))\n\n;; Composes two functions together\n(typ compose (forall (a b c) (-> (-> b c) (-> a b) (-> a c))))\n(def compose (\\(f g) (\\x (f (g x)))))\n\n(typ flip (forall (a b c) (-> (-> a b c) (-> b a c))))\n(def flip (\\f (\\(x y) (f y x))))\n  ; TODO other version:\n  ; (def flip (\\(f x y) (f y x)))\n\n(typ fst (forall (a b) (-> [a b] a)))\n(typ snd (forall (a b) (-> [a b] b)))\n\n(def fst (\\[a _] a))\n(def snd (\\[_ b] b))\n\n;; Returns the length of a given list\n(typ len (forall a (-> (List a) Num)))\n(defrec len (\\xs (case xs ([] 0) ([_ | xs1] (+ 1 (len xs1))))))\n\n;; Maps a function, f, over a list of values and returns the resulting list\n(typ map (forall (a b) (-> (-> a b) (List a) (List b))))\n(defrec map (\\(f xs)\n  (case xs ([] []) ([hd|tl] [(f hd)|(map f tl)]))))\n\n;; Combines two lists with a given function, extra elements are dropped\n(typ map2 (forall (a b c) (-> (-> a b c) (List a) (List b) (List c))))\n(defrec map2 (\\(f xs ys)\n  (case [xs ys]\n    ([[x|xs1] [y|ys1]] [ (f x y) | (map2 f xs1 ys1) ])\n    (_                 []))))\n\n;; Takes a function, an accumulator, and a list as input and reduces using the function from the left\n(typ foldl (forall (a b) (-> (-> a b b) b (List a) b)))\n(defrec foldl (\\(f acc xs)\n  (case xs ([] acc) ([x|xs1] (foldl f (f x acc) xs1)))))\n\n;; Takes a function, an accumulator, and a list as input and reduces using the function from the right\n(typ foldr (forall (a b) (-> (-> a b b) b (List a) b)))\n(defrec foldr (\\(f acc xs)\n  (case xs ([] acc) ([x|xs1] (f x (foldr f acc xs1))))))\n\n;; Given two lists, append the second list to the end of the first\n(typ append (forall a (-> (List a) (List a) (List a))))\n(defrec append (\\(xs ys)\n  (case xs ([] ys) ([x|xs1] [ x | (append xs1 ys)]))))\n\n;; concatenate a list of lists into a single list\n(typ concat (forall a (-> (List (List a)) (List a))))\n(def concat (\\xss (foldr append [] xss)))\n  ; TODO eta-reduced version:\n  ; (def concat (foldr append []))\n\n;; Map a given function over a list and concatenate the resulting list of lists\n(typ concatMap (forall (a b) (-> (-> a (List b)) (List a) (List b))))\n(def concatMap (\\(f xs) (concat (map f xs))))\n\n;; Takes two lists and returns a list that is their cartesian product\n(typ cartProd (forall (a b) (-> (List a) (List b) (List [a b]))))\n(def cartProd (\\(xs ys)\n  (concatMap (\\x (map (\\y [x y]) ys)) xs)))\n\n;; Takes elements at the same position from two input lists and returns a list of pairs of these elements\n(typ zip (forall (a b) (-> (List a) (List b) (List [a b]))))\n(def zip (\\(xs ys) (map2 (\\(x y) [x y]) xs ys)))\n  ; TODO eta-reduced version:\n  ; (def zip (map2 (\\(x y) [x y])))\n\n;; The empty list\n;; (typ nil (forall a (List a)))\n(typ nil [])\n(def nil [])\n\n;; attaches an element to the front of a list\n(typ cons (forall a (-> a (List a) (List a))))\n(def cons (\\(x xs) [x | xs]))\n\n;; attaches an element to the end of a list\n(typ snoc (forall a (-> a (List a) (List a))))\n(def snoc (\\(x ys) (append ys [x])))\n\n;; Returns the first element of a given list\n(typ hd (forall a (-> (List a) a)))\n(def hd (\\[x|xs] x))\n\n;; Returns the last element of a given list\n(typ tl (forall a (-> (List a) (List a))))\n(def tl (\\[x|xs] xs))\n\n;; Given a list, reverse its order\n(typ reverse (forall a (-> (List a) (List a))))\n(def reverse (\\xs (foldl cons nil xs)))\n  ; TODO eta-reduced version:\n  ; (def reverse (foldl cons nil))\n\n;; Given two numbers, creates the list between them (inclusive)\n(typ range (-> Num Num (List Num)))\n(defrec range (\\(i j)\n  (if (< i (+ j 1))\n      (cons i (range (+ i 1) j))\n      nil)))\n\n;; Given a number, create the list of 0 to that number inclusive (number must be > 0)\n(typ list0N (-> Num (List Num)))\n(def list0N (\\n (range 0 n)))\n\n;; Given a number, create the list of 1 to that number inclusive\n(typ list1N (-> Num (List Num)))\n(def list1N (\\n (range 1 n)))\n\n(typ zeroTo (-> Num (List Num)))\n(def zeroTo (\\n (range 0 (- n 1))))\n\n;; Given a number n and some value x, return a list with x repeated n times\n(typ repeat (forall a (-> Num a (List a))))\n(def repeat (\\(n x) (map (always x) (range 1 n))))\n\n;; Given two lists, return a single list that alternates between their values (first element is from first list)\n(typ intermingle (forall a (-> (List a) (List a) (List a))))\n(defrec intermingle (\\(xs ys)\n  (case [xs ys]\n    ([[x|xs1] [y|ys1]] (cons x (cons y (intermingle xs1 ys1))))\n    ([[]      []]      nil)\n    (_                 (append xs ys)))))\n\n(typ mapi (forall (a b) (-> (-> [Num a] b) (List a) (List b))))\n(def mapi (\\(f xs) (map f (zip (range 0 (- (len xs) 1)) xs))))\n\n\n(typ nth (forall a (-> (List a) Num (union Null a))))\n(defrec nth (\\(xs n)\n  (if (< n 0)       null\n    (case [n xs]\n      ([_ []]       null)\n      ([0 [x|xs1]]  x)\n      ([_ [x|xs1]]  (nth xs1 (- n 1)))))))\n\n; (defrec nth (\\(xs n)\n;   (if (< n 0)   \'ERROR: nth\'\n;     (case xs\n;       ([]       \'ERROR: nth\')\n;       ([x|xs1]  (if (= n 0) x (nth xs1 (- n 1))))))))\n\n; TODO change typ/def\n; (typ take (forall a (-> (List a) Num (union Null (List a)))))\n\n(typ take (forall a (-> (List a) Num (List (union Null a)))))\n(defrec take (\\(xs n)\n  (if (= n 0) []\n    (case xs\n      ([]      [null])\n      ([x|xs1] [x | (take xs1 (- n 1))])))))\n\n; (def take\n;   (letrec take_ (\\(n xs)\n;     (case [n xs]\n;       ([0 _]       [])\n;       ([_ []]      [])\n;       ([_ [x|xs1]] [x | (take_ (- n 1) xs1)])))\n;   (compose take_ (max 0))))\n\n(typ elem (forall a (-> a (List a) Bool)))\n(defrec elem (\\(x ys)\n  (case ys\n    ([]      false)\n    ([y|ys1] (or (= x y) (elem x ys1))))))\n\n;; multiply two numbers and return the result\n(typ mult (-> Num Num Num))\n(defrec mult (\\(m n)\n  (if (< m 1) 0 (+ n (mult (+ m -1) n)))))\n\n;; Given two numbers, subtract the second from the first\n(typ minus (-> Num Num Num))\n(def minus (\\(x y) (+ x (mult y -1))))\n\n;; Given two numbers, divide the first by the second\n(typ div (-> Num Num Num))\n(defrec div (\\(m n)\n  (if (< m n) 0\n  (if (< n 2) m\n    (+ 1 (div (minus m n) n))))))\n\n;; Given a number, returns the negative of that number\n(typ neg (-> Num Num))\n(def neg (\\x (- 0 x)))\n\n;; Given a bool, returns the opposite boolean value\n(typ not (-> Bool Bool))\n(def not (\\b (if b false true)))\n\n;; Given two bools, returns a bool regarding if the first argument is true, then the second argument is as well\n(typ implies (-> Bool Bool Bool))\n(def implies (\\(p q) (if p q true)))\n\n(typ or  (-> Bool Bool Bool))\n(typ and (-> Bool Bool Bool))\n\n(def or  (\\(p q) (if p true q)))\n(def and (\\(p q) (if p q false)))\n\n(typ some (forall a (-> (-> a Bool) (List a) Bool)))\n(defrec some (\\(p xs)\n  (case xs\n    ([]      false)\n    ([x|xs1] (or (p x) (some p xs1))))))\n\n(typ all (forall a (-> (-> a Bool) (List a) Bool)))\n(defrec all (\\(p xs)\n  (case xs\n    ([]      true)\n    ([x|xs1] (and (p x) (all p xs1))))))\n\n;; Given an upper bound, lower bound, and a number, restricts that number between those bounds (inclusive)\n;; Ex. clamp 1 5 4 = 4\n;; Ex. clamp 1 5 6 = 5\n(typ clamp (-> Num Num Num Num))\n(def clamp (\\(i j n) (if (< n i) i (if (< j n) j n))))\n\n(typ between (-> Num Num Num Bool))\n(def between (\\(i j n) (= n (clamp i j n))))\n\n(typ lt (-> Num Num Bool))\n(typ eq (-> Num Num Bool))\n(typ le (-> Num Num Bool))\n(typ gt (-> Num Num Bool))\n(typ ge (-> Num Num Bool))\n\n(def lt (\\(x y) (< x y)))\n(def eq (\\(x y) (= x y)))\n(def le (\\(x y) (or (lt x y) (eq x y))))\n(def gt (flip lt))\n(def ge (\\(x y) (or (gt x y) (eq x y))))\n\n(typ plus (-> Num Num Num))\n(def plus (\\(x y) (+ x y)))\n\n(typ min (-> Num Num Num))\n(def min (\\(i j) (if (lt i j) i j)))\n\n(typ max (-> Num Num Num))\n(def max (\\(i j) (if (gt i j) i j)))\n\n(typ minimum (-> (List Num) Num))\n(def minimum (\\[hd|tl] (foldl min hd tl)))\n\n(typ maximum (-> (List Num) Num))\n(def maximum (\\[hd|tl] (foldl max hd tl)))\n\n(typ average (-> (List Num) Num))\n(def average (\\nums\n  (let sum (foldl plus 0 nums)\n  (let n   (len nums)\n    (/ sum n)))))\n\n;; Combine a list of strings with a given separator\n;; Ex. joinStrings \', \' [\'hello\' \'world\'] = \'hello, world\'\n(typ joinStrings (-> String (List String) String))\n(def joinStrings (\\(sep ss)\n  (foldr (\\(str acc) (if (= acc \'\') str (+ str (+ sep acc)))) \'\' ss)))\n\n;; Concatenate a list of strings and return the resulting string\n(typ concatStrings (-> (List String) String))\n(def concatStrings (joinStrings \'\'))\n\n;; Concatenates a list of strings, interspersing a single space in between each string\n(typ spaces (-> (List String) String))\n(def spaces (joinStrings \' \'))\n\n;; First two arguments are appended at the front and then end of the third argument correspondingly\n;; Ex. delimit \'+\' \'+\' \'plus\' = \'+plus+\'\n(typ delimit (-> String String String String))\n(def delimit (\\(a b s) (concatStrings [a s b])))\n\n;; delimit a string with parentheses\n(typ parens (-> String String))\n(def parens (delimit \'(\' \')\'))\n\n;\n; SVG Manipulating Functions\n;\n\n; === SVG Types ===\n\n(def Point [Num Num])\n(def RGBA [Num Num Num Num])\n(def Color (union String Num RGBA))\n(def PathCmds (List (union String Num)))\n(def Points (List Point))\n(def RotationCmd [[String Num Num Num]])\n(def AttrVal (union String Num Bool Color PathCmds Points RotationCmd))\n(def AttrName String)\n(def AttrPair [AttrName AttrVal])\n(def Attrs (List AttrPair))\n(def NodeKind String)\n; TODO add recursive types properly\n(def SVG [NodeKind Attrs (List SVG_or_Text)])\n(def SVG_or_Text (union SVG [String String]))\n(def Blob (List SVG))\n\n; === Attribute Lookup ===\n\n(typ lookupWithDefault (forall (k v) (-> v k (List [k v]) v)))\n(defrec lookupWithDefault (\\(default k dict)\n  (let foo (lookupWithDefault default k)\n  (case dict\n    ([]            default)\n    ([[k1 v]|rest] (if (= k k1) v (foo rest)))))))\n\n(typ lookup (forall (k v) (-> k (List [k v]) (union v Null))))\n(defrec lookup (\\(k dict)\n  (let foo (lookup k)\n  (case dict\n    ([]            null)\n    ([[k1 v]|rest] (if (= k k1) v (foo rest)))))))\n\n(typ addExtras (-> Num (List [String (List [Num AttrVal])]) SVG SVG))\n(defrec addExtras (\\(i extras shape)\n  (case extras\n    ([] shape)\n    ([[k table] | rest]\n      (let v (lookup i table)\n      (typecase v\n        (Null    (addExtras i rest shape))\n        (AttrVal (addExtras i rest (addAttr shape [k v])))))))))\n\n(typ lookupAttr (-> SVG AttrName (union AttrVal Null)))\n(def lookupAttr (\\([_ attrs _] k) (lookup k attrs)))\n\n(typ lookupAttrWithDefault (-> AttrVal SVG AttrName AttrVal))\n(def lookupAttrWithDefault (\\(default [_ attrs _] k) (lookupWithDefault default k attrs)))\n\n; Pairs of Type-Specific Lookup Functions\n\n(typ lookupNumAttr (-> SVG AttrName (union Num Null)))\n(def lookupNumAttr (\\([_ attrs _] k)\n  (let val (lookup k attrs)\n  (typecase val (Num val) (_ null)))))\n\n(typ lookupNumAttrWithDefault (-> Num SVG AttrName Num))\n(def lookupNumAttrWithDefault (\\(default shape k)\n  (let val (lookupNumAttr shape k)\n  (typecase val (Num val) (Null default)))))\n\n(typ lookupPointsAttr (-> SVG AttrName (union Points Null)))\n(def lookupPointsAttr (\\([_ attrs _] k)\n  (let val (lookup k attrs)\n  (typecase val ((List [Num Num]) val) (_ null)))))\n\n(typ lookupPointsAttrWithDefault (-> Points SVG AttrName Points))\n(def lookupPointsAttrWithDefault (\\(default shape k)\n  (let val (lookupPointsAttr shape k)\n  (typecase val ((List [Num Num]) val) (Null default)))))\n\n(typ lookupStringAttr (-> SVG AttrName (union String Null)))\n(def lookupStringAttr (\\([_ attrs _] k)\n  (let val (lookup k attrs)\n  (typecase val (String val) (_ null)))))\n\n(typ lookupStringAttrWithDefault (-> String SVG AttrName String))\n(def lookupStringAttrWithDefault (\\(default shape k)\n  (let val (lookupStringAttr shape k)\n  (typecase val (String val) (Null default)))))\n\n; === Points ===\n\n(def Vec2D [Num Num])\n\n(typ x (-> Point Num))\n(def x (\\[x _] x))\n  ; TODO\n  ; (def x fst)\n\n(typ y (-> Point Num))\n(def y (\\[_ y] y))\n  ; TODO\n  ; (def y snd)\n\n(typ vec2DPlus (-> Point Vec2D Point))\n(def vec2DPlus (\\(pt vec)\n  [\n    (+ (x pt) (x vec))\n    (+ (y pt) (y vec))\n  ]\n))\n\n(typ vec2DMinus (-> Point Point Vec2D))\n(def vec2DMinus (\\(pt vec)\n  [\n    (- (x pt) (x vec))\n    (- (y pt) (y vec))\n  ]\n))\n\n(typ vec2DScalarMult (-> Num Vec2D Point))\n(def vec2DScalarMult (\\(num vec)\n  [\n    (* (x vec) num)\n    (* (y vec) num)\n  ]\n))\n\n\n; === Circles ===\n\n(def Circle SVG)\n\n;; argument order - color, x, y, radius\n;; creates a circle, center at (x,y) with given radius and color\n(typ circle (-> Color Num Num Num Circle))\n(def circle (\\(fill x y r)\n  [\'circle\'\n     [[\'cx\' x] [\'cy\' y] [\'r\' r] [\'fill\' fill]]\n     []]))\n\n(typ circleCenter (-> Ellipse Point))\n(def circleCenter (\\circle\n  [\n    (lookupNumAttrWithDefault 0 circle \'cx\')\n    (lookupNumAttrWithDefault 0 circle \'cy\')\n  ]\n))\n\n(typ circleRadius (-> Circle Num))\n(def circleRadius (\\circle\n  (lookupNumAttrWithDefault 0 circle \'r\')\n))\n\n(typ circleDiameter (-> Circle Num))\n(def circleDiameter (\\circle\n  (* 2 (circleRadius circle))\n))\n\n(typ circleNorth (-> Circle Point))\n(def circleNorth (\\circle\n  (let [cx cy] (circleCenter circle)\n    [cx (- cy (circleRadius circle))]\n  )\n))\n\n(typ circleEast (-> Circle Point))\n(def circleEast (\\circle\n  (let [cx cy] (circleCenter circle)\n    [(+ cx (circleRadius circle)) cy]\n  )\n))\n\n(typ circleSouth (-> Circle Point))\n(def circleSouth (\\circle\n  (let [cx cy] (circleCenter circle)\n    [cx (+ cy (circleRadius circle))]\n  )\n))\n\n(typ circleWest (-> Circle Point))\n(def circleWest (\\circle\n  (let [cx cy] (circleCenter circle)\n    [(- cx (circleRadius circle)) cy]\n  )\n))\n\n\n;; argument order - color, width, x, y, radius\n;; Just as circle, except new width parameter determines thickness of ring\n(typ ring (-> Color Num Num Num Num SVG))\n(def ring (\\(c w x y r)\n  [\'circle\'\n     [ [\'cx\' x] [\'cy\' y] [\'r\' r] [\'fill\' \'none\'] [\'stroke\' c] [\'stroke-width\' w] ]\n     []]))\n\n\n; === Ellipses ===\n\n(def Ellipse SVG)\n\n;; argument order - color, x, y, x-radius, y-radius\n;; Just as circle, except radius is separated into x and y parameters\n(typ ellipse (-> Color Num Num Num Num Ellipse))\n(def ellipse (\\(fill x y rx ry)\n  [\'ellipse\'\n     [ [\'cx\' x] [\'cy\' y] [\'rx\' rx] [\'ry\' ry] [\'fill\' fill] ]\n     []]))\n\n(typ ellipseCenter (-> Ellipse Point))\n(def ellipseCenter (\\ellipse\n  [\n    (lookupNumAttrWithDefault 0 ellipse \'cx\')\n    (lookupNumAttrWithDefault 0 ellipse \'cy\')\n  ]\n))\n\n(typ ellipseRadiusX (-> Ellipse Num))\n(def ellipseRadiusX (\\ellipse\n  (lookupNumAttrWithDefault 0 ellipse \'rx\')\n))\n\n(typ ellipseRadiusY (-> Ellipse Num))\n(def ellipseRadiusY (\\ellipse\n  (lookupNumAttrWithDefault 0 ellipse \'ry\')\n))\n\n(typ ellipseDiameterX (-> Ellipse Num))\n(def ellipseDiameterX (\\ellipse\n  (* 2 (ellipseRadiusX ellipse))\n))\n\n(typ ellipseDiameterY (-> Ellipse Num))\n(def ellipseDiameterY (\\ellipse\n  (* 2 (ellipseRadiusY ellipse))\n))\n\n(typ ellipseNorth (-> Ellipse Point))\n(def ellipseNorth (\\ellipse\n  (let [cx cy] (ellipseCenter ellipse)\n    [cx (- cy (ellipseRadiusY ellipse))]\n  )\n))\n\n(typ ellipseEast (-> Ellipse Point))\n(def ellipseEast (\\ellipse\n  (let [cx cy] (ellipseCenter ellipse)\n    [(+ cx (ellipseRadiusX ellipse)) cy]\n  )\n))\n\n(typ ellipseSouth (-> Ellipse Point))\n(def ellipseSouth (\\ellipse\n  (let [cx cy] (ellipseCenter ellipse)\n    [cx (+ cy (ellipseRadiusY ellipse))]\n  )\n))\n\n(typ ellipseWest (-> Ellipse Point))\n(def ellipseWest (\\ellipse\n  (let [cx cy] (ellipseCenter ellipse)\n    [(- cx (ellipseRadiusX ellipse)) cy]\n  )\n))\n\n\n; === Bounds-based shapes (Oval and Box) ===\n\n(def BoundedShape SVG)\n(def Bounds [Num Num Num Num])\n\n(typ boundedShapeLeft (-> BoundedShape Num))\n(def boundedShapeLeft (\\shape\n  (lookupNumAttrWithDefault 0 shape \'LEFT\')\n))\n\n(typ boundedShapeTop (-> BoundedShape Num))\n(def boundedShapeTop (\\shape\n  (lookupNumAttrWithDefault 0 shape \'TOP\')\n))\n\n(typ boundedShapeRight (-> BoundedShape Num))\n(def boundedShapeRight (\\shape\n  (lookupNumAttrWithDefault 0 shape \'RIGHT\')\n))\n\n(typ boundedShapeBot (-> BoundedShape Num))\n(def boundedShapeBot (\\shape\n  (lookupNumAttrWithDefault 0 shape \'BOT\')\n))\n\n(typ boundedShapeWidth (-> BoundedShape Num))\n(def boundedShapeWidth (\\shape\n  (- (boundedShapeRight shape) (boundedShapeLeft shape))\n))\n\n(typ boundedShapeHeight (-> BoundedShape Num))\n(def boundedShapeHeight (\\shape\n  (- (boundedShapeBot shape) (boundedShapeTop shape))\n))\n\n(typ boundedShapeLeftTop (-> BoundedShape Point))\n(def boundedShapeLeftTop (\\shape\n  [\n    (boundedShapeLeft shape)\n    (boundedShapeTop shape)\n  ]\n))\n\n(typ boundedShapeCenterTop (-> BoundedShape Point))\n(def boundedShapeCenterTop (\\shape\n  [\n    (/ (+ (boundedShapeLeft shape) (boundedShapeRight shape)) 2)\n    (boundedShapeTop shape)\n  ]\n))\n\n(typ boundedShapeRightTop (-> BoundedShape Point))\n(def boundedShapeRightTop (\\shape\n  [\n    (boundedShapeRight shape)\n    (boundedShapeTop shape)\n  ]\n))\n\n(typ boundedShapeRightCenter (-> BoundedShape Point))\n(def boundedShapeRightCenter (\\shape\n  [\n    (boundedShapeRight shape)\n    (/ (+ (boundedShapeTop shape) (boundedShapeBot shape)) 2)\n  ]\n))\n\n(typ boundedShapeRightBot (-> BoundedShape Point))\n(def boundedShapeRightBot (\\shape\n  [\n    (boundedShapeRight shape)\n    (boundedShapeBot shape)\n  ]\n))\n\n(typ boundedShapeCenterBot (-> BoundedShape Point))\n(def boundedShapeCenterBot (\\shape\n  [\n    (/ (+ (boundedShapeLeft shape) (boundedShapeRight shape)) 2)\n    (boundedShapeBot shape)\n  ]\n))\n\n(typ boundedShapeLeftBot (-> BoundedShape Point))\n(def boundedShapeLeftBot (\\shape\n  [\n    (boundedShapeLeft shape)\n    (boundedShapeBot shape)\n  ]\n))\n\n(typ boundedShapeLeftCenter (-> BoundedShape Point))\n(def boundedShapeLeftCenter (\\shape\n  [\n    (boundedShapeLeft shape)\n    (/ (+ (boundedShapeTop shape) (boundedShapeBot shape)) 2)\n  ]\n))\n\n(typ boundedShapeCenter (-> BoundedShape Point))\n(def boundedShapeCenter (\\shape\n  [\n    (/ (+ (boundedShapeLeft shape) (boundedShapeRight shape)) 2)\n    (/ (+ (boundedShapeTop shape) (boundedShapeBot shape)) 2)\n  ]\n))\n\n\n; === Rectangles ===\n\n(def Rect SVG)\n\n;; argument order - color, x, y, width, height\n;; creates a rectangle of given width and height with (x,y) as the top left corner coordinate\n(typ rect (-> Color Num Num Num Num Rect))\n(def rect (\\(fill x y w h)\n  [\'rect\'\n     [ [\'x\' x] [\'y\' y] [\'width\' w] [\'height\' h] [\'fill\' fill] ]\n     []]))\n\n(typ square (-> Color Num Num Num Rect))\n(def square (\\(fill x y side) (rect fill x y side side)))\n\n(typ rectWidth (-> Rect Num))\n(def rectWidth (\\rect\n  (lookupNumAttrWithDefault 0 rect \'width\')\n))\n\n(typ rectHeight (-> Rect Num))\n(def rectHeight (\\rect\n  (lookupNumAttrWithDefault 0 rect \'height\')\n))\n\n(typ rectLeftTop (-> Rect Point))\n(def rectLeftTop (\\rect\n  [\n    (lookupNumAttrWithDefault 0 rect \'x\')\n    (lookupNumAttrWithDefault 0 rect \'y\')\n  ]\n))\n\n(typ rectCenterTop (-> Rect Point))\n(def rectCenterTop (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (/ (rectWidth rect) 2) 0 ]\n  )\n))\n\n(typ rectRightTop (-> Rect Point))\n(def rectRightTop (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (rectWidth rect) 0 ]\n  )\n))\n\n(typ rectRightCenter (-> Rect Point))\n(def rectRightCenter (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (rectWidth rect) (/ (rectHeight rect) 2) ]\n  )\n))\n\n(typ rectRightBot (-> Rect Point))\n(def rectRightBot (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (rectWidth rect) (rectHeight rect) ]\n  )\n))\n\n(typ rectCenterBot (-> Rect Point))\n(def rectCenterBot (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (/ (rectWidth rect) 2) (rectHeight rect) ]\n  )\n))\n\n(typ rectLeftBot (-> Rect Point))\n(def rectLeftBot (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [0 (rectHeight rect) ]\n  )\n))\n\n(typ rectLeftCenter (-> Rect Point))\n(def rectLeftCenter (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [0 (/ (rectHeight rect) 2) ]\n  )\n))\n\n(typ rectCenter (-> Rect Point))\n(def rectCenter (\\rect\n  (vec2DPlus\n    (rectLeftTop rect)\n    [ (/ (rectWidth rect) 2) (/ (rectHeight rect) 2) ]\n  )\n))\n\n\n; === Lines ===\n\n(def Line SVG)\n\n;; argument order - color, width, x1, y1, x1, y2\n;; creates a line from (x1, y1) to (x2,y2) with given color and width\n(typ line (-> Color Num Num Num Num Num Line))\n(def line (\\(fill w x1 y1 x2 y2)\n  [\'line\'\n     [ [\'x1\' x1] [\'y1\' y1] [\'x2\' x2] [\'y2\' y2] [\'stroke\' fill] [\'stroke-width\' w] ]\n     []]))\n\n(typ lineBetween (-> Color Num Point Point Line))\n(def lineBetween (\\(fill w [x1 y1] [x2 y2])\n  (line fill w x1 y1 x2 y2)))\n\n(typ lineStart (-> Line Point))\n(def lineStart (\\line\n  [\n    (lookupNumAttrWithDefault 0 line \'x1\')\n    (lookupNumAttrWithDefault 0 line \'y1\')\n  ]\n))\n\n(typ lineEnd (-> Line Point))\n(def lineEnd (\\line\n  [\n    (lookupNumAttrWithDefault 0 line \'x2\')\n    (lookupNumAttrWithDefault 0 line \'y2\')\n  ]\n))\n\n(typ lineMidPoint (-> Line Point))\n(def lineMidPoint (\\line\n  (halfwayBetween (lineStart line) (lineEnd line))\n))\n\n\n;; argument order - fill, stroke, width, points\n;; creates a polygon following the list of points, with given fill color and a border with given width and stroke\n(typ polygon (-> Color Color Num Points SVG))\n(def polygon (\\(fill stroke w pts)\n  [\'polygon\'\n     [ [\'fill\' fill] [\'points\' pts] [\'stroke\' stroke] [\'stroke-width\' w] ]\n     []]))\n\n;; argument order - fill, stroke, width, points\n;; See polygon\n(typ polyline (-> Color Color Num Points SVG))\n(def polyline (\\(fill stroke w pts)\n  [\'polyline\'\n     [ [\'fill\' fill] [\'points\' pts] [\'stroke\' stroke] [\'stroke-width\' w] ]\n     []]))\n\n;; argument order - fill, stroke, width, d\n;; Given SVG path command d, create path with given fill color, stroke and width\n;; See https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths for path command info\n(typ path (-> Color Color Num PathCmds SVG))\n(def path (\\(fill stroke w d)\n  [\'path\'\n     [ [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' w] [\'d\' d] ]\n     []]))\n\n;; argument order - x, y, string\n;; place a text string with top left corner at (x,y) - with default color & font\n(typ text (-> Num Num String SVG))\n(def text (\\(x y s)\n   [\'text\' [[\'x\' x] [\'y\' y] [\'style\' \'fill:black\']\n            [\'font-family\' \'Tahoma, sans-serif\']]\n           [[\'TEXT\' s]]]))\n\n;; argument order - shape, new attribute\n;; Add a new attribute to a given Shape\n(typ addAttr (-> SVG AttrPair SVG))\n(def addAttr (\\([shapeKind oldAttrs children] newAttr)\n  [shapeKind (snoc newAttr oldAttrs) children]))\n\n(typ consAttr (-> SVG AttrPair SVG))\n(def consAttr (\\([shapeKind oldAttrs children] newAttr)\n  [shapeKind (cons newAttr oldAttrs) children]))\n\n;; Given a list of shapes, compose into a single SVG\n(def svg (\\shapes [\'svg\' [] shapes]))\n\n;; argument order - x-maximum, y-maximum, shapes\n;; Given a list of shapes, compose into a single SVG within the x & y maxima\n(typ svgViewBox (-> Num Num (List SVG) SVG))\n(def svgViewBox (\\(xMax yMax shapes)\n  (let [sx sy] [(toString xMax) (toString yMax)]\n  [\'svg\'\n    [[\'x\' \'0\'] [\'y\' \'0\'] [\'viewBox\' (joinStrings \' \' [\'0\' \'0\' sx sy])]]\n    shapes])))\n\n;; As rect, except x & y represent the center of the defined rectangle\n(typ rectByCenter (-> Color Num Num Num Num Rect))\n(def rectByCenter (\\(fill cx cy w h)\n  (rect fill (- cx (/ w 2)) (- cy (/ h 2)) w h)))\n\n;; As square, except x & y represent the center of the defined rectangle\n(typ squareByCenter (-> Color Num Num Num Rect))\n(def squareByCenter (\\(fill cx cy w) (rectByCenter fill cx cy w w)))\n\n;; Some shapes with given default values for fill, stroke, and stroke width\n; TODO remove these\n(def circle_    (circle \'red\'))\n(def ellipse_   (ellipse \'orange\'))\n(def rect_      (rect \'#999999\'))\n(def square_    (square \'#999999\'))\n(def line_      (line \'blue\' 2))\n(def polygon_   (polygon \'green\' \'purple\' 3))\n(def path_      (path \'transparent\' \'goldenrod\' 5))\n\n;; updates an SVG by comparing differences with another SVG\n;; Note: accDiff pre-condition: indices in increasing order\n;; (so can\'t just use foldr instead of reverse . foldl)\n(typ updateCanvas (-> SVG SVG SVG))\n(def updateCanvas (\\([_ svgAttrs oldShapes] diff)\n  (let oldShapesI (zip (list1N (len oldShapes)) oldShapes)\n  (let initAcc [[] diff]\n  (let f (\\([i oldShape] [accShapes accDiff])\n    (case accDiff\n      ([]\n        [(cons oldShape accShapes) accDiff])\n      ([[j newShape] | accDiffRest]\n        (if (= i j)\n          [(cons newShape accShapes) accDiffRest]\n          [(cons oldShape accShapes) accDiff]))))\n  (let newShapes (reverse (fst (foldl f initAcc oldShapesI)))\n    [\'svg\' svgAttrs newShapes]))))))\n\n(def addBlob (\\(newShapes [\'svg\' svgAttrs oldShapes])\n  [\'svg\' svgAttrs (append oldShapes newShapes)]))\n\n(typ groupMap (forall (a b) (-> (List a) (-> a b) (List b))))\n(def groupMap (\\(xs f) (map f xs)))\n\n(def autoChose (\\(_ x _) x))\n(def inferred  (\\(x _ _) x))\n(def flow (\\(_ x) x))\n\n; \'constant folding\'\n(def twoPi (* 2 (pi)))\n(def halfPi (/ (pi) 2))\n\n;; Helper function for nPointsOnCircle, calculates angle of points\n;; Note: angles are calculated clockwise from the traditional pi/2 mark\n(typ nPointsOnUnitCircle (-> Num Num (List Point)))\n(def nPointsOnUnitCircle (\\(n rot)\n  (let off (- halfPi rot)\n  (let foo (\\i\n    (let ang (+ off (* (/ i n) twoPi))\n    [(cos ang) (neg (sin ang))]))\n  (map foo (list0N (- n 1)))))))\n\n(typ nPointsOnCircle (-> Num Num Num Num Num (List Num)))\n;; argument order - Num of points, degree of rotation, x-center, y-center, radius\n;; Scales nPointsOnUnitCircle to the proper size and location with a given radius and center\n(def nPointsOnCircle (\\(n rot cx cy r)\n  (let pts (nPointsOnUnitCircle n rot)\n  (map (\\[x y] [(+ cx (* x r)) (+ cy (* y r))]) pts))))\n\n(typ nStar (-> Color Color Num Num Num Num Num Num Num SVG))\n;; argument order -\n;; fill color - interior color of star\n;; stroke color - border color of star\n;; width - thickness of stroke\n;; points - number of star points\n;; len1 - length from center to one set of star points\n;; len2 - length from center to other set of star points (either inner or outer compared to len1)\n;; rot - degree of rotation\n;; cx - x-coordinate of center position\n;; cy - y-coordinate of center position\n;; Creates stars that can be modified on a number of parameters\n(def nStar (\\(fill stroke w n len1 len2 rot cx cy)\n  (let pti (\\[i len]\n    (let anglei (+ (- (/ (* i (pi)) n) rot) halfPi)\n    (let xi (+ cx (* len (cos anglei)))\n    (let yi (+ cy (neg (* len (sin anglei))))\n      [xi yi]))))\n  (let lengths\n    (map (\\b (if b len1 len2))\n         (concat (repeat n [true false])))\n  (let indices (list0N (- (* 2! n) 1!))\n    (polygon fill stroke w (map pti (zip indices lengths))))))))\n\n(typ setZones (-> String SVG SVG))\n(def setZones (\\(s shape) (addAttr shape [\'ZONES\' s])))\n\n(typ zones (-> String (List SVG) (List SVG)))\n(def zones (\\(s shapes) (map (setZones s) shapes)))\n  ; TODO eta-reduced version:\n  ; (def zones (\\s (map (setZones s))))\n\n;; Remove all zones from shapes except for the first in the list\n(typ hideZonesTail (-> (List SVG) (List SVG)))\n(def hideZonesTail  (\\[hd | tl] [hd | (zones \'none\' tl)]))\n\n;; Turn all zones to basic for a given list of shapes except for the first shape\n(typ basicZonesTail (-> (List SVG) (List SVG)))\n(def basicZonesTail (\\[hd | tl] [hd | (zones \'basic\' tl)]))\n\n(typ ghost (-> SVG SVG))\n(def ghost\n  ; consAttr (instead of addAttr) makes internal calls to\n  ; Utils.maybeRemoveFirst \'HIDDEN\' slightly faster\n  (\\shape (consAttr shape [\'HIDDEN\' \'\'])))\n\n(def ghosts (map ghost))\n\n;; hSlider_ : Bool -> Bool -> Int -> Int -> Int -> Num -> Num -> Str -> Num\n;; -> [Num (List Svg)]\n;; argument order - dropBall roundInt xStart xEnd y minVal maxVal caption srcVal\n;; dropBall - Determines if the slider ball continues to appear past the edges of the slider\n;; roundInt - Determines whether to round to Ints or not\n;; xStart - left edge of slider\n;; xEnd - right edge of slider\n;; y - y positioning of entire slider bar\n;; minVal - minimum value of slider\n;; maxVal - maximum value of slider\n;; caption - text to display along with the slider\n;; srcVal - the current value given by the slider ball\n(def hSlider_ (\\(dropBall roundInt x0 x1 y minVal maxVal caption srcVal)\n  (let preVal (clamp minVal maxVal srcVal)\n  (let targetVal (if roundInt (round preVal) preVal)\n  (let shapes\n    (let ball\n      (let [xDiff valDiff] [(- x1 x0) (- maxVal minVal)]\n      (let xBall (+ x0 (* xDiff (/ (- srcVal minVal) valDiff)))\n      (if (= preVal srcVal) (circle \'black\' xBall y 10!)\n      (if dropBall          (circle \'black\' 0! 0! 0!)\n                            (circle \'red\' xBall y 10!)))))\n    [ (line \'black\' 3! x0 y x1 y)\n      (text (+ x1 10) (+ y 5) (+ caption (toString targetVal)))\n      (circle \'black\' x0 y 4!) (circle \'black\' x1 y 4!) ball ])\n  [targetVal (ghosts shapes)])))))\n; TODO only draw zones for ball\n\n(def vSlider_ (\\(dropBall roundInt y0 y1 x minVal maxVal caption srcVal)\n  (let preVal (clamp minVal maxVal srcVal)\n  (let targetVal (if roundInt (round preVal) preVal)\n  (let shapes\n    (let ball\n      (let [yDiff valDiff] [(- y1 y0) (- maxVal minVal)]\n      (let yBall (+ y0 (* yDiff (/ (- srcVal minVal) valDiff)))\n      (if (= preVal srcVal) (circle \'black\' x yBall 10!)\n      (if dropBall          (circle \'black\' 0! 0! 0!)\n                            (circle \'red\' x yBall 10!)))))\n    [ (line \'black\' 3! x y0 x y1)\n      ; (text (+ x1 10) (+ y 5) (+ caption (toString targetVal)))\n      (circle \'black\' x y0 4!) (circle \'black\' x y1 4!) ball ])\n  [targetVal (ghosts shapes)])))))\n; TODO only draw zones for ball\n\n(def hSlider (hSlider_ false))\n(def vSlider (vSlider_ false))\n\n;; button_ : Bool -> Num -> Num -> String -> Num -> SVG\n;; Similar to sliders, but just has boolean values\n(def button_ (\\(dropBall xStart y caption xCur)\n  (let [rPoint wLine rBall wSlider] [4! 3! 10! 70!]\n  (let xEnd (+ xStart wSlider)\n  (let xBall (+ xStart (* xCur wSlider))\n  (let xBall_ (clamp xStart xEnd xBall)\n  (let val (< xCur 0.5)\n  (let shapes1\n    [ (circle \'black\' xStart y rPoint)\n      (circle \'black\' xEnd y rPoint)\n      (line \'black\' wLine xStart y xEnd y)\n      (text (+ xEnd 10) (+ y 5) (+ caption (toString val))) ]\n  (let shapes2\n    [ (if (= xBall_ xBall) (circle (if val \'darkgreen\' \'darkred\') xBall y rBall)\n      (if dropBall         (circle \'black\' 0! 0! 0!)\n                           (circle \'red\' xBall y rBall))) ]\n  (let shapes (append (zones \'none\' shapes1) (zones \'basic\' shapes2))\n  [val (ghosts shapes)]))))))))))\n\n(def button (button_ false))\n\n(def xySlider\n  (\\(xStart xEnd yStart yEnd xMin xMax yMin yMax xCaption yCaption xCur yCur)\n    (let [rCorner wEdge rBall] [4! 3! 10!]\n    (let [xDiff yDiff xValDiff yValDiff] [(- xEnd xStart) (- yEnd yStart) (- xMax xMin) (- yMax yMin)]\n    (let xBall (+ xStart (* xDiff (/ (- xCur xMin) xValDiff)))\n    (let yBall (+ yStart (* yDiff (/ (- yCur yMin) yValDiff)))\n    (let cBall (if (and (between xMin xMax xCur) (between yMin yMax yCur)) \'black\' \'red\')\n    (let xVal (ceiling (clamp xMin xMax xCur))\n    (let yVal (ceiling (clamp yMin yMax yCur))\n    (let myLine (\\(x1 y1 x2 y2) (line \'black\' wEdge x1 y1 x2 y2))\n    (let myCirc (\\(x0 y0) (circle \'black\' x0 y0 rCorner))\n    (let shapes\n      [ (myLine xStart yStart xEnd yStart)\n        (myLine xStart yStart xStart yEnd)\n        (myLine xStart yEnd xEnd yEnd)\n        (myLine xEnd yStart xEnd yEnd)\n        (myCirc xStart yStart)\n        (myCirc xStart yEnd)\n        (myCirc xEnd yStart)\n        (myCirc xEnd yEnd)\n        (circle cBall xBall yBall rBall)\n        (text (- (+ xStart (/ xDiff 2)) 40) (+ yEnd 20) (+ xCaption (toString xVal)))\n        (text (+ xEnd 10) (+ yStart (/ yDiff 2)) (+ yCaption (toString yVal))) ]\n    [ [ xVal yVal ] (ghosts shapes) ]\n))))))))))))\n\n(typ enumSlider (forall a (-> Num Num Num [a|(List a)] String Num [a (List SVG)])))\n(def enumSlider (\\(x0 x1 y enum@[a|_] caption srcVal)\n  (let n (len enum)\n  (let [minVal maxVal] [0! n]\n  (let preVal (clamp minVal maxVal srcVal)\n  (let i (floor preVal)\n  (let item ; using dummy first element for typechecking\n    (let item_ (nth enum (if (= i n) (- n 1) i))\n    (typecase item_\n      (Null a)\n      (_    item_)))\n  (let wrap (\\circ (addAttr circ [\'SELECTED\' \'\'])) ; TODO\n  (let shapes\n    (let rail [ (line \'black\' 3! x0 y x1 y) ]\n    (let ball\n      (let [xDiff valDiff] [(- x1 x0) (- maxVal minVal)]\n      (let xBall (+ x0 (* xDiff (/ (- srcVal minVal) valDiff)))\n      (let colorBall (if (= preVal srcVal) \'black\' \'red\')\n        [ (wrap (circle colorBall xBall y 10!)) ])))\n    (let endpoints\n      [ (wrap (circle \'black\' x0 y 4!)) (wrap (circle \'black\' x1 y 4!)) ]\n    (let tickpoints\n      (let sep (/ (- x1 x0) n)\n      (map (\\j (wrap (circle \'grey\' (+ x0 (mult j sep)) y 4!)))\n           (range 1! (- n 1!))))\n    (let label [ (text (+ x1 10!) (+ y 5!) (+ caption (toString item))) ]\n    (concat [ rail endpoints tickpoints ball label ]))))))\n  [item (ghosts shapes)])))))))))\n\n(def addSelectionSliders (\\(y0 seeds shapesCaps)\n  (let shapesCapsSeeds (zip shapesCaps (take seeds (len shapesCaps)))\n  (let foo (\\[i [[shape cap] seed]]\n    (let [k _ _] shape\n    (let enum\n      (if (= k \'circle\') [\'\' \'cx\' \'cy\' \'r\']\n      (if (= k \'line\')   [\'\' \'x1\' \'y1\' \'x2\' \'y2\']\n      (if (= k \'rect\')   [\'\' \'x\' \'y\' \'width\' \'height\']\n        [(+ \'NO SELECTION ENUM FOR KIND \' k)])))\n    (let [item slider] (enumSlider 20! 170! (+ y0 (mult i 30!)) enum cap seed)\n    (let shape1 (addAttr shape [\'SELECTED\' item]) ; TODO overwrite existing\n    [shape1|slider])))))\n  (concat (mapi foo shapesCapsSeeds))))))\n\n; Text Widgets\n\n(def simpleText (\\(family color size x1 x2 y horizAlignSeed textVal)\n  (let xMid (+ x1 (/ (- x2 x1) 2!))\n  (let [anchor hAlignSlider]\n    (let dx (/ (- x2 x1) 4!)\n    (let yLine (+ 30! y)\n    (enumSlider (- xMid dx) (+ xMid dx) yLine\n      [\'start\' \'middle\' \'end\'] \'\' horizAlignSeed)))\n  (let x\n    (if (= anchor \'start\') x1\n    (if (= anchor \'middle\') xMid\n    (if (= anchor \'end\') x2\n      \'CRASH\')))\n  (let theText\n    [\'text\'\n      [[\'x\' x] [\'y\' y]\n       [\'style\' (+ \'fill:\' color)]\n       [\'font-family\' family] [\'font-size\' size]\n       [\'text-anchor\' anchor]]\n      [[\'TEXT\' textVal]]]\n  (let rails\n    (let pad 15!\n    (let yBaseLine (+ y pad)\n    (let xSideLine (- x1 pad)\n    (let rail (line \'gray\' 3)\n    (let baseLine (rail xSideLine yBaseLine x2 yBaseLine)\n    (let sideLine (rail xSideLine yBaseLine xSideLine (- y size))\n    (let dragBall (circle \'black\' x yBaseLine 8!)\n    (ghosts [baseLine sideLine dragBall]))))))))\n  (concat [[theText] hAlignSlider rails])\n)))))))\n\n\n(typ rotate (-> SVG Num Num Num SVG))\n;; argument order - shape, rot, x, y\n;; Takes a shape rotates it rot degrees around point (x,y)\n(def rotate (\\(shape n1 n2 n3)\n  (addAttr shape [\'transform\' [[\'rotate\' n1 n2 n3]]])))\n\n(typ rotateAround (-> Num Num Num SVG SVG))\n(def rotateAround (\\(rot x y shape)\n  (addAttr shape [\'transform\' [[\'rotate\' rot x y]]])))\n\n(typ radToDeg (-> Num Num))\n(def radToDeg (\\rad (* (/ rad (pi)) 180!)))\n\n\n; Polygon and Path Helpers\n\n(typ middleOfPoints (-> (List Point) Point))\n(def middleOfPoints (\\pts\n  (let [xs ys] [(map fst pts) (map snd pts)]\n  (let [xMin xMax] [(minimum xs) (maximum xs)]\n  (let [yMin yMax] [(minimum ys) (maximum ys)]\n  (let xMiddle (+ xMin (* 0.5 (- xMax xMin)))\n  (let yMiddle (+ yMin (* 0.5 (- yMax yMin)))\n    [xMiddle yMiddle] )))))))\n\n(typ polygonPoints (-> SVG Points))\n(def polygonPoints (\\shape@[shapeKind _ _]\n  (case shapeKind\n    (\'polygon\' (lookupPointsAttrWithDefault [] shape \'points\'))\n    (_         []))))\n\n(typ allPointsOfPathCmds_ (-> PathCmds (List [(union Num String) (union Num String)])))\n(defrec allPointsOfPathCmds_ (\\cmds (case cmds\n  ([]    [])\n  ([\'Z\'] [])\n\n  ([\'M\' x y | rest] (cons [x y] (allPointsOfPathCmds_ rest)))\n  ([\'L\' x y | rest] (cons [x y] (allPointsOfPathCmds_ rest)))\n\n  ([\'Q\' x1 y1 x y | rest]\n    (append [[x1 y1] [x y]] (allPointsOfPathCmds_ rest)))\n\n  ([\'C\' x1 y1 x2 y2 x y | rest]\n    (append [[x1 y1] [x2 y2] [x y]] (allPointsOfPathCmds_ rest)))\n\n  (_ [(let _ (debug \"Prelude.allPointsOfPathCmds_: not Nums...\") [-1 -1])])\n)))\n\n; (typ allPointsOfPathCmds (-> PathCmds (List Point)))\n; (def allPointsOfPathCmds (\\cmds\n;   (let toNum (\\numOrString\n;     (typecase numOrString (Num numOrString) (String -1)))\n;   (map (\\[x y] [(toNum x) (toNum y)]) (allPointsOfPathCmds_ cmds)))))\n\n; TODO remove inner annotations and named lambda\n\n(typ allPointsOfPathCmds (-> PathCmds (List Point)))\n(def allPointsOfPathCmds (\\cmds\n  (typ toNum (-> (union Num String) Num))\n  (let toNum (\\numOrString\n    (typecase numOrString (Num numOrString) (String -1)))\n  (typ foo (-> [(union Num String) (union Num String)] Point))\n  (let foo (\\[x y] [(toNum x) (toNum y)])\n  (map foo (allPointsOfPathCmds_ cmds))))))\n\n\n; Raw Shapes\n\n(def rawShape (\\(kind attrs) [kind attrs []]))\n\n(typ rawRect (-> Color Color Num Num Num Num Num Num Rect))\n(def rawRect (\\(fill stroke strokeWidth x y w h rot)\n  (let [cx cy] [(+ x (/ w 2!)) (+ y (/ h 2!))]\n  (rotateAround rot cx cy\n    (rawShape \'rect\' [\n      [\'x\' x] [\'y\' y] [\'width\' w] [\'height\' h]\n      [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ])))))\n\n(typ rawCircle (-> Color Color Num Num Num Num Circle))\n(def rawCircle (\\(fill stroke strokeWidth cx cy r)\n  (rawShape \'circle\' [\n    [\'cx\' cx] [\'cy\' cy] [\'r\' r]\n    [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ])))\n\n(typ rawEllipse (-> Color Color Num Num Num Num Num Num Ellipse))\n(def rawEllipse (\\(fill stroke strokeWidth cx cy rx ry rot)\n  (rotateAround rot cx cy\n    (rawShape \'ellipse\' [\n      [\'cx\' cx] [\'cy\' cy] [\'rx\' rx] [\'ry\' ry]\n      [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ]))))\n\n(typ rawPolygon (-> Color Color Num Points Num SVG))\n(def rawPolygon (\\(fill stroke w pts rot)\n  (let [cx cy] (middleOfPoints pts)\n  (rotateAround rot cx cy\n    (rawShape \'polygon\'\n      [ [\'fill\' fill] [\'points\' pts] [\'stroke\' stroke] [\'stroke-width\' w] ])))))\n\n(typ rawPath (-> Color Color Num PathCmds Num SVG))\n(def rawPath (\\(fill stroke w d rot)\n  (let [cx cy] (middleOfPoints (allPointsOfPathCmds d))\n  (rotateAround rot cx cy\n    (rawShape \'path\'\n      [ [\'fill\' fill] [\'d\' d] [\'stroke\' stroke] [\'stroke-width\' w] ])))))\n\n\n; Shapes via Bounding Boxes\n\n(typ box (-> Bounds Color Color Num BoundedShape))\n(def box (\\(bounds fill stroke strokeWidth)\n  (let [x y xw yh] bounds\n  [\'BOX\'\n    [ [\'LEFT\' x] [\'TOP\' y] [\'RIGHT\' xw] [\'BOT\' yh]\n      [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth]\n    ] []\n  ])))\n\n; string fill/stroke/stroke-width attributes to avoid sliders\n(typ hiddenBoundingBox (-> Bounds BoundedShape))\n(def hiddenBoundingBox (\\bounds\n  (ghost (box bounds \'transparent\' \'transparent\' \'0\'))))\n\n(typ simpleBoundingBox (-> Bounds BoundedShape))\n(def simpleBoundingBox (\\bounds\n  (ghost (box bounds \'transparent\' \'darkblue\' 1))))\n\n(typ strList (-> (List String) String))\n(def strList\n  (let foo (\\(x acc) (+ (+ acc (if (= acc \'\') \'\' \' \')) (toString x)))\n  (foldl foo \'\')))\n\n(typ fancyBoundingBox (-> Bounds (List SVG)))\n(def fancyBoundingBox (\\bounds\n  (let [left top right bot] bounds\n  (let [width height] [(- right left) (- bot top)]\n  (let [c1 c2 r] [\'darkblue\' \'skyblue\' 6]\n  [ (ghost (box bounds \'transparent\' c1 1))\n    (ghost (setZones \'none\' (circle c2 left top r)))\n    (ghost (setZones \'none\' (circle c2 right top r)))\n    (ghost (setZones \'none\' (circle c2 right bot r)))\n    (ghost (setZones \'none\' (circle c2 left bot r)))\n    (ghost (setZones \'none\' (circle c2 left (+ top (/ height 2)) r)))\n    (ghost (setZones \'none\' (circle c2 right (+ top (/ height 2)) r)))\n    (ghost (setZones \'none\' (circle c2 (+ left (/ width 2)) top r)))\n    (ghost (setZones \'none\' (circle c2 (+ left (/ width 2)) bot r)))\n  ])))))\n\n(typ groupWithPad (-> Num Bounds (List SVG) SVG))\n(def groupWithPad (\\(pad bounds shapes)\n  (let [left top right bot] bounds\n  (let paddedBounds [(- left pad) (- top pad) (+ right pad) (+ bot pad)]\n  [\'g\' [[\'BOUNDS\' bounds]]\n       (cons (hiddenBoundingBox paddedBounds) shapes)]\n))))\n\n(typ group (-> Bounds (List SVG) SVG))\n(def group (groupWithPad (let nGroupPad 20 nGroupPad)))\n\n  ; NOTE:\n  ;   keep the names nGroupPad and nPolyPathPad (and values)\n  ;   in sync with ExpressionBasedTransform.elm\n\n  ; (def group (groupWithPad 15))\n\n(def polyPathGroup (groupWithPad (let nPolyPathPad 10 nPolyPathPad)))\n\n; TODO make one pass over pts\n(typ boundsOfPoints (-> (List Point) Bounds))\n(def boundsOfPoints (\\pts\n  (let left  (minimum (map fst pts))\n  (let right (maximum (map fst pts))\n  (let top   (minimum (map snd pts))\n  (let bot   (maximum (map snd pts))\n    [left top right bot]\n))))))\n\n(typ extremeShapePoints (-> SVG Points))\n(def extremeShapePoints (\\shape@[kind _ _]\n  (case kind\n\n    (\'line\'\n      (let attrs@[x1 y1 x2 y2] (map (lookupAttr shape) [\"x1\" \"y1\" \"x2\" \"y2\"])\n      (typecase attrs\n        ([Num Num Num Num] [[x1 y1] [x2 y2]])\n        (_ []))))\n\n    (\'rect\'\n      (let attrs@[x y w h] (map (lookupAttr shape) [\"x\" \"y\" \"width\" \"height\"])\n      (typecase attrs\n        ([Num Num Num Num] [[x y] [(+ x w) (+ y h)]])\n        (_ []))))\n\n    (\'circle\'\n      (let attrs@[cx cy r] (map (lookupAttr shape) [\"cx\" \"cy\" \"r\"])\n      (typecase attrs\n        ([Num Num Num] [[(- cx r) (- cy r)] [(+ cx r) (+ cy r)]])\n        (_ []))))\n\n    (\'ellipse\'\n      (let attrs@[cx cy rx ry] (map (lookupAttr shape) [\"cx\" \"cy\" \"rx\" \"ry\"])\n      (typecase attrs\n        ([Num Num Num Num] [[(- cx rx) (- cy ry)] [(+ cx rx) (+ cy ry)]])\n        (_ []))))\n\n    (\'polygon\' (polygonPoints shape))\n\n    (\'path\'\n      (let pathCmds (lookupAttr shape \"d\")\n      (typecase pathCmds\n        ((List (union String Num)) (allPointsOfPathCmds pathCmds))\n        (_ []))))\n\n    (_ [])\n)))\n\n(typ anchoredGroup (-> (List SVG) SVG))\n(def anchoredGroup (\\shapes\n  (let bounds (boundsOfPoints (concat (map extremeShapePoints shapes)))\n  (group bounds shapes)\n)))\n\n; (def group (\\(bounds shapes)\n;   [\'g\' [[\'BOUNDS\' bounds]]\n;        (cons (hiddenBoundingBox bounds) shapes)]))\n\n       ; (concat [(fancyBoundingBox bounds) shapes])]))\n\n; TODO no longer used...\n(typ rotatedRect (-> Color Num Num Num Num Num Rect))\n(def rotatedRect (\\(fill x y w h rot)\n  (let [cx cy] [(+ x (/ w 2!)) (+ y (/ h 2!))]\n  (let bounds [x y (+ x w) (+ y h)]\n  (let shape (rotateAround rot cx cy (rect fill x y w h))\n  (group bounds [shape])\n)))))\n\n(typ rectangle (-> Color Color Num Num Bounds Rect))\n(def rectangle (\\(fill stroke strokeWidth rot bounds)\n  (let [left top right bot] bounds\n  (let [cx cy] [(+ left (/ (- right left) 2!)) (+ top (/ (- bot top) 2!))]\n  (let shape (rotateAround rot cx cy (box bounds fill stroke strokeWidth))\n  shape\n)))))\n  ; (group bounds [shape])\n\n; TODO no longer used...\n(typ rotatedEllipse (-> Color Num Num Num Num Num Ellipse))\n(def rotatedEllipse (\\(fill cx cy rx ry rot)\n  (let bounds [(- cx rx) (- cy ry) (+ cx rx) (+ cy ry)]\n  (let shape (rotateAround rot cx cy (ellipse fill cx cy rx ry))\n  (group bounds [shape])\n))))\n\n; TODO take rot\n(typ oval (-> Color Color Num Bounds BoundedShape))\n(def oval (\\(fill stroke strokeWidth bounds)\n  (let [left top right bot] bounds\n  (let shape\n    [\'OVAL\'\n       [ [\'LEFT\' left] [\'TOP\' top] [\'RIGHT\' right] [\'BOT\' bot]\n         [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ]\n       []]\n  shape\n))))\n\n; ; TODO take rot\n; (def oval (\\(fill stroke strokeWidth bounds)\n;   (let [left top right bot] bounds\n;   (let [rx ry] [(/ (- right left) 2!) (/ (- bot top) 2!)]\n;   (let [cx cy] [(+ left rx) (+ top ry)]\n;   (let shape ; TODO change def ellipse to take stroke/strokeWidth\n;     [\'ellipse\'\n;        [ [\'cx\' cx] [\'cy\' cy] [\'rx\' rx] [\'ry\' ry]\n;          [\'fill\' fill] [\'stroke\' stroke] [\'stroke-width\' strokeWidth] ]\n;        []]\n;   (group bounds [shape])\n; ))))))\n\n(def scaleBetween (\\(a b pct)\n  (case pct\n    (0 a)\n    (1 b)\n    (_ (+ a (* pct (- b a)))))))\n\n(typ stretchyPolygon (-> Bounds Color Color Num (List Num) SVG))\n(def stretchyPolygon (\\(bounds fill stroke strokeWidth percentages)\n  (let [left top right bot] bounds\n  (let [xScale yScale] [(scaleBetween left right) (scaleBetween top bot)]\n  (let pts (map (\\[xPct yPct] [ (xScale xPct) (yScale yPct) ]) percentages)\n  ; (group bounds [(polygon fill stroke strokeWidth pts)])\n  (polyPathGroup bounds [(polygon fill stroke strokeWidth pts)])\n)))))\n\n; TODO no longer used...\n(def pointyPath (\\(fill stroke w d)\n  (let dot (\\(x y) (ghost (circle \'orange\' x y 5)))\n  (letrec pointsOf (\\cmds\n    (case cmds\n      ([]                     [])\n      ([\'Z\']                  [])\n      ([\'M\' x y | rest]       (append [(dot x y)] (pointsOf rest)))\n      ([\'L\' x y | rest]       (append [(dot x y)] (pointsOf rest)))\n      ([\'Q\' x1 y1 x y | rest] (append [(dot x1 y1) (dot x y)] (pointsOf rest)))\n      ([\'C\' x1 y1 x2 y2 x y | rest] (append [(dot x1 y1) (dot x2 y2) (dot x y)] (pointsOf rest)))\n      (_                      \'ERROR\')))\n  [\'g\' []\n    (cons\n      (path fill stroke w d)\n      [])]\n))))\n      ; turning off points for now\n      ; (pointsOf d)) ]\n\n; can refactor to make one pass\n; can also change representation/template code to pair points\n(def stretchyPath (\\(bounds fill stroke w d)\n  (let [left top right bot] bounds\n  (let [xScale yScale] [(scaleBetween left right) (scaleBetween top bot)]\n  (let dot (\\(x y) (ghost (circle \'orange\' x y 5)))\n  (letrec toPath (\\cmds\n    (case cmds\n      ([]    [])\n      ([\'Z\'] [\'Z\'])\n      ([\'M\' x y | rest] (append [\'M\' (xScale x) (yScale y)] (toPath rest)))\n      ([\'L\' x y | rest] (append [\'L\' (xScale x) (yScale y)] (toPath rest)))\n      ([\'Q\' x1 y1 x y | rest]\n        (append [\'Q\' (xScale x1) (yScale y1) (xScale x) (yScale y)]\n                (toPath rest)))\n      ([\'C\' x1 y1 x2 y2 x y | rest]\n        (append [\'C\' (xScale x1) (yScale y1) (xScale x2) (yScale y2) (xScale x) (yScale y)]\n                (toPath rest)))\n      (_ \'ERROR\')))\n  (letrec pointsOf (\\cmds\n    (case cmds\n      ([]    [])\n      ([\'Z\'] [])\n      ([\'M\' x y | rest] (append [(dot (xScale x) (yScale y))] (pointsOf rest)))\n      ([\'L\' x y | rest] (append [(dot (xScale x) (yScale y))] (pointsOf rest)))\n      ([\'Q\' x1 y1 x y | rest]\n        (append [(dot (xScale x1) (yScale y1)) (dot (xScale x) (yScale y))]\n                (pointsOf rest)))\n      ([\'C\' x1 y1 x2 y2 x y | rest]\n        (append [(dot (xScale x1) (yScale y1))\n                 (dot (xScale x2) (yScale y2))\n                 (dot (xScale x)  (yScale y))]\n                (pointsOf rest)))\n      (_ \'ERROR\')))\n  ; (group bounds\n  (polyPathGroup bounds\n    (cons\n      (path fill stroke w (toPath d))\n      []))\n)))))))\n      ; turning off points for now\n      ; (pointsOf d)))\n\n(typ evalOffset (-> [Num Num] Num))\n(def evalOffset (\\[base off]\n  (case off\n    (0 base)\n    (_ (+ base off)))))\n\n(def stickyPolygon (\\(bounds fill stroke strokeWidth offsets)\n  (let pts (map (\\[xOff yOff] [ (evalOffset xOff) (evalOffset yOff) ]) offsets)\n  (group bounds [(polygon fill stroke strokeWidth pts)])\n)))\n\n(typ withBounds (-> Bounds (-> Bounds (List SVG)) (List SVG)))\n(def withBounds (\\(bounds f) (f bounds)))\n\n(typ withAnchor (-> Point (-> Point (List SVG)) (List SVG)))\n(def withAnchor (\\(anchor f) (f anchor)))\n\n(typ star (-> Bounds (List SVG)))\n(def star (\\bounds\n  (let [left top right bot] bounds\n  (let [width height] [(- right left) (- bot top)]\n  (let [cx cy] [(+ left (/ width 2)) (+ top (/ height 2))]\n  [(nStar \'lightblue\' \'black\' 0 6 (min (/ width 2) (/ height 2)) 10 0 cx cy)]\n)))))\n\n(typ blobs (-> (List Blob) SVG))\n(def blobs (\\blobs\n  (let modifyBlob (\\[i blob]\n    (case blob\n      ([[\'g\' gAttrs [shape | shapes]]]\n       [[\'g\' gAttrs [(consAttr shape [\'BLOB\' (toString (+ i 1))]) | shapes]]])\n      ([shape] [(consAttr shape [\'BLOB\' (toString (+ i 1))])])\n      (_       blob)))\n  (svg (concat (mapi modifyBlob blobs)))\n)))\n\n\n; === Relations ===\n\n(typ halfwayBetween (-> Point Point Point))\n(def halfwayBetween (\\(pt1 pt2)\n  (vec2DScalarMult 0.5 (vec2DPlus pt1 pt2))\n))\n\n(typ nextInLine (-> Point Point Point))\n(def nextInLine (\\(pt1 pt2)\n  (vec2DPlus pt2 (vec2DMinus pt2 pt1))\n))\n\n\n; === Basic Replicate ===\n\n(def horizontalArray (\\(n sep func [x y])\n  (let _ ; draw point widget to control anchor\n    ([x y] : Point)\n  (let draw_i (\\i\n    (let xi (+ x (* i sep))\n    (func [xi y])))\n  (concat (map draw_i (zeroTo n)))\n))))\n\n(def linearArrayFromTo (\\(n func [xStart yStart] [xEnd yEnd])\n  (let xsep (/ (- xEnd xStart) (- n 1))\n  (let ysep (/ (- yEnd yStart) (- n 1))\n  (let draw_i (\\i\n    (let xi (+ xStart (* i xsep))\n    (let yi (+ yStart (* i ysep))\n    (func [xi yi]))))\n  (concat (map draw_i (zeroTo n)))\n)))))\n\n; To reduce size of resulting trace,\n; could subtract up to M>1 at a time.\n;\n(defrec floorAndLocalFreeze (\\n\n  (if (le n 1) 0\n  ;else\n    (+ 1 (floorAndLocalFreeze (- n 1))))))\n\n  ; (let _ ; draw point widget to control anchor\n  ;   ([cx cy] : Point)\n(def radialArray (\\(n radius rot func [cx cy])\n  (let center ; draw ghost circle to control anchor\n              ; not using point widget, since it\'s not selectable\n    (circle \'orange\' cx cy 20)\n  (let _ ; draw point widget to control radius\n    (let xWidget (floorAndLocalFreeze cx)\n    (let yWidget (- (floorAndLocalFreeze cy) radius)\n      ([xWidget yWidget] : Point)))\n  (let endpoints (nPointsOnCircle n rot cx cy radius)\n  (let bounds\n    [(- cx radius) (- cy radius) (+ cx radius) (+ cy radius)]\n  [(group bounds (cons center (concat (map func endpoints))))]\n))))))\n\n(def offsetAnchor (\\(dx dy f)\n  (\\[x y] (f [(+ x dx) (+ y dy)]))\n))\n\n(def horizontalArrayByBounds (\\(n sep func [left_0 top right_0 bot])\n  (let w_i     (- right_0 left_0)\n  (let left_i  (\\i (+ left_0 (* i (+ w_i sep))))\n  (let right_i (\\i (+ (left_i i) w_i))\n  (let draw_i  (\\i (func [(left_i i) top (right_i i) bot]))\n  (let bounds  [left_0 top (right_i (- n 1)) bot]\n    [(groupWithPad 30 bounds (concat (map draw_i (zeroTo n))))]\n)))))))\n\n(def repeatInsideBounds (\\(n sep func bounds@[left top right bot])\n  (let w_i (/ (- (- right left) (* sep (- n 1))) n)\n  (let draw_i (\\i\n    (let left_i (+ left (* i (+ w_i sep)))\n    (let right_i (+ left_i w_i)\n    (func [left_i top right_i bot]))))\n  [(groupWithPad 30 bounds (concat (map draw_i (zeroTo n))))]\n))))\n\n\n; The type checker relies on the name of this definition.\n(let dummyPreludeMain [\'svg\' [] []] dummyPreludeMain)\n\n";
   var src = prelude;
   return _elm.PreludeGenerated.values = {_op: _op,src: src};
};
Elm.LangParser2 = Elm.LangParser2 || {};
Elm.LangParser2.make = function (_elm) {
   "use strict";
   _elm.LangParser2 = _elm.LangParser2 || {};
   if (_elm.LangParser2.values) return _elm.LangParser2.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Char = Elm.Char.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $OurParser2 = Elm.OurParser2.make(_elm),
   $PreludeGenerated = Elm.PreludeGenerated.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var isInt = function (n) {
      return _U.eq(n,$Basics.toFloat($Basics.floor(n)));
   };
   var dummyLocWithDebugInfo = F2(function (b,n) {
      return {ctor: "_Tuple3",_0: 0,_1: b,_2: ""};
   });
   var charInsideString = function (closeStringChar) {
      return A2($OurParser2._op["<++"],
      $OurParser2.satisfy(function (c) {
         return !_U.eq(c,closeStringChar) && !_U.eq(c,_U.chr("\\"));
      }),
      A2($OurParser2._op[">>>"],
      $OurParser2.$char(_U.chr("\\")),
      $OurParser2.satisfy($Basics.always(true))));
   };
   var string_ = function (s) {
      return A2($OurParser2._op["<$>"],
      $Basics.always(s),
      $OurParser2.token(s));
   };
   var parseFrozen = A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   string_($Lang.frozen),
   string_($Lang.thawed)),
   string_($Lang.assignOnlyOnce)),
   string_($Lang.unann));
   var parseSign = A2($OurParser2.option,
   1,
   A2($OurParser2._op[">>="],
   $OurParser2.$char(_U.chr("-")),
   function (c) {
      return A3($OurParser2.returnWithInfo,-1,c.start,c.end);
   }));
   var isDelimiter = function (c) {
      return A2($String.any,
      F2(function (x,y) {    return _U.eq(x,y);})(c),
      "[]{}()|");
   };
   var isWhitespace = function (c) {
      return _U.eq(c,_U.chr(" ")) || (_U.eq(c,
      _U.chr("\n")) || _U.eq(c,_U.chr("\t")));
   };
   var munchManySpaces = A2($OurParser2._op["<$>"],
   $Basics.always({ctor: "_Tuple0"}),
   $OurParser2.munch(isWhitespace));
   var preWhite = function (p) {
      return A2($OurParser2._op[">>>"],munchManySpaces,p);
   };
   var whiteToken = function (_p0) {
      return preWhite($OurParser2.token(_p0));
   };
   var parseStrDelimit = function (quoteChar) {
      var quoteCharString = $String.fromChar(quoteChar);
      return A3($OurParser2.between,
      whiteToken(quoteCharString),
      $OurParser2.token(quoteCharString),
      A2($OurParser2._op["<$>"],
      function (_p1) {
         return A2($Lang.EString,
         quoteCharString,
         $String.fromList(A2($List.map,
         function (_) {
            return _.val;
         },
         _p1)));
      },
      $OurParser2.many(charInsideString(quoteChar))));
   };
   var parseStrLit = A2($OurParser2._op["<++"],
   parseStrDelimit(_U.chr("\'")),
   parseStrDelimit(_U.chr("\"")));
   var delimit = F2(function (a,b) {
      return A2($OurParser2.between,whiteToken(a),whiteToken(b));
   });
   var parens = A2(delimit,"(",")");
   var saveToken = function (_p2) {
      return preWhite(string_(_p2));
   };
   var whitespace = $OurParser2.munch(isWhitespace);
   var parseEBase = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<$>"],
      $Basics.always($Lang.exp_(A2($Lang.EBase,
      ws.val,
      $Lang.EBool(true)))),
      $OurParser2.token("true")),
      A2($OurParser2._op["<$>"],
      $Basics.always($Lang.exp_(A2($Lang.EBase,
      ws.val,
      $Lang.EBool(false)))),
      $OurParser2.token("false"))),
      A2($OurParser2._op["<$>"],
      $Basics.always($Lang.exp_(A2($Lang.EBase,ws.val,$Lang.ENull))),
      $OurParser2.token("null"))),
      A2($OurParser2._op["<$>"],
      function (_p3) {
         return $Lang.exp_(A2($Lang.EBase,ws.val,_p3));
      },
      parseStrLit));
   });
   var parseListLiteral = F2(function (p,constructor) {
      return A2($OurParser2._op[">>="],
      whitespace,
      function (ws1) {
         return A2($OurParser2._op[">>="],
         $OurParser2.token("["),
         function (openBracket) {
            return A2($OurParser2._op[">>="],
            $OurParser2.many(p),
            function (xs) {
               return A2($OurParser2._op[">>="],
               whitespace,
               function (ws3) {
                  return A2($OurParser2._op[">>="],
                  $OurParser2.token("]"),
                  function (closeBracket) {
                     var constructed = A5(constructor,
                     ws1.val,
                     xs.val,
                     "",
                     $Maybe.Nothing,
                     ws3.val);
                     return A3($OurParser2.returnWithInfo,
                     constructed,
                     openBracket.start,
                     closeBracket.end);
                  });
               });
            });
         });
      });
   });
   var parseMultiCons = F2(function (p,constructor) {
      return A2($OurParser2._op[">>="],
      whitespace,
      function (ws1) {
         return A2($OurParser2._op[">>="],
         $OurParser2.token("["),
         function (openBracket) {
            return A2($OurParser2._op[">>="],
            $OurParser2.some(p),
            function (xs) {
               return A2($OurParser2._op[">>="],
               whitespace,
               function (ws2) {
                  return A2($OurParser2._op[">>="],
                  A2($OurParser2._op[">>>"],$OurParser2.token("|"),p),
                  function (y) {
                     return A2($OurParser2._op[">>="],
                     whitespace,
                     function (ws3) {
                        return A2($OurParser2._op[">>="],
                        $OurParser2.token("]"),
                        function (closeBracket) {
                           var constructed = A5(constructor,
                           ws1.val,
                           xs.val,
                           ws2.val,
                           $Maybe.Just(y),
                           ws3.val);
                           return A3($OurParser2.returnWithInfo,
                           constructed,
                           openBracket.start,
                           closeBracket.end);
                        });
                     });
                  });
               });
            });
         });
      });
   });
   var parseListLiteralOrMultiCons = F2(function (p,constructor) {
      return $OurParser2.recursively(function (_p4) {
         return A2($OurParser2._op["<++"],
         A2(parseListLiteral,p,constructor),
         A2(parseMultiCons,p,constructor));
      });
   });
   var parseWildcard = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op[">>>"],
      $OurParser2.token("_"),
      $OurParser2.$return(A3($Lang.PVar,
      ws.val,
      "_",
      $Lang.noWidgetDecl)));
   });
   var parsePVar = function (identParser) {
      return A2($OurParser2._op[">>="],
      whitespace,
      function (ws) {
         return A2($OurParser2._op["<$>"],
         function (ident) {
            return A3($Lang.PVar,ws.val,ident,$Lang.noWidgetDecl);
         },
         identParser);
      });
   };
   var parseFlatPatList = function (identParser) {
      var pVarParser = parsePVar(identParser);
      return A2($OurParser2._op[">>="],
      whitespace,
      function (ws1) {
         return A2($OurParser2._op[">>="],
         $OurParser2.token("["),
         function (opening) {
            return A2($OurParser2._op[">>="],
            $OurParser2.many(pVarParser),
            function (pVars) {
               return A2($OurParser2._op[">>="],
               whitespace,
               function (ws2) {
                  return A2($OurParser2._op[">>="],
                  $OurParser2.token("]"),
                  function (closing) {
                     return A3($OurParser2.returnWithInfo,
                     A5($Lang.PList,ws1.val,pVars.val,"",$Maybe.Nothing,ws2.val),
                     opening.start,
                     closing.end);
                  });
               });
            });
         });
      });
   };
   var whiteTokenOneWS = function (token) {
      return A2($OurParser2.lookafter,
      whiteToken(token),
      $OurParser2.satisfy(isWhitespace));
   };
   var parseRec = A2($OurParser2._op["<++"],
   A2($OurParser2._op["<$>"],
   $Basics.always(true),
   whiteTokenOneWS("letrec")),
   A2($OurParser2._op["<$>"],
   $Basics.always(false),
   whiteTokenOneWS("let")));
   var parseDefRec = A2($OurParser2._op["<++"],
   A2($OurParser2._op["<$>"],
   $Basics.always(true),
   whiteTokenOneWS("defrec")),
   A2($OurParser2._op["<$>"],
   $Basics.always(false),
   whiteTokenOneWS("def")));
   var parseTWildcard = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op["<$>"],
      function (_p5) {
         return $Lang.TWildcard(ws.val);
      },
      whiteTokenOneWS("_"));
   });
   var parseUOp = A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Cos),
   whiteTokenOneWS("cos")),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Sin),
   whiteTokenOneWS("sin"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.ArcCos),
   whiteTokenOneWS("arccos"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.ArcSin),
   whiteTokenOneWS("arcsin"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Floor),
   whiteTokenOneWS("floor"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Ceil),
   whiteTokenOneWS("ceiling"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Round),
   whiteTokenOneWS("round"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.ToStr),
   whiteTokenOneWS("toString"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Sqrt),
   whiteTokenOneWS("sqrt"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.DebugLog),
   whiteTokenOneWS("debug"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Explode),
   whiteTokenOneWS("explode")));
   var isAlphaNumeric = function (c) {
      return $Char.isLower(c) || ($Char.isUpper(c) || $Char.isDigit(c));
   };
   var isIdentChar = function (c) {
      return isAlphaNumeric(c) || (_U.eq(c,_U.chr("_")) || _U.eq(c,
      _U.chr("\'")));
   };
   var whiteTokenOneNonIdent = function (token) {
      return A2($OurParser2.lookafter,
      whiteToken(token),
      $OurParser2.satisfy(function (_p6) {
         return $Basics.not(isIdentChar(_p6));
      }));
   };
   var parseTBase_ = A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.TNum),
   whiteTokenOneNonIdent("Num")),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.TBool),
   whiteTokenOneNonIdent("Bool"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.TString),
   whiteTokenOneNonIdent("String"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.TNull),
   whiteTokenOneNonIdent("Null")));
   var parseTBase = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op[">>="],
      parseTBase_,
      function (type_Constructor) {
         return $OurParser2.$return(type_Constructor.val(ws.val));
      });
   });
   var parseNullOp = A2($OurParser2._op["<++"],
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Pi),
   whiteTokenOneNonIdent("pi")),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.DictEmpty),
   whiteTokenOneNonIdent("empty")));
   var parseConst = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseNullOp,
      function (op) {
         return A2($OurParser2._op[">>="],
         whitespace,
         function (ws2) {
            return $OurParser2.$return($Lang.exp_(A4($Lang.EOp,
            ws1.val,
            op,
            _U.list([]),
            ws2.val)));
         });
      }));
   });
   var isSymbol = function (c) {
      return $Basics.not(isAlphaNumeric(c) || (isWhitespace(c) || isDelimiter(c)));
   };
   var whiteTokenOneNonSymbol = function (token) {
      return A2($OurParser2.lookafter,
      whiteToken(token),
      $OurParser2.satisfy(function (_p7) {
         return $Basics.not(isSymbol(_p7));
      }));
   };
   var parseTOp = A2($OurParser2._op["<$>"],
   $Basics.always($Lang.DictInsert),
   whiteTokenOneNonSymbol("insert"));
   var parseBOp = A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<++"],
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Plus),
   whiteTokenOneNonSymbol("+")),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Minus),
   whiteTokenOneNonSymbol("-"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Mult),
   whiteTokenOneNonSymbol("*"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Div),
   whiteTokenOneNonSymbol("/"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Lt),
   whiteTokenOneNonSymbol("<"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Eq),
   whiteTokenOneNonSymbol("="))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Mod),
   whiteTokenOneWS("mod"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.Pow),
   whiteTokenOneWS("pow"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.ArcTan2),
   whiteTokenOneWS("arctan2"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.DictGet),
   whiteTokenOneWS("get"))),
   A2($OurParser2._op["<$>"],
   $Basics.always($Lang.DictRemove),
   whiteTokenOneWS("remove")));
   var isAlpha = function (c) {
      return $Char.isLower(c) || $Char.isUpper(c);
   };
   var unwrapChars = function (_p8) {
      return A2($List.map,
      function (_) {
         return _.val;
      },
      function (_) {
         return _.val;
      }(_p8));
   };
   var parseInt = A2($OurParser2._op[">>="],
   $OurParser2.some($OurParser2.satisfy($Char.isDigit)),
   function (cs) {
      var i = A2($Utils.fromOk,
      "Parser.parseInt",
      $String.toInt($String.fromList(unwrapChars(cs))));
      return A3($OurParser2.returnWithInfo,i,cs.start,cs.end);
   });
   var parseFloat = A2($OurParser2._op[">>="],
   $OurParser2.some($OurParser2.satisfy($Char.isDigit)),
   function (cs1) {
      return A2($OurParser2._op[">>="],
      $OurParser2.satisfy(F2(function (x,y) {
         return _U.eq(x,y);
      })(_U.chr("."))),
      function (c) {
         return A2($OurParser2._op[">>="],
         $OurParser2.some($OurParser2.satisfy($Char.isDigit)),
         function (cs2) {
            var n = A2($Utils.fromOk,
            "Parser.parseFloat",
            $String.toFloat($String.fromList(A2($Basics._op["++"],
            unwrapChars(cs1),
            A2($Basics._op["++"],_U.list([c.val]),unwrapChars(cs2))))));
            return A3($OurParser2.returnWithInfo,n,cs1.start,cs2.end);
         });
      });
   });
   var parseNum = A2($OurParser2._op[">>="],
   parseSign,
   function (i) {
      return A2($OurParser2._op[">>="],
      A2($OurParser2._op["<++"],
      parseFloat,
      A2($OurParser2._op["<$>"],$Basics.toFloat,parseInt)),
      function (n) {
         return A2($OurParser2._op[">>="],
         parseFrozen,
         function (b) {
            return A3($OurParser2.returnWithInfo,
            {ctor: "_Tuple2",_0: i.val * n.val,_1: b.val},
            i.start,
            b.end);
         });
      });
   });
   var parseNumV = A2($OurParser2._op["<$>"],
   function (_p9) {
      var _p10 = _p9;
      return $Lang.vConst({ctor: "_Tuple2"
                          ,_0: _p10._0
                          ,_1: $Lang.dummyTrace_(_p10._1)});
   },
   parseNum);
   var parsePBase = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<$>"],
      function (_p11) {
         return A2($Lang.PConst,ws.val,$Basics.fst(_p11));
      },
      parseNum),
      A2($OurParser2._op["<$>"],
      $Basics.always(A2($Lang.PBase,ws.val,$Lang.EBool(true))),
      whiteTokenOneNonIdent("true"))),
      A2($OurParser2._op["<$>"],
      $Basics.always(A2($Lang.PBase,ws.val,$Lang.EBool(false))),
      whiteTokenOneNonIdent("false"))),
      A2($OurParser2._op["<$>"],$Lang.PBase(ws.val),parseStrLit));
   });
   var parseWidgetDecl = function (cap) {
      return A2($OurParser2._op[">>="],
      $OurParser2.token("{"),
      function (open) {
         return A2($OurParser2._op[">>="],
         preWhite(parseNum),
         function (min) {
            return A2($OurParser2._op[">>="],
            saveToken("-"),
            function (tok) {
               return A2($OurParser2._op[">>="],
               preWhite(parseNum),
               function (max) {
                  return A2($OurParser2._op[">>="],
                  whiteToken("}"),
                  function (close) {
                     var a = _U.update(min,{val: $Basics.fst(min.val)});
                     var b = _U.update(max,{val: $Basics.fst(max.val)});
                     var wd = function () {
                        if (A2($List.all,isInt,_U.list([a.val,b.val]))) {
                              var a$ = _U.update(a,{val: $Basics.floor(a.val)});
                              var b$ = _U.update(b,{val: $Basics.floor(b.val)});
                              return A4($Lang.IntSlider,a$,tok,b$,cap);
                           } else return A4($Lang.NumSlider,a,tok,b,cap);
                     }();
                     return A3($OurParser2.returnWithInfo,wd,open.start,close.end);
                  });
               });
            });
         });
      });
   };
   var parseMaybeWidgetDecl = function (cap) {
      return A2($OurParser2.option,
      $Lang.NoWidgetDecl,
      parseWidgetDecl(cap));
   };
   var parseNumE = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op[">>="],
      parseNum,
      function (nb) {
         return A2($OurParser2._op[">>="],
         parseMaybeWidgetDecl($Maybe.Nothing),
         function (wd) {
            var _p12 = nb.val;
            var n = _p12._0;
            var b = _p12._1;
            var _p13 = wd.val;
            if (_p13.ctor === "NoWidgetDecl") {
                  return A3($OurParser2.returnWithInfo,
                  $Lang.exp_(A4($Lang.EConst,
                  ws.val,
                  n,
                  A2(dummyLocWithDebugInfo,b,n),
                  wd)),
                  nb.start,
                  nb.end);
               } else {
                  return A3($OurParser2.returnWithInfo,
                  $Lang.exp_(A4($Lang.EConst,
                  ws.val,
                  n,
                  A2(dummyLocWithDebugInfo,b,n),
                  wd)),
                  nb.start,
                  wd.end);
               }
         });
      });
   });
   var parseBound = parseNumE;
   var parseIdent_ = function (firstCharPred) {
      return A2($OurParser2._op[">>="],
      $OurParser2.satisfy(firstCharPred),
      function (c) {
         return A2($OurParser2._op[">>="],
         $OurParser2.many($OurParser2.satisfy(isIdentChar)),
         function (cs) {
            var x = $String.fromList(A2($List._op["::"],
            c.val,
            unwrapChars(cs)));
            return A3($OurParser2.returnWithInfo,x,c.start,cs.end);
         });
      });
   };
   var parseIdent = parseIdent_(isAlpha);
   var parseVar = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op["<$>"],
      function (_p14) {
         return $Lang.exp_(A2($Lang.EVar,ws.val,_p14));
      },
      parseIdent);
   });
   var parseTypeCasePat = $OurParser2.recursively(function (_p15) {
      return A2($OurParser2._op["<++"],
      parsePVar(parseIdent),
      parseFlatPatList(parseIdent));
   });
   var parseAsPat = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return A2($OurParser2._op[">>="],
      parseIdent,
      function (ident) {
         return A2($OurParser2._op[">>="],
         whitespace,
         function (ws2) {
            return A2($OurParser2._op[">>="],
            A2($OurParser2._op[">>>"],$OurParser2.token("@"),parsePat),
            function (pat) {
               return A3($OurParser2.returnWithInfo,
               A4($Lang.PAs,ws1.val,ident.val,ws2.val,pat),
               ident.start,
               pat.end);
            });
         });
      });
   });
   var parsePat = $OurParser2.recursively(function (_p16) {
      return A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],parseAsPat,parsePVar(parseIdent)),
      parsePBase),
      parseWildcard),
      parsePatList);
   });
   var parsePatList = A2(parseListLiteralOrMultiCons,
   parsePat,
   $Lang.PList);
   var parsePats = A2($OurParser2._op["<++"],
   A2($OurParser2._op[">>="],
   parsePat,
   function (p) {
      return A3($OurParser2.returnWithInfo,
      _U.list([p]),
      p.start,
      p.end);
   }),
   parens($OurParser2.many(parsePat)));
   var parseLowerIdent = parseIdent_($Char.isLower);
   var parseTVar = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op["<$>"],
      function (ident) {
         return A2($Lang.TVar,ws.val,ident);
      },
      parseLowerIdent);
   });
   var parseOneTForallVar = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op[">>="],
      parseLowerIdent,
      function (a) {
         return $OurParser2.$return({ctor: "_Tuple2"
                                    ,_0: ws.val
                                    ,_1: a.val});
      });
   });
   var parseManyTForallVars = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseOneTForallVar,
      function (tVar) {
         return A2($OurParser2._op[">>="],
         $OurParser2.some(parseOneTForallVar),
         function (tVars) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return(A3($Lang.Many,
               ws1.val,
               A2($List._op["::"],
               tVar.val,
               A2($List.map,function (_) {    return _.val;},tVars.val)),
               ws2.val));
            });
         });
      }));
   });
   var parseTForallVars = A2($OurParser2._op["<++"],
   A2($OurParser2._op[">>="],
   parseOneTForallVar,
   function (tVar) {
      return $OurParser2.$return($Lang.One(tVar.val));
   }),
   parseManyTForallVars);
   var parseUpperIdent = parseIdent_($Char.isUpper);
   var parseTypeAliasPat = $OurParser2.recursively(function (_p17) {
      return A2($OurParser2._op["<++"],
      parsePVar(parseUpperIdent),
      parseFlatPatList(parseUpperIdent));
   });
   var parseTNamed = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op["<$>"],
      function (ident) {
         return A2($Lang.TNamed,ws.val,ident);
      },
      parseUpperIdent);
   });
   var parseSimpleType = $OurParser2.recursively(function (_p18) {
      return A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],parseTBase,parseTList),
      parseTDict),
      parseTTuple),
      parseTUnion),
      parseTNamed),
      parseTVar),
      parseTWildcard);
   });
   var parseTDict = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],whiteTokenOneWS("Dict"),parseType),
      function (tipe1) {
         return A2($OurParser2._op[">>="],
         parseType,
         function (tipe2) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return(A4($Lang.TDict,
               ws1.val,
               tipe1,
               tipe2,
               ws2.val));
            });
         });
      }));
   });
   var parseType = $OurParser2.recursively(function (_p19) {
      return A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],parseSimpleType,parseTArrow),
      parseTForall);
   });
   var parseTArrow = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],
      whiteTokenOneWS("->"),
      $OurParser2.many(parseType)),
      function (types) {
         return A2($OurParser2._op[">>="],
         whitespace,
         function (ws2) {
            return $OurParser2.$return(A3($Lang.TArrow,
            ws1.val,
            types.val,
            ws2.val));
         });
      }));
   });
   var parseTForall = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],
      whiteTokenOneWS("forall"),
      parseTForallVars),
      function (tVars) {
         return A2($OurParser2._op[">>="],
         parseType,
         function (t) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return(A4($Lang.TForall,
               ws1.val,
               tVars.val,
               t,
               ws2.val));
            });
         });
      }));
   });
   var parseTList = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],whiteTokenOneWS("List"),parseType),
      function (tipe) {
         return A2($OurParser2._op[">>="],
         whitespace,
         function (ws2) {
            return $OurParser2.$return(A3($Lang.TList,
            ws1.val,
            tipe,
            ws2.val));
         });
      }));
   });
   var parseTTuple = A2(parseListLiteralOrMultiCons,
   parseType,
   $Lang.TTuple);
   var parseTUnion = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],
      whiteTokenOneWS("union"),
      $OurParser2.many(parseSimpleType)),
      function (types) {
         return A2($OurParser2._op[">>="],
         whitespace,
         function (ws2) {
            return $OurParser2.$return(A3($Lang.TUnion,
            ws1.val,
            types.val,
            ws2.val));
         });
      }));
   });
   var parseT = $OurParser2.parse(parseType);
   var parseCommentExp = A2($OurParser2._op[">>="],
   whitespace,
   function (ws) {
      return A2($OurParser2._op[">>="],
      $OurParser2.token(";"),
      function (semi) {
         return A2($OurParser2._op[">>="],
         $OurParser2.many($OurParser2.satisfy(F2(function (x,y) {
            return !_U.eq(x,y);
         })(_U.chr("\n")))),
         function (cs) {
            return A2($OurParser2._op[">>="],
            $OurParser2.satisfy(F2(function (x,y) {
               return _U.eq(x,y);
            })(_U.chr("\n"))),
            function (newline) {
               return A2($OurParser2._op[">>="],
               parseExp,
               function (e) {
                  return A3($OurParser2.returnWithInfo,
                  $Lang.exp_(A3($Lang.EComment,
                  ws.val,
                  $String.fromList(unwrapChars(cs)),
                  e)),
                  semi.start,
                  e.end);
               });
            });
         });
      });
   });
   var parseExp = $OurParser2.recursively(function (_p20) {
      return A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],
      A2($OurParser2._op["<++"],parseColonType,parseNumE),
      parseEBase),
      parseVar),
      parseFun),
      parseConst),
      parseUnop),
      parseBinop),
      parseTriop),
      parseIf),
      parseCase),
      parseTypeCase),
      parseExpList),
      parseLet),
      parseTypeAlias),
      parseDef),
      parseTyp),
      parseApp),
      parseCommentExp),
      parseLangOption);
   });
   var parseApp = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseExp,
      function (f) {
         return A2($OurParser2._op[">>="],
         parseExpArgs,
         function (es) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return($Lang.exp_(A4($Lang.EApp,
               ws1.val,
               f,
               es.val,
               ws2.val)));
            });
         });
      }));
   });
   var parseExpArgs = $OurParser2.many(parseExp);
   var parseBinop = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseBOp,
      function (op) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e1) {
            return A2($OurParser2._op[">>="],
            parseExp,
            function (e2) {
               return A2($OurParser2._op[">>="],
               whitespace,
               function (ws2) {
                  return $OurParser2.$return($Lang.exp_(A4($Lang.EOp,
                  ws1.val,
                  op,
                  _U.list([e1,e2]),
                  ws2.val)));
               });
            });
         });
      }));
   });
   var parseCase = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],whiteTokenOneWS("case"),parseExp),
      function (e) {
         return A2($OurParser2._op[">>="],
         $OurParser2.some(parseBranch),
         function (bs) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return($Lang.exp_(A4($Lang.ECase,
               ws1.val,
               e,
               bs.val,
               ws2.val)));
            });
         });
      }));
   });
   var parseBranch = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parsePat,
      function (p) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return(A4($Lang.Branch_,
               ws1.val,
               p,
               e,
               ws2.val));
            });
         });
      }));
   });
   var parseColonType = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseExp,
      function (e) {
         return A2($OurParser2._op[">>="],
         whitespace,
         function (ws2) {
            return A2($OurParser2._op[">>="],
            A2($OurParser2._op[">>>"],$OurParser2.token(":"),parseType),
            function (tipe) {
               return A2($OurParser2._op[">>="],
               whitespace,
               function (ws3) {
                  return $OurParser2.$return($Lang.exp_(A5($Lang.EColonType,
                  ws1.val,
                  e,
                  ws2.val,
                  tipe,
                  ws3.val)));
               });
            });
         });
      }));
   });
   var parseDef = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return A2($OurParser2._op[">>="],
      parens(A2($OurParser2._op[">>="],
      parseDefRec,
      function (b) {
         return A2($OurParser2._op[">>="],
         parsePat,
         function (p) {
            return A2($OurParser2._op[">>="],
            parseExp,
            function (e1) {
               return A2($OurParser2._op[">>="],
               whitespace,
               function (ws2) {
                  return $OurParser2.$return({ctor: "_Tuple4"
                                             ,_0: b
                                             ,_1: p
                                             ,_2: e1
                                             ,_3: ws2});
               });
            });
         });
      })),
      function (def) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e2) {
            var _p21 = def.val;
            var b = _p21._0;
            var p = _p21._1;
            var e1 = _p21._2;
            var ws2 = _p21._3;
            return A3($OurParser2.returnWithInfo,
            $Lang.exp_(A7($Lang.ELet,
            ws1.val,
            $Lang.Def,
            b.val,
            p,
            e1,
            e2,
            ws2.val)),
            def.start,
            def.end);
         });
      });
   });
   var parseExpList = A2($OurParser2._op["<$>"],
   $Lang.exp_,
   A2(parseListLiteralOrMultiCons,parseExp,$Lang.EList));
   var parseFun = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],$OurParser2.token("\\"),parsePats),
      function (ps) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return($Lang.exp_(A4($Lang.EFun,
               ws1.val,
               ps.val,
               e,
               ws2.val)));
            });
         });
      }));
   });
   var parseIf = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],whiteTokenOneWS("if"),parseExp),
      function (e1) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e2) {
            return A2($OurParser2._op[">>="],
            parseExp,
            function (e3) {
               return A2($OurParser2._op[">>="],
               whitespace,
               function (ws2) {
                  return $OurParser2.$return($Lang.exp_(A5($Lang.EIf,
                  ws1.val,
                  e1,
                  e2,
                  e3,
                  ws2.val)));
               });
            });
         });
      }));
   });
   var parseLangOption = function () {
      var p = preWhite($OurParser2.munch1(function (c) {
         return !_U.eq(c,_U.chr("\n")) && (!_U.eq(c,
         _U.chr(" ")) && !_U.eq(c,_U.chr(":")));
      }));
      return A2($OurParser2._op[">>="],
      whitespace,
      function (ws1) {
         return A2($OurParser2._op[">>="],
         $OurParser2.token("#"),
         function (pound) {
            return A2($OurParser2._op[">>="],
            p,
            function (s1) {
               return A2($OurParser2._op[">>="],
               A2($OurParser2._op[">>>"],whiteToken(":"),whitespace),
               function (ws2) {
                  return A2($OurParser2._op[">>="],
                  p,
                  function (s2) {
                     return A2($OurParser2._op[">>="],
                     A2($OurParser2._op[">>>"],
                     A2($OurParser2._op[">>>"],
                     $OurParser2.many($OurParser2.satisfy(F2(function (x,y) {
                        return _U.eq(x,y);
                     })(_U.chr(" ")))),
                     $OurParser2.satisfy(F2(function (x,y) {
                        return _U.eq(x,y);
                     })(_U.chr("\n")))),
                     parseExp),
                     function (e) {
                        return A3($OurParser2.returnWithInfo,
                        $Lang.exp_(A5($Lang.EOption,ws1.val,s1,ws2.val,s2,e)),
                        pound.start,
                        e.end);
                     });
                  });
               });
            });
         });
      });
   }();
   var parseLet = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseRec,
      function (b) {
         return A2($OurParser2._op[">>="],
         parsePat,
         function (p) {
            return A2($OurParser2._op[">>="],
            parseExp,
            function (e1) {
               return A2($OurParser2._op[">>="],
               parseExp,
               function (e2) {
                  return A2($OurParser2._op[">>="],
                  whitespace,
                  function (ws2) {
                     return $OurParser2.$return($Lang.exp_(A7($Lang.ELet,
                     ws1.val,
                     $Lang.Let,
                     b.val,
                     p,
                     e1,
                     e2,
                     ws2.val)));
                  });
               });
            });
         });
      }));
   });
   var parseTriop = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseTOp,
      function (op) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e1) {
            return A2($OurParser2._op[">>="],
            parseExp,
            function (e2) {
               return A2($OurParser2._op[">>="],
               parseExp,
               function (e3) {
                  return A2($OurParser2._op[">>="],
                  whitespace,
                  function (ws2) {
                     return $OurParser2.$return($Lang.exp_(A4($Lang.EOp,
                     ws1.val,
                     op,
                     _U.list([e1,e2,e3]),
                     ws2.val)));
                  });
               });
            });
         });
      }));
   });
   var parseTyp = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return A2($OurParser2._op[">>="],
      parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],whiteTokenOneWS("typ"),parsePat),
      function (p) {
         return A2($OurParser2._op[">>="],
         parseType,
         function (tipe) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return({ctor: "_Tuple3"
                                          ,_0: p
                                          ,_1: tipe
                                          ,_2: ws2});
            });
         });
      })),
      function (typ) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e) {
            var _p22 = typ.val;
            var p = _p22._0;
            var tipe = _p22._1;
            var ws2 = _p22._2;
            return A3($OurParser2.returnWithInfo,
            $Lang.exp_(A5($Lang.ETyp,ws1.val,p,tipe,e,ws2.val)),
            typ.start,
            typ.end);
         });
      });
   });
   var parseTypeAlias = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return A2($OurParser2._op[">>="],
      parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],
      whiteTokenOneWS("def"),
      parseTypeAliasPat),
      function (p) {
         return A2($OurParser2._op[">>="],
         parseType,
         function (tipe) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return({ctor: "_Tuple3"
                                          ,_0: p
                                          ,_1: tipe
                                          ,_2: ws2});
            });
         });
      })),
      function (typ) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e) {
            var _p23 = typ.val;
            var p = _p23._0;
            var tipe = _p23._1;
            var ws2 = _p23._2;
            return A3($OurParser2.returnWithInfo,
            $Lang.exp_(A5($Lang.ETypeAlias,ws1.val,p,tipe,e,ws2.val)),
            typ.start,
            typ.end);
         });
      });
   });
   var parseTypeCase = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      A2($OurParser2._op[">>>"],
      whiteTokenOneWS("typecase"),
      parseTypeCasePat),
      function (pat) {
         return A2($OurParser2._op[">>="],
         $OurParser2.some(parseTBranch),
         function (bs) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return($Lang.exp_(A4($Lang.ETypeCase,
               ws1.val,
               pat,
               bs.val,
               ws2.val)));
            });
         });
      }));
   });
   var parseTBranch = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseType,
      function (tipe) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return(A4($Lang.TBranch_,
               ws1.val,
               tipe,
               e,
               ws2.val));
            });
         });
      }));
   });
   var parseUnop = A2($OurParser2._op[">>="],
   whitespace,
   function (ws1) {
      return parens(A2($OurParser2._op[">>="],
      parseUOp,
      function (op) {
         return A2($OurParser2._op[">>="],
         parseExp,
         function (e1) {
            return A2($OurParser2._op[">>="],
            whitespace,
            function (ws2) {
               return $OurParser2.$return($Lang.exp_(A4($Lang.EOp,
               ws1.val,
               op,
               _U.list([e1]),
               ws2.val)));
            });
         });
      }));
   });
   var parseE_ = function (f) {
      return $OurParser2.parse(A2($OurParser2._op[">>="],
      parseExp,
      function (e) {
         return A2($OurParser2._op[">>>"],
         preWhite($OurParser2.end),
         A3($OurParser2.returnWithInfo,f(e).val,e.start,e.end));
      }));
   };
   var substPlusOf_ = F2(function (substPlus,exp) {
      var accumulator = F2(function (e,s) {
         var _p24 = e.val.e__;
         if (_p24.ctor === "EConst" && _p24._2.ctor === "_Tuple3") {
               var _p27 = _p24._1;
               var _p26 = _p24._2._0;
               var _p25 = A2($Dict.get,_p26,s);
               if (_p25.ctor === "Nothing") {
                     return A3($Dict.insert,_p26,_U.update(e,{val: _p27}),s);
                  } else {
                     return _U.eq(_p27,_p25._0.val) ? s : _U.crash("LangParser2",
                     {start: {line: 155,column: 46}
                     ,end: {line: 155,column: 57}})(A2($Basics._op["++"],
                     "substPlusOf_ Constant: ",
                     $Basics.toString(_p27)));
                  }
            } else {
               return s;
            }
      });
      return A3($Lang.foldExp,accumulator,substPlus,exp);
   });
   var recordIdentifiers = function (_p28) {
      recordIdentifiers: while (true) {
         var _p29 = _p28;
         var _p39 = _p29._0;
         var _p38 = _p29._1;
         var ret = function (e__) {
            return A3($OurParser2.WithInfo,
            A2($Lang.Exp_,e__,_p38.val.eid),
            _p38.start,
            _p38.end);
         };
         var _p30 = {ctor: "_Tuple2",_0: _p39.val,_1: _p38.val.e__};
         _v5_4: do {
            _v5_3: do {
               switch (_p30._0.ctor)
               {case "PVar": switch (_p30._1.ctor)
                    {case "EConst": if (_p30._1._2.ctor === "_Tuple3") {
                               return ret(A4($Lang.EConst,
                               _p30._1._0,
                               _p30._1._1,
                               {ctor: "_Tuple3"
                               ,_0: _p30._1._2._0
                               ,_1: _p30._1._2._1
                               ,_2: _p30._0._1},
                               _p30._1._3));
                            } else {
                               break _v5_4;
                            }
                       case "EColonType": break _v5_3;
                       default: break _v5_4;}
                  case "PList": switch (_p30._1.ctor)
                    {case "EList": var _p37 = _p30._1._4;
                         var _p36 = _p30._1._2;
                         var _p35 = _p30._1._0;
                         var _p34 = _p30._1._3;
                         var _p33 = _p30._1._1;
                         var _p31 = A2($Utils.maybeZip,_p30._0._1,_p33);
                         if (_p31.ctor === "Nothing") {
                               return ret(A5($Lang.EList,_p35,_p33,_p36,_p34,_p37));
                            } else {
                               var es$ = A2($List.map,recordIdentifiers,_p31._0);
                               var me$ = function () {
                                  var _p32 = {ctor: "_Tuple2",_0: _p30._0._3,_1: _p34};
                                  if (_p32.ctor === "_Tuple2" && _p32._0.ctor === "Just" && _p32._1.ctor === "Just")
                                  {
                                        return $Maybe.Just(recordIdentifiers({ctor: "_Tuple2"
                                                                             ,_0: _p32._0._0
                                                                             ,_1: _p32._1._0}));
                                     } else {
                                        return _p34;
                                     }
                               }();
                               return ret(A5($Lang.EList,_p35,es$,_p36,me$,_p37));
                            }
                       case "EColonType": break _v5_3;
                       default: break _v5_4;}
                  case "PAs": var _v8 = {ctor: "_Tuple2",_0: _p30._0._3,_1: _p38};
                    _p28 = _v8;
                    continue recordIdentifiers;
                  default: if (_p30._1.ctor === "EColonType") {
                          break _v5_3;
                       } else {
                          break _v5_4;
                       }}
            } while (false);
            return ret(A5($Lang.EColonType,
            _p30._1._0,
            recordIdentifiers({ctor: "_Tuple2",_0: _p39,_1: _p30._1._1}),
            _p30._1._2,
            _p30._1._3,
            _p30._1._4));
         } while (false);
         return ret(_p30._1);
      }
   };
   var freshen_ = F2(function (k,e) {
      return function (_p40) {
         var _p41 = _p40;
         var _p43 = _p41._0;
         var nextK = function () {
            var _p42 = _p43;
            if (_p42.ctor === "EConst" && _p42._2.ctor === "_Tuple3") {
                  return _p42._2._0;
               } else {
                  return _p41._1;
               }
         }();
         return {ctor: "_Tuple2"
                ,_0: A3($OurParser2.WithInfo,
                A2($Lang.Exp_,_p43,nextK),
                e.start,
                e.end)
                ,_1: nextK + 1};
      }(function () {
         var _p44 = e.val.e__;
         switch (_p44.ctor)
         {case "EConst": var _p45 = _p44._2;
              var b = _p45._1;
              var x = _p45._2;
              return {ctor: "_Tuple2"
                     ,_0: A4($Lang.EConst,
                     _p44._0,
                     _p44._1,
                     {ctor: "_Tuple3",_0: k,_1: b,_2: x},
                     _p44._3)
                     ,_1: k + 1};
            case "EBase": return {ctor: "_Tuple2"
                                 ,_0: A2($Lang.EBase,_p44._0,_p44._1)
                                 ,_1: k};
            case "EVar": return {ctor: "_Tuple2"
                                ,_0: A2($Lang.EVar,_p44._0,_p44._1)
                                ,_1: k};
            case "EFun": var _p46 = A2(freshen_,k,_p44._2);
              var e$ = _p46._0;
              var k$ = _p46._1;
              return {ctor: "_Tuple2"
                     ,_0: A4($Lang.EFun,_p44._0,_p44._1,e$,_p44._3)
                     ,_1: k$};
            case "EApp": var _p47 = A2($Utils.mapFst,
              $Utils.uncons,
              A2(freshenExps,k,A2($List._op["::"],_p44._1,_p44._2)));
              var f$ = _p47._0._0;
              var es$ = _p47._0._1;
              var k$ = _p47._1;
              return {ctor: "_Tuple2"
                     ,_0: A4($Lang.EApp,_p44._0,f$,es$,_p44._3)
                     ,_1: k$};
            case "EOp": var _p48 = A2(freshenExps,k,_p44._2);
              var es$ = _p48._0;
              var k$ = _p48._1;
              return {ctor: "_Tuple2"
                     ,_0: A4($Lang.EOp,_p44._0,_p44._1,es$,_p44._3)
                     ,_1: k$};
            case "EList": var _p54 = _p44._4;
              var _p53 = _p44._2;
              var _p52 = _p44._0;
              var _p49 = A2(freshenExps,k,_p44._1);
              var es$ = _p49._0;
              var k$ = _p49._1;
              var _p50 = _p44._3;
              if (_p50.ctor === "Nothing") {
                    return {ctor: "_Tuple2"
                           ,_0: A5($Lang.EList,_p52,es$,_p53,$Maybe.Nothing,_p54)
                           ,_1: k$};
                 } else {
                    var _p51 = A2(freshen_,k$,_p50._0);
                    var e$ = _p51._0;
                    var k$$ = _p51._1;
                    return {ctor: "_Tuple2"
                           ,_0: A5($Lang.EList,_p52,es$,_p53,$Maybe.Just(e$),_p54)
                           ,_1: k$$};
                 }
            case "EIf": var _p55 = A2($Utils.mapFst,
              $Utils.unwrap3,
              A2(freshenExps,k,_U.list([_p44._1,_p44._2,_p44._3])));
              var e1$ = _p55._0._0;
              var e2$ = _p55._0._1;
              var e3$ = _p55._0._2;
              var k$ = _p55._1;
              return {ctor: "_Tuple2"
                     ,_0: A5($Lang.EIf,_p44._0,e1$,e2$,e3$,_p44._4)
                     ,_1: k$};
            case "ELet": var _p57 = _p44._3;
              var _p56 = A2($Utils.mapFst,
              $Utils.unwrap2,
              A2(freshenExps,k,_U.list([_p44._4,_p44._5])));
              var e1$ = _p56._0._0;
              var e2$ = _p56._0._1;
              var k$ = _p56._1;
              var e1$$ = recordIdentifiers({ctor: "_Tuple2"
                                           ,_0: _p57
                                           ,_1: e1$});
              return {ctor: "_Tuple2"
                     ,_0: A7($Lang.ELet,
                     _p44._0,
                     _p44._1,
                     _p44._2,
                     _p57,
                     e1$$,
                     e2$,
                     _p44._6)
                     ,_1: k$};
            case "ECase": var _p60 = _p44._2;
              var bes = $Lang.branchExps(_p60);
              var _p58 = A2($Utils.mapFst,
              $Utils.uncons,
              A2(freshenExps,k,A2($List._op["::"],_p44._1,bes)));
              var e$ = _p58._0._0;
              var bes$ = _p58._0._1;
              var k$ = _p58._1;
              var replaceBranch = F2(function (oldBranch,newE) {
                 var _p59 = oldBranch.val;
                 var bws1 = _p59._0;
                 var pat = _p59._1;
                 var oldE = _p59._2;
                 var bws2 = _p59._3;
                 return _U.update(oldBranch,
                 {val: A4($Lang.Branch_,bws1,pat,newE,bws2)});
              });
              return {ctor: "_Tuple2"
                     ,_0: A4($Lang.ECase,
                     _p44._0,
                     e$,
                     A3($List.map2,replaceBranch,_p60,bes$),
                     _p44._3)
                     ,_1: k$};
            case "ETypeCase": var _p63 = _p44._2;
              var bes = $Lang.tbranchExps(_p63);
              var _p61 = A2(freshenExps,k,bes);
              var bes$ = _p61._0;
              var k$ = _p61._1;
              var replaceBranch = F2(function (oldBranch,newE) {
                 var _p62 = oldBranch.val;
                 var bws1 = _p62._0;
                 var tipe = _p62._1;
                 var oldE = _p62._2;
                 var bws2 = _p62._3;
                 return _U.update(oldBranch,
                 {val: A4($Lang.TBranch_,bws1,tipe,newE,bws2)});
              });
              return {ctor: "_Tuple2"
                     ,_0: A4($Lang.ETypeCase,
                     _p44._0,
                     _p44._1,
                     A3($List.map2,replaceBranch,_p63,bes$),
                     _p44._3)
                     ,_1: k$};
            case "EComment": var _p64 = A2(freshen_,k,_p44._2);
              var e1$ = _p64._0;
              var k$ = _p64._1;
              return {ctor: "_Tuple2"
                     ,_0: A3($Lang.EComment,_p44._0,_p44._1,e1$)
                     ,_1: k$};
            case "EOption": var _p65 = A2(freshen_,k,_p44._4);
              var e1$ = _p65._0;
              var k$ = _p65._1;
              return {ctor: "_Tuple2"
                     ,_0: A5($Lang.EOption,_p44._0,_p44._1,_p44._2,_p44._3,e1$)
                     ,_1: k$};
            case "ETyp": var _p66 = A2(freshen_,k,_p44._3);
              var e$ = _p66._0;
              var k$ = _p66._1;
              return {ctor: "_Tuple2"
                     ,_0: A5($Lang.ETyp,_p44._0,_p44._1,_p44._2,e$,_p44._4)
                     ,_1: k$};
            case "EColonType": var _p67 = A2(freshen_,k,_p44._1);
              var e$ = _p67._0;
              var k$ = _p67._1;
              return {ctor: "_Tuple2"
                     ,_0: A5($Lang.EColonType,_p44._0,e$,_p44._2,_p44._3,_p44._4)
                     ,_1: k$};
            default: var _p68 = A2(freshen_,k,_p44._3);
              var e$ = _p68._0;
              var k$ = _p68._1;
              return {ctor: "_Tuple2"
                     ,_0: A5($Lang.ETypeAlias,_p44._0,_p44._1,_p44._2,e$,_p44._4)
                     ,_1: k$};}
      }());
   });
   var freshenExps = F2(function (k,es) {
      return A3($List.foldr,
      F2(function (e,_p69) {
         var _p70 = _p69;
         var _p71 = A2(freshen_,_p70._1,e);
         var e1 = _p71._0;
         var k1 = _p71._1;
         return {ctor: "_Tuple2"
                ,_0: A2($List._op["::"],e1,_p70._0)
                ,_1: k1};
      }),
      {ctor: "_Tuple2",_0: _U.list([]),_1: k},
      es);
   });
   var _p72 = A2(freshen_,
   1,
   A2($Utils.fromOkay,
   "parse prelude",
   A2(parseE_,$Basics.identity,$PreludeGenerated.src)));
   var prelude = _p72._0;
   var initK = _p72._1;
   var isPreludeLocId = function (k) {
      return _U.cmp(k,initK) < 0;
   };
   var isPreludeLoc = function (_p73) {
      var _p74 = _p73;
      return isPreludeLocId(_p74._0);
   };
   var isPreludeEId = function (k) {
      return _U.cmp(k,initK) < 0;
   };
   var freshen = function (e) {
      return $Basics.fst(A2(freshen_,initK,e));
   };
   var parseE = parseE_(freshen);
   var substPlusOf = function (e) {
      var preludeSubst = A2(substPlusOf_,$Dict.empty,prelude);
      return A2(substPlusOf_,preludeSubst,e);
   };
   var substOf = function (_p75) {
      return A2($Dict.map,
      $Basics.always(function (_) {    return _.val;}),
      substPlusOf(_p75));
   };
   var substStrOf = function (_p76) {
      return A2($Dict.map,
      $Basics.always($Basics.toString),
      substOf(_p76));
   };
   return _elm.LangParser2.values = {_op: _op
                                    ,prelude: prelude
                                    ,isPreludeLoc: isPreludeLoc
                                    ,isPreludeLocId: isPreludeLocId
                                    ,isPreludeEId: isPreludeEId
                                    ,substOf: substOf
                                    ,substStrOf: substStrOf
                                    ,parseE: parseE
                                    ,parseT: parseT
                                    ,freshen: freshen
                                    ,substPlusOf: substPlusOf};
};
Elm.Types = Elm.Types || {};
Elm.Types.make = function (_elm) {
   "use strict";
   _elm.Types = _elm.Types || {};
   if (_elm.Types.values) return _elm.Types.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Ace = Elm.Ace.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangParser2 = Elm.LangParser2.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $OurParser2 = Elm.OurParser2.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var main = $Graphics$Element.show(1);
   var dummyAceTypeInfo = {annotations: _U.list([])
                          ,highlights: _U.list([])
                          ,tooltips: _U.list([])};
   var aceTypeInfo = function (typeInfo) {
      var errorAnnots = A2($List.map,
      function (i) {
         return {row: i,text: "Type Error...",type_: "error"};
      },
      $Set.toList(A3($List.foldr,
      F2(function (typeError,acc) {
         return A2($Set.insert,typeError.pos.line - 1,acc);
      }),
      $Set.empty,
      typeInfo.typeErrors)));
      var _p0 = A3($List.foldr,
      F2(function (typeError,_p1) {
         var _p2 = _p1;
         var _p3 = {ctor: "_Tuple2"
                   ,_0: typeError.pos.line - 1
                   ,_1: typeError.pos.col - 1};
         var i = _p3._0;
         var j = _p3._1;
         var tip = {row: i,col: j,text: typeError.val};
         var marker = {color: "orange"
                      ,range: {start: {row: i + 1,column: j + 1}
                              ,end: {row: i + 1,column: j + 2}}};
         return {ctor: "_Tuple2"
                ,_0: A2($List._op["::"],tip,_p2._0)
                ,_1: A2($List._op["::"],marker,_p2._1)};
      }),
      {ctor: "_Tuple2",_0: _U.list([]),_1: _U.list([])},
      typeInfo.typeErrors);
      var errorTips = _p0._0;
      var errorHighlights = _p0._1;
      var varTypeTips = A3($List.foldr,
      F2(function (_p4,acc) {
         var _p5 = _p4;
         var _p8 = _p5._0;
         var _p7 = _p5._1;
         var s1 = $String.trim($LangUnparser.unparsePat(_p8));
         var _p6 = {ctor: "_Tuple2"
                   ,_0: A2($Dict.get,_p7,typeInfo.finalTypes)
                   ,_1: A2($Dict.get,_p7,typeInfo.rawTypes)};
         _v2_2: do {
            if (_p6.ctor === "_Tuple2") {
                  if (_p6._0.ctor === "Just" && _p6._0._0.ctor === "Just") {
                        var text = A2($Basics._op["++"],
                        s1,
                        A2($Basics._op["++"],
                        " : ",
                        A2($Basics._op["++"],
                        $String.trim($LangUnparser.unparseType(_p6._0._0._0)),
                        " ")));
                        return A2($List._op["::"],
                        {row: _p8.start.line - 1,col: _p8.start.col - 1,text: text},
                        acc);
                     } else {
                        if (_p6._1.ctor === "Just" && _p6._1._0.ctor === "_Tuple2" && _p6._1._0._1.ctor === "Just")
                        {
                              var text = A2($Basics._op["++"],
                              s1,
                              A2($Basics._op["++"],
                              " : ",
                              A2($Basics._op["++"],
                              $String.trim($LangUnparser.unparseType(_p6._1._0._1._0)),
                              " ")));
                              return A2($List._op["::"],
                              {row: _p8.start.line - 1,col: _p8.start.col - 1,text: text},
                              acc);
                           } else {
                              break _v2_2;
                           }
                     }
               } else {
                  break _v2_2;
               }
         } while (false);
         return acc;
      }),
      _U.list([]),
      typeInfo.namedExps);
      var expTypeTips = A3($Dict.foldr,
      F3(function (eid,_p9,acc) {
         var _p10 = _p9;
         var _p12 = _p10._0;
         var record = function (t) {
            var text = $String.trim($LangUnparser.unparseType(t));
            return {row: _p12.line - 1,col: _p12.col - 1,text: text};
         };
         var _p11 = {ctor: "_Tuple2"
                    ,_0: A2($Dict.get,eid,typeInfo.finalTypes)
                    ,_1: _p10._1};
         _v4_2: do {
            if (_p11.ctor === "_Tuple2") {
                  if (_p11._0.ctor === "Just" && _p11._0._0.ctor === "Just") {
                        return A2($List._op["::"],record(_p11._0._0._0),acc);
                     } else {
                        if (_p11._1.ctor === "Just") {
                              return A2($List._op["::"],record(_p11._1._0),acc);
                           } else {
                              break _v4_2;
                           }
                     }
               } else {
                  break _v4_2;
               }
         } while (false);
         return acc;
      }),
      _U.list([]),
      typeInfo.rawTypes);
      return {annotations: errorAnnots
             ,highlights: errorHighlights
             ,tooltips: A2($Basics._op["++"],
             varTypeTips,
             A2($Basics._op["++"],expTypeTips,errorTips))};
   };
   var preludeTypeEnv = _U.list([]);
   var initTypeInfo = {constraints: _U.list([])
                      ,activeConstraints: _U.list([])
                      ,typeErrors: _U.list([])
                      ,rawTypes: $Dict.empty
                      ,finalTypes: $Dict.empty
                      ,namedExps: _U.list([])
                      ,constraintCount: 0
                      ,constraintVarCount: 0
                      ,preludeTypeEnv: $Maybe.Nothing};
   var applyUnifier = function (unifier) {
      return $Lang.mapType(function (t) {
         var _p13 = t.val;
         if (_p13.ctor === "TVar") {
               var _p14 = A2($Utils.maybeFind,_p13._1,unifier);
               if (_p14.ctor === "Just") {
                     return _p14._0;
                  } else {
                     return t;
                  }
            } else {
               return t;
            }
      });
   };
   var applyUnifierToConstraints = function (unifier) {
      return $List.map($Utils.mapSnd(function (_p15) {
         var _p16 = _p15;
         return {ctor: "_Tuple2"
                ,_0: A2(applyUnifier,unifier,_p16._0)
                ,_1: A2(applyUnifier,unifier,_p16._1)};
      }));
   };
   var rewriteArrow = F2(function (unifier,_p17) {
      var _p18 = _p17;
      var argTypes$ = A2($List.map,applyUnifier(unifier),_p18._0);
      var retType$ = A2(applyUnifier,unifier,_p18._1);
      return {ctor: "_Tuple2",_0: argTypes$,_1: retType$};
   });
   var strUnifier = function (_p19) {
      return $Utils.bracks($Utils.spaces(A2($List.map,
      function (_p20) {
         var _p21 = _p20;
         return A2($Basics._op["++"],
         _p21._0,
         A2($Basics._op["++"],
         "=",
         $String.trim($LangUnparser.unparseType(_p21._1))));
      },
      _p19)));
   };
   var bindSubtypeResult = F2(function (res1,f) {
      var _p22 = res1.result;
      if (_p22.ctor === "Err") {
            return {result: $Result.Err(_p22._0)
                   ,typeInfo: res1.typeInfo};
         } else {
            return f(res1.typeInfo);
         }
   });
   var tryCatchAlls = F2(function (err,list) {
      tryCatchAlls: while (true) {
         var _p23 = list;
         if (_p23.ctor === "[]") {
               return err;
            } else {
               var _p24 = _p23._0({ctor: "_Tuple0"});
               if (_p24.ctor === "Nothing") {
                     var _v13 = err,_v14 = _p23._1;
                     err = _v13;
                     list = _v14;
                     continue tryCatchAlls;
                  } else {
                     return {result: $Result.Ok({ctor: "_Tuple0"})
                            ,typeInfo: _p24._0};
                  }
            }
      }
   });
   var propagateResult = function (result) {    return result;};
   var isConstraintVar = function (a) {
      var _p25 = A2($Utils.munchString,"_x",a);
      if (_p25.ctor === "Nothing") {
            return false;
         } else {
            return true;
         }
   };
   var constraintVarsOf = function (ts) {
      return A3($List.foldl,
      F2(function (argType,acc) {
         var _p26 = argType.val;
         if (_p26.ctor === "TVar") {
               var _p27 = _p26._1;
               return isConstraintVar(_p27) ? A2($Set.insert,_p27,acc) : acc;
            } else {
               return acc;
            }
      }),
      $Set.empty,
      ts);
   };
   var constraintVarsOfArrow = function (_p28) {
      var _p29 = _p28;
      return constraintVarsOf(A2($Basics._op["++"],
      _p29._0,
      _U.list([_p29._1])));
   };
   var checkSubtypeTVar = F3(function (t,okConstrain,err) {
      var _p30 = t.val;
      if (_p30.ctor === "TVar") {
            if (isConstraintVar(_p30._1)) {
                  var result = okConstrain;
                  return $Maybe.Just(result.typeInfo);
               } else return $Maybe.Nothing;
         } else {
            return $Maybe.Nothing;
         }
   });
   var splitTypesInArrow = function (ts) {
      var n = $List.length(ts);
      var argTypes = A2($List.take,n - 1,ts);
      var _p31 = A2($List.drop,n - 1,ts);
      if (_p31.ctor === "::" && _p31._1.ctor === "[]") {
            return {ctor: "_Tuple2",_0: argTypes,_1: _p31._0};
         } else {
            return _U.crashCase("Types",
            {start: {line: 513,column: 3},end: {line: 515,column: 52}},
            _p31)("splitTypesInArrow");
         }
   };
   var isArrowTemplate = function (tipe) {
      var _p33 = tipe.val;
      if (_p33.ctor === "TArrow") {
            var _p34 = _p33._1;
            return $Set.isEmpty(constraintVarsOf(_p34)) ? $Maybe.Nothing : $Maybe.Just(splitTypesInArrow(_p34));
         } else {
            return $Maybe.Nothing;
         }
   };
   var stripArrow = function (t) {
      var _p35 = t.val;
      if (_p35.ctor === "TArrow") {
            return $Maybe.Just(splitTypesInArrow(_p35._1));
         } else {
            return $Maybe.Nothing;
         }
   };
   var stripPolymorphicArrow = function (t) {
      var _p36 = t.val;
      if (_p36.ctor === "TForall") {
            if (_p36._1.ctor === "One") {
                  return A2($Utils.bindMaybe,
                  function (arrow) {
                     return $Maybe.Just({ctor: "_Tuple2"
                                        ,_0: _U.list([$Basics.snd(_p36._1._0)])
                                        ,_1: arrow});
                  },
                  stripArrow(_p36._2));
               } else {
                  return A2($Utils.bindMaybe,
                  function (arrow) {
                     return $Maybe.Just({ctor: "_Tuple2"
                                        ,_0: A2($List.map,$Basics.snd,_p36._1._1)
                                        ,_1: arrow});
                  },
                  stripArrow(_p36._2));
               }
         } else {
            return A2($Utils.bindMaybe,
            function (arrow) {
               return $Maybe.Just({ctor: "_Tuple2"
                                  ,_0: _U.list([])
                                  ,_1: arrow});
            },
            stripArrow(t));
         }
   };
   var generateConstraintVars = F2(function (n,typeInfo) {
      var k = typeInfo.constraintVarCount;
      var vars = A2($List.map,
      function (i) {
         return A2($Basics._op["++"],"_x",$Basics.toString(i));
      },
      _U.range(k + 1,k + n));
      return {ctor: "_Tuple2"
             ,_0: vars
             ,_1: _U.update(typeInfo,{constraintVarCount: k + n})};
   });
   var addTypeErrorAt = F3(function (pos,typeError,typeInfo) {
      return _U.update(typeInfo,
      {typeErrors: A2($List._op["::"],
      A2($OurParser2.WithPos,typeError,pos),
      typeInfo.typeErrors)});
   });
   var finishSynthesizeWithError = F3(function (pos,
   error,
   typeInfo) {
      return {result: $Maybe.Nothing
             ,typeInfo: A3(addTypeErrorAt,pos,error,typeInfo)};
   });
   var addFinalType = F3(function (eid,mt,typeInfo) {
      return _U.update(typeInfo,
      {finalTypes: A3($Dict.insert,eid,mt,typeInfo.finalTypes)});
   });
   var addRawType = F4(function (eid,pos,mt,typeInfo) {
      return _U.update(typeInfo,
      {rawTypes: A3($Dict.insert,
      eid,
      {ctor: "_Tuple2",_0: pos,_1: mt},
      typeInfo.rawTypes)});
   });
   var finishSynthesizeWithType = F4(function (eid,
   pos,
   tipe,
   typeInfo) {
      return {result: $Maybe.Just(tipe)
             ,typeInfo: A4(addRawType,eid,pos,$Maybe.Just(tipe),typeInfo)};
   });
   var addNamedExp = F3(function (p,eid,typeInfo) {
      return _U.update(typeInfo,
      {namedExps: A2($List._op["::"],
      {ctor: "_Tuple2",_0: p,_1: eid},
      typeInfo.namedExps)});
   });
   var addRawConstraints = F2(function (constraints,typeInfo) {
      var k = typeInfo.constraintCount;
      var n = $List.length(constraints);
      var constraints$ = A2($Utils.zip,
      _U.range(k + 1,k + n),
      constraints);
      return _U.update(typeInfo,
      {constraints: A2($Basics._op["++"],
      constraints$,
      typeInfo.constraints)
      ,activeConstraints: A2($Basics._op["++"],
      constraints$,
      typeInfo.activeConstraints)
      ,constraintCount: k + n});
   });
   var expandTypeAlias = F2(function (typeEnv,x) {
      expandTypeAlias: while (true) {
         var check = function (pts) {
            check: while (true) {
               var _p37 = pts;
               if (_p37.ctor === "[]") {
                     return $Maybe.Nothing;
                  } else {
                     var _p40 = _p37._0._1;
                     var _p39 = _p37._1;
                     var _p38 = {ctor: "_Tuple2",_0: _p37._0._0.val,_1: _p40.val};
                     _v24_2: do {
                        if (_p38.ctor === "_Tuple2") {
                              switch (_p38._0.ctor)
                              {case "PVar": if (_U.eq(x,_p38._0._1)) return $Maybe.Just(_p40);
                                   else {
                                         var _v25 = _p39;
                                         pts = _v25;
                                         continue check;
                                      }
                                 case "PList":
                                 if (_p38._0._3.ctor === "Nothing" && _p38._1.ctor === "TTuple" && _p38._1._3.ctor === "Nothing")
                                   {
                                         var _v26 = A2($Basics._op["++"],
                                         A2($Utils.zip,_p38._0._1,_p38._1._1),
                                         _p39);
                                         pts = _v26;
                                         continue check;
                                      } else {
                                         break _v24_2;
                                      }
                                 default: break _v24_2;}
                           } else {
                              break _v24_2;
                           }
                     } while (false);
                     return $Maybe.Nothing;
                  }
            }
         };
         var _p41 = typeEnv;
         if (_p41.ctor === "::") {
               if (_p41._0.ctor === "TypeAlias") {
                     var _p42 = check(_U.list([{ctor: "_Tuple2"
                                               ,_0: _p41._0._0
                                               ,_1: _p41._0._1}]));
                     if (_p42.ctor === "Just") {
                           return $Maybe.Just(_p42._0);
                        } else {
                           var _v29 = _p41._1,_v30 = x;
                           typeEnv = _v29;
                           x = _v30;
                           continue expandTypeAlias;
                        }
                  } else {
                     var _v31 = _p41._1,_v32 = x;
                     typeEnv = _v31;
                     x = _v32;
                     continue expandTypeAlias;
                  }
            } else {
               return $Maybe.Nothing;
            }
      }
   });
   var lookupTypeAlias = F2(function (typeEnv,x) {
      var _p43 = A2(expandTypeAlias,typeEnv,x);
      if (_p43.ctor === "Just") {
            return true;
         } else {
            return false;
         }
   });
   var lookupTypAnnotation_ = F2(function (typeEnv,x) {
      lookupTypAnnotation_: while (true) {
         var _p44 = typeEnv;
         if (_p44.ctor === "[]") {
               return $Maybe.Nothing;
            } else {
               switch (_p44._0.ctor)
               {case "TypeVar": var _v35 = _p44._1,_v36 = x;
                    typeEnv = _v35;
                    x = _v36;
                    continue lookupTypAnnotation_;
                  case "TypeAlias": var _v37 = _p44._1,_v38 = x;
                    typeEnv = _v37;
                    x = _v38;
                    continue lookupTypAnnotation_;
                  case "CheckType": if (_U.eq(x,_p44._0._0))
                    return $Maybe.Just(_p44._0._1); else {
                          var _v39 = _p44._1,_v40 = x;
                          typeEnv = _v39;
                          x = _v40;
                          continue lookupTypAnnotation_;
                       }
                  default: if (_U.eq(x,_p44._0._0)) return $Maybe.Nothing; else {
                          var _v41 = _p44._1,_v42 = x;
                          typeEnv = _v41;
                          x = _v42;
                          continue lookupTypAnnotation_;
                       }}
            }
      }
   });
   var lookupTypAnnotation = F2(function (typeEnv,p) {
      var _p45 = p.val;
      if (_p45.ctor === "PVar") {
            return A2(lookupTypAnnotation_,typeEnv,_p45._1);
         } else {
            return $Maybe.Nothing;
         }
   });
   var lookupVar = F2(function (typeEnv,x) {
      lookupVar: while (true) {
         var _p46 = typeEnv;
         if (_p46.ctor === "[]") {
               return $Maybe.Nothing;
            } else {
               switch (_p46._0.ctor)
               {case "TypeVar": var _v45 = _p46._1,_v46 = x;
                    typeEnv = _v45;
                    x = _v46;
                    continue lookupVar;
                  case "TypeAlias": var _v47 = _p46._1,_v48 = x;
                    typeEnv = _v47;
                    x = _v48;
                    continue lookupVar;
                  case "HasType": if (_U.eq(x,_p46._0._0))
                    return $Maybe.Just(_p46._0._1); else {
                          var _v49 = _p46._1,_v50 = x;
                          typeEnv = _v49;
                          x = _v50;
                          continue lookupVar;
                       }
                  default: if (_U.eq(x,_p46._0._0)) return $Maybe.Nothing; else {
                          var _v51 = _p46._1,_v52 = x;
                          typeEnv = _v51;
                          x = _v52;
                          continue lookupVar;
                       }}
            }
      }
   });
   var strRawConstraint = function (_p47) {
      var _p48 = _p47;
      return $Utils.spaces(_U.list([$String.trim($LangUnparser.unparseType(_p48._0))
                                   ,"="
                                   ,$String.trim($LangUnparser.unparseType(_p48._1))]));
   };
   var strConstraint = function (_p49) {
      var _p50 = _p49;
      return $Utils.spaces(_U.list([$Utils.bracks($Basics.toString(_p50._0))
                                   ,strRawConstraint(_p50._1)]));
   };
   var strEInfo = function (eInfo) {
      return $Utils.spaces(_U.list([$Basics.toString(eInfo.val)
                                   ,$Lang.strPos(eInfo.start)]));
   };
   var eInfoOf = function (e) {
      return {val: e.val.eid,start: e.start,end: e.end};
   };
   var tForall = F2(function (vars,t) {
      var _p51 = vars;
      if (_p51.ctor === "[]") {
            return _U.crashCase("Types",
            {start: {line: 189,column: 3},end: {line: 193,column: 70}},
            _p51)("tForall: no vars");
         } else {
            if (_p51._1.ctor === "[]") {
                  return $Lang.withDummyRange(A4($Lang.TForall,
                  " ",
                  $Lang.One({ctor: "_Tuple2",_0: " ",_1: _p51._0}),
                  t,
                  ""));
               } else {
                  var typeVars = A2($List._op["::"],
                  {ctor: "_Tuple2",_0: "",_1: _p51._0},
                  A2($List.map,
                  function (a) {
                     return {ctor: "_Tuple2",_0: " ",_1: a};
                  },
                  _p51._1));
                  return $Lang.withDummyRange(A4($Lang.TForall,
                  " ",
                  A3($Lang.Many," ",typeVars,""),
                  t,
                  ""));
               }
         }
   });
   var tArrow = function (_p53) {
      var _p54 = _p53;
      return $Lang.withDummyRange(A3($Lang.TArrow,
      " ",
      A2($Basics._op["++"],_p54._0,_U.list([_p54._1])),
      ""));
   };
   var tPolyArrow = F2(function (vars,arrowType) {
      return A2(tForall,vars,tArrow(arrowType));
   });
   var tUnion = function (ts) {
      return $Lang.withDummyRange(A3($Lang.TUnion," ",ts,""));
   };
   var tList = function (t) {
      return $Lang.withDummyRange(A3($Lang.TList," ",t,""));
   };
   var joinTypes_ = F2(function (t1,t2) {
      var err = $Result.Err($Utils.spaces(_U.list(["joinTypes failed:"
                                                  ,$LangUnparser.unparseType(t1)
                                                  ,$LangUnparser.unparseType(t2)])));
      var _p55 = {ctor: "_Tuple2",_0: t1.val,_1: t2.val};
      _v57_3: do {
         if (_p55.ctor === "_Tuple2") {
               switch (_p55._1.ctor)
               {case "TList":
                  if (_p55._0.ctor === "TTuple" && _p55._0._1.ctor === "[]" && _p55._0._3.ctor === "Nothing")
                    {
                          return $Result.Ok(t2);
                       } else {
                          break _v57_3;
                       }
                  case "TTuple":
                  if (_p55._0.ctor === "TTuple" && _p55._0._1.ctor === "[]" && _p55._0._3.ctor === "Nothing")
                    {
                          var _p56 = joinManyTypes(_p55._1._1);
                          if (_p56.ctor === "Err") {
                                return err;
                             } else {
                                var _p59 = _p56._0;
                                var _p57 = _p55._1._3;
                                if (_p57.ctor === "Nothing") {
                                      return $Result.Ok(tList(_p59));
                                   } else {
                                      var _p58 = A2(joinTypes,tList(_p59),_p57._0);
                                      if (_p58.ctor === "Err") {
                                            return err;
                                         } else {
                                            return $Result.Ok(_p58._0);
                                         }
                                   }
                             }
                       } else {
                          break _v57_3;
                       }
                  case "TUnion": var _p62 = _p55._1._1;
                    var someEqualType = A3($List.foldl,
                    F2(function (tipe2,acc) {
                       var _p60 = acc;
                       if (_p60.ctor === "Just") {
                             return $Maybe.Just({ctor: "_Tuple0"});
                          } else {
                             return A2(checkEqualType,
                             t1,
                             tipe2) ? $Maybe.Just({ctor: "_Tuple0"}) : $Maybe.Nothing;
                          }
                    }),
                    $Maybe.Nothing,
                    _p62);
                    var _p61 = someEqualType;
                    if (_p61.ctor === "Just") {
                          return $Result.Ok(t2);
                       } else {
                          return $Result.Ok(tUnion(A2($List._op["::"],t1,_p62)));
                       }
                  default: break _v57_3;}
            } else {
               break _v57_3;
            }
      } while (false);
      return $Result.Ok(tUnion(_U.list([t1,t2])));
   });
   var checkEqualType = F2(function (tipe1,tipe2) {
      var dummyTypeEnv = _U.list([]);
      var result = A4(checkEquivType,
      initTypeInfo,
      dummyTypeEnv,
      tipe1,
      tipe2);
      var _p63 = result.result;
      if (_p63.ctor === "Err") {
            return false;
         } else {
            return _U.eq(result.typeInfo.constraints,_U.list([]));
         }
   });
   var checkEquivType = F4(function (typeInfo,
   typeEnv,
   tipe1,
   tipe2) {
      return A2(bindSubtypeResult,
      A4(checkSubtype,typeInfo,typeEnv,tipe1,tipe2),
      function (typeInfo$) {
         return A4(checkSubtype,typeInfo$,typeEnv,tipe2,tipe1);
      });
   });
   var checkSubtype = F4(function (typeInfo,typeEnv,tipe1,tipe2) {
      checkSubtype: while (true) {
         var errAdd = function (msg) {
            return {typeInfo: typeInfo
                   ,result: $Result.Err($Utils.spaces(_U.list(["checkSubtype failed:"
                                                              ,$String.trim($LangUnparser.unparseType(tipe1))
                                                              ," <: "
                                                              ,$String.trim($LangUnparser.unparseType(tipe2))
                                                              ,msg])))};
         };
         var err = errAdd("");
         var ok = {typeInfo: typeInfo
                  ,result: $Result.Ok({ctor: "_Tuple0"})};
         var okConstrain = {result: $Result.Ok({ctor: "_Tuple0"})
                           ,typeInfo: A2(addRawConstraints,
                           _U.list([{ctor: "_Tuple2",_0: tipe1,_1: tipe2}]),
                           typeInfo)};
         var _p64 = {ctor: "_Tuple2",_0: tipe1.val,_1: tipe2.val};
         _v64_15: do {
            _v64_6: do {
               if (_p64.ctor === "_Tuple2") {
                     switch (_p64._0.ctor)
                     {case "TNum": switch (_p64._1.ctor)
                          {case "TNum": return ok;
                             case "TNamed": break _v64_6;
                             default: break _v64_15;}
                        case "TBool": switch (_p64._1.ctor)
                          {case "TBool": return ok;
                             case "TNamed": break _v64_6;
                             default: break _v64_15;}
                        case "TString": switch (_p64._1.ctor)
                          {case "TString": return ok;
                             case "TNamed": break _v64_6;
                             default: break _v64_15;}
                        case "TNull": switch (_p64._1.ctor)
                          {case "TNull": return ok;
                             case "TNamed": break _v64_6;
                             default: break _v64_15;}
                        case "TNamed": if (_p64._1.ctor === "TNamed") {
                                var _p68 = _p64._1._1;
                                var _p67 = _p64._0._1;
                                if (_U.eq(_p67,_p68)) return ok; else {
                                      var maybeNewGoal = function () {
                                         var _p65 = {ctor: "_Tuple2"
                                                    ,_0: A2(expandTypeAlias,typeEnv,_p67)
                                                    ,_1: A2(expandTypeAlias,typeEnv,_p68)};
                                         if (_p65._0.ctor === "Just") {
                                               if (_p65._1.ctor === "Just") {
                                                     return $Maybe.Just({ctor: "_Tuple2"
                                                                        ,_0: _p65._0._0
                                                                        ,_1: _p65._1._0});
                                                  } else {
                                                     return $Maybe.Just({ctor: "_Tuple2"
                                                                        ,_0: _p65._0._0
                                                                        ,_1: tipe2});
                                                  }
                                            } else {
                                               if (_p65._1.ctor === "Just") {
                                                     return $Maybe.Just({ctor: "_Tuple2"
                                                                        ,_0: tipe1
                                                                        ,_1: _p65._1._0});
                                                  } else {
                                                     return $Maybe.Nothing;
                                                  }
                                            }
                                      }();
                                      var _p66 = maybeNewGoal;
                                      if (_p66.ctor === "Just") {
                                            var _v67 = typeInfo,
                                            _v68 = typeEnv,
                                            _v69 = _p66._0._0,
                                            _v70 = _p66._0._1;
                                            typeInfo = _v67;
                                            typeEnv = _v68;
                                            tipe1 = _v69;
                                            tipe2 = _v70;
                                            continue checkSubtype;
                                         } else {
                                            return err;
                                         }
                                   }
                             } else {
                                var _p69 = A2(expandTypeAlias,typeEnv,_p64._0._1);
                                if (_p69.ctor === "Just") {
                                      var _v72 = typeInfo,
                                      _v73 = typeEnv,
                                      _v74 = _p69._0,
                                      _v75 = tipe2;
                                      typeInfo = _v72;
                                      typeEnv = _v73;
                                      tipe1 = _v74;
                                      tipe2 = _v75;
                                      continue checkSubtype;
                                   } else {
                                      return err;
                                   }
                             }
                        case "TUnion": switch (_p64._1.ctor)
                          {case "TNamed": break _v64_6;
                             case "TUnion": var allOk = A3($List.foldl,
                               function (t1) {
                                  return $Utils.bindMaybe(function (acc) {
                                     return A4(checkSubtypeSomeRight,acc,typeEnv,t1,_p64._1._1);
                                  });
                               },
                               $Maybe.Just(typeInfo),
                               _p64._0._1);
                               var _p71 = allOk;
                               if (_p71.ctor === "Nothing") {
                                     return err;
                                  } else {
                                     return {result: $Result.Ok({ctor: "_Tuple0"})
                                            ,typeInfo: _p71._0};
                                  }
                             default: break _v64_15;}
                        case "TList": switch (_p64._1.ctor)
                          {case "TNamed": break _v64_6;
                             case "TList": var _v77 = typeInfo,
                               _v78 = typeEnv,
                               _v79 = _p64._0._1,
                               _v80 = _p64._1._1;
                               typeInfo = _v77;
                               typeEnv = _v78;
                               tipe1 = _v79;
                               tipe2 = _v80;
                               continue checkSubtype;
                             default: break _v64_15;}
                        case "TDict": switch (_p64._1.ctor)
                          {case "TNamed": break _v64_6;
                             case "TDict": return A2(bindSubtypeResult,
                               A4(checkEquivType,typeInfo,typeEnv,_p64._0._1,_p64._1._1),
                               function (typeInfo$) {
                                  return A4(checkSubtype,
                                  typeInfo$,
                                  typeEnv,
                                  _p64._0._2,
                                  _p64._1._2);
                               });
                             default: break _v64_15;}
                        case "TTuple": switch (_p64._1.ctor)
                          {case "TNamed": break _v64_6;
                             case "TTuple": var _p72 = A2($Utils.maybeZip,
                               _p64._0._1,
                               _p64._1._1);
                               if (_p72.ctor === "Nothing") {
                                     return errAdd("lengths of tuple types are not equal");
                                  } else {
                                     return A2(bindSubtypeResult,
                                     A3(checkSubtypeList,typeInfo,typeEnv,_p72._0),
                                     function (typeInfo$) {
                                        return A4(checkSubMaybeType,
                                        typeInfo$,
                                        typeEnv,
                                        _p64._0._3,
                                        _p64._1._3);
                                     });
                                  }
                             case "TList": if (_p64._0._3.ctor === "Nothing") {
                                     var _p73 = _p64._0._1;
                                     var n = $List.length(_p73);
                                     return A3(checkSubtypeList,
                                     typeInfo,
                                     typeEnv,
                                     A2($Utils.zip,_p73,A2($List.repeat,n,_p64._1._1)));
                                  } else {
                                     var _p74 = _p64._0._3._0.val;
                                     if (_p74.ctor === "TList") {
                                           var ts$ = A2($Basics._op["++"],
                                           _p64._0._1,
                                           _U.list([_p74._1]));
                                           var n = $List.length(ts$);
                                           return A3(checkSubtypeList,
                                           typeInfo,
                                           typeEnv,
                                           A2($Utils.zip,ts$,A2($List.repeat,n,_p64._1._1)));
                                        } else {
                                           return errAdd("the rest type of the tuple is not a list type");
                                        }
                                  }
                             default: break _v64_15;}
                        case "TArrow": switch (_p64._1.ctor)
                          {case "TNamed": break _v64_6;
                             case "TArrow": var _p75 = splitTypesInArrow(_p64._0._1);
                               var args1 = _p75._0;
                               var ret1 = _p75._1;
                               var _p76 = splitTypesInArrow(_p64._1._1);
                               var args2 = _p76._0;
                               var ret2 = _p76._1;
                               var _p77 = A2($Utils.maybeZip,args2,args1);
                               if (_p77.ctor === "Nothing") {
                                     return err;
                                  } else {
                                     var result = A3(checkSubtypeList,typeInfo,typeEnv,_p77._0);
                                     var _p78 = result.result;
                                     if (_p78.ctor === "Err") {
                                           return err;
                                        } else {
                                           var _v85 = result.typeInfo,
                                           _v86 = typeEnv,
                                           _v87 = ret1,
                                           _v88 = ret2;
                                           typeInfo = _v85;
                                           typeEnv = _v86;
                                           tipe1 = _v87;
                                           tipe2 = _v88;
                                           continue checkSubtype;
                                        }
                                  }
                             default: break _v64_15;}
                        case "TVar": switch (_p64._1.ctor)
                          {case "TNamed": break _v64_6;
                             case "TVar": var _p80 = _p64._1._1;
                               var _p79 = _p64._0._1;
                               return isConstraintVar(_p79) && isConstraintVar(_p80) ? _U.eq(_p79,
                               _p80) ? ok : okConstrain : isConstraintVar(_p79) ? okConstrain : isConstraintVar(_p80) ? okConstrain : _U.eq(_p79,
                               _p80) ? ok : err;
                             default: break _v64_15;}
                        default: if (_p64._1.ctor === "TNamed") {
                                break _v64_6;
                             } else {
                                break _v64_15;
                             }}
                  } else {
                     break _v64_15;
                  }
            } while (false);
            var _p70 = A2(expandTypeAlias,typeEnv,_p64._1._1);
            if (_p70.ctor === "Just") {
                  var _v90 = typeInfo,
                  _v91 = typeEnv,
                  _v92 = tipe1,
                  _v93 = _p70._0;
                  typeInfo = _v90;
                  typeEnv = _v91;
                  tipe1 = _v92;
                  tipe2 = _v93;
                  continue checkSubtype;
               } else {
                  return err;
               }
         } while (false);
         return A2(tryCatchAlls,
         err,
         _U.list([function (_p81) {
                    var _p82 = _p81;
                    return A3(checkSubtypeTVar,tipe1,okConstrain,err);
                 }
                 ,function (_p83) {
                    var _p84 = _p83;
                    return A3(checkSubtypeTVar,tipe2,okConstrain,err);
                 }
                 ,function (_p85) {
                    var _p86 = _p85;
                    return A4(checkSubtypeUnionRight,typeInfo,typeEnv,tipe1,tipe2);
                 }
                 ,function (_p87) {
                    var _p88 = _p87;
                    return A4(checkSubtypeUnionLeft,typeInfo,typeEnv,tipe1,tipe2);
                 }
                 ,function (_p89) {
                    var _p90 = _p89;
                    return A4(checkSubtypeFoldLeft,typeInfo,typeEnv,tipe1,tipe2);
                 }
                 ,function (_p91) {
                    var _p92 = _p91;
                    return A4(checkSubtypeSingletonUnion,
                    typeInfo,
                    typeEnv,
                    tipe1,
                    tipe2);
                 }]));
      }
   });
   var checkSubMaybeType = F4(function (typeInfo,typeEnv,mt1,mt2) {
      var _p93 = {ctor: "_Tuple2",_0: mt1,_1: mt2};
      _v100_2: do {
         if (_p93.ctor === "_Tuple2") {
               if (_p93._0.ctor === "Just") {
                     if (_p93._1.ctor === "Just") {
                           return A4(checkSubtype,
                           typeInfo,
                           typeEnv,
                           _p93._0._0,
                           _p93._1._0);
                        } else {
                           break _v100_2;
                        }
                  } else {
                     if (_p93._1.ctor === "Nothing") {
                           return {result: $Result.Ok({ctor: "_Tuple0"})
                                  ,typeInfo: typeInfo};
                        } else {
                           break _v100_2;
                        }
                  }
            } else {
               break _v100_2;
            }
      } while (false);
      return {result: $Result.Err("checkSubMaybeType failed...")
             ,typeInfo: typeInfo};
   });
   var checkSubtypeFoldLeft = F4(function (typeInfo,
   typeEnv,
   tipe1,
   tipe2) {
      var _p94 = coerceTupleToList(tipe1);
      if (_p94.ctor === "Just" && _p94._0.ctor === "Ok") {
            var result = A4(checkSubtype,
            typeInfo,
            typeEnv,
            _p94._0._0,
            tipe2);
            var _p95 = result.result;
            if (_p95.ctor === "Ok") {
                  return $Maybe.Just(result.typeInfo);
               } else {
                  return $Maybe.Nothing;
               }
         } else {
            return $Maybe.Nothing;
         }
   });
   var coerceTupleToList = function (t) {
      var _p96 = t.val;
      if (_p96.ctor === "TTuple") {
            if (_p96._1.ctor === "[]") {
                  return $Maybe.Nothing;
               } else {
                  var _p97 = joinManyTypes(_p96._1);
                  if (_p97.ctor === "Err") {
                        return $Maybe.Just($Result.Err(_p97._0));
                     } else {
                        var _p100 = _p97._0;
                        var _p98 = _p96._3;
                        if (_p98.ctor === "Nothing") {
                              return $Maybe.Just($Result.Ok(tList(_p100)));
                           } else {
                              var _p99 = A2(joinTypes,tList(_p100),_p98._0);
                              if (_p99.ctor === "Err") {
                                    return $Maybe.Just($Result.Err(_p99._0));
                                 } else {
                                    return $Maybe.Just($Result.Ok(_p99._0));
                                 }
                           }
                     }
               }
         } else {
            return $Maybe.Nothing;
         }
   };
   var joinManyTypes = function (ts) {
      var _p101 = ts;
      if (_p101.ctor === "[]") {
            return _U.crashCase("Types",
            {start: {line: 1525,column: 3},end: {line: 1532,column: 19}},
            _p101)("joinManyTypes: empty list");
         } else {
            return A3($List.foldl,
            F2(function (tNext,acc) {
               var _p103 = acc;
               if (_p103.ctor === "Err") {
                     return $Result.Err(_p103._0);
                  } else {
                     return A2(joinTypes,tNext,_p103._0);
                  }
            }),
            $Result.Ok(_p101._0),
            _p101._1);
         }
   };
   var joinTypes = F2(function (t1,t2) {
      var dummyTypeInfo = initTypeInfo;
      var dummyTypeEnv = _U.list([]);
      var _p104 = A4(checkSubtype,
      dummyTypeInfo,
      dummyTypeEnv,
      t1,
      t2).result;
      if (_p104.ctor === "Ok" && _p104._0.ctor === "_Tuple0") {
            return $Result.Ok(t2);
         } else {
            var _p105 = A4(checkSubtype,
            dummyTypeInfo,
            dummyTypeEnv,
            t2,
            t1).result;
            if (_p105.ctor === "Ok" && _p105._0.ctor === "_Tuple0") {
                  return $Result.Ok(t1);
               } else {
                  var _p106 = A2(joinTypes_,t1,t2);
                  if (_p106.ctor === "Ok") {
                        return $Result.Ok(_p106._0);
                     } else {
                        return A2(joinTypes_,t2,t1);
                     }
               }
         }
   });
   var checkSubtypeList = F3(function (typeInfo,typeEnv,list) {
      var _p107 = A3($List.foldl,
      F2(function (_p109,_p108) {
         var _p110 = _p109;
         var _p111 = _p108;
         var _p114 = _p111._1;
         var _p113 = _p111._0;
         var _p112 = _p113;
         if (_p112.ctor === "Err") {
               return {ctor: "_Tuple2",_0: _p113,_1: _p114};
            } else {
               var nextResult = A4(checkSubtype,
               _p114,
               typeEnv,
               _p110._0,
               _p110._1);
               return {ctor: "_Tuple2"
                      ,_0: nextResult.result
                      ,_1: nextResult.typeInfo};
            }
      }),
      {ctor: "_Tuple2"
      ,_0: $Result.Ok({ctor: "_Tuple0"})
      ,_1: typeInfo},
      list);
      var result = _p107._0;
      var typeInfo$ = _p107._1;
      return {result: result,typeInfo: typeInfo$};
   });
   var checkSubtypeSingletonUnion = F4(function (typeInfo,
   typeEnv,
   tipe1,
   tipe2) {
      var _p115 = tipe1.val;
      if (_p115.ctor === "TUnion" && _p115._1.ctor === "::" && _p115._1._1.ctor === "[]")
      {
            var result = A4(checkSubtype,
            typeInfo,
            typeEnv,
            _p115._1._0,
            tipe2);
            var _p116 = result.result;
            if (_p116.ctor === "Ok") {
                  return $Maybe.Just(result.typeInfo);
               } else {
                  return $Maybe.Nothing;
               }
         } else {
            return $Maybe.Nothing;
         }
   });
   var checkSubtypeSomeRight = F4(function (typeInfo,
   typeEnv,
   t1,
   ts2) {
      return A3($List.foldl,
      F2(function (t2,acc) {
         var _p117 = acc;
         if (_p117.ctor === "Just") {
               return acc;
            } else {
               var result = A4(checkSubtype,typeInfo,typeEnv,t1,t2);
               var _p118 = result.result;
               if (_p118.ctor === "Ok") {
                     return $Maybe.Just(result.typeInfo);
                  } else {
                     return $Maybe.Nothing;
                  }
            }
      }),
      $Maybe.Nothing,
      ts2);
   });
   var checkSubtypeUnionLeft = F4(function (typeInfo,
   typeEnv,
   tipe1,
   tipe2) {
      var _p119 = {ctor: "_Tuple2",_0: tipe1.val,_1: tipe2.val};
      if (_p119.ctor === "_Tuple2" && _p119._0.ctor === "TUnion") {
            var _p121 = _p119._0._1;
            var obligations = A2($Utils.zip,
            _p121,
            A2($List.repeat,$List.length(_p121),tipe2));
            var result = A3(checkSubtypeList,typeInfo,typeEnv,obligations);
            var _p120 = result.result;
            if (_p120.ctor === "Ok") {
                  return $Maybe.Just(result.typeInfo);
               } else {
                  return $Maybe.Nothing;
               }
         } else {
            return $Maybe.Nothing;
         }
   });
   var checkSubtypeUnionRight = F4(function (typeInfo,
   typeEnv,
   tipe1,
   tipe2) {
      var _p122 = {ctor: "_Tuple2",_0: tipe1.val,_1: tipe2.val};
      if (_p122.ctor === "_Tuple2" && _p122._1.ctor === "TUnion") {
            return A2($Utils.bindMaybe,
            $Maybe.Just,
            A4(checkSubtypeSomeRight,typeInfo,typeEnv,tipe1,_p122._1._1));
         } else {
            return $Maybe.Nothing;
         }
   });
   var subtractType = F2(function (union1,tipe2) {
      var _p123 = tipe2.val;
      if (_p123.ctor === "TUnion") {
            return A3($List.foldl,
            $Basics.flip(subtractType),
            union1,
            _p123._1);
         } else {
            return A3($List.foldl,
            F2(function (t1,acc) {
               return A2(checkEqualType,
               t1,
               tipe2) ? acc : A2($List._op["::"],t1,acc);
            }),
            _U.list([]),
            union1);
         }
   });
   var checkSubtypeSimple = F3(function (typeEnv,tipe1,tipe2) {
      var result = A4(checkSubtype,
      initTypeInfo,
      typeEnv,
      tipe1,
      tipe2);
      var _p124 = result.result;
      if (_p124.ctor === "Err") {
            return false;
         } else {
            return true;
         }
   });
   var unify = F5(function (typeEnv,vars,accActive,accUnifier,cs) {
      var _p125 = cs;
      if (_p125.ctor === "[]") {
            return $Result.Ok({ctor: "_Tuple2"
                              ,_0: accUnifier
                              ,_1: accActive});
         } else {
            var _p142 = _p125._1;
            var _p141 = _p125._0;
            var recurse = A2(unify,typeEnv,vars);
            var _p126 = _p141;
            var id = _p126._0;
            var t1 = _p126._1._0;
            var t2 = _p126._1._1;
            var err = $Utils.spaces(_U.list(["Unification failure:"
                                            ,$String.trim($LangUnparser.unparseType(t1))
                                            ,$String.trim($LangUnparser.unparseType(t2))]));
            if (A2(checkEqualType,t1,t2)) return A3(recurse,
               accActive,
               accUnifier,
               _p142); else {
                  var _p127 = {ctor: "_Tuple2",_0: t1.val,_1: t2.val};
                  _v125_10: do {
                     _v125_9: do {
                        _v125_2: do {
                           _v125_1: do {
                              if (_p127.ctor === "_Tuple2") {
                                    switch (_p127._0.ctor)
                                    {case "TVar": switch (_p127._1.ctor)
                                         {case "TVar": var _p129 = _p127._1._1;
                                              var _p128 = _p127._0._1;
                                              return A2($List.member,_p128,vars) ? A3(recurse,
                                              accActive,
                                              A2($List._op["::"],
                                              {ctor: "_Tuple2",_0: _p128,_1: t2},
                                              accUnifier),
                                              A2(applyUnifierToConstraints,
                                              _U.list([{ctor: "_Tuple2",_0: _p128,_1: t2}]),
                                              _p142)) : A2($List.member,_p129,vars) ? A3(recurse,
                                              accActive,
                                              A2($List._op["::"],
                                              {ctor: "_Tuple2",_0: _p129,_1: t1},
                                              accUnifier),
                                              A2(applyUnifierToConstraints,
                                              _U.list([{ctor: "_Tuple2",_0: _p129,_1: t1}]),
                                              _p142)) : A3(recurse,
                                              A2($List._op["::"],_p141,accActive),
                                              accUnifier,
                                              _p142);
                                            case "TNamed": break _v125_1;
                                            default: break _v125_1;}
                                       case "TArrow": switch (_p127._1.ctor)
                                         {case "TVar": break _v125_2;
                                            case "TArrow": var _p132 = A2($Utils.maybeZip,
                                              _p127._0._1,
                                              _p127._1._1);
                                              if (_p132.ctor === "Nothing") {
                                                    return $Result.Err("unify TArrow: different arity");
                                                 } else {
                                                    var induced = A2($List.map,
                                                    function (raw) {
                                                       return {ctor: "_Tuple2",_0: -1,_1: raw};
                                                    },
                                                    _p132._0);
                                                    return A3(recurse,
                                                    accActive,
                                                    accUnifier,
                                                    A2($Basics._op["++"],induced,_p142));
                                                 }
                                            case "TNamed": break _v125_9;
                                            default: break _v125_10;}
                                       case "TTuple": switch (_p127._1.ctor)
                                         {case "TVar": break _v125_2;
                                            case "TTuple": var _p133 = A2($Utils.maybeZip,
                                              _p127._0._1,
                                              _p127._1._1);
                                              if (_p133.ctor === "Nothing") {
                                                    return $Result.Err("unify TTuple: different arity");
                                                 } else {
                                                    var induced = A2($List.map,
                                                    function (raw) {
                                                       return {ctor: "_Tuple2",_0: -1,_1: raw};
                                                    },
                                                    _p133._0);
                                                    var _p134 = {ctor: "_Tuple2",_0: _p127._0._3,_1: _p127._1._3};
                                                    _v128_2: do {
                                                       if (_p134.ctor === "_Tuple2") {
                                                             if (_p134._0.ctor === "Nothing") {
                                                                   if (_p134._1.ctor === "Nothing") {
                                                                         return A3(recurse,
                                                                         accActive,
                                                                         accUnifier,
                                                                         A2($Basics._op["++"],induced,_p142));
                                                                      } else {
                                                                         break _v128_2;
                                                                      }
                                                                } else {
                                                                   if (_p134._1.ctor === "Just") {
                                                                         var induced$ = A2($List._op["::"],
                                                                         {ctor: "_Tuple2"
                                                                         ,_0: -1
                                                                         ,_1: {ctor: "_Tuple2",_0: _p134._0._0,_1: _p134._1._0}},
                                                                         induced);
                                                                         return A3(recurse,
                                                                         accActive,
                                                                         accUnifier,
                                                                         A2($Basics._op["++"],induced$,_p142));
                                                                      } else {
                                                                         break _v128_2;
                                                                      }
                                                                }
                                                          } else {
                                                             break _v128_2;
                                                          }
                                                    } while (false);
                                                    return $Result.Err("unify TTuple: rest types don\'t match");
                                                 }
                                            case "TNamed": break _v125_9;
                                            default: break _v125_10;}
                                       case "TList": switch (_p127._1.ctor)
                                         {case "TVar": break _v125_2;
                                            case "TList": var induced = _U.list([{ctor: "_Tuple2"
                                                                                 ,_0: -1
                                                                                 ,_1: {ctor: "_Tuple2",_0: _p127._0._1,_1: _p127._1._1}}]);
                                              return A3(recurse,
                                              accActive,
                                              accUnifier,
                                              A2($Basics._op["++"],induced,_p142));
                                            case "TTuple": var _p136 = _p127._0._1;
                                              var induced = A2($List.map,
                                              function (ti) {
                                                 return {ctor: "_Tuple2"
                                                        ,_0: -1
                                                        ,_1: {ctor: "_Tuple2",_0: _p136,_1: ti}};
                                              },
                                              _p127._1._1);
                                              var induced$ = function () {
                                                 var _p135 = _p127._1._3;
                                                 if (_p135.ctor === "Nothing") {
                                                       return induced;
                                                    } else {
                                                       return A2($List._op["::"],
                                                       {ctor: "_Tuple2"
                                                       ,_0: -1
                                                       ,_1: {ctor: "_Tuple2",_0: tList(_p136),_1: _p135._0}},
                                                       induced);
                                                    }
                                              }();
                                              return A3(recurse,
                                              accActive,
                                              accUnifier,
                                              A2($Basics._op["++"],induced$,_p142));
                                            case "TNamed": break _v125_9;
                                            default: break _v125_10;}
                                       case "TNamed": switch (_p127._1.ctor)
                                         {case "TVar": break _v125_2;
                                            case "TNamed": var maybeNewGoal = function () {
                                                 var _p137 = {ctor: "_Tuple2"
                                                             ,_0: A2(expandTypeAlias,typeEnv,_p127._0._1)
                                                             ,_1: A2(expandTypeAlias,typeEnv,_p127._1._1)};
                                                 if (_p137._0.ctor === "Just") {
                                                       if (_p137._1.ctor === "Just") {
                                                             return $Maybe.Just({ctor: "_Tuple2"
                                                                                ,_0: _p137._0._0
                                                                                ,_1: _p137._1._0});
                                                          } else {
                                                             return $Maybe.Just({ctor: "_Tuple2",_0: _p137._0._0,_1: t2});
                                                          }
                                                    } else {
                                                       if (_p137._1.ctor === "Just") {
                                                             return $Maybe.Just({ctor: "_Tuple2",_0: t1,_1: _p137._1._0});
                                                          } else {
                                                             return $Maybe.Nothing;
                                                          }
                                                    }
                                              }();
                                              var _p138 = maybeNewGoal;
                                              if (_p138.ctor === "Just") {
                                                    var induced = _U.list([{ctor: "_Tuple2"
                                                                           ,_0: -1
                                                                           ,_1: {ctor: "_Tuple2",_0: _p138._0._0,_1: _p138._0._1}}]);
                                                    return A3(recurse,
                                                    accActive,
                                                    accUnifier,
                                                    A2($Basics._op["++"],induced,_p142));
                                                 } else {
                                                    return $Result.Err(err);
                                                 }
                                            default: var _p139 = A2(expandTypeAlias,typeEnv,_p127._0._1);
                                              if (_p139.ctor === "Just") {
                                                    var induced = _U.list([{ctor: "_Tuple2"
                                                                           ,_0: -1
                                                                           ,_1: {ctor: "_Tuple2",_0: _p139._0,_1: t2}}]);
                                                    return A3(recurse,
                                                    accActive,
                                                    accUnifier,
                                                    A2($Basics._op["++"],induced,_p142));
                                                 } else {
                                                    return $Result.Err(err);
                                                 }}
                                       default: switch (_p127._1.ctor)
                                         {case "TVar": break _v125_2;
                                            case "TNamed": break _v125_9;
                                            default: break _v125_10;}}
                                 } else {
                                    break _v125_10;
                                 }
                           } while (false);
                           var _p130 = _p127._0._1;
                           return A2($List.member,_p130,vars) ? A3(recurse,
                           accActive,
                           A2($List._op["::"],
                           {ctor: "_Tuple2",_0: _p130,_1: t2},
                           accUnifier),
                           A2(applyUnifierToConstraints,
                           _U.list([{ctor: "_Tuple2",_0: _p130,_1: t2}]),
                           _p142)) : A3(recurse,
                           A2($List._op["::"],_p141,accActive),
                           accUnifier,
                           _p142);
                        } while (false);
                        var _p131 = _p127._1._1;
                        return A2($List.member,_p131,vars) ? A3(recurse,
                        accActive,
                        A2($List._op["::"],
                        {ctor: "_Tuple2",_0: _p131,_1: t1},
                        accUnifier),
                        A2(applyUnifierToConstraints,
                        _U.list([{ctor: "_Tuple2",_0: _p131,_1: t1}]),
                        _p142)) : A3(recurse,
                        A2($List._op["::"],_p141,accActive),
                        accUnifier,
                        _p142);
                     } while (false);
                     var _p140 = A2(expandTypeAlias,typeEnv,_p127._1._1);
                     if (_p140.ctor === "Just") {
                           var induced = _U.list([{ctor: "_Tuple2"
                                                  ,_0: -1
                                                  ,_1: {ctor: "_Tuple2",_0: t1,_1: _p140._0}}]);
                           return A3(recurse,
                           accActive,
                           accUnifier,
                           A2($Basics._op["++"],induced,_p142));
                        } else {
                           return $Result.Err(err);
                        }
                  } while (false);
                  return A3(checkSubtypeSimple,typeEnv,t1,t2) ? A3(recurse,
                  accActive,
                  accUnifier,
                  _p142) : A3(checkSubtypeSimple,typeEnv,t2,t1) ? A3(recurse,
                  accActive,
                  accUnifier,
                  _p142) : $Result.Err(err);
               }
         }
   });
   var tTupleRest = F2(function (ts,tRest) {
      return $Lang.withDummyRange(A5($Lang.TTuple,
      " ",
      ts,
      "",
      tRest,
      ""));
   });
   var tTuple = function (ts) {
      return A2(tTupleRest,ts,$Maybe.Nothing);
   };
   var tVar = function (x) {
      return $Lang.withDummyRange(A2($Lang.TVar," ",x));
   };
   var newArrowTemplate = F2(function (typeInfo,n) {
      var _p143 = A2(generateConstraintVars,1 + n,typeInfo);
      var constraintVars = _p143._0;
      var typeInfo$ = _p143._1;
      var arrow = splitTypesInArrow(A2($List.map,
      tVar,
      constraintVars));
      return {ctor: "_Tuple2",_0: arrow,_1: typeInfo$};
   });
   var instantiatePolyArrowWithConstraintVars = F2(function (typeInfo,
   _p144) {
      var _p145 = _p144;
      var _p147 = _p145._0;
      var _p146 = A2(generateConstraintVars,
      $List.length(_p147),
      typeInfo);
      var constraintVars = _p146._0;
      var typeInfo$ = _p146._1;
      var subst = A3($List.map2,
      F2(function (x,y) {
         return {ctor: "_Tuple2",_0: x,_1: tVar(y)};
      }),
      _p147,
      constraintVars);
      var argTypes$ = A2($List.map,applyUnifier(subst),_p145._1._0);
      var retType$ = A2(applyUnifier,subst,_p145._1._1);
      return {result: {ctor: "_Tuple2"
                      ,_0: constraintVars
                      ,_1: {ctor: "_Tuple2",_0: argTypes$,_1: retType$}}
             ,typeInfo: typeInfo$};
   });
   var instantiateTypeWithConstraintVars = F2(function (typeInfo,
   t) {
      var _p148 = stripPolymorphicArrow(t);
      if (_p148.ctor === "Nothing") {
            return {result: {ctor: "_Tuple2",_0: _U.list([]),_1: t}
                   ,typeInfo: typeInfo};
         } else {
            var result = A2(instantiatePolyArrowWithConstraintVars,
            typeInfo,
            _p148._0);
            var _p149 = result.result;
            var constraintVars = _p149._0;
            var arrow = _p149._1;
            return {result: {ctor: "_Tuple2"
                            ,_0: constraintVars
                            ,_1: tArrow(arrow)}
                   ,typeInfo: result.typeInfo};
         }
   });
   var instantiateTypesWithConstraintVars = F2(function (typeInfo,
   ts) {
      var _p150 = A3($List.foldl,
      F2(function (t,_p151) {
         var _p152 = _p151;
         var result = A2(instantiateTypeWithConstraintVars,_p152._2,t);
         var _p153 = result.result;
         var newVars = _p153._0;
         var t$ = _p153._1;
         return {ctor: "_Tuple3"
                ,_0: A2($Basics._op["++"],_p152._0,newVars)
                ,_1: A2($Basics._op["++"],_p152._1,_U.list([t$]))
                ,_2: result.typeInfo};
      }),
      {ctor: "_Tuple3",_0: _U.list([]),_1: _U.list([]),_2: typeInfo},
      ts);
      var newVars = _p150._0;
      var newTypes = _p150._1;
      var newTypeInfo = _p150._2;
      return {result: {ctor: "_Tuple2",_0: newVars,_1: newTypes}
             ,typeInfo: newTypeInfo};
   });
   var tNull = $Lang.withDummyRange($Lang.TNull(" "));
   var tString = $Lang.withDummyRange($Lang.TString(" "));
   var tNum = $Lang.withDummyRange($Lang.TNum(" "));
   var parseT = function (s) {
      if (_U.eq(s," Num ")) return tNum; else {
            var _p154 = $LangParser2.parseT(s);
            if (_p154.ctor === "Err") {
                  return _U.crashCase("Types",
                  {start: {line: 252,column: 3},end: {line: 254,column: 15}},
                  _p154)(A2($Basics._op["++"],"bad primitive op type: ",s));
               } else {
                  return _p154._0;
               }
         }
   };
   var opTypeTable = A2($List.map,
   $Utils.mapSnd(parseT),
   _U.list([{ctor: "_Tuple2",_0: $Lang.Pi,_1: " Num "}
           ,{ctor: "_Tuple2"
            ,_0: $Lang.ToStr
            ,_1: " (forall a (-> a String))"}
           ,{ctor: "_Tuple2"
            ,_0: $Lang.DebugLog
            ,_1: " (forall a (-> a String))"}
           ,{ctor: "_Tuple2",_0: $Lang.Eq,_1: " (forall a (-> a a Bool))"}
           ,{ctor: "_Tuple2",_0: $Lang.Cos,_1: " (-> Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Sin,_1: " (-> Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.ArcCos,_1: " (-> Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.ArcSin,_1: " (-> Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.ArcTan2,_1: " (-> Num Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Floor,_1: " (-> Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Ceil,_1: " (-> Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Round,_1: " (-> Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Sqrt,_1: " (-> Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Plus,_1: " DUMMY"}
           ,{ctor: "_Tuple2",_0: $Lang.Minus,_1: " (-> Num Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Mult,_1: " (-> Num Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Div,_1: " (-> Num Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Lt,_1: " (-> Num Num Bool)"}
           ,{ctor: "_Tuple2",_0: $Lang.Mod,_1: " (-> Num Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.Pow,_1: " (-> Num Num Num)"}
           ,{ctor: "_Tuple2",_0: $Lang.DictEmpty,_1: " TODO"}
           ,{ctor: "_Tuple2",_0: $Lang.DictGet,_1: " TODO"}
           ,{ctor: "_Tuple2",_0: $Lang.DictRemove,_1: " TODO"}
           ,{ctor: "_Tuple2",_0: $Lang.DictInsert,_1: " TODO"}]));
   var opType = function (op) {
      var _p156 = A2($Utils.maybeFind,op.val,opTypeTable);
      if (_p156.ctor === "Just") {
            return _p156._0;
         } else {
            return _U.crashCase("Types",
            {start: {line: 258,column: 3},end: {line: 260,column: 69}},
            _p156)(A2($Basics._op["++"],
            "opType not defined: ",
            $Lang.strOp(op.val)));
         }
   };
   var tBool = $Lang.withDummyRange($Lang.TBool(" "));
   var lookupPat = F2(function (typeEnv,p) {
      var _p158 = p.val;
      switch (_p158.ctor)
      {case "PVar": return A2(lookupVar,typeEnv,_p158._1);
         case "PAs": return A2(lookupVar,typeEnv,_p158._1);
         case "PConst": return $Maybe.Just(tNum);
         case "PBase": switch (_p158._1.ctor)
           {case "EBool": return $Maybe.Just(tBool);
              case "EString": return $Maybe.Just(tString);
              default: return $Maybe.Just(tNull);}
         default: return A2($Utils.bindMaybe,
           function (ts) {
              var _p159 = _p158._3;
              if (_p159.ctor === "Nothing") {
                    return $Maybe.Just(tTuple(ts));
                 } else {
                    return A2($Utils.bindMaybe,
                    function (tRest) {
                       return $Maybe.Just(A2(tTupleRest,ts,$Maybe.Just(tRest)));
                    },
                    A2(lookupPat,typeEnv,_p159._0));
                 }
           },
           $Utils.projJusts(A2($List.map,lookupPat(typeEnv),_p158._1)));}
   });
   var sanityChecks = true;
   var stopAtError = false;
   var debugLog = $Config.debugLog($Config.debugTypeChecker);
   var solveConstraintsFor = F3(function (typeInfo,typeEnv,vars) {
      var _p160 = A5(unify,
      typeEnv,
      vars,
      _U.list([]),
      _U.list([]),
      typeInfo.activeConstraints);
      if (_p160.ctor === "Ok") {
            return {result: $Result.Ok($List.reverse(_p160._0._0))
                   ,typeInfo: _U.update(typeInfo,
                   {activeConstraints: $List.reverse(_p160._0._1)})};
         } else {
            var _p161 = A2(debugLog,
            "TODO display the constraints that failed...",
            {ctor: "_Tuple0"});
            return {result: $Result.Err(_p160._0),typeInfo: typeInfo};
         }
   });
   var solveTemplateArrow = F4(function (typeInfo,
   typeEnv,
   eFuncInfo,
   arrow) {
      var vars = $Set.toList(constraintVarsOfArrow(arrow));
      var result = A3(solveConstraintsFor,typeInfo,typeEnv,vars);
      var _p162 = result.result;
      if (_p162.ctor === "Err") {
            return {result: $Maybe.Nothing
                   ,typeInfo: A3(addTypeErrorAt,
                   eFuncInfo.start,
                   _p162._0,
                   typeInfo)};
         } else {
            var arrow$ = A2(rewriteArrow,_p162._0,arrow);
            var unconstrainedVars = $Set.toList(constraintVarsOfArrow(arrow$));
            var arrow = function () {
               if (_U.eq(unconstrainedVars,_U.list([])))
               return tArrow(arrow$); else {
                     var newTypeVars = A2($List.map,
                     $String.dropLeft(1),
                     unconstrainedVars);
                     return A2(tPolyArrow,
                     newTypeVars,
                     A2(rewriteArrow,
                     A2($List.map,
                     function (a) {
                        return {ctor: "_Tuple2"
                               ,_0: a
                               ,_1: tVar(A2($String.dropLeft,1,a))};
                     },
                     unconstrainedVars),
                     arrow$));
                  }
            }();
            return {result: $Maybe.Just(arrow)
                   ,typeInfo: A3(addFinalType,
                   eFuncInfo.val,
                   $Maybe.Just(arrow),
                   result.typeInfo)};
         }
   });
   var displayRawTypes = function (typeInfo) {
      return A3($Dict.foldl,
      F3(function (eid,_p164,_p163) {
         var _p165 = _p164;
         var _p166 = _p163;
         var _p167 = _p165._1;
         if (_p167.ctor === "Nothing") {
               return {ctor: "_Tuple0"};
            } else {
               var s = $LangUnparser.unparseType(_p167._0);
               var _p168 = A2(debugLog,
               "synthesized type: ",
               {ctor: "_Tuple2",_0: eid,_1: s});
               return {ctor: "_Tuple0"};
            }
      }),
      {ctor: "_Tuple0"},
      typeInfo.rawTypes);
   };
   var displayConstraints = function (typeInfo) {
      var display = F2(function (cap,constraints) {
         if (_U.eq(constraints,_U.list([]))) return {ctor: "_Tuple0"};
         else {
               var _p169 = A2(debugLog,cap,{ctor: "_Tuple0"});
               var _p170 = A3($List.foldl,
               function (_p171) {
                  return debugLog(strConstraint(_p171));
               },
               {ctor: "_Tuple0"},
               constraints);
               return {ctor: "_Tuple0"};
            }
      });
      var _p172 = A2(display,"ALL CONSTRAINTS",typeInfo.constraints);
      var _p173 = A2(display,
      "ACTIVE CONSTRAINTS",
      typeInfo.activeConstraints);
      return {ctor: "_Tuple0"};
   };
   var displayNamedExps = function (typeInfo) {
      var _p174 = A2(debugLog,"NAMED EXPS",{ctor: "_Tuple0"});
      return A3($List.foldr,
      F2(function (_p176,_p175) {
         var _p177 = _p176;
         var _p183 = _p177._0;
         var _p182 = _p177._1;
         var _p178 = _p175;
         var s1 = $String.trim($LangUnparser.unparsePat(_p183));
         var _p179 = {ctor: "_Tuple2"
                     ,_0: A2($Dict.get,_p182,typeInfo.finalTypes)
                     ,_1: A2($Dict.get,_p182,typeInfo.rawTypes)};
         _v148_2: do {
            if (_p179.ctor === "_Tuple2") {
                  if (_p179._0.ctor === "Just" && _p179._0._0.ctor === "Just")
                  {
                        var s2 = $String.trim($LangUnparser.unparseType(_p179._0._0._0));
                        var _p180 = A2(debugLog,
                        A2($Basics._op["++"],
                        s1,
                        A2($Basics._op["++"]," : ",A2($Basics._op["++"],s2," "))),
                        $Lang.strPos(_p183.start));
                        return {ctor: "_Tuple0"};
                     } else {
                        if (_p179._1.ctor === "Just" && _p179._1._0.ctor === "_Tuple2" && _p179._1._0._1.ctor === "Just")
                        {
                              var s2 = $String.trim($LangUnparser.unparseType(_p179._1._0._1._0));
                              var _p181 = A2(debugLog,
                              A2($Basics._op["++"],
                              s1,
                              A2($Basics._op["++"]," : ",A2($Basics._op["++"],s2," (raw) "))),
                              $Lang.strPos(_p183.start));
                              return {ctor: "_Tuple0"};
                           } else {
                              break _v148_2;
                           }
                     }
               } else {
                  break _v148_2;
               }
         } while (false);
         return {ctor: "_Tuple0"};
      }),
      {ctor: "_Tuple0"},
      typeInfo.namedExps);
   };
   var displayTypeErrors = function (typeInfo) {
      var n = $List.length(typeInfo.typeErrors);
      if (_U.eq(n,0)) return {ctor: "_Tuple0"}; else {
            var _p184 = A2(debugLog,"# TYPE ERRORS",n);
            return A3($List.foldr,
            F2(function (typeError,_p185) {
               var _p186 = _p185;
               var _p187 = A2(debugLog,
               typeError.val,
               $Lang.strPos(typeError.pos));
               return {ctor: "_Tuple0"};
            }),
            {ctor: "_Tuple0"},
            typeInfo.typeErrors);
         }
   };
   var displayTypeInfo = function (typeInfo) {
      var _p188 = displayTypeErrors(typeInfo);
      return {ctor: "_Tuple0"};
   };
   var AndTypeInfo = F2(function (a,b) {
      return {result: a,typeInfo: b};
   });
   var AceTypeInfo = F3(function (a,b,c) {
      return {annotations: a,highlights: b,tooltips: c};
   });
   var TypeInfo = F9(function (a,b,c,d,e,f,g,h,i) {
      return {constraints: a
             ,activeConstraints: b
             ,typeErrors: c
             ,rawTypes: d
             ,finalTypes: e
             ,namedExps: f
             ,constraintCount: g
             ,constraintVarCount: h
             ,preludeTypeEnv: i};
   });
   var TypeAlias = F2(function (a,b) {
      return {ctor: "TypeAlias",_0: a,_1: b};
   });
   var TypeVar = function (a) {
      return {ctor: "TypeVar",_0: a};
   };
   var addTypeVarBindings = F2(function (typeVars,typeEnv) {
      var newTypeBindings = A2($List.map,
      TypeVar,
      $List.reverse(typeVars));
      return A2($Basics._op["++"],newTypeBindings,typeEnv);
   });
   var isWellFormed = F2(function (typeEnv,tipe) {
      var _p189 = function () {
         var _p190 = tipe.val;
         if (_p190.ctor === "TForall") {
               if (_p190._1.ctor === "Many") {
                     return {ctor: "_Tuple2"
                            ,_0: A2($List.map,$Basics.snd,_p190._1._1)
                            ,_1: _p190._2};
                  } else {
                     return {ctor: "_Tuple2"
                            ,_0: _U.list([$Basics.snd(_p190._1._0)])
                            ,_1: _p190._2};
                  }
            } else {
               return {ctor: "_Tuple2",_0: _U.list([]),_1: tipe};
            }
      }();
      var prenexVars = _p189._0;
      var tipe$ = _p189._1;
      var typeEnv$ = A2($Basics._op["++"],
      A2($List.map,TypeVar,$List.reverse(prenexVars)),
      typeEnv);
      var noNestedForalls = A3($Lang.foldType,
      F2(function (t,acc) {
         var _p191 = t.val;
         if (_p191.ctor === "TForall") {
               return false;
            } else {
               return acc;
            }
      }),
      tipe$,
      true);
      var allVarsBound = A3($Lang.foldType,
      F2(function (t,acc) {
         var _p192 = t.val;
         switch (_p192.ctor)
         {case "TNamed": return acc && A2(lookupTypeAlias,
              typeEnv$,
              _p192._1);
            case "TVar": var _p193 = _p192._1;
              return isConstraintVar(_p193) ? false : acc && A2($List.member,
              TypeVar(_p193),
              typeEnv$);
            default: return acc;}
      }),
      tipe$,
      true);
      return noNestedForalls && allVarsBound;
   });
   var CheckType = F2(function (a,b) {
      return {ctor: "CheckType",_0: a,_1: b};
   });
   var addTypBindings = F3(function (p,t,typeEnv) {
      var _p194 = p.val;
      if (_p194.ctor === "PVar") {
            return $Result.Ok(A2($List._op["::"],
            A2(CheckType,_p194._1,t),
            typeEnv));
         } else {
            return _U.crashCase("Types",
            {start: {line: 350,column: 3},end: {line: 352,column: 88}},
            _p194)("addTypBindings: Currently, only (typ x T) is supported.");
         }
   });
   var HasType = F2(function (a,b) {
      return {ctor: "HasType",_0: a,_1: b};
   });
   var addBindingsOne = F2(function (_p196,acc) {
      addBindingsOne: while (true) {
         var _p197 = _p196;
         var _p208 = _p197._1;
         var _p207 = _p197._0;
         var fail = function (s) {
            return $Result.Err($Utils.spaces(_U.list(["addBindings"
                                                     ,$LangUnparser.unparsePat(_p207)
                                                     ,$LangUnparser.unparseType(_p208)
                                                     ,s])));
         };
         var _p198 = {ctor: "_Tuple2",_0: _p207.val,_1: _p208.val};
         _v155_8: do {
            if (_p198.ctor === "_Tuple2") {
                  switch (_p198._0.ctor)
                  {case "PConst": return $Result.Ok(acc);
                     case "PBase": return $Result.Ok(acc);
                     case "PVar": if (_p198._0._1 === "_") {
                             return $Result.Ok(acc);
                          } else {
                             return $Result.Ok(A2($List._op["::"],
                             A2(HasType,_p198._0._1,_p208),
                             acc));
                          }
                     case "PAs": var _v156 = {ctor: "_Tuple2"
                                             ,_0: _p198._0._3
                                             ,_1: _p208},
                       _v157 = A2($List._op["::"],A2(HasType,_p198._0._1,_p208),acc);
                       _p196 = _v156;
                       acc = _v157;
                       continue addBindingsOne;
                     default: switch (_p198._1.ctor)
                       {case "TNamed": var _p199 = A2(expandTypeAlias,acc,_p198._1._1);
                            if (_p199.ctor === "Nothing") {
                                  return fail("Type alias not defined");
                               } else {
                                  var _v159 = {ctor: "_Tuple2",_0: _p207,_1: _p199._0},
                                  _v160 = acc;
                                  _p196 = _v159;
                                  acc = _v160;
                                  continue addBindingsOne;
                               }
                          case "TTuple": var maybeRestBinding = function () {
                               var _p200 = {ctor: "_Tuple2"
                                           ,_0: _p198._0._3
                                           ,_1: _p198._1._3};
                               _v161_2: do {
                                  if (_p200.ctor === "_Tuple2") {
                                        if (_p200._0.ctor === "Nothing") {
                                              if (_p200._1.ctor === "Nothing") {
                                                    return $Result.Ok(_U.list([]));
                                                 } else {
                                                    break _v161_2;
                                                 }
                                           } else {
                                              if (_p200._1.ctor === "Just") {
                                                    var _p201 = {ctor: "_Tuple2"
                                                                ,_0: _p200._0._0.val
                                                                ,_1: _p200._1._0.val};
                                                    if (_p201.ctor === "_Tuple2" && _p201._0.ctor === "PVar" && _p201._1.ctor === "TList")
                                                    {
                                                          return $Result.Ok(_U.list([A2(HasType,
                                                          _p201._0._1,
                                                          _p201._1._1)]));
                                                       } else {
                                                          return fail("PList ERROR 1 TODO");
                                                       }
                                                 } else {
                                                    break _v161_2;
                                                 }
                                           }
                                     } else {
                                        break _v161_2;
                                     }
                               } while (false);
                               return fail("PList ERROR 2 TODO");
                            }();
                            var _p202 = {ctor: "_Tuple2"
                                        ,_0: A3(addBindings,_p198._0._1,_p198._1._1,acc)
                                        ,_1: maybeRestBinding};
                            if (_p202.ctor === "_Tuple2" && _p202._0.ctor === "Ok" && _p202._1.ctor === "Ok")
                            {
                                  return $Result.Ok(A2($Basics._op["++"],
                                  _p202._1._0,
                                  _p202._0._0));
                               } else {
                                  return fail("");
                               }
                          case "TList": var _p206 = _p198._0._1;
                            var _p203 = A3(addBindings,
                            _p206,
                            A2($List.repeat,$List.length(_p206),_p198._1._1),
                            acc);
                            if (_p203.ctor === "Err") {
                                  return fail(_p203._0);
                               } else {
                                  var _p205 = _p203._0;
                                  var _p204 = _p198._0._3;
                                  if (_p204.ctor === "Nothing") {
                                        return $Result.Ok(_p205);
                                     } else {
                                        var _v166 = {ctor: "_Tuple2",_0: _p204._0,_1: _p208},
                                        _v167 = _p205;
                                        _p196 = _v166;
                                        acc = _v167;
                                        continue addBindingsOne;
                                     }
                               }
                          default: break _v155_8;}}
               } else {
                  break _v155_8;
               }
         } while (false);
         return fail("");
      }
   });
   var addBindings = F3(function (pats,types,typeEnv) {
      var _p209 = A2($Utils.maybeZip,pats,types);
      if (_p209.ctor === "Nothing") {
            return $Result.Err("addBindings: can\'t zip");
         } else {
            return A2(addBindingsMany,_p209._0,typeEnv);
         }
   });
   var addBindingsMany = F2(function (patsAndTypes,typeEnv) {
      return A3($List.foldl,
      F2(function (pt,macc) {
         var _p210 = macc;
         if (_p210.ctor === "Err") {
               return $Result.Err(_p210._0);
            } else {
               return A2(addBindingsOne,pt,_p210._0);
            }
      }),
      $Result.Ok(typeEnv),
      patsAndTypes);
   });
   var narrowUnionType = F4(function (p,
   tAfterPreviousCases,
   tThisCase,
   typeEnv) {
      var tThisCase$ = function () {
         var _p211 = {ctor: "_Tuple2"
                     ,_0: tThisCase.val
                     ,_1: tAfterPreviousCases};
         if (_p211.ctor === "_Tuple2" && _p211._0.ctor === "TWildcard") {
               if (_p211._1.ctor === "::" && _p211._1._1.ctor === "[]") {
                     return _p211._1._0;
                  } else {
                     return tUnion(tAfterPreviousCases);
                  }
            } else {
               return tThisCase;
            }
      }();
      var tAfterThisCase = A2(subtractType,
      tAfterPreviousCases,
      tThisCase$);
      var _p212 = A2(addBindingsOne,
      {ctor: "_Tuple2",_0: p,_1: tThisCase$},
      typeEnv);
      if (_p212.ctor === "Err") {
            return $Result.Err(_p212._0);
         } else {
            return $Result.Ok({ctor: "_Tuple2"
                              ,_0: tAfterThisCase
                              ,_1: _p212._0});
         }
   });
   var addRecBinding = F4(function (rec,p,t,typeEnv) {
      if ($Basics.not(rec)) return typeEnv; else {
            var _p213 = p.val;
            if (_p213.ctor === "PVar") {
                  var tMono = function () {
                     var _p214 = stripPolymorphicArrow(t);
                     if (_p214.ctor === "Nothing") {
                           return t;
                        } else {
                           return tArrow(_p214._0._1);
                        }
                  }();
                  return A2($List._op["::"],A2(HasType,_p213._1,tMono),typeEnv);
               } else {
                  var _p215 = A2(debugLog,
                  "addRecBinding: multi TODO",
                  {ctor: "_Tuple2"
                  ,_0: $LangUnparser.unparsePat(p)
                  ,_1: $LangUnparser.unparseType(t)});
                  return typeEnv;
               }
         }
   });
   var synthesizeType = F3(function (typeInfo,typeEnv,e) {
      synthesizeType: while (true) {
         var finish = {withType: A2(finishSynthesizeWithType,
                      e.val.eid,
                      e.start)
                      ,withError: finishSynthesizeWithError(e.start)};
         var _p216 = e.val.e__;
         switch (_p216.ctor)
         {case "EColonType": var _p217 = _p216._3;
              if ($Basics.not(A2(isWellFormed,typeEnv,_p217))) {
                    var err = $Utils.spaces(_U.list([$Basics.toString(e.val.eid)
                                                    ,$Lang.strPos(_p217.start)
                                                    ,"Type annotation not well-formed:"
                                                    ,$String.trim($LangUnparser.unparseType(_p217))]));
                    return A2(finish.withError,err,typeInfo);
                 } else {
                    var result1 = A4(checkType,typeInfo,typeEnv,_p216._1,_p217);
                    return result1.result ? A2(finish.withType,
                    _p217,
                    result1.typeInfo) : {result: $Maybe.Nothing
                                        ,typeInfo: result1.typeInfo};
                 }
            case "EConst": return A2(finish.withType,tNum,typeInfo);
            case "EBase": var _p218 = _p216._1;
              switch (_p218.ctor)
              {case "EBool": return A2(finish.withType,tBool,typeInfo);
                 case "EString": return A2(finish.withType,tString,typeInfo);
                 default: return A2(finish.withType,tNull,typeInfo);}
            case "EVar": var _p220 = _p216._1;
              var _p219 = A2(lookupVar,typeEnv,_p220);
              if (_p219.ctor === "Just") {
                    return A2(finish.withType,_p219._0,typeInfo);
                 } else {
                    var err = $Utils.spaces(_U.list([$Basics.toString(e.val.eid)
                                                    ,"var not found: "
                                                    ,_p220]));
                    return A2(finish.withError,err,typeInfo);
                 }
            case "EFun": var _p222 = _p216._1;
              var _p221 = A2(newArrowTemplate,typeInfo,$List.length(_p222));
              var arrow = _p221._0;
              var typeInfo$ = _p221._1;
              return A6(tsFun,finish,typeInfo$,typeEnv,_p222,_p216._2,arrow);
            case "EOp": if (_p216._2.ctor === "[]") {
                    return A2(finish.withType,opType(_p216._1),typeInfo);
                 } else {
                    var _p226 = _p216._1;
                    var _p225 = _p216._2;
                    var _p223 = {ctor: "_Tuple2"
                                ,_0: _p226.val
                                ,_1: stripPolymorphicArrow(opType(_p226))};
                    _v177_0: do {
                       if (_p223._1.ctor === "Just") {
                             if (_p223._0.ctor === "Plus") {
                                   break _v177_0;
                                } else {
                                   if (_p223._1._0.ctor === "_Tuple2" && _p223._1._0._0.ctor === "[]")
                                   {
                                         return A5(tsAppMono,
                                         finish,
                                         typeInfo,
                                         typeEnv,
                                         _p225,
                                         _p223._1._0._1);
                                      } else {
                                         return A5(tsAppPoly,
                                         finish,
                                         typeInfo,
                                         typeEnv,
                                         _p225,
                                         _p223._1._0);
                                      }
                                }
                          } else {
                             if (_p223._0.ctor === "Plus") {
                                   break _v177_0;
                                } else {
                                   return A2(finish.withError,
                                   "synthesizeType: EOp ...",
                                   typeInfo);
                                }
                          }
                    } while (false);
                    var result = A5(tsAppMono,
                    finish,
                    typeInfo,
                    typeEnv,
                    _p225,
                    {ctor: "_Tuple2",_0: _U.list([tNum,tNum]),_1: tNum});
                    var _p224 = result.result;
                    if (_p224.ctor === "Just") {
                          return result;
                       } else {
                          return A5(tsAppMono,
                          finish,
                          typeInfo,
                          typeEnv,
                          _p225,
                          {ctor: "_Tuple2",_0: _U.list([tString,tString]),_1: tString});
                       }
                 }
            case "EApp": var _p229 = _p216._2;
              var result1 = A3(synthesizeType,typeInfo,typeEnv,_p216._1);
              var _p227 = result1.result;
              if (_p227.ctor === "Nothing") {
                    return A2(finish.withError,
                    "synthesizeTyp: EApp ...",
                    result1.typeInfo);
                 } else {
                    var _p228 = stripPolymorphicArrow(_p227._0);
                    if (_p228.ctor === "Just") {
                          if (_p228._0.ctor === "_Tuple2" && _p228._0._0.ctor === "[]")
                          {
                                return A5(tsAppMono,
                                finish,
                                result1.typeInfo,
                                typeEnv,
                                _p229,
                                _p228._0._1);
                             } else {
                                return A5(tsAppPoly,
                                finish,
                                result1.typeInfo,
                                typeEnv,
                                _p229,
                                _p228._0);
                             }
                       } else {
                          var err = "TS-App: t1 not arrow...";
                          return A2(finish.withError,err,result1.typeInfo);
                       }
                 }
            case "EList": var _p230 = A3($List.foldl,
              F2(function (ei,_p231) {
                 var _p232 = _p231;
                 var result = A3(synthesizeType,_p232._1,typeEnv,ei);
                 return {ctor: "_Tuple2"
                        ,_0: A2($List._op["::"],result.result,_p232._0)
                        ,_1: result.typeInfo};
              }),
              {ctor: "_Tuple2",_0: _U.list([]),_1: typeInfo},
              $List.reverse(_p216._1));
              var maybeTypes = _p230._0;
              var typeInfo$ = _p230._1;
              var _p233 = $Utils.projJusts(maybeTypes);
              if (_p233.ctor === "Nothing") {
                    return A2(finish.withError,
                    "synthesizeType: EList 1 ...",
                    typeInfo$);
                 } else {
                    var _p236 = _p233._0;
                    var _p234 = _p216._3;
                    if (_p234.ctor === "Nothing") {
                          return A2(finish.withType,tTuple(_p236),typeInfo$);
                       } else {
                          var result = A3(synthesizeType,typeInfo$,typeEnv,_p234._0);
                          var _p235 = result.result;
                          if (_p235.ctor === "Nothing") {
                                return A2(finish.withError,
                                "synthesizeType: EList 2 ...",
                                result.typeInfo);
                             } else {
                                return A2(finish.withType,
                                A2(tTupleRest,_p236,$Maybe.Just(_p235._0)),
                                result.typeInfo);
                             }
                       }
                 }
            case "EIf": var result1 = A4(checkType,
              typeInfo,
              typeEnv,
              _p216._1,
              tBool);
              if ($Basics.not(result1.result)) return A2(finish.withError,
                 "synthesizeType: EIf 1 ...",
                 result1.typeInfo); else {
                    var result2 = A3(synthesizeType,
                    result1.typeInfo,
                    typeEnv,
                    _p216._2);
                    var result3 = A3(synthesizeType,
                    result2.typeInfo,
                    typeEnv,
                    _p216._3);
                    var _p237 = {ctor: "_Tuple2"
                                ,_0: result2.result
                                ,_1: result3.result};
                    if (_p237.ctor === "_Tuple2" && _p237._0.ctor === "Just" && _p237._1.ctor === "Just")
                    {
                          var _p238 = A2(joinTypes,_p237._0._0,_p237._1._0);
                          if (_p238.ctor === "Ok") {
                                return A2(finish.withType,_p238._0,result3.typeInfo);
                             } else {
                                return A2(finish.withError,
                                "synthesizeType: EIf 2 ...",
                                result3.typeInfo);
                             }
                       } else {
                          return A2(finish.withError,
                          "synthesizeType: EIf 3 ...",
                          result3.typeInfo);
                       }
                 }
            case "ECase": var result1 = A3(synthesizeType,
              typeInfo,
              typeEnv,
              _p216._1);
              var _p239 = result1.result;
              if (_p239.ctor === "Nothing") {
                    return A2(finish.withError,
                    "synthesizeType: ECase ...",
                    result1.typeInfo);
                 } else {
                    var _p246 = _p239._0;
                    var _p240 = $Set.isEmpty(constraintVarsOf(_U.list([_p246]))) ? {ctor: "_Tuple0"} : A2(debugLog,
                    "ECase: TODO constraints based on patterns",
                    {ctor: "_Tuple0"});
                    var maybeThings = A3($List.foldl,
                    F2(function (pe,acc) {
                       var _p241 = pe.val;
                       var pi = _p241._1;
                       var ei = _p241._2;
                       var _p242 = {ctor: "_Tuple2"
                                   ,_0: acc
                                   ,_1: A2(addBindingsOne,
                                   {ctor: "_Tuple2",_0: pi,_1: _p246},
                                   typeEnv)};
                       if (_p242._0.ctor === "Ok") {
                             if (_p242._1.ctor === "Ok") {
                                   return $Result.Ok(A2($List._op["::"],
                                   {ctor: "_Tuple2",_0: _p242._1._0,_1: ei},
                                   _p242._0._0));
                                } else {
                                   return $Result.Err(_p242._1._0);
                                }
                          } else {
                             return $Result.Err(_p242._0._0);
                          }
                    }),
                    $Result.Ok(_U.list([])),
                    _p216._2);
                    var _p243 = maybeThings;
                    if (_p243.ctor === "Err") {
                          var err$ = $Utils.spaces(_U.list(["ECase: could not typecheck all patterns"
                                                           ,_p243._0]));
                          return A2(finish.withError,err$,result1.typeInfo);
                       } else {
                          var result2 = A2(synthesizeBranchTypes,
                          result1.typeInfo,
                          _p243._0);
                          var _p244 = $Utils.projJusts(result2.result);
                          if (_p244.ctor === "Nothing") {
                                var err = "ECase: could not typecheck all branches";
                                return A2(finish.withError,err,result2.typeInfo);
                             } else {
                                var _p245 = joinManyTypes(_p244._0);
                                if (_p245.ctor === "Err") {
                                      return A2(finish.withError,_p245._0,result2.typeInfo);
                                   } else {
                                      return A2(finish.withType,_p245._0,result2.typeInfo);
                                   }
                             }
                       }
                 }
            case "ETypeCase": var _p259 = _p216._1;
              var _p247 = A2(lookupPat,typeEnv,_p259);
              if (_p247.ctor === "Nothing") {
                    var err = A2($Basics._op["++"],
                    "no type for the pattern: ",
                    $LangUnparser.unparsePat(_p259));
                    return {result: $Maybe.Nothing
                           ,typeInfo: A3(addTypeErrorAt,_p259.start,err,typeInfo)};
                 } else {
                    var _p258 = _p247._0;
                    var _p248 = _p258.val;
                    if (_p248.ctor === "TUnion") {
                          var _p249 = A3($List.foldl,
                          F2(function (te,_p250) {
                             var _p251 = _p250;
                             var _p254 = _p251._0;
                             var _p252 = te.val;
                             var ti = _p252._1;
                             var ei = _p252._2;
                             var _p253 = {ctor: "_Tuple2"
                                         ,_0: _p251._1
                                         ,_1: A4(narrowUnionType,_p259,_p254,ti,typeEnv)};
                             if (_p253._0.ctor === "Ok") {
                                   if (_p253._1.ctor === "Ok") {
                                         return {ctor: "_Tuple2"
                                                ,_0: _p253._1._0._0
                                                ,_1: $Result.Ok(A2($List._op["::"],
                                                {ctor: "_Tuple2",_0: _p253._1._0._1,_1: ei},
                                                _p253._0._0))};
                                      } else {
                                         return {ctor: "_Tuple2"
                                                ,_0: _p254
                                                ,_1: $Result.Err(_p253._1._0)};
                                      }
                                } else {
                                   return {ctor: "_Tuple2"
                                          ,_0: _p254
                                          ,_1: $Result.Err(_p253._0._0)};
                                }
                          }),
                          {ctor: "_Tuple2",_0: _p248._1,_1: $Result.Ok(_U.list([]))},
                          _p216._2);
                          var maybeThings = _p249._1;
                          var _p255 = maybeThings;
                          if (_p255.ctor === "Err") {
                                var err$ = $Utils.spaces(_U.list(["ETypeCase: could not typecheck all patterns"
                                                                 ,_p255._0]));
                                return A2(finish.withError,err$,typeInfo);
                             } else {
                                var result2 = A2(synthesizeBranchTypes,typeInfo,_p255._0);
                                var _p256 = $Utils.projJusts(result2.result);
                                if (_p256.ctor === "Nothing") {
                                      var err = "ETypeCase: could not typecheck all branches";
                                      return A2(finish.withError,err,result2.typeInfo);
                                   } else {
                                      var _p257 = joinManyTypes(_p256._0);
                                      if (_p257.ctor === "Err") {
                                            return A2(finish.withError,_p257._0,result2.typeInfo);
                                         } else {
                                            return A2(finish.withType,_p257._0,result2.typeInfo);
                                         }
                                   }
                             }
                       } else {
                          var err = A2($Basics._op["++"],
                          "pattern is not a union type: ",
                          $LangUnparser.unparseType(_p258));
                          return {result: $Maybe.Nothing
                                 ,typeInfo: A3(addTypeErrorAt,_p259.start,err,typeInfo)};
                       }
                 }
            case "ELet": var _p267 = _p216._2;
              var _p266 = _p216._3;
              var _p265 = _p216._5;
              var _p264 = _p216._4;
              var _p260 = {ctor: "_Tuple4"
                          ,_0: _p266.val
                          ,_1: A2(lookupTypAnnotation,typeEnv,_p266)
                          ,_2: _p267
                          ,_3: _p264.val.e__};
              _v199_0: do {
                 if (_p260._1.ctor === "Nothing") {
                       if (_p260._0.ctor === "PVar" && _p260._0._1 === "dummyPreludeMain")
                       {
                             break _v199_0;
                          } else {
                             if (_p260._2 === true && _p260._3.ctor === "EFun") {
                                   var _p261 = A2(newArrowTemplate,
                                   typeInfo,
                                   $List.length(_p260._3._1));
                                   var arrow = _p261._0;
                                   var typeInfo$ = _p261._1;
                                   var t1 = tArrow(arrow);
                                   var e1$ = A2($Lang.replaceE__,
                                   _p264,
                                   A5($Lang.EColonType,"",_p264,"",t1,""));
                                   var typeEnv$ = A4(addRecBinding,true,_p266,t1,typeEnv);
                                   return A6(tsLet,
                                   finish.withType,
                                   typeInfo$,
                                   typeEnv$,
                                   _p266,
                                   e1$,
                                   _p265);
                                } else {
                                   return A6(tsLet,
                                   finish.withType,
                                   typeInfo,
                                   typeEnv,
                                   _p266,
                                   _p264,
                                   _p265);
                                }
                          }
                    } else {
                       if (_p260._0.ctor === "PVar" && _p260._0._1 === "dummyPreludeMain")
                       {
                             break _v199_0;
                          } else {
                             if (_p260._3.ctor === "EColonType") {
                                   var _p262 = _p260._1._0;
                                   if (_U.eq(_p262,_p260._3._3)) {
                                         var typeEnv$ = A4(addRecBinding,_p267,_p266,_p262,typeEnv);
                                         return A6(tsLet,
                                         finish.withType,
                                         typeInfo,
                                         typeEnv$,
                                         _p266,
                                         _p264,
                                         _p265);
                                      } else {
                                         var err = $Utils.spaces(_U.list(["checkType"
                                                                         ,$Basics.toString(e.val.eid)
                                                                         ,"Double annotation. Remove one."]));
                                         return A2(finish.withError,err,typeInfo);
                                      }
                                } else {
                                   var _p263 = _p260._1._0;
                                   if ($Basics.not(A2(isWellFormed,typeEnv,_p263))) {
                                         var err = $Utils.spaces(_U.list([$Basics.toString(e.val.eid)
                                                                         ,$Lang.strPos(_p263.start)
                                                                         ,"Type annotation not well-formed, at def:"
                                                                         ,$String.trim($LangUnparser.unparseType(_p263))]));
                                         if (stopAtError) return A2(finish.withError,err,typeInfo);
                                         else {
                                               var t1 = tVar("__NO_TYPE__");
                                               var typeInfo$ = A3(addTypeErrorAt,t1.start,err,typeInfo);
                                               return A7(tsLetFinishE2,
                                               finish.withType,
                                               typeInfo$,
                                               typeEnv,
                                               _p266,
                                               t1,
                                               eInfoOf(_p264),
                                               _p265);
                                            }
                                      } else {
                                         var typeEnv$ = A4(addRecBinding,_p267,_p266,_p263,typeEnv);
                                         var e1$ = A2($Lang.replaceE__,
                                         _p264,
                                         A5($Lang.EColonType,"",_p264,"",_p263,""));
                                         var e$ = A2($Lang.replaceE__,
                                         e,
                                         A7($Lang.ELet,
                                         _p216._0,
                                         _p216._1,
                                         _p267,
                                         _p266,
                                         e1$,
                                         _p265,
                                         _p216._6));
                                         var _v200 = typeInfo,_v201 = typeEnv$,_v202 = e$;
                                         typeInfo = _v200;
                                         typeEnv = _v201;
                                         e = _v202;
                                         continue synthesizeType;
                                      }
                                }
                          }
                    }
              } while (false);
              return {result: $Maybe.Nothing
                     ,typeInfo: _U.update(typeInfo,
                     {preludeTypeEnv: $Maybe.Just(typeEnv)})};
            case "EComment": return propagateResult(A3(synthesizeType,
              typeInfo,
              typeEnv,
              _p216._2));
            case "EOption": return propagateResult(A3(synthesizeType,
              typeInfo,
              typeEnv,
              _p216._4));
            case "ETyp": var _p268 = A3(addTypBindings,
              _p216._1,
              _p216._2,
              typeEnv);
              if (_p268.ctor === "Err") {
                    return {result: $Maybe.Nothing,typeInfo: typeInfo};
                 } else {
                    return propagateResult(A3(synthesizeType,
                    typeInfo,
                    _p268._0,
                    _p216._3));
                 }
            default: var typeEnv$ = A2($List._op["::"],
              A2(TypeAlias,_p216._1,_p216._2),
              typeEnv);
              return propagateResult(A3(synthesizeType,
              typeInfo,
              typeEnv$,
              _p216._3));}
      }
   });
   var checkType = F4(function (typeInfo,typeEnv,e,goalType) {
      checkType: while (true) {
         var _p269 = e.val.e__;
         switch (_p269.ctor)
         {case "EFun": var _p270 = stripPolymorphicArrow(goalType);
              if (_p270.ctor === "Nothing") {
                    return {typeInfo: typeInfo,result: false};
                 } else {
                    var _p271 = A3(addBindings,
                    _p269._1,
                    _p270._0._1._0,
                    A2(addTypeVarBindings,_p270._0._0,typeEnv));
                    if (_p271.ctor === "Err") {
                          return {result: false
                                 ,typeInfo: A3(addTypeErrorAt,e.start,_p271._0,typeInfo)};
                       } else {
                          var _v207 = typeInfo,
                          _v208 = _p271._0,
                          _v209 = _p269._2,
                          _v210 = _p270._0._1._1;
                          typeInfo = _v207;
                          typeEnv = _v208;
                          e = _v209;
                          goalType = _v210;
                          continue checkType;
                       }
                 }
            case "EIf": var result1 = A4(checkType,
              typeInfo,
              typeEnv,
              _p269._1,
              tBool);
              var result2 = A4(checkType,
              result1.typeInfo,
              typeEnv,
              _p269._2,
              goalType);
              var result3 = A4(checkType,
              result2.typeInfo,
              typeEnv,
              _p269._3,
              goalType);
              return {result: result1.result && (result2.result && result3.result)
                     ,typeInfo: result3.typeInfo};
            case "ECase": var result1 = A3(synthesizeType,
              typeInfo,
              typeEnv,
              _p269._1);
              var _p272 = result1.result;
              if (_p272.ctor === "Nothing") {
                    return {result: false,typeInfo: result1.typeInfo};
                 } else {
                    var result_branches = A3($List.foldl,
                    F2(function (pe,acc) {
                       var _p273 = pe.val;
                       var pi = _p273._1;
                       var ei = _p273._2;
                       var _p274 = A2(addBindingsOne,
                       {ctor: "_Tuple2",_0: pi,_1: _p272._0},
                       typeEnv);
                       if (_p274.ctor === "Err") {
                             return {result: false
                                    ,typeInfo: A3(addTypeErrorAt,pi.start,_p274._0,acc.typeInfo)};
                          } else {
                             var resulti = A4(checkType,
                             acc.typeInfo,
                             _p274._0,
                             ei,
                             goalType);
                             return {result: resulti.result && acc.result
                                    ,typeInfo: resulti.typeInfo};
                          }
                    }),
                    {result: true,typeInfo: result1.typeInfo},
                    _p269._2);
                    var _p275 = result_branches.result;
                    if (_p275 === true) {
                          return result_branches;
                       } else {
                          var err = "couldn\'t check all branches";
                          return {result: false
                                 ,typeInfo: A3(addTypeErrorAt,
                                 e.start,
                                 err,
                                 result_branches.typeInfo)};
                       }
                 }
            case "ETypeCase": var _p287 = _p269._1;
              var _p276 = A2(lookupPat,typeEnv,_p287);
              if (_p276.ctor === "Nothing") {
                    var err = A2($Basics._op["++"],
                    "no type for the pattern: ",
                    $LangUnparser.unparsePat(_p287));
                    return {result: false
                           ,typeInfo: A3(addTypeErrorAt,_p287.start,err,typeInfo)};
                 } else {
                    var _p286 = _p276._0;
                    var _p277 = _p286.val;
                    if (_p277.ctor === "TUnion") {
                          var _p278 = A3($List.foldl,
                          F2(function (te,_p279) {
                             var _p280 = _p279;
                             var _p284 = _p280._1;
                             var _p283 = _p280._0;
                             var _p281 = te.val;
                             var ti = _p281._1;
                             var ei = _p281._2;
                             var _p282 = A4(narrowUnionType,_p287,_p283,ti,typeEnv);
                             if (_p282.ctor === "Err") {
                                   var acc2$ = {result: false
                                               ,typeInfo: A3(addTypeErrorAt,
                                               _p287.start,
                                               _p282._0,
                                               _p284.typeInfo)};
                                   return {ctor: "_Tuple2",_0: _p283,_1: acc2$};
                                } else {
                                   var resulti = A4(checkType,
                                   _p284.typeInfo,
                                   _p282._0._1,
                                   ei,
                                   goalType);
                                   var acc2$ = {result: resulti.result && _p284.result
                                               ,typeInfo: resulti.typeInfo};
                                   return {ctor: "_Tuple2",_0: _p282._0._0,_1: acc2$};
                                }
                          }),
                          {ctor: "_Tuple2"
                          ,_0: _p277._1
                          ,_1: {result: true,typeInfo: typeInfo}},
                          _p269._2);
                          var unionResidual = _p278._0;
                          var result_branches = _p278._1;
                          var _p285 = result_branches.result;
                          if (_p285 === true) {
                                return result_branches;
                             } else {
                                var err = "couldn\'t check all branches";
                                return {result: false
                                       ,typeInfo: A3(addTypeErrorAt,
                                       e.start,
                                       err,
                                       result_branches.typeInfo)};
                             }
                       } else {
                          var err = A2($Basics._op["++"],
                          "pattern is not a union type: ",
                          $LangUnparser.unparseType(_p286));
                          return {result: false
                                 ,typeInfo: A3(addTypeErrorAt,_p287.start,err,typeInfo)};
                       }
                 }
            case "EComment": var _v219 = typeInfo,
              _v220 = typeEnv,
              _v221 = _p269._2,
              _v222 = goalType;
              typeInfo = _v219;
              typeEnv = _v220;
              e = _v221;
              goalType = _v222;
              continue checkType;
            default: var result1 = A3(synthesizeType,typeInfo,typeEnv,e);
              var typeInfo1 = result1.typeInfo;
              var _p288 = result1.result;
              if (_p288.ctor === "Nothing") {
                    var err = $Utils.spaces(_U.list(["checkType"
                                                    ,$Basics.toString(e.val.eid)
                                                    ,$String.trim($LangUnparser.unparseType(goalType))
                                                    ,"failed to synthesize a type"]));
                    return {result: false
                           ,typeInfo: A3(addTypeErrorAt,e.start,err,typeInfo1)};
                 } else {
                    var result2 = A4(checkSubtype,
                    typeInfo1,
                    typeEnv,
                    _p288._0,
                    goalType);
                    var _p289 = result2.result;
                    if (_p289.ctor === "Err") {
                          var err$ = $Utils.spaces(_U.list(["checkType"
                                                           ,$Basics.toString(e.val.eid)
                                                           ,_p289._0]));
                          return {result: false
                                 ,typeInfo: A3(addTypeErrorAt,e.start,err$,result2.typeInfo)};
                       } else {
                          return {result: true,typeInfo: result2.typeInfo};
                       }
                 }}
      }
   });
   var synthesizeBranchTypes = F2(function (typeInfo,list) {
      var _p290 = A3($List.foldl,
      F2(function (_p292,_p291) {
         var _p293 = _p292;
         var _p294 = _p291;
         var resulti = A3(synthesizeType,_p294._1,_p293._0,_p293._1);
         return {ctor: "_Tuple2"
                ,_0: A2($List._op["::"],resulti.result,_p294._0)
                ,_1: resulti.typeInfo};
      }),
      {ctor: "_Tuple2",_0: _U.list([]),_1: typeInfo},
      list);
      var maybeTypes = _p290._0;
      var typeInfo$ = _p290._1;
      return {result: $List.reverse(maybeTypes),typeInfo: typeInfo$};
   });
   var tsAppMono = F5(function (finish,
   typeInfo,
   typeEnv,
   eArgs,
   _p295) {
      var _p296 = _p295;
      var _p304 = _p296._1;
      var _p303 = _p296._0;
      var checkArgs = F2(function (argsAndTypes,retType) {
         var _p297 = A3($List.foldl,
         F2(function (_p299,_p298) {
            var _p300 = _p299;
            var _p301 = _p298;
            var res = A4(checkType,_p301._1,typeEnv,_p300._0,_p300._1);
            return {ctor: "_Tuple2"
                   ,_0: _p301._0 && res.result
                   ,_1: res.typeInfo};
         }),
         {ctor: "_Tuple2",_0: true,_1: typeInfo},
         argsAndTypes);
         var argsOkay = _p297._0;
         var typeInfo$ = _p297._1;
         return argsOkay ? A2(finish.withType,
         retType,
         typeInfo$) : A2(finish.withError,
         "Function arguments don\'t match required types.",
         typeInfo$);
      });
      var _p302 = {ctor: "_Tuple2"
                  ,_0: $List.length(eArgs)
                  ,_1: $List.length(_p303)};
      var nArgs = _p302._0;
      var nTypes = _p302._1;
      if (_U.eq(nArgs,nTypes)) return A2(checkArgs,
         A2($Utils.zip,eArgs,_p303),
         _p304); else if (_U.cmp(nArgs,nTypes) < 0) {
               var argTypes$ = A2($List.take,nArgs,_p303);
               var retType$ = tArrow({ctor: "_Tuple2"
                                     ,_0: A2($List.drop,nArgs,_p303)
                                     ,_1: _p304});
               return A2(checkArgs,A2($Utils.zip,eArgs,argTypes$),retType$);
            } else return A2(finish.withError,
            "Too many arguments to this function.",
            typeInfo);
   });
   var tsAppPoly = F5(function (finish,
   typeInfo,
   typeEnv,
   eArgs,
   polyArrow) {
      var result = A3(synthesizeTypeMany,typeInfo,typeEnv,eArgs);
      var _p305 = $Utils.projJusts(result.result);
      if (_p305.ctor === "Nothing") {
            var err = "Could not typecheck all of the arguments.";
            return A2(finish.withError,err,result.typeInfo);
         } else {
            var result1 = A2(instantiatePolyArrowWithConstraintVars,
            result.typeInfo,
            polyArrow);
            var result2 = A2(instantiateTypesWithConstraintVars,
            result1.typeInfo,
            _p305._0);
            var _p306 = result1.result;
            var constraintVars1 = _p306._0;
            var argTypes$ = _p306._1._0;
            var retType$ = _p306._1._1;
            var _p307 = result2.result;
            var constraintVars2 = _p307._0;
            var tActuals$ = _p307._1;
            var typeInfo$ = A2(addRawConstraints,
            A2($Utils.zip,argTypes$,tActuals$),
            result2.typeInfo);
            var constraintVars = A2($Basics._op["++"],
            constraintVars1,
            constraintVars2);
            var result3 = A3(solveConstraintsFor,
            typeInfo$,
            typeEnv,
            constraintVars);
            var _p308 = result3.result;
            if (_p308.ctor === "Err") {
                  return A2(finish.withError,_p308._0,typeInfo$);
               } else {
                  var _p310 = _p308._0;
                  var retType$$ = A2(applyUnifier,_p310,retType$);
                  var _p309 = {ctor: "_Tuple2"
                              ,_0: $List.length(eArgs)
                              ,_1: $List.length(argTypes$)};
                  var nArgs = _p309._0;
                  var nTypes = _p309._1;
                  if (_U.eq(nArgs,nTypes)) return A2(finish.withType,
                     retType$$,
                     result3.typeInfo); else if (_U.cmp(nArgs,nTypes) < 0) {
                           var remainingArgTypes$ = A2($List.map,
                           applyUnifier(_p310),
                           A2($List.drop,$List.length(eArgs),argTypes$));
                           return A2(finish.withType,
                           tArrow({ctor: "_Tuple2",_0: remainingArgTypes$,_1: retType$$}),
                           result3.typeInfo);
                        } else return A2(finish.withError,
                        "Too many arguments to this function.",
                        result3.typeInfo);
               }
         }
   });
   var synthesizeTypeMany = F3(function (typeInfo,typeEnv,es) {
      return A2(synthesizeBranchTypes,
      typeInfo,
      A2($List.map,
      function (ei) {
         return {ctor: "_Tuple2",_0: typeEnv,_1: ei};
      },
      es));
   });
   var tsFun = F6(function (finish,
   typeInfo,
   typeEnv,
   ps,
   eBody,
   _p311) {
      var _p312 = _p311;
      var _p316 = _p312._1;
      var _p315 = _p312._0;
      var _p313 = A3(addBindings,ps,_p315,typeEnv);
      if (_p313.ctor === "Err") {
            return A2(finish.withError,_p313._0,typeInfo);
         } else {
            var result1 = A3(synthesizeType,typeInfo,_p313._0,eBody);
            var _p314 = result1.result;
            if (_p314.ctor === "Nothing") {
                  return A2(finish.withError,
                  "can\'t synthesize type for function body",
                  result1.typeInfo);
               } else {
                  return A2(finish.withType,
                  tArrow({ctor: "_Tuple2",_0: _p315,_1: _p316}),
                  A2(addRawConstraints,
                  _U.list([{ctor: "_Tuple2",_0: _p316,_1: _p314._0}]),
                  result1.typeInfo));
               }
         }
   });
   var tsLet = F6(function (finishWithType,
   typeInfo,
   typeEnv,
   p,
   e1,
   e2) {
      var result1 = A3(synthesizeType,typeInfo,typeEnv,e1);
      var _p317 = result1.result;
      if (_p317.ctor === "Nothing") {
            if (stopAtError) return result1; else {
                  var t1 = tVar("__NO_TYPE__");
                  return A7(tsLetFinishE2,
                  finishWithType,
                  result1.typeInfo,
                  typeEnv,
                  p,
                  t1,
                  eInfoOf(e1),
                  e2);
               }
         } else {
            var _p320 = _p317._0;
            var result1$ = function () {
               var _p318 = isArrowTemplate(_p320);
               if (_p318.ctor === "Just") {
                     return A4(solveTemplateArrow,
                     result1.typeInfo,
                     typeEnv,
                     eInfoOf(e1),
                     _p318._0);
                  } else {
                     return {result: $Maybe.Just(_p320)
                            ,typeInfo: result1.typeInfo};
                  }
            }();
            var _p319 = result1$.result;
            if (_p319.ctor === "Just") {
                  return A7(tsLetFinishE2,
                  finishWithType,
                  result1$.typeInfo,
                  typeEnv,
                  p,
                  _p319._0,
                  eInfoOf(e1),
                  e2);
               } else {
                  if (stopAtError) return result1$; else {
                        var t1$ = tVar("__NO_TYPE__");
                        return A7(tsLetFinishE2,
                        finishWithType,
                        result1$.typeInfo,
                        typeEnv,
                        p,
                        t1$,
                        eInfoOf(e1),
                        e2);
                     }
               }
         }
   });
   var tsLetFinishE2 = F7(function (finishWithType,
   typeInfo,
   typeEnv,
   p,
   t1,
   eInfo1,
   e2) {
      if ($Basics.not(sanityChecks)) return A7(tsLetFinishE2_,
         finishWithType,
         typeInfo,
         typeEnv,
         p,
         t1,
         eInfo1.val,
         e2); else if (A2(isWellFormed,typeEnv,t1))
         return A7(tsLetFinishE2_,
            finishWithType,
            typeInfo,
            typeEnv,
            p,
            t1,
            eInfo1.val,
            e2); else {
               var err = $Utils.spaces(_U.list(["[TYPE SYSTEM BUG]"
                                               ,$Basics.toString(eInfo1.val)
                                               ,$Lang.strPos(t1.start)
                                               ,"Synthesized type not well-formed:"
                                               ,$String.trim($LangUnparser.unparseType(t1))]));
               var typeInfo$ = A3(addTypeErrorAt,eInfo1.start,err,typeInfo);
               return stopAtError ? {result: $Maybe.Nothing
                                    ,typeInfo: typeInfo$} : A7(tsLetFinishE2_,
               finishWithType,
               typeInfo$,
               typeEnv,
               p,
               t1,
               eInfo1.val,
               e2);
            }
   });
   var tsLetFinishE2_ = F7(function (finishWithType,
   typeInfo,
   typeEnv,
   p,
   t1,
   e1eid,
   e2) {
      var _p321 = A3(addBindings,
      _U.list([p]),
      _U.list([t1]),
      typeEnv);
      if (_p321.ctor === "Err") {
            return {result: $Maybe.Nothing
                   ,typeInfo: A3(addTypeErrorAt,p.start,_p321._0,typeInfo)};
         } else {
            var typeInfo$ = A3(addNamedExp,
            p,
            e1eid,
            A3(addFinalType,e1eid,$Maybe.Just(t1),typeInfo));
            var result2 = A3(synthesizeType,typeInfo$,_p321._0,e2);
            var _p322 = result2.result;
            if (_p322.ctor === "Nothing") {
                  return {result: $Maybe.Nothing,typeInfo: result2.typeInfo};
               } else {
                  return A2(finishWithType,_p322._0,result2.typeInfo);
               }
         }
   });
   var typecheck = function (e) {
      var _p323 = A2(debugLog,"TYPE CHECKING","...");
      var result = A3(synthesizeType,initTypeInfo,preludeTypeEnv,e);
      var _p324 = displayTypeInfo(result.typeInfo);
      return aceTypeInfo(result.typeInfo);
   };
   var valIsType = F2(function (val,tipe) {
      var unsupported = function (msg) {
         return _U.crash("Types",
         {start: {line: 90,column: 5}
         ,end: {line: 90,column: 16}})(A2($Basics._op["++"],
         "typing values against ",
         A2($Basics._op["++"],msg," is not supported")));
      };
      var _p325 = {ctor: "_Tuple2",_0: val.v_,_1: tipe.val};
      _v240_12: do {
         if (_p325.ctor === "_Tuple2") {
               switch (_p325._1.ctor)
               {case "TNum": if (_p325._0.ctor === "VConst") {
                          return true;
                       } else {
                          break _v240_12;
                       }
                  case "TBool":
                  if (_p325._0.ctor === "VBase" && _p325._0._0.ctor === "VBool") {
                          return true;
                       } else {
                          break _v240_12;
                       }
                  case "TString":
                  if (_p325._0.ctor === "VBase" && _p325._0._0.ctor === "VString")
                    {
                          return true;
                       } else {
                          break _v240_12;
                       }
                  case "TNull":
                  if (_p325._0.ctor === "VBase" && _p325._0._0.ctor === "VNull") {
                          return true;
                       } else {
                          break _v240_12;
                       }
                  case "TList": if (_p325._0.ctor === "VList") {
                          return A2($List.all,
                          function (v) {
                             return A2(valIsType,v,_p325._1._1);
                          },
                          _p325._0._0);
                       } else {
                          break _v240_12;
                       }
                  case "TDict": return unsupported("dictionary types");
                  case "TTuple": if (_p325._0.ctor === "VList") {
                          var _p330 = _p325._0._0;
                          var _p329 = _p325._1._1;
                          var typeListsMatch = A3($List.foldl,
                          F2(function (_p326,res) {
                             var _p327 = _p326;
                             return res && A2(valIsType,_p327._0,_p327._1);
                          }),
                          true,
                          A2($Utils.zip,_p330,_p329));
                          var _p328 = _p325._1._3;
                          if (_p328.ctor === "Nothing") {
                                return typeListsMatch && _U.eq($List.length(_p330),
                                $List.length(_p329));
                             } else {
                                return typeListsMatch && (_U.cmp($List.length(_p330),
                                $List.length(_p329)) > -1 && A2($List.all,
                                function (v) {
                                   return A2(valIsType,v,_p328._0);
                                },
                                A2($List.drop,$List.length(_p329),_p330)));
                             }
                       } else {
                          break _v240_12;
                       }
                  case "TArrow": return unsupported("arrow types");
                  case "TUnion": return A2($List.any,valIsType(val),_p325._1._1);
                  case "TNamed": return unsupported("type aliases");
                  case "TVar": return unsupported("type variables");
                  case "TWildcard": return true;
                  default: break _v240_12;}
            } else {
               break _v240_12;
            }
      } while (false);
      return false;
   });
   var identifiersEquivalent = F2(function (t1,t2) {
      var flatIdents = function (t) {
         flatIdents: while (true) {
            var _p331 = t.val;
            switch (_p331.ctor)
            {case "TNum": return _U.list([]);
               case "TBool": return _U.list([]);
               case "TString": return _U.list([]);
               case "TNull": return _U.list([]);
               case "TList": var _v244 = _p331._1;
                 t = _v244;
                 continue flatIdents;
               case "TDict": return A2($Basics._op["++"],
                 flatIdents(_p331._1),
                 flatIdents(_p331._2));
               case "TTuple": var restTypeIdents = function () {
                    var _p332 = _p331._3;
                    if (_p332.ctor === "Just") {
                          return flatIdents(_p332._0);
                       } else {
                          return _U.list([]);
                       }
                 }();
                 return A2($Basics._op["++"],
                 A2($List.concatMap,flatIdents,_p331._1),
                 restTypeIdents);
               case "TArrow": return A2($List.concatMap,flatIdents,_p331._1);
               case "TUnion": return A2($List.concatMap,flatIdents,_p331._1);
               case "TNamed": return _U.list([]);
               case "TVar": return _U.list([_p331._1]);
               case "TWildcard": return _U.list([]);
               default: return _U.crashCase("Types",
                 {start: {line: 63,column: 5},end: {line: 83,column: 73}},
                 _p331)("identifiersEquiv TForall TODO");}
         }
      };
      return A2($Utils.oneToOneMappingExists,
      flatIdents(t1),
      flatIdents(t2));
   });
   var astsMatch = F2(function (t1,t2) {
      astsMatch: while (true) {
         var _p334 = {ctor: "_Tuple2",_0: t1.val,_1: t2.val};
         _v246_14: do {
            if (_p334.ctor === "_Tuple2") {
                  switch (_p334._0.ctor)
                  {case "TNum": if (_p334._1.ctor === "TNum") {
                             return true;
                          } else {
                             break _v246_14;
                          }
                     case "TBool": if (_p334._1.ctor === "TBool") {
                             return true;
                          } else {
                             break _v246_14;
                          }
                     case "TString": if (_p334._1.ctor === "TString") {
                             return true;
                          } else {
                             break _v246_14;
                          }
                     case "TNull": if (_p334._1.ctor === "TNull") {
                             return true;
                          } else {
                             break _v246_14;
                          }
                     case "TList": if (_p334._1.ctor === "TList") {
                             var _v247 = _p334._0._1,_v248 = _p334._1._1;
                             t1 = _v247;
                             t2 = _v248;
                             continue astsMatch;
                          } else {
                             break _v246_14;
                          }
                     case "TDict": if (_p334._1.ctor === "TDict") {
                             return A2(astsMatch,_p334._0._1,_p334._1._1) && A2(astsMatch,
                             _p334._0._2,
                             _p334._1._2);
                          } else {
                             break _v246_14;
                          }
                     case "TTuple": if (_p334._1.ctor === "TTuple") {
                             var maybeRestTypesMatch = function () {
                                var _p335 = {ctor: "_Tuple2"
                                            ,_0: _p334._0._3
                                            ,_1: _p334._1._3};
                                _v249_2: do {
                                   if (_p335.ctor === "_Tuple2") {
                                         if (_p335._0.ctor === "Nothing") {
                                               if (_p335._1.ctor === "Nothing") {
                                                     return true;
                                                  } else {
                                                     break _v249_2;
                                                  }
                                            } else {
                                               if (_p335._1.ctor === "Just") {
                                                     return A2(astsMatch,_p335._0._0,_p335._1._0);
                                                  } else {
                                                     break _v249_2;
                                                  }
                                            }
                                      } else {
                                         break _v249_2;
                                      }
                                } while (false);
                                return false;
                             }();
                             return maybeRestTypesMatch && A3($Utils.listsEqualBy,
                             astsMatch,
                             _p334._0._1,
                             _p334._1._1);
                          } else {
                             break _v246_14;
                          }
                     case "TArrow": if (_p334._1.ctor === "TArrow") {
                             return A3($Utils.listsEqualBy,
                             astsMatch,
                             _p334._0._1,
                             _p334._1._1);
                          } else {
                             break _v246_14;
                          }
                     case "TUnion": if (_p334._1.ctor === "TUnion") {
                             return A3($Utils.listsEqualBy,
                             astsMatch,
                             _p334._0._1,
                             _p334._1._1);
                          } else {
                             break _v246_14;
                          }
                     case "TNamed": if (_p334._1.ctor === "TNamed") {
                             return _U.eq(_p334._0._1,_p334._1._1);
                          } else {
                             break _v246_14;
                          }
                     case "TVar": if (_p334._1.ctor === "TVar") {
                             return true;
                          } else {
                             break _v246_14;
                          }
                     case "TWildcard": if (_p334._1.ctor === "TWildcard") {
                             return true;
                          } else {
                             break _v246_14;
                          }
                     default: if (_p334._0._1.ctor === "One") {
                             if (_p334._1.ctor === "TForall" && _p334._1._1.ctor === "One")
                             {
                                   var _v250 = _p334._0._2,_v251 = _p334._1._2;
                                   t1 = _v250;
                                   t2 = _v251;
                                   continue astsMatch;
                                } else {
                                   break _v246_14;
                                }
                          } else {
                             if (_p334._1.ctor === "TForall" && _p334._1._1.ctor === "Many")
                             {
                                   return _U.eq($List.length(_p334._0._1._1),
                                   $List.length(_p334._1._1._1)) && A2(astsMatch,
                                   _p334._0._2,
                                   _p334._1._2);
                                } else {
                                   break _v246_14;
                                }
                          }}
               } else {
                  break _v246_14;
               }
         } while (false);
         return false;
      }
   });
   var equal = F2(function (t1,t2) {
      return A2(astsMatch,t1,t2) && A2(identifiersEquivalent,
      t1,
      t2);
   });
   return _elm.Types.values = {_op: _op
                              ,equal: equal
                              ,astsMatch: astsMatch
                              ,identifiersEquivalent: identifiersEquivalent
                              ,valIsType: valIsType
                              ,HasType: HasType
                              ,CheckType: CheckType
                              ,TypeVar: TypeVar
                              ,TypeAlias: TypeAlias
                              ,TypeInfo: TypeInfo
                              ,AceTypeInfo: AceTypeInfo
                              ,AndTypeInfo: AndTypeInfo
                              ,debugLog: debugLog
                              ,stopAtError: stopAtError
                              ,sanityChecks: sanityChecks
                              ,tBool: tBool
                              ,tNum: tNum
                              ,tString: tString
                              ,tNull: tNull
                              ,tVar: tVar
                              ,tTupleRest: tTupleRest
                              ,tTuple: tTuple
                              ,tList: tList
                              ,tUnion: tUnion
                              ,tArrow: tArrow
                              ,tPolyArrow: tPolyArrow
                              ,tForall: tForall
                              ,eInfoOf: eInfoOf
                              ,strEInfo: strEInfo
                              ,strRawConstraint: strRawConstraint
                              ,strConstraint: strConstraint
                              ,opTypeTable: opTypeTable
                              ,parseT: parseT
                              ,opType: opType
                              ,addBindings: addBindings
                              ,addBindingsMany: addBindingsMany
                              ,addBindingsOne: addBindingsOne
                              ,addRecBinding: addRecBinding
                              ,addTypeVarBindings: addTypeVarBindings
                              ,addTypBindings: addTypBindings
                              ,lookupVar: lookupVar
                              ,lookupPat: lookupPat
                              ,lookupTypAnnotation: lookupTypAnnotation
                              ,lookupTypAnnotation_: lookupTypAnnotation_
                              ,expandTypeAlias: expandTypeAlias
                              ,lookupTypeAlias: lookupTypeAlias
                              ,narrowUnionType: narrowUnionType
                              ,subtractType: subtractType
                              ,addRawConstraints: addRawConstraints
                              ,addNamedExp: addNamedExp
                              ,addRawType: addRawType
                              ,addFinalType: addFinalType
                              ,addTypeErrorAt: addTypeErrorAt
                              ,generateConstraintVars: generateConstraintVars
                              ,stripArrow: stripArrow
                              ,stripPolymorphicArrow: stripPolymorphicArrow
                              ,splitTypesInArrow: splitTypesInArrow
                              ,isArrowTemplate: isArrowTemplate
                              ,isConstraintVar: isConstraintVar
                              ,constraintVarsOf: constraintVarsOf
                              ,constraintVarsOfArrow: constraintVarsOfArrow
                              ,newArrowTemplate: newArrowTemplate
                              ,isWellFormed: isWellFormed
                              ,checkType: checkType
                              ,finishSynthesizeWithType: finishSynthesizeWithType
                              ,finishSynthesizeWithError: finishSynthesizeWithError
                              ,propagateResult: propagateResult
                              ,synthesizeType: synthesizeType
                              ,tsAppMono: tsAppMono
                              ,tsAppPoly: tsAppPoly
                              ,instantiatePolyArrowWithConstraintVars: instantiatePolyArrowWithConstraintVars
                              ,instantiateTypeWithConstraintVars: instantiateTypeWithConstraintVars
                              ,instantiateTypesWithConstraintVars: instantiateTypesWithConstraintVars
                              ,tsFun: tsFun
                              ,tsLet: tsLet
                              ,tsLetFinishE2: tsLetFinishE2
                              ,tsLetFinishE2_: tsLetFinishE2_
                              ,solveTemplateArrow: solveTemplateArrow
                              ,synthesizeBranchTypes: synthesizeBranchTypes
                              ,synthesizeTypeMany: synthesizeTypeMany
                              ,checkSubtype: checkSubtype
                              ,tryCatchAlls: tryCatchAlls
                              ,checkSubtypeTVar: checkSubtypeTVar
                              ,checkSubtypeUnionRight: checkSubtypeUnionRight
                              ,checkSubtypeUnionLeft: checkSubtypeUnionLeft
                              ,checkSubtypeFoldLeft: checkSubtypeFoldLeft
                              ,checkSubtypeSingletonUnion: checkSubtypeSingletonUnion
                              ,checkSubtypeList: checkSubtypeList
                              ,checkSubMaybeType: checkSubMaybeType
                              ,checkSubtypeSomeRight: checkSubtypeSomeRight
                              ,checkEquivType: checkEquivType
                              ,checkEqualType: checkEqualType
                              ,checkSubtypeSimple: checkSubtypeSimple
                              ,bindSubtypeResult: bindSubtypeResult
                              ,coerceTupleToList: coerceTupleToList
                              ,joinTypes: joinTypes
                              ,joinTypes_: joinTypes_
                              ,joinManyTypes: joinManyTypes
                              ,strUnifier: strUnifier
                              ,solveConstraintsFor: solveConstraintsFor
                              ,unify: unify
                              ,applyUnifier: applyUnifier
                              ,applyUnifierToConstraints: applyUnifierToConstraints
                              ,rewriteArrow: rewriteArrow
                              ,typecheck: typecheck
                              ,initTypeInfo: initTypeInfo
                              ,preludeTypeEnv: preludeTypeEnv
                              ,displayTypeInfo: displayTypeInfo
                              ,displayRawTypes: displayRawTypes
                              ,displayConstraints: displayConstraints
                              ,displayNamedExps: displayNamedExps
                              ,displayTypeErrors: displayTypeErrors
                              ,aceTypeInfo: aceTypeInfo
                              ,dummyAceTypeInfo: dummyAceTypeInfo
                              ,main: main};
};
Elm.Eval = Elm.Eval || {};
Elm.Eval.make = function (_elm) {
   "use strict";
   _elm.Eval = _elm.Eval || {};
   if (_elm.Eval.values) return _elm.Eval.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangParser2 = Elm.LangParser2.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Types = Elm.Types.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var btString = function (bt) {
      var _p0 = bt;
      if (_p0.ctor === "[]") {
            return "";
         } else {
            var singleLineExpStrs = A2($String.join,
            "\n",
            $List.reverse(A2($List.map,
            function (_p1) {
               return $Utils.head_($String.lines($String.trimLeft($LangUnparser.unparse(_p1))));
            },
            _p0._1)));
            return A2($Basics._op["++"],
            singleLineExpStrs,
            A2($Basics._op["++"],"\n",$LangUnparser.unparse(_p0._0)));
         }
   };
   var errorWithBacktrace = F2(function (bt,message) {
      return $Lang.errorMsg(A2($Basics._op["++"],
      btString(bt),
      A2($Basics._op["++"],"\n",message)));
   });
   var crashWithBacktrace = F2(function (bt,message) {
      return $Lang.crashWithMsg(A2($Basics._op["++"],
      btString(bt),
      A2($Basics._op["++"],"\n",message)));
   });
   var postProcessWidgets = function (widgets) {
      var dedupedWidgets = $Utils.dedup(widgets);
      var _p2 = A2($List.partition,
      function (widget) {
         var _p3 = widget;
         switch (_p3.ctor)
         {case "WIntSlider": return true;
            case "WNumSlider": return true;
            default: return false;}
      },
      dedupedWidgets);
      var rangeWidgets = _p2._0;
      var pointWidgets = _p2._1;
      return A2($Basics._op["++"],rangeWidgets,pointWidgets);
   };
   var valToDictKey = F2(function (bt,val_) {
      var _p4 = val_;
      _v2_5: do {
         switch (_p4.ctor)
         {case "VConst": if (_p4._0.ctor === "_Tuple2") {
                    return $Result.Ok({ctor: "_Tuple2"
                                      ,_0: $Basics.toString(_p4._0._0)
                                      ,_1: "num"});
                 } else {
                    break _v2_5;
                 }
            case "VBase": switch (_p4._0.ctor)
              {case "VBool": return $Result.Ok({ctor: "_Tuple2"
                                               ,_0: $Basics.toString(_p4._0._0)
                                               ,_1: "bool"});
                 case "VString": return $Result.Ok({ctor: "_Tuple2"
                                                   ,_0: $Basics.toString(_p4._0._0)
                                                   ,_1: "string"});
                 default: return $Result.Ok({ctor: "_Tuple2"
                                            ,_0: ""
                                            ,_1: "null"});}
            case "VList": return A2($Result.map,
              function (keyStrings) {
                 return {ctor: "_Tuple2"
                        ,_0: $Basics.toString(keyStrings)
                        ,_1: "list"};
              },
              $Utils.projOk(A2($List.map,
              function (_p5) {
                 return A2(valToDictKey,
                 bt,
                 function (_) {
                    return _.v_;
                 }(_p5));
              },
              _p4._0)));
            default: break _v2_5;}
      } while (false);
      return A2(errorWithBacktrace,
      bt,
      A2($Basics._op["++"],
      "Cannot use ",
      A2($Basics._op["++"],
      $Lang.strVal($Lang.val(val_)),
      " in a key to a dictionary.")));
   });
   var eBaseToVBase = function (eBaseVal) {
      var _p6 = eBaseVal;
      switch (_p6.ctor)
      {case "EBool": return $Lang.VBool(_p6._0);
         case "EString": return $Lang.VString(_p6._1);
         default: return $Lang.VNull;}
   };
   var evalDelta = F3(function (bt,op,is) {
      var _p7 = {ctor: "_Tuple2",_0: op,_1: is};
      _v4_16: do {
         if (_p7.ctor === "_Tuple2") {
               if (_p7._1.ctor === "::") {
                     if (_p7._1._1.ctor === "::") {
                           if (_p7._1._1._1.ctor === "[]") {
                                 switch (_p7._0.ctor)
                                 {case "Plus": return A2(F2(function (x,y) {    return x + y;}),
                                      _p7._1._0,
                                      _p7._1._1._0);
                                    case "Minus": return A2(F2(function (x,y) {    return x - y;}),
                                      _p7._1._0,
                                      _p7._1._1._0);
                                    case "Mult": return A2(F2(function (x,y) {    return x * y;}),
                                      _p7._1._0,
                                      _p7._1._1._0);
                                    case "Div": return A2(F2(function (x,y) {    return x / y;}),
                                      _p7._1._0,
                                      _p7._1._1._0);
                                    case "Pow": return A2(F2(function (x,y) {
                                         return Math.pow(x,y);
                                      }),
                                      _p7._1._0,
                                      _p7._1._1._0);
                                    case "Mod": return $Basics.toFloat(A2(F2(function (x,y) {
                                         return A2($Basics._op["%"],x,y);
                                      }),
                                      $Basics.floor(_p7._1._0),
                                      $Basics.floor(_p7._1._1._0)));
                                    case "ArcTan2": return A2($Basics.atan2,_p7._1._0,_p7._1._1._0);
                                    default: break _v4_16;}
                              } else {
                                 break _v4_16;
                              }
                        } else {
                           switch (_p7._0.ctor)
                           {case "Cos": return $Basics.cos(_p7._1._0);
                              case "Sin": return $Basics.sin(_p7._1._0);
                              case "ArcCos": return $Basics.acos(_p7._1._0);
                              case "ArcSin": return $Basics.asin(_p7._1._0);
                              case "Floor": return $Basics.toFloat($Basics.floor(_p7._1._0));
                              case "Ceil": return $Basics.toFloat($Basics.ceiling(_p7._1._0));
                              case "Round": return $Basics.toFloat($Basics.round(_p7._1._0));
                              case "Sqrt": return $Basics.sqrt(_p7._1._0);
                              default: break _v4_16;}
                        }
                  } else {
                     if (_p7._0.ctor === "Pi") {
                           return $Basics.pi;
                        } else {
                           break _v4_16;
                        }
                  }
            } else {
               break _v4_16;
            }
      } while (false);
      return A2(crashWithBacktrace,
      bt,
      A2($Basics._op["++"],
      "Little evaluator bug: Eval.evalDelta ",
      $Lang.strOp(op)));
   });
   var mkCap = F2(function (mcap,l) {
      var s = function () {
         var _p8 = {ctor: "_Tuple2",_0: mcap,_1: l};
         if (_p8._0.ctor === "Just") {
               return _p8._0._0.val;
            } else {
               if (_p8._1._2 === "") {
                     return $Lang.strLoc(l);
                  } else {
                     return _p8._1._2;
                  }
            }
      }();
      return A2($Basics._op["++"],s,": ");
   });
   var lookupVar = F4(function (env,bt,x,pos) {
      var _p9 = A2($Utils.maybeFind,x,env);
      if (_p9.ctor === "Just") {
            return $Result.Ok(_p9._0);
         } else {
            return A2(errorWithBacktrace,
            bt,
            A2($Basics._op["++"],
            $Lang.strPos(pos),
            A2($Basics._op["++"],
            " variable not found: ",
            A2($Basics._op["++"],
            x,
            A2($Basics._op["++"],
            "\nVariables in scope: ",
            A2($String.join," ",A2($List.map,$Basics.fst,env)))))));
         }
   });
   var typeCaseMatch = F4(function (env,bt,pat,tipe) {
      var _p10 = {ctor: "_Tuple2",_0: pat.val,_1: tipe.val};
      _v7_2: do {
         if (_p10.ctor === "_Tuple2") {
               switch (_p10._0.ctor)
               {case "PList":
                  if (_p10._0._3.ctor === "Nothing" && _p10._1.ctor === "TTuple")
                    {
                          var _p16 = _p10._1._1;
                          var _p15 = _p10._0._1;
                          var typeListsMatch = A2($Result.map,
                          function (bools) {
                             return A2($List.all,
                             F2(function (x,y) {    return _U.eq(x,y);})(true),
                             bools);
                          },
                          $Utils.projOk(A2($List.map,
                          function (_p11) {
                             var _p12 = _p11;
                             return A4(typeCaseMatch,env,bt,_p12._0,_p12._1);
                          },
                          A2($Utils.zip,_p15,_p16))));
                          var _p13 = typeListsMatch;
                          if (_p13.ctor === "Err") {
                                return $Result.Err(_p13._0);
                             } else {
                                if (_p13._0 === false) {
                                      return $Result.Ok(false);
                                   } else {
                                      var _p14 = _p10._1._3;
                                      if (_p14.ctor === "Nothing") {
                                            return $Result.Ok(_U.eq($List.length(_p15),
                                            $List.length(_p16)));
                                         } else {
                                            return _U.cmp($List.length(_p15),
                                            $List.length(_p16)) > -1 ? A2($Result.map,
                                            function (bools) {
                                               return A2($List.all,
                                               F2(function (x,y) {    return _U.eq(x,y);})(true),
                                               bools);
                                            },
                                            $Utils.projOk(A2($List.map,
                                            function (p) {
                                               return A4(typeCaseMatch,env,bt,p,_p14._0);
                                            },
                                            A2($List.drop,$List.length(_p16),_p15)))) : $Result.Ok(false);
                                         }
                                   }
                             }
                       } else {
                          break _v7_2;
                       }
                  case "PVar": return A2($Result.map,
                    function (val) {
                       return A2($Types.valIsType,val,tipe);
                    },
                    A4(lookupVar,env,bt,_p10._0._1,pat.start));
                  default: break _v7_2;}
            } else {
               break _v7_2;
            }
      } while (false);
      return A2(errorWithBacktrace,
      bt,
      A2($Basics._op["++"],
      "unexpected pattern in typecase: ",
      A2($Basics._op["++"],
      $LangUnparser.unparsePat(pat),
      "\n\nAllowed patterns are bare identifiers and [ident1 ident2 ...]")));
   });
   var match = function (_p17) {
      var _p18 = _p17;
      var _p27 = _p18._1;
      var _p26 = _p18._0;
      var _p19 = {ctor: "_Tuple2",_0: _p26.val,_1: _p27.v_};
      _v12_7: do {
         _v12_4: do {
            if (_p19.ctor === "_Tuple2") {
                  switch (_p19._0.ctor)
                  {case "PVar": return $Maybe.Just(_U.list([{ctor: "_Tuple2"
                                                            ,_0: _p19._0._1
                                                            ,_1: _p27}]));
                     case "PAs": var _p20 = match({ctor: "_Tuple2"
                                                  ,_0: _p19._0._3
                                                  ,_1: _p27});
                       if (_p20.ctor === "Just") {
                             return $Maybe.Just(A2($List._op["::"],
                             {ctor: "_Tuple2",_0: _p19._0._1,_1: _p27},
                             _p20._0));
                          } else {
                             return $Maybe.Nothing;
                          }
                     case "PList": if (_p19._0._3.ctor === "Nothing") {
                             if (_p19._1.ctor === "VList") {
                                   return A2($Utils.bindMaybe,
                                   matchList,
                                   A2($Utils.maybeZip,_p19._0._1,_p19._1._0));
                                } else {
                                   break _v12_4;
                                }
                          } else {
                             if (_p19._1.ctor === "VList") {
                                   var _p24 = _p19._1._0;
                                   var _p23 = _p19._0._1;
                                   var _p21 = {ctor: "_Tuple2"
                                              ,_0: $List.length(_p23)
                                              ,_1: $List.length(_p24)};
                                   var n = _p21._0;
                                   var m = _p21._1;
                                   if (_U.cmp(n,m) > 0) return $Maybe.Nothing; else {
                                         var _p22 = A2($Utils.split,n,_p24);
                                         var vs1 = _p22._0;
                                         var vs2 = _p22._1;
                                         return A2(cons,
                                         {ctor: "_Tuple2",_0: _p19._0._3._0,_1: $Lang.vList(vs2)},
                                         matchList(A2($Utils.zip,_p23,vs1)));
                                      }
                                } else {
                                   break _v12_4;
                                }
                          }
                     case "PConst":
                     if (_p19._1.ctor === "VConst" && _p19._1._0.ctor === "_Tuple2")
                       {
                             return _U.eq(_p19._0._1,
                             _p19._1._0._0) ? $Maybe.Just(_U.list([])) : $Maybe.Nothing;
                          } else {
                             break _v12_7;
                          }
                     default: if (_p19._1.ctor === "VBase") {
                             return _U.eq(eBaseToVBase(_p19._0._1),
                             _p19._1._0) ? $Maybe.Just(_U.list([])) : $Maybe.Nothing;
                          } else {
                             break _v12_7;
                          }}
               } else {
                  break _v12_7;
               }
         } while (false);
         return $Maybe.Nothing;
      } while (false);
      return _U.crashCase("Eval",
      {start: {line: 17,column: 15},end: {line: 35,column: 107}},
      _p19)(A2($Basics._op["++"],
      "Little evaluator bug: Eval.match ",
      A2($Basics._op["++"],
      $Basics.toString(_p26.val),
      A2($Basics._op["++"]," vs ",$Basics.toString(_p27.v_)))));
   };
   var cons = F2(function (pv,menv) {
      var _p28 = {ctor: "_Tuple2",_0: menv,_1: match(pv)};
      if (_p28.ctor === "_Tuple2" && _p28._0.ctor === "Just" && _p28._1.ctor === "Just")
      {
            return $Maybe.Just(A2($Basics._op["++"],
            _p28._1._0,
            _p28._0._0));
         } else {
            return $Maybe.Nothing;
         }
   });
   var matchList = function (pvs) {
      return A3($List.foldl,
      F2(function (pv,acc) {
         var _p29 = {ctor: "_Tuple2",_0: acc,_1: match(pv)};
         if (_p29.ctor === "_Tuple2" && _p29._0.ctor === "Just" && _p29._1.ctor === "Just")
         {
               return $Maybe.Just(A2($Basics._op["++"],
               _p29._1._0,
               _p29._0._0));
            } else {
               return $Maybe.Nothing;
            }
      }),
      $Maybe.Just(_U.list([])),
      pvs);
   };
   var evalBranches = F4(function (env,bt,v,bs) {
      return A3($List.foldl,
      F2(function (_p30,acc) {
         var _p31 = _p30;
         var _p32 = {ctor: "_Tuple2"
                    ,_0: acc
                    ,_1: A2(cons,
                    {ctor: "_Tuple2",_0: _p31._1,_1: v},
                    $Maybe.Just(env))};
         _v17_3: do {
            if (_p32.ctor === "_Tuple2") {
                  if (_p32._0.ctor === "Ok") {
                        if (_p32._0._0.ctor === "Just") {
                              return acc;
                           } else {
                              if (_p32._1.ctor === "Just") {
                                    return A2($Result.map,
                                    $Maybe.Just,
                                    A3(eval_,_p32._1._0,bt,_p31._2));
                                 } else {
                                    break _v17_3;
                                 }
                           }
                     } else {
                        return acc;
                     }
               } else {
                  break _v17_3;
               }
         } while (false);
         return $Result.Ok($Maybe.Nothing);
      }),
      $Result.Ok($Maybe.Nothing),
      A2($List.map,function (_) {    return _.val;},bs));
   });
   var eval_ = F3(function (env,bt,e) {
      return A2($Result.map,$Basics.fst,A3($eval,env,bt,e));
   });
   var $eval = F3(function (env,bt,e) {
      $eval: while (true) {
         var ret = function (v_) {
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: A2($Lang.Val,v_,_U.list([e.val.eid]))
                        ,_1: _U.list([])}
                   ,_1: env};
         };
         var retAdd = F2(function (eid,_p33) {
            var _p34 = _p33;
            var _p35 = _p34._0;
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: A2($Lang.Val,_p35.v_,A2($List._op["::"],eid,_p35.vtrace))
                        ,_1: _U.list([])}
                   ,_1: _p34._1};
         });
         var retAddWs = F2(function (eid,_p36) {
            var _p37 = _p36;
            var _p38 = _p37._0._0;
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: A2($Lang.Val,_p38.v_,A2($List._op["::"],eid,_p38.vtrace))
                        ,_1: _p37._0._1}
                   ,_1: _p37._1};
         });
         var retAddThis_ = function (_p39) {
            var _p40 = _p39;
            return A2(retAdd,
            e.val.eid,
            {ctor: "_Tuple2",_0: _p40._0,_1: _p40._1});
         };
         var retAddThis = function (v) {
            return retAddThis_({ctor: "_Tuple2",_0: v,_1: env});
         };
         var retBoth = function (_p41) {
            var _p42 = _p41;
            var _p43 = _p42._0;
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: _U.update(_p43,
                        {vtrace: A2($List._op["::"],e.val.eid,_p43.vtrace)})
                        ,_1: _p42._1}
                   ,_1: env};
         };
         var addWidgets = F2(function (ws1,_p44) {
            var _p45 = _p44;
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: _p45._0._0
                        ,_1: A2($Basics._op["++"],ws1,_p45._0._1)}
                   ,_1: _p45._1};
         });
         var bt$ = _U.cmp(e.start.line,1) > -1 ? A2($List._op["::"],
         e,
         bt) : bt;
         var _p46 = e.val.e__;
         switch (_p46.ctor)
         {case "EConst": var _p49 = _p46._2;
              var _p48 = _p46._1;
              var v_ = $Lang.VConst({ctor: "_Tuple2"
                                    ,_0: _p48
                                    ,_1: $Lang.TrLoc(_p49)});
              var _p47 = _p46._3.val;
              switch (_p47.ctor)
              {case "NoWidgetDecl": return $Result.Ok(ret(v_));
                 case "IntSlider": return $Result.Ok(retBoth({ctor: "_Tuple2"
                                                             ,_0: A2($Lang.Val,v_,_U.list([]))
                                                             ,_1: _U.list([A5($Lang.WIntSlider,
                                                             _p47._0.val,
                                                             _p47._2.val,
                                                             A2(mkCap,_p47._3,_p49),
                                                             $Basics.floor(_p48),
                                                             _p49)])}));
                 default: return $Result.Ok(retBoth({ctor: "_Tuple2"
                                                    ,_0: A2($Lang.Val,v_,_U.list([]))
                                                    ,_1: _U.list([A5($Lang.WNumSlider,
                                                    _p47._0.val,
                                                    _p47._2.val,
                                                    A2(mkCap,_p47._3,_p49),
                                                    _p48,
                                                    _p49)])}));}
            case "EBase":
            return $Result.Ok(ret($Lang.VBase(eBaseToVBase(_p46._1))));
            case "EVar": return A2($Result.map,
              retAddThis,
              A4(lookupVar,env,A2($List._op["::"],e,bt),_p46._1,e.start));
            case "EOp": return A2($Result.map,
              function (res) {
                 return A2(retAddWs,
                 e.val.eid,
                 {ctor: "_Tuple2",_0: res,_1: env});
              },
              A4(evalOp,env,A2($List._op["::"],e,bt),_p46._1,_p46._2));
            case "EList": var _p50 = $Utils.projOk(A2($List.map,
              A2(eval_,env,bt$),
              _p46._1));
              if (_p50.ctor === "Err") {
                    return $Result.Err(_p50._0);
                 } else {
                    var _p51 = $List.unzip(_p50._0);
                    var vs = _p51._0;
                    var wss = _p51._1;
                    var ws = $List.concat(wss);
                    var _p52 = _p46._3;
                    if (_p52.ctor === "Nothing") {
                          return $Result.Ok(retBoth({ctor: "_Tuple2"
                                                    ,_0: A2($Lang.Val,$Lang.VList(vs),_U.list([]))
                                                    ,_1: ws}));
                       } else {
                          var _p55 = _p52._0;
                          var _p53 = A3(eval_,env,bt$,_p55);
                          if (_p53.ctor === "Err") {
                                return $Result.Err(_p53._0);
                             } else {
                                var _p54 = _p53._0._0.v_;
                                if (_p54.ctor === "VList") {
                                      return $Result.Ok(retBoth({ctor: "_Tuple2"
                                                                ,_0: A2($Lang.Val,
                                                                $Lang.VList(A2($Basics._op["++"],vs,_p54._0)),
                                                                _U.list([]))
                                                                ,_1: A2($Basics._op["++"],ws,_p53._0._1)}));
                                   } else {
                                      return A2(errorWithBacktrace,
                                      A2($List._op["::"],e,bt),
                                      A2($Basics._op["++"],
                                      $Lang.strPos(_p55.start),
                                      " rest expression not a list."));
                                   }
                             }
                       }
                 }
            case "EIf": var _p59 = _p46._1;
              var _p56 = A3(eval_,env,bt,_p59);
              if (_p56.ctor === "Err") {
                    return $Result.Err(_p56._0);
                 } else {
                    var _p58 = _p56._0._1;
                    var _p57 = _p56._0._0.v_;
                    if (_p57.ctor === "VBase" && _p57._0.ctor === "VBool") {
                          if (_p57._0._0 === true) {
                                return A2($Result.map,
                                addWidgets(_p58),
                                A3($eval,env,bt,_p46._2));
                             } else {
                                return A2($Result.map,
                                addWidgets(_p58),
                                A3($eval,env,bt,_p46._3));
                             }
                       } else {
                          return A2(errorWithBacktrace,
                          A2($List._op["::"],e,bt),
                          A2($Basics._op["++"],
                          $Lang.strPos(_p59.start),
                          " if-exp expected a Bool but got something else."));
                       }
                 }
            case "ECase": var _p62 = _p46._1;
              var _p60 = A3(eval_,env,A2($List._op["::"],e,bt),_p62);
              if (_p60.ctor === "Err") {
                    return $Result.Err(_p60._0);
                 } else {
                    var _p61 = A4(evalBranches,
                    env,
                    A2($List._op["::"],e,bt),
                    _p60._0._0,
                    _p46._2);
                    if (_p61.ctor === "Ok") {
                          if (_p61._0.ctor === "Just" && _p61._0._0.ctor === "_Tuple2")
                          {
                                return $Result.Ok(retBoth({ctor: "_Tuple2"
                                                          ,_0: _p61._0._0._0
                                                          ,_1: A2($Basics._op["++"],_p60._0._1,_p61._0._0._1)}));
                             } else {
                                return A2(errorWithBacktrace,
                                A2($List._op["::"],e,bt),
                                A2($Basics._op["++"],
                                $Lang.strPos(_p62.start),
                                " non-exhaustive case statement"));
                             }
                       } else {
                          return $Result.Err(_p61._0);
                       }
                 }
            case "ETypeCase": var _p64 = _p46._1;
              var _p63 = A4(evalTBranches,
              env,
              A2($List._op["::"],e,bt),
              _p64,
              _p46._2);
              if (_p63.ctor === "Ok") {
                    if (_p63._0.ctor === "Just" && _p63._0._0.ctor === "_Tuple2")
                    {
                          return $Result.Ok(retBoth({ctor: "_Tuple2"
                                                    ,_0: _p63._0._0._0
                                                    ,_1: _p63._0._0._1}));
                       } else {
                          return A2(errorWithBacktrace,
                          A2($List._op["::"],e,bt),
                          A2($Basics._op["++"],
                          $Lang.strPos(_p64.start),
                          " non-exhaustive typecase statement"));
                       }
                 } else {
                    return $Result.Err(_p63._0);
                 }
            case "EColonType": var _p84 = _p46._1;
              var _p80 = _p46._3.val;
              if (_p80.ctor === "TNamed") {
                    if (!_U.eq($String.trim(_p80._1),"Point")) {
                          var _v35 = env,_v36 = bt,_v37 = _p84;
                          env = _v35;
                          bt = _v36;
                          e = _v37;
                          continue $eval;
                       } else return A2($Result.map,
                       function (result) {
                          var _p81 = result;
                          var v = _p81._0._0;
                          var ws = _p81._0._1;
                          var env$ = _p81._1;
                          var _p82 = v.v_;
                          if (_p82.ctor === "VList" && _p82._0.ctor === "::" && _p82._0._1.ctor === "::" && _p82._0._1._1.ctor === "[]")
                          {
                                var _p83 = {ctor: "_Tuple2"
                                           ,_0: _p82._0._0.v_
                                           ,_1: _p82._0._1._0.v_};
                                if (_p83.ctor === "_Tuple2" && _p83._0.ctor === "VConst" && _p83._1.ctor === "VConst")
                                {
                                      return {ctor: "_Tuple2"
                                             ,_0: {ctor: "_Tuple2"
                                                  ,_0: v
                                                  ,_1: A2($Basics._op["++"],
                                                  ws,
                                                  _U.list([A2($Lang.WPointSlider,_p83._0._0,_p83._1._0)]))}
                                             ,_1: env$};
                                   } else {
                                      return result;
                                   }
                             } else {
                                return result;
                             }
                       },
                       A3($eval,env,bt,_p84));
                 } else {
                    var _v40 = env,_v41 = bt,_v42 = _p84;
                    env = _v40;
                    bt = _v41;
                    e = _v42;
                    continue $eval;
                 }
            case "EComment": var _v43 = env,_v44 = bt,_v45 = _p46._2;
              env = _v43;
              bt = _v44;
              e = _v45;
              continue $eval;
            case "EOption": var _v46 = env,_v47 = bt,_v48 = _p46._4;
              env = _v46;
              bt = _v47;
              e = _v48;
              continue $eval;
            case "ETyp": var _v49 = env,_v50 = bt,_v51 = _p46._3;
              env = _v49;
              bt = _v50;
              e = _v51;
              continue $eval;
            case "ETypeAlias": var _v52 = env,_v53 = bt,_v54 = _p46._3;
              env = _v52;
              bt = _v53;
              e = _v54;
              continue $eval;
            case "EFun":
            if (_p46._1.ctor === "::" && _p46._1._1.ctor === "[]") {
                    return $Result.Ok(ret(A4($Lang.VClosure,
                    $Maybe.Nothing,
                    _p46._1._0,
                    _p46._2,
                    env)));
                 } else {
                    var _p85 = _p46._2;
                    return A2($Result.map,
                    retAddWs(_p85.val.eid),
                    A3($eval,env,bt$,A2($Lang.eFun,_p46._1,_p85)));
                 }
            case "EApp": if (_p46._2.ctor === "::") {
                    if (_p46._2._1.ctor === "[]") {
                          var _p72 = _p46._1;
                          var _p65 = A3(eval_,env,bt$,_p72);
                          if (_p65.ctor === "Err") {
                                return $Result.Err(_p65._0);
                             } else {
                                var _p71 = _p65._0._0;
                                var _p66 = A3(eval_,env,bt$,_p46._2._0);
                                if (_p66.ctor === "Err") {
                                      return $Result.Err(_p66._0);
                                   } else {
                                      var _p70 = _p66._0._0;
                                      var ws = A2($Basics._op["++"],_p65._0._1,_p66._0._1);
                                      var _p67 = _p71.v_;
                                      if (_p67.ctor === "VClosure") {
                                            if (_p67._0.ctor === "Nothing") {
                                                  var _p68 = A2(cons,
                                                  {ctor: "_Tuple2",_0: _p67._1,_1: _p70},
                                                  $Maybe.Just(_p67._3));
                                                  if (_p68.ctor === "Just") {
                                                        return A2($Result.map,
                                                        addWidgets(ws),
                                                        A3($eval,_p68._0,bt$,_p67._2));
                                                     } else {
                                                        return A2(errorWithBacktrace,
                                                        A2($List._op["::"],e,bt),
                                                        A2($Basics._op["++"],
                                                        $Lang.strPos(_p72.start),
                                                        "bad environment"));
                                                     }
                                               } else {
                                                  var _p69 = A2(cons,
                                                  {ctor: "_Tuple2",_0: $Lang.pVar(_p67._0._0),_1: _p71},
                                                  A2(cons,
                                                  {ctor: "_Tuple2",_0: _p67._1,_1: _p70},
                                                  $Maybe.Just(_p67._3)));
                                                  if (_p69.ctor === "Just") {
                                                        return A2($Result.map,
                                                        addWidgets(ws),
                                                        A3($eval,_p69._0,bt$,_p67._2));
                                                     } else {
                                                        return A2(errorWithBacktrace,
                                                        A2($List._op["::"],e,bt),
                                                        A2($Basics._op["++"],
                                                        $Lang.strPos(_p72.start),
                                                        "bad environment"));
                                                     }
                                               }
                                         } else {
                                            return A2(errorWithBacktrace,
                                            A2($List._op["::"],e,bt),
                                            A2($Basics._op["++"],
                                            $Lang.strPos(_p72.start),
                                            " not a function"));
                                         }
                                   }
                             }
                       } else {
                          return A2($Result.map,
                          retAddWs(e.val.eid),
                          A3($eval,env,bt$,A2($Lang.eApp,_p46._1,_p46._2)));
                       }
                 } else {
                    return A2(errorWithBacktrace,
                    A2($List._op["::"],e,bt),
                    A2($Basics._op["++"],
                    $Lang.strPos(_p46._1.start),
                    " application with no arguments"));
                 }
            default: if (_p46._2 === true) {
                    var _p79 = _p46._4;
                    var _p73 = A3(eval_,env,bt$,_p79);
                    if (_p73.ctor === "Err") {
                          return $Result.Err(_p73._0);
                       } else {
                          var _p78 = _p73._0._0;
                          var _p74 = {ctor: "_Tuple2",_0: _p46._3.val,_1: _p78.v_};
                          _v61_2: do {
                             if (_p74.ctor === "_Tuple2") {
                                   switch (_p74._0.ctor)
                                   {case "PVar":
                                      if (_p74._1.ctor === "VClosure" && _p74._1._0.ctor === "Nothing")
                                        {
                                              var _p77 = _p74._0._1;
                                              var _p75 = A2($Utils.assert,
                                              "eval letrec",
                                              _U.eq(env,_p74._1._3));
                                              var v1$ = A2($Lang.Val,
                                              A4($Lang.VClosure,$Maybe.Just(_p77),_p74._1._1,_p74._1._2,env),
                                              _p78.vtrace);
                                              var _p76 = A2(cons,
                                              {ctor: "_Tuple2",_0: $Lang.pVar(_p77),_1: v1$},
                                              $Maybe.Just(env));
                                              if (_p76.ctor === "Just") {
                                                    return A2($Result.map,
                                                    addWidgets(_p73._0._1),
                                                    A3($eval,_p76._0,bt$,_p46._5));
                                                 } else {
                                                    return A2(errorWithBacktrace,
                                                    A2($List._op["::"],e,bt),
                                                    A2($Basics._op["++"],$Lang.strPos(e.start),"bad ELet"));
                                                 }
                                           } else {
                                              break _v61_2;
                                           }
                                      case "PList": return A2(errorWithBacktrace,
                                        A2($List._op["::"],e,bt),
                                        A2($Basics._op["++"],
                                        $Lang.strPos(_p79.start),
                                        "mutually recursive functions (i.e. letrec [...] [...] e) \\n               not yet implemented"));
                                      default: break _v61_2;}
                                } else {
                                   break _v61_2;
                                }
                          } while (false);
                          return A2(errorWithBacktrace,
                          A2($List._op["::"],e,bt),
                          A2($Basics._op["++"],$Lang.strPos(e.start),"bad ELet"));
                       }
                 } else {
                    var _p86 = _p46._5;
                    return A2($Result.map,
                    retAddWs(_p86.val.eid),
                    A3($eval,
                    env,
                    bt$,
                    A2($Lang.eApp,
                    A2($Lang.eFun,_U.list([_p46._3]),_p86),
                    _U.list([_p46._4]))));
                 }}
      }
   });
   var evalOp = F4(function (env,bt,opWithInfo,es) {
      var _p87 = {ctor: "_Tuple2"
                 ,_0: opWithInfo.val
                 ,_1: opWithInfo.start};
      var op = _p87._0;
      var opStart = _p87._1;
      var argsEvaledRes = $Utils.projOk(A2($List.map,
      A2(eval_,env,bt),
      es));
      var _p88 = argsEvaledRes;
      if (_p88.ctor === "Err") {
            return $Result.Err(_p88._0);
         } else {
            var _p89 = $List.unzip(_p88._0);
            var vs = _p89._0;
            var wss = _p89._1;
            var error = function (_p90) {
               var _p91 = _p90;
               return A2(errorWithBacktrace,
               bt,
               A2($Basics._op["++"],
               "Bad arguments to ",
               A2($Basics._op["++"],
               $Lang.strOp(op),
               A2($Basics._op["++"],
               " operator ",
               A2($Basics._op["++"],
               $Lang.strPos(opStart),
               A2($Basics._op["++"],
               ":\n",
               $Utils.lines(A2($List.map,
               function (_p92) {
                  var _p93 = _p92;
                  return A2($Basics._op["++"],
                  $Lang.strVal(_p93._0),
                  A2($Basics._op["++"]," from ",$LangUnparser.unparse(_p93._1)));
               },
               A2($Utils.zip,vs,es)))))))));
            };
            var emptyVTrace = function (val_) {
               return A2($Lang.Val,val_,_U.list([]));
            };
            var emptyVTraceOk = function (val_) {
               return $Result.Ok(emptyVTrace(val_));
            };
            var nullaryOp = F2(function (args,retVal) {
               var _p94 = args;
               if (_p94.ctor === "[]") {
                     return emptyVTraceOk(retVal);
                  } else {
                     return error({ctor: "_Tuple0"});
                  }
            });
            var unaryMathOp = F2(function (op,args) {
               var _p95 = args;
               if (_p95.ctor === "::" && _p95._0.ctor === "VConst" && _p95._0._0.ctor === "_Tuple2" && _p95._1.ctor === "[]")
               {
                     return emptyVTraceOk($Lang.VConst({ctor: "_Tuple2"
                                                       ,_0: A3(evalDelta,bt,op,_U.list([_p95._0._0._0]))
                                                       ,_1: A2($Lang.TrOp,op,_U.list([_p95._0._0._1]))}));
                  } else {
                     return error({ctor: "_Tuple0"});
                  }
            });
            var binMathOp = F2(function (op,args) {
               var _p96 = args;
               if (_p96.ctor === "::" && _p96._0.ctor === "VConst" && _p96._0._0.ctor === "_Tuple2" && _p96._1.ctor === "::" && _p96._1._0.ctor === "VConst" && _p96._1._0._0.ctor === "_Tuple2" && _p96._1._1.ctor === "[]")
               {
                     return emptyVTraceOk($Lang.VConst({ctor: "_Tuple2"
                                                       ,_0: A3(evalDelta,
                                                       bt,
                                                       op,
                                                       _U.list([_p96._0._0._0,_p96._1._0._0._0]))
                                                       ,_1: A2($Lang.TrOp,
                                                       op,
                                                       _U.list([_p96._0._0._1,_p96._1._0._0._1]))}));
                  } else {
                     return error({ctor: "_Tuple0"});
                  }
            });
            var args = A2($List.map,function (_) {    return _.v_;},vs);
            var newValRes = function () {
               var _p97 = op;
               switch (_p97.ctor)
               {case "Plus": var _p98 = args;
                    if (_p98.ctor === "::" && _p98._0.ctor === "VBase" && _p98._0._0.ctor === "VString" && _p98._1.ctor === "::" && _p98._1._0.ctor === "VBase" && _p98._1._0._0.ctor === "VString" && _p98._1._1.ctor === "[]")
                    {
                          return emptyVTraceOk($Lang.VBase($Lang.VString(A2($Basics._op["++"],
                          _p98._0._0._0,
                          _p98._1._0._0._0))));
                       } else {
                          return A2(binMathOp,op,args);
                       }
                  case "Minus": return A2(binMathOp,op,args);
                  case "Mult": return A2(binMathOp,op,args);
                  case "Div": return A2(binMathOp,op,args);
                  case "Mod": return A2(binMathOp,op,args);
                  case "Pow": return A2(binMathOp,op,args);
                  case "ArcTan2": return A2(binMathOp,op,args);
                  case "Lt": var _p99 = args;
                    if (_p99.ctor === "::" && _p99._0.ctor === "VConst" && _p99._0._0.ctor === "_Tuple2" && _p99._1.ctor === "::" && _p99._1._0.ctor === "VConst" && _p99._1._0._0.ctor === "_Tuple2" && _p99._1._1.ctor === "[]")
                    {
                          return emptyVTraceOk($Lang.VBase($Lang.VBool(_U.cmp(_p99._0._0._0,
                          _p99._1._0._0._0) < 0)));
                       } else {
                          return error({ctor: "_Tuple0"});
                       }
                  case "Eq": var _p100 = args;
                    _v72_2: do {
                       if (_p100.ctor === "::" && _p100._1.ctor === "::" && _p100._1._1.ctor === "[]")
                       {
                             switch (_p100._0.ctor)
                             {case "VConst":
                                if (_p100._0._0.ctor === "_Tuple2" && _p100._1._0.ctor === "VConst" && _p100._1._0._0.ctor === "_Tuple2")
                                  {
                                        return emptyVTraceOk($Lang.VBase($Lang.VBool(_U.eq(_p100._0._0._0,
                                        _p100._1._0._0._0))));
                                     } else {
                                        break _v72_2;
                                     }
                                case "VBase":
                                if (_p100._0._0.ctor === "VString" && _p100._1._0.ctor === "VBase" && _p100._1._0._0.ctor === "VString")
                                  {
                                        return emptyVTraceOk($Lang.VBase($Lang.VBool(_U.eq(_p100._0._0._0,
                                        _p100._1._0._0._0))));
                                     } else {
                                        break _v72_2;
                                     }
                                default: break _v72_2;}
                          } else {
                             return error({ctor: "_Tuple0"});
                          }
                    } while (false);
                    return emptyVTraceOk($Lang.VBase($Lang.VBool(false)));
                  case "Pi": return A2(nullaryOp,
                    args,
                    $Lang.VConst({ctor: "_Tuple2"
                                 ,_0: $Basics.pi
                                 ,_1: A2($Lang.TrOp,op,_U.list([]))}));
                  case "DictEmpty": return A2(nullaryOp,
                    args,
                    $Lang.VDict($Dict.empty));
                  case "DictInsert": var _p101 = vs;
                    if (_p101.ctor === "::" && _p101._1.ctor === "::" && _p101._1._1.ctor === "::" && _p101._1._1._1.ctor === "[]")
                    {
                          var _p102 = _p101._1._1._0.v_;
                          if (_p102.ctor === "VDict") {
                                return A2($Result.map,
                                function (dkey) {
                                   return emptyVTrace($Lang.VDict(A3($Dict.insert,
                                   dkey,
                                   _p101._1._0,
                                   _p102._0)));
                                },
                                A2(valToDictKey,bt,_p101._0.v_));
                             } else {
                                return error({ctor: "_Tuple0"});
                             }
                       } else {
                          return error({ctor: "_Tuple0"});
                       }
                  case "DictGet": var _p103 = args;
                    if (_p103.ctor === "::" && _p103._1.ctor === "::" && _p103._1._0.ctor === "VDict" && _p103._1._1.ctor === "[]")
                    {
                          return A2($Result.map,
                          function (dkey) {
                             return A3($Utils.getWithDefault,
                             dkey,
                             emptyVTrace($Lang.VBase($Lang.VNull)),
                             _p103._1._0._0);
                          },
                          A2(valToDictKey,bt,_p103._0));
                       } else {
                          return error({ctor: "_Tuple0"});
                       }
                  case "DictRemove": var _p104 = args;
                    if (_p104.ctor === "::" && _p104._1.ctor === "::" && _p104._1._0.ctor === "VDict" && _p104._1._1.ctor === "[]")
                    {
                          return A2($Result.map,
                          function (dkey) {
                             return emptyVTrace($Lang.VDict(A2($Dict.remove,
                             dkey,
                             _p104._1._0._0)));
                          },
                          A2(valToDictKey,bt,_p104._0));
                       } else {
                          return error({ctor: "_Tuple0"});
                       }
                  case "Cos": return A2(unaryMathOp,op,args);
                  case "Sin": return A2(unaryMathOp,op,args);
                  case "ArcCos": return A2(unaryMathOp,op,args);
                  case "ArcSin": return A2(unaryMathOp,op,args);
                  case "Floor": return A2(unaryMathOp,op,args);
                  case "Ceil": return A2(unaryMathOp,op,args);
                  case "Round": return A2(unaryMathOp,op,args);
                  case "Sqrt": return A2(unaryMathOp,op,args);
                  case "Explode": var _p105 = args;
                    if (_p105.ctor === "::" && _p105._0.ctor === "VBase" && _p105._0._0.ctor === "VString" && _p105._1.ctor === "[]")
                    {
                          return emptyVTraceOk($Lang.VList(A2($List.map,
                          function (_p106) {
                             return $Lang.vStr($String.fromChar(_p106));
                          },
                          $String.toList(_p105._0._0._0))));
                       } else {
                          return error({ctor: "_Tuple0"});
                       }
                  case "DebugLog": var _p107 = vs;
                    if (_p107.ctor === "::" && _p107._1.ctor === "[]") {
                          var _p109 = _p107._0;
                          var _p108 = A2($Debug.log,$Lang.strVal(_p109),"");
                          return $Result.Ok(_p109);
                       } else {
                          return error({ctor: "_Tuple0"});
                       }
                  default: var _p110 = vs;
                    if (_p110.ctor === "::" && _p110._1.ctor === "[]") {
                          return emptyVTraceOk($Lang.VBase($Lang.VString($Lang.strVal(_p110._0))));
                       } else {
                          return error({ctor: "_Tuple0"});
                       }}
            }();
            return A2($Result.map,
            function (newVal) {
               return {ctor: "_Tuple2",_0: newVal,_1: $List.concat(wss)};
            },
            newValRes);
         }
   });
   var evalTBranches = F4(function (env,bt,pat,tbranches) {
      return A3($List.foldl,
      F2(function (_p111,acc) {
         var _p112 = _p111;
         var _p113 = {ctor: "_Tuple2"
                     ,_0: acc
                     ,_1: A4(typeCaseMatch,env,bt,pat,_p112._1)};
         if (_p113._0.ctor === "Ok") {
               if (_p113._0._0.ctor === "Just") {
                     return acc;
                  } else {
                     if (_p113._1.ctor === "Ok") {
                           return _p113._1._0 ? A2($Result.map,
                           $Maybe.Just,
                           A3(eval_,env,bt,_p112._2)) : acc;
                        } else {
                           return $Result.Err(_p113._1._0);
                        }
                  }
            } else {
               return acc;
            }
      }),
      $Result.Ok($Maybe.Nothing),
      A2($List.map,function (_) {    return _.val;},tbranches));
   });
   var initEnvRes = A2($Result.map,
   $Basics.snd,
   A3($eval,_U.list([]),_U.list([]),$LangParser2.prelude));
   var initEnv = A2($Utils.fromOk,"Eval.initEnv",initEnvRes);
   var run = function (e) {
      return A2($Result.map,
      $Utils.mapSnd(postProcessWidgets),
      A3(eval_,initEnv,_U.list([]),e));
   };
   var parseAndRun = function (_p114) {
      return $Lang.strVal($Basics.fst($Utils.fromOk_(run(A2($Utils.fromOkay,
      "parseAndRun",
      $LangParser2.parseE(_p114))))));
   };
   var parseAndRun_ = function (_p115) {
      return A2($Lang.strVal_,
      true,
      $Basics.fst($Utils.fromOk_(run(A2($Utils.fromOkay,
      "parseAndRun_",
      $LangParser2.parseE(_p115))))));
   };
   return _elm.Eval.values = {_op: _op
                             ,run: run
                             ,parseAndRun: parseAndRun
                             ,parseAndRun_: parseAndRun_
                             ,evalDelta: evalDelta
                             ,$eval: $eval};
};
Elm.ColorNum = Elm.ColorNum || {};
Elm.ColorNum.make = function (_elm) {
   "use strict";
   _elm.ColorNum = _elm.ColorNum || {};
   if (_elm.ColorNum.values) return _elm.ColorNum.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var codes = _U.list([{ctor: "_Tuple3",_0: 200,_1: 55,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 57,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 60,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 62,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 65,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 67,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 70,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 72,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 74,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 77,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 79,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 82,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 84,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 86,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 89,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 91,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 94,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 96,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 99,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 101,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 103,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 106,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 108,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 111,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 113,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 115,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 118,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 120,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 123,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 125,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 128,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 130,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 132,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 135,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 137,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 140,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 142,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 144,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 147,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 149,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 152,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 154,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 157,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 159,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 161,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 164,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 166,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 169,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 171,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 173,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 176,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 178,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 181,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 183,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 186,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 188,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 190,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 193,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 195,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 198,_2: 55}
                       ,{ctor: "_Tuple3",_0: 200,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 198,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 195,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 193,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 190,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 188,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 186,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 183,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 181,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 178,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 176,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 173,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 171,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 169,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 166,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 164,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 161,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 159,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 157,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 154,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 152,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 149,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 147,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 144,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 142,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 140,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 137,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 135,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 132,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 130,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 128,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 125,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 123,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 120,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 118,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 115,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 113,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 111,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 108,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 106,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 103,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 101,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 99,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 96,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 94,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 91,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 89,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 86,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 84,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 82,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 79,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 77,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 74,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 72,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 70,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 67,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 65,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 62,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 60,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 57,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 55}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 57}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 60}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 62}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 65}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 67}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 70}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 72}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 74}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 77}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 79}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 82}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 84}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 86}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 89}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 91}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 94}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 96}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 99}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 101}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 103}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 106}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 108}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 111}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 113}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 115}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 118}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 120}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 123}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 125}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 128}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 130}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 132}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 135}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 137}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 140}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 142}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 144}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 147}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 149}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 152}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 154}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 157}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 159}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 161}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 164}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 166}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 169}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 171}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 173}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 176}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 178}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 181}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 183}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 186}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 188}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 190}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 193}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 195}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 198}
                       ,{ctor: "_Tuple3",_0: 55,_1: 200,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 198,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 195,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 193,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 190,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 188,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 186,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 183,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 181,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 178,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 176,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 173,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 171,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 169,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 166,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 164,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 161,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 159,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 157,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 154,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 152,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 149,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 147,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 144,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 142,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 140,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 137,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 135,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 132,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 130,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 128,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 125,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 123,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 120,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 118,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 115,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 113,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 111,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 108,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 106,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 103,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 101,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 99,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 96,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 94,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 91,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 89,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 86,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 84,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 82,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 79,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 77,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 74,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 72,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 70,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 67,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 65,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 62,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 60,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 57,_2: 200}
                       ,{ctor: "_Tuple3",_0: 55,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 57,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 60,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 62,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 65,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 67,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 70,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 72,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 74,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 77,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 79,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 82,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 84,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 86,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 89,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 91,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 94,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 96,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 99,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 101,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 103,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 106,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 108,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 111,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 113,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 115,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 118,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 120,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 123,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 125,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 128,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 130,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 132,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 135,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 137,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 140,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 142,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 144,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 147,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 149,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 152,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 154,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 157,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 159,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 161,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 164,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 166,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 169,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 171,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 173,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 176,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 178,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 181,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 183,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 186,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 188,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 190,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 193,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 195,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 198,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 200}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 198}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 195}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 193}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 190}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 188}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 186}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 183}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 181}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 178}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 176}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 173}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 171}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 169}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 166}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 164}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 161}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 159}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 157}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 154}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 152}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 149}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 147}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 144}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 142}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 140}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 137}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 135}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 132}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 130}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 128}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 125}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 123}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 120}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 118}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 115}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 113}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 111}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 108}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 106}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 103}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 101}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 99}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 96}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 94}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 91}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 89}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 86}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 84}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 82}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 79}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 77}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 74}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 72}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 70}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 67}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 65}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 62}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 60}
                       ,{ctor: "_Tuple3",_0: 200,_1: 55,_2: 57}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 0,_1: 0,_2: 0}
                       ,{ctor: "_Tuple3",_0: 3,_1: 3,_2: 3}
                       ,{ctor: "_Tuple3",_0: 5,_1: 5,_2: 5}
                       ,{ctor: "_Tuple3",_0: 8,_1: 8,_2: 8}
                       ,{ctor: "_Tuple3",_0: 10,_1: 10,_2: 10}
                       ,{ctor: "_Tuple3",_0: 13,_1: 13,_2: 13}
                       ,{ctor: "_Tuple3",_0: 15,_1: 15,_2: 15}
                       ,{ctor: "_Tuple3",_0: 18,_1: 18,_2: 18}
                       ,{ctor: "_Tuple3",_0: 20,_1: 20,_2: 20}
                       ,{ctor: "_Tuple3",_0: 23,_1: 23,_2: 23}
                       ,{ctor: "_Tuple3",_0: 26,_1: 26,_2: 26}
                       ,{ctor: "_Tuple3",_0: 28,_1: 28,_2: 28}
                       ,{ctor: "_Tuple3",_0: 31,_1: 31,_2: 31}
                       ,{ctor: "_Tuple3",_0: 33,_1: 33,_2: 33}
                       ,{ctor: "_Tuple3",_0: 36,_1: 36,_2: 36}
                       ,{ctor: "_Tuple3",_0: 38,_1: 38,_2: 38}
                       ,{ctor: "_Tuple3",_0: 41,_1: 41,_2: 41}
                       ,{ctor: "_Tuple3",_0: 43,_1: 43,_2: 43}
                       ,{ctor: "_Tuple3",_0: 46,_1: 46,_2: 46}
                       ,{ctor: "_Tuple3",_0: 48,_1: 48,_2: 48}
                       ,{ctor: "_Tuple3",_0: 51,_1: 51,_2: 51}
                       ,{ctor: "_Tuple3",_0: 54,_1: 54,_2: 54}
                       ,{ctor: "_Tuple3",_0: 56,_1: 56,_2: 56}
                       ,{ctor: "_Tuple3",_0: 59,_1: 59,_2: 59}
                       ,{ctor: "_Tuple3",_0: 61,_1: 61,_2: 61}
                       ,{ctor: "_Tuple3",_0: 64,_1: 64,_2: 64}
                       ,{ctor: "_Tuple3",_0: 66,_1: 66,_2: 66}
                       ,{ctor: "_Tuple3",_0: 69,_1: 69,_2: 69}
                       ,{ctor: "_Tuple3",_0: 71,_1: 71,_2: 71}
                       ,{ctor: "_Tuple3",_0: 74,_1: 74,_2: 74}
                       ,{ctor: "_Tuple3",_0: 77,_1: 77,_2: 77}
                       ,{ctor: "_Tuple3",_0: 79,_1: 79,_2: 79}
                       ,{ctor: "_Tuple3",_0: 82,_1: 82,_2: 82}
                       ,{ctor: "_Tuple3",_0: 84,_1: 84,_2: 84}
                       ,{ctor: "_Tuple3",_0: 87,_1: 87,_2: 87}
                       ,{ctor: "_Tuple3",_0: 89,_1: 89,_2: 89}
                       ,{ctor: "_Tuple3",_0: 92,_1: 92,_2: 92}
                       ,{ctor: "_Tuple3",_0: 94,_1: 94,_2: 94}
                       ,{ctor: "_Tuple3",_0: 97,_1: 97,_2: 97}
                       ,{ctor: "_Tuple3",_0: 99,_1: 99,_2: 99}
                       ,{ctor: "_Tuple3",_0: 102,_1: 102,_2: 102}
                       ,{ctor: "_Tuple3",_0: 105,_1: 105,_2: 105}
                       ,{ctor: "_Tuple3",_0: 107,_1: 107,_2: 107}
                       ,{ctor: "_Tuple3",_0: 110,_1: 110,_2: 110}
                       ,{ctor: "_Tuple3",_0: 112,_1: 112,_2: 112}
                       ,{ctor: "_Tuple3",_0: 115,_1: 115,_2: 115}
                       ,{ctor: "_Tuple3",_0: 117,_1: 117,_2: 117}
                       ,{ctor: "_Tuple3",_0: 120,_1: 120,_2: 120}
                       ,{ctor: "_Tuple3",_0: 122,_1: 122,_2: 122}
                       ,{ctor: "_Tuple3",_0: 125,_1: 125,_2: 125}
                       ,{ctor: "_Tuple3",_0: 128,_1: 128,_2: 128}
                       ,{ctor: "_Tuple3",_0: 130,_1: 130,_2: 130}
                       ,{ctor: "_Tuple3",_0: 133,_1: 133,_2: 133}
                       ,{ctor: "_Tuple3",_0: 135,_1: 135,_2: 135}
                       ,{ctor: "_Tuple3",_0: 138,_1: 138,_2: 138}
                       ,{ctor: "_Tuple3",_0: 140,_1: 140,_2: 140}
                       ,{ctor: "_Tuple3",_0: 143,_1: 143,_2: 143}
                       ,{ctor: "_Tuple3",_0: 145,_1: 145,_2: 145}
                       ,{ctor: "_Tuple3",_0: 148,_1: 148,_2: 148}
                       ,{ctor: "_Tuple3",_0: 150,_1: 150,_2: 150}
                       ,{ctor: "_Tuple3",_0: 153,_1: 153,_2: 153}
                       ,{ctor: "_Tuple3",_0: 156,_1: 156,_2: 156}
                       ,{ctor: "_Tuple3",_0: 158,_1: 158,_2: 158}
                       ,{ctor: "_Tuple3",_0: 161,_1: 161,_2: 161}
                       ,{ctor: "_Tuple3",_0: 163,_1: 163,_2: 163}
                       ,{ctor: "_Tuple3",_0: 166,_1: 166,_2: 166}
                       ,{ctor: "_Tuple3",_0: 168,_1: 168,_2: 168}
                       ,{ctor: "_Tuple3",_0: 171,_1: 171,_2: 171}
                       ,{ctor: "_Tuple3",_0: 173,_1: 173,_2: 173}
                       ,{ctor: "_Tuple3",_0: 176,_1: 176,_2: 176}
                       ,{ctor: "_Tuple3",_0: 179,_1: 179,_2: 179}
                       ,{ctor: "_Tuple3",_0: 181,_1: 181,_2: 181}
                       ,{ctor: "_Tuple3",_0: 184,_1: 184,_2: 184}
                       ,{ctor: "_Tuple3",_0: 186,_1: 186,_2: 186}
                       ,{ctor: "_Tuple3",_0: 189,_1: 189,_2: 189}
                       ,{ctor: "_Tuple3",_0: 191,_1: 191,_2: 191}
                       ,{ctor: "_Tuple3",_0: 194,_1: 194,_2: 194}
                       ,{ctor: "_Tuple3",_0: 196,_1: 196,_2: 196}
                       ,{ctor: "_Tuple3",_0: 199,_1: 199,_2: 199}
                       ,{ctor: "_Tuple3",_0: 201,_1: 201,_2: 201}
                       ,{ctor: "_Tuple3",_0: 204,_1: 204,_2: 204}
                       ,{ctor: "_Tuple3",_0: 207,_1: 207,_2: 207}
                       ,{ctor: "_Tuple3",_0: 209,_1: 209,_2: 209}
                       ,{ctor: "_Tuple3",_0: 212,_1: 212,_2: 212}
                       ,{ctor: "_Tuple3",_0: 214,_1: 214,_2: 214}
                       ,{ctor: "_Tuple3",_0: 217,_1: 217,_2: 217}
                       ,{ctor: "_Tuple3",_0: 219,_1: 219,_2: 219}
                       ,{ctor: "_Tuple3",_0: 222,_1: 222,_2: 222}
                       ,{ctor: "_Tuple3",_0: 224,_1: 224,_2: 224}
                       ,{ctor: "_Tuple3",_0: 227,_1: 227,_2: 227}
                       ,{ctor: "_Tuple3",_0: 230,_1: 230,_2: 230}
                       ,{ctor: "_Tuple3",_0: 232,_1: 232,_2: 232}
                       ,{ctor: "_Tuple3",_0: 235,_1: 235,_2: 235}
                       ,{ctor: "_Tuple3",_0: 237,_1: 237,_2: 237}
                       ,{ctor: "_Tuple3",_0: 240,_1: 240,_2: 240}
                       ,{ctor: "_Tuple3",_0: 242,_1: 242,_2: 242}
                       ,{ctor: "_Tuple3",_0: 245,_1: 245,_2: 245}
                       ,{ctor: "_Tuple3",_0: 247,_1: 247,_2: 247}
                       ,{ctor: "_Tuple3",_0: 250,_1: 250,_2: 250}
                       ,{ctor: "_Tuple3",_0: 252,_1: 252,_2: 252}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}
                       ,{ctor: "_Tuple3",_0: 255,_1: 255,_2: 255}]);
   var dict = function () {
      var f = F2(function (_p0,acc) {
         var _p1 = _p0;
         return A3($Dict.insert,
         _p1._0 - 1,
         _U.list([_p1._1._0,_p1._1._1,_p1._1._2,1.0]),
         acc);
      });
      return A3($Utils.foldli,f,$Dict.empty,codes);
   }();
   var convert = function (i) {
      var _p2 = A2($Dict.get,$Basics.floor(i),dict);
      if (_p2.ctor === "Nothing") {
            return _U.list([0,0,0,1]);
         } else {
            return _p2._0;
         }
   };
   return _elm.ColorNum.values = {_op: _op,convert: convert};
};
Elm.Either = Elm.Either || {};
Elm.Either.make = function (_elm) {
   "use strict";
   _elm.Either = _elm.Either || {};
   if (_elm.Either.values) return _elm.Either.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var Right = function (a) {    return {ctor: "Right",_0: a};};
   var Left = function (a) {    return {ctor: "Left",_0: a};};
   return _elm.Either.values = {_op: _op,Left: Left,Right: Right};
};
Elm.LangSvg = Elm.LangSvg || {};
Elm.LangSvg.make = function (_elm) {
   "use strict";
   _elm.LangSvg = _elm.LangSvg || {};
   if (_elm.LangSvg.values) return _elm.LangSvg.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Char = Elm.Char.make(_elm),
   $ColorNum = Elm.ColorNum.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Either = Elm.Either.make(_elm),
   $Eval = Elm.Eval.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Regex = Elm.Regex.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Svg = Elm.Svg.make(_elm),
   $Utils = Elm.Utils.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var fetchMovieFrameVal = F4(function (slideNumber,
   movieNumber,
   movieTime,
   movieVal) {
      var _p0 = $Lang.unwrapVList(movieVal);
      _v0_2: do {
         if (_p0.ctor === "Just" && _p0._0.ctor === "::" && _p0._0._0.ctor === "VBase" && _p0._0._0._0.ctor === "VString" && _p0._0._1.ctor === "::")
         {
               if (_p0._0._1._1.ctor === "[]") {
                     if (_p0._0._0._0._0 === "Static" && _p0._0._1._0.ctor === "VClosure")
                     {
                           var _p9 = _p0._0._1._0._1;
                           var _p1 = _p9.val;
                           if (_p1.ctor === "PVar") {
                                 var fenv$ = A2($List._op["::"],
                                 {ctor: "_Tuple2"
                                 ,_0: _p1._1
                                 ,_1: $Lang.vConst({ctor: "_Tuple2"
                                                   ,_0: $Basics.toFloat(slideNumber)
                                                   ,_1: $Lang.dummyTrace})},
                                 _p0._0._1._0._3);
                                 var _p4 = A2($Result.map,
                                 function (_p2) {
                                    var _p3 = _p2;
                                    return _p3._0._0.v_;
                                 },
                                 A3($Eval.$eval,fenv$,_U.list([]),_p0._0._1._0._2));
                                 if (_p4.ctor === "Ok") {
                                       if (_p4._0.ctor === "VClosure") {
                                             var _p8 = _p4._0._1;
                                             var _p5 = _p8.val;
                                             if (_p5.ctor === "PVar") {
                                                   var fenvInner$ = A2($List._op["::"],
                                                   {ctor: "_Tuple2"
                                                   ,_0: _p5._1
                                                   ,_1: $Lang.vConst({ctor: "_Tuple2"
                                                                     ,_0: $Basics.toFloat(movieNumber)
                                                                     ,_1: $Lang.dummyTrace})},
                                                   _p4._0._3);
                                                   return A2($Result.map,
                                                   function (_p6) {
                                                      var _p7 = _p6;
                                                      return _p7._0._0;
                                                   },
                                                   A3($Eval.$eval,fenvInner$,_U.list([]),_p4._0._2));
                                                } else {
                                                   return $Result.Err(A2($Basics._op["++"],
                                                   "expected static movie frame function to take two arguments, got ",
                                                   $Basics.toString(_p8.val)));
                                                }
                                          } else {
                                             return $Result.Err(A2($Basics._op["++"],
                                             "expected static movie frame function to take two arguments, got ",
                                             $Basics.toString(_p4._0)));
                                          }
                                    } else {
                                       return $Result.Err(_p4._0);
                                    }
                              } else {
                                 return $Result.Err(A2($Basics._op["++"],
                                 "expected static movie frame function to take two arguments, got ",
                                 $Basics.toString(_p9.val)));
                              }
                        } else {
                           break _v0_2;
                        }
                  } else {
                     if (_p0._0._0._0._0 === "Dynamic" && _p0._0._1._0.ctor === "VConst" && _p0._0._1._0._0.ctor === "_Tuple2" && _p0._0._1._1._0.ctor === "VClosure" && _p0._0._1._1._1.ctor === "::" && _p0._0._1._1._1._0.ctor === "VBase" && _p0._0._1._1._1._0._0.ctor === "VBool" && _p0._0._1._1._1._1.ctor === "[]")
                     {
                           var _p23 = _p0._0._1._1._0._1;
                           var _p10 = _p23.val;
                           if (_p10.ctor === "PVar") {
                                 var fenv$ = A2($List._op["::"],
                                 {ctor: "_Tuple2"
                                 ,_0: _p10._1
                                 ,_1: $Lang.vConst({ctor: "_Tuple2"
                                                   ,_0: $Basics.toFloat(slideNumber)
                                                   ,_1: $Lang.dummyTrace})},
                                 _p0._0._1._1._0._3);
                                 var _p13 = A2($Result.map,
                                 function (_p11) {
                                    var _p12 = _p11;
                                    return _p12._0._0.v_;
                                 },
                                 A3($Eval.$eval,fenv$,_U.list([]),_p0._0._1._1._0._2));
                                 if (_p13.ctor === "Ok") {
                                       if (_p13._0.ctor === "VClosure") {
                                             var _p22 = _p13._0._1;
                                             var _p14 = _p22.val;
                                             if (_p14.ctor === "PVar") {
                                                   var fenvInner1$ = A2($List._op["::"],
                                                   {ctor: "_Tuple2"
                                                   ,_0: _p14._1
                                                   ,_1: $Lang.vConst({ctor: "_Tuple2"
                                                                     ,_0: $Basics.toFloat(movieNumber)
                                                                     ,_1: $Lang.dummyTrace})},
                                                   _p13._0._3);
                                                   var _p17 = A2($Result.map,
                                                   function (_p15) {
                                                      var _p16 = _p15;
                                                      return _p16._0._0.v_;
                                                   },
                                                   A3($Eval.$eval,fenvInner1$,_U.list([]),_p13._0._2));
                                                   if (_p17.ctor === "Ok") {
                                                         if (_p17._0.ctor === "VClosure") {
                                                               var _p21 = _p17._0._1;
                                                               var _p18 = _p21.val;
                                                               if (_p18.ctor === "PVar") {
                                                                     var fenvInner2$ = A2($List._op["::"],
                                                                     {ctor: "_Tuple2"
                                                                     ,_0: _p18._1
                                                                     ,_1: $Lang.vConst({ctor: "_Tuple2"
                                                                                       ,_0: movieTime
                                                                                       ,_1: $Lang.dummyTrace})},
                                                                     _p17._0._3);
                                                                     return A2($Result.map,
                                                                     function (_p19) {
                                                                        var _p20 = _p19;
                                                                        return _p20._0._0;
                                                                     },
                                                                     A3($Eval.$eval,fenvInner2$,_U.list([]),_p17._0._2));
                                                                  } else {
                                                                     return $Result.Err(A2($Basics._op["++"],
                                                                     "expected dynamic movie frame function to take four arguments, got ",
                                                                     $Basics.toString(_p21.val)));
                                                                  }
                                                            } else {
                                                               return $Result.Err(A2($Basics._op["++"],
                                                               "expected dynamic movie frame function to take four arguments, got ",
                                                               $Basics.toString(_p17._0)));
                                                            }
                                                      } else {
                                                         return $Result.Err(_p17._0);
                                                      }
                                                } else {
                                                   return $Result.Err(A2($Basics._op["++"],
                                                   "expected dynamic movie frame function to take four arguments, got ",
                                                   $Basics.toString(_p22.val)));
                                                }
                                          } else {
                                             return $Result.Err(A2($Basics._op["++"],
                                             "expected dynamic movie frame function to take four arguments, got ",
                                             $Basics.toString(_p13._0)));
                                          }
                                    } else {
                                       return $Result.Err(_p13._0);
                                    }
                              } else {
                                 return $Result.Err(A2($Basics._op["++"],
                                 "expected dynamic movie frame function to take four arguments, got ",
                                 $Basics.toString(_p23.val)));
                              }
                        } else {
                           break _v0_2;
                        }
                  }
            } else {
               break _v0_2;
            }
      } while (false);
      return $Result.Ok(movieVal);
   });
   var fetchMovieDurationAndContinueBool = function (movieVal) {
      var _p24 = $Lang.unwrapVList(movieVal);
      _v14_2: do {
         if (_p24.ctor === "Just" && _p24._0.ctor === "::" && _p24._0._0.ctor === "VBase" && _p24._0._0._0.ctor === "VString" && _p24._0._1.ctor === "::")
         {
               if (_p24._0._1._1.ctor === "[]") {
                     if (_p24._0._0._0._0 === "Static" && _p24._0._1._0.ctor === "VClosure")
                     {
                           return {ctor: "_Tuple2",_0: 0.0,_1: false};
                        } else {
                           break _v14_2;
                        }
                  } else {
                     if (_p24._0._0._0._0 === "Dynamic" && _p24._0._1._0.ctor === "VConst" && _p24._0._1._0._0.ctor === "_Tuple2" && _p24._0._1._1._0.ctor === "VClosure" && _p24._0._1._1._1.ctor === "::" && _p24._0._1._1._1._0.ctor === "VBase" && _p24._0._1._1._1._0._0.ctor === "VBool" && _p24._0._1._1._1._1.ctor === "[]")
                     {
                           return {ctor: "_Tuple2"
                                  ,_0: _p24._0._1._0._0._0
                                  ,_1: _p24._0._1._1._1._0._0._0};
                        } else {
                           break _v14_2;
                        }
                  }
            } else {
               break _v14_2;
            }
      } while (false);
      return {ctor: "_Tuple2",_0: 0.0,_1: false};
   };
   var fetchMovieVal = F2(function (movieNumber,slideVal) {
      var _p25 = $Lang.unwrapVList(slideVal);
      if (_p25.ctor === "Just" && _p25._0.ctor === "::" && _p25._0._0.ctor === "VConst" && _p25._0._0._0.ctor === "_Tuple2" && _p25._0._1.ctor === "::" && _p25._0._1._0.ctor === "VClosure" && _p25._0._1._1.ctor === "[]")
      {
            var _p29 = _p25._0._1._0._1;
            var _p26 = _p29.val;
            if (_p26.ctor === "PVar") {
                  var fenv$ = A2($List._op["::"],
                  {ctor: "_Tuple2"
                  ,_0: _p26._1
                  ,_1: $Lang.vConst({ctor: "_Tuple2"
                                    ,_0: $Basics.toFloat(movieNumber)
                                    ,_1: $Lang.dummyTrace})},
                  _p25._0._1._0._3);
                  return A2($Result.map,
                  function (_p27) {
                     var _p28 = _p27;
                     return _p28._0._0;
                  },
                  A3($Eval.$eval,fenv$,_U.list([]),_p25._0._1._0._2));
               } else {
                  return $Result.Err(A2($Basics._op["++"],
                  "expected movie function to take a single argument, got ",
                  $Basics.toString(_p29.val)));
               }
         } else {
            return $Result.Ok(slideVal);
         }
   });
   var fetchSlideVal = F2(function (slideNumber,val) {
      var _p30 = $Lang.unwrapVList(val);
      if (_p30.ctor === "Just" && _p30._0.ctor === "::" && _p30._0._0.ctor === "VConst" && _p30._0._0._0.ctor === "_Tuple2" && _p30._0._1.ctor === "::" && _p30._0._1._0.ctor === "VClosure" && _p30._0._1._1.ctor === "[]")
      {
            var _p34 = _p30._0._1._0._1;
            var _p31 = _p34.val;
            if (_p31.ctor === "PVar") {
                  var fenv$ = A2($List._op["::"],
                  {ctor: "_Tuple2"
                  ,_0: _p31._1
                  ,_1: $Lang.vConst({ctor: "_Tuple2"
                                    ,_0: $Basics.toFloat(slideNumber)
                                    ,_1: $Lang.dummyTrace})},
                  _p30._0._1._0._3);
                  return A2($Result.map,
                  function (_p32) {
                     var _p33 = _p32;
                     return _p33._0._0;
                  },
                  A3($Eval.$eval,fenv$,_U.list([]),_p30._0._1._0._2));
               } else {
                  return $Result.Err(A2($Basics._op["++"],
                  "expected slide function to take a single argument, got ",
                  $Basics.toString(_p34.val)));
               }
         } else {
            return $Result.Ok(val);
         }
   });
   var fetchMovieCount = function (slideVal) {
      var _p35 = $Lang.unwrapVList(slideVal);
      if (_p35.ctor === "Just" && _p35._0.ctor === "::" && _p35._0._0.ctor === "VConst" && _p35._0._0._0.ctor === "_Tuple2" && _p35._0._1.ctor === "::" && _p35._0._1._1.ctor === "[]")
      {
            return $Basics.round(_p35._0._0._0._0);
         } else {
            return 1;
         }
   };
   var fetchSlideCount = function (val) {
      var _p36 = $Lang.unwrapVList(val);
      if (_p36.ctor === "Just" && _p36._0.ctor === "::" && _p36._0._0.ctor === "VConst" && _p36._0._0._0.ctor === "_Tuple2" && _p36._0._1.ctor === "::" && _p36._0._1._1.ctor === "[]")
      {
            return $Basics.round(_p36._0._0._0._0);
         } else {
            return 1;
         }
   };
   var fetchEverything_ = F4(function (slideNumber,
   movieNumber,
   movieTime,
   val) {
      var slideCount = fetchSlideCount(val);
      return A2($Result.andThen,
      A2(fetchSlideVal,slideNumber,val),
      function (slideVal) {
         var movieCount = fetchMovieCount(slideVal);
         return A2($Result.andThen,
         A2(fetchMovieVal,movieNumber,slideVal),
         function (movieVal) {
            var _p37 = fetchMovieDurationAndContinueBool(movieVal);
            var movieDuration = _p37._0;
            var $continue = _p37._1;
            return A2($Result.map,
            function (movieFrameVal) {
               return {ctor: "_Tuple5"
                      ,_0: slideCount
                      ,_1: movieCount
                      ,_2: movieDuration
                      ,_3: $continue
                      ,_4: movieFrameVal};
            },
            A4(fetchMovieFrameVal,
            slideNumber,
            movieNumber,
            movieTime,
            movieVal));
         });
      });
   });
   var resolveToMovieFrameVal = F4(function (slideNumber,
   movieNumber,
   movieTime,
   val) {
      return A2($Result.map,
      function (_p38) {
         var _p39 = _p38;
         return _p39._4;
      },
      A4(fetchEverything_,slideNumber,movieNumber,movieTime,val));
   });
   var resolveToMovieCount = F2(function (slideNumber,val) {
      return A2($Result.map,
      fetchMovieCount,
      A2(fetchSlideVal,slideNumber,val));
   });
   var foldSlate = F3(function (_p40,acc,f) {
      var _p41 = _p40;
      var foldNode = F2(function (i,acc) {
         var node = A3($Utils.justGet_,"foldSlate",i,_p41._1);
         var _p42 = node;
         if (_p42.ctor === "TextNode") {
               return A3(f,i,node,acc);
            } else {
               return A3(f,i,node,A3($List.foldl,foldNode,acc,_p42._2));
            }
      });
      return A2(foldNode,_p41._0,acc);
   });
   var foldSlateNodeInfo = F3(function (slate,acc,f) {
      return A3(foldSlate,
      slate,
      acc,
      F2(function (i,node) {
         var _p43 = node;
         if (_p43.ctor === "TextNode") {
               return f($Either.Left({ctor: "_Tuple2",_0: i,_1: _p43._0}));
            } else {
               return f($Either.Right({ctor: "_Tuple3"
                                      ,_0: i
                                      ,_1: _p43._0
                                      ,_2: _p43._1}));
            }
      }));
   });
   var dummySvgVal = function () {
      var zero = $Lang.vConst({ctor: "_Tuple2"
                              ,_0: 0
                              ,_1: $Lang.dummyTrace});
      var attrs = $Lang.vList(A2($List.map,
      function (k) {
         return $Lang.vList(_U.list([$Lang.vStr(k),zero]));
      },
      _U.list(["cx","cy","r"])));
      var children = $Lang.vList(_U.list([]));
      return $Lang.vList(_U.list([$Lang.vStr("circle")
                                 ,attrs
                                 ,children]));
   }();
   var justGetSvgNode = F3(function (cap,nodeId,_p44) {
      var _p45 = _p44;
      var _p46 = A3($Utils.justGet_,cap,nodeId,_p45._1);
      if (_p46.ctor === "SvgNode") {
            return {ctor: "_Tuple2",_0: _p46._0,_1: _p46._1};
         } else {
            return _U.crashCase("LangSvg",
            {start: {line: 617,column: 3},end: {line: 619,column: 64}},
            _p46)(A2($Basics._op["++"],cap,": TextNode ?"));
         }
   });
   var maybeFindBounds = function (l) {
      var _p48 = A2($Utils.maybeFind,"BOUNDS",l);
      if (_p48.ctor === "Nothing") {
            return $Maybe.Nothing;
         } else {
            var roundBounds = true;
            var _p49 = {ctor: "_Tuple2",_0: _p48._0.av_,_1: roundBounds};
            _v30_2: do {
               if (_p49.ctor === "_Tuple2" && _p49._0.ctor === "ABounds") {
                     if (_p49._1 === false) {
                           return $Maybe.Just(_p49._0._0);
                        } else {
                           if (_p49._0._0.ctor === "_Tuple4") {
                                 var f = $Utils.mapFst(function (_p50) {
                                    return $Basics.toFloat($Basics.round(_p50));
                                 });
                                 return $Maybe.Just({ctor: "_Tuple4"
                                                    ,_0: f(_p49._0._0._0)
                                                    ,_1: f(_p49._0._0._1)
                                                    ,_2: f(_p49._0._0._2)
                                                    ,_3: f(_p49._0._0._3)});
                              } else {
                                 break _v30_2;
                              }
                        }
                  } else {
                     break _v30_2;
                  }
            } while (false);
            return $Maybe.Nothing;
         }
   };
   var maybeFindBlobId = function (l) {
      var _p51 = A2($Utils.maybeFind,"BLOB",l);
      if (_p51.ctor === "Nothing") {
            return $Maybe.Nothing;
         } else {
            var _p52 = _p51._0.av_;
            if (_p52.ctor === "AString") {
                  return $Maybe.Just($Utils.parseInt(_p52._0));
               } else {
                  return $Maybe.Nothing;
               }
         }
   };
   var findAVal = F2(function (attr,attrs) {
      var _p53 = A2($Utils.maybeFind,attr,attrs);
      if (_p53.ctor === "Just") {
            return _p53._0;
         } else {
            return _U.crashCase("LangSvg",
            {start: {line: 542,column: 3},end: {line: 544,column: 53}},
            _p53)(A2($Basics._op["++"],"findAVal: ",attr));
         }
   });
   var getBoundsAttrs = function (attrs0) {
      return A2($Maybe.andThen,
      A2($Utils.maybeRemoveFirst,"LEFT",attrs0),
      function (_p55) {
         var _p56 = _p55;
         return A2($Maybe.andThen,
         A2($Utils.maybeRemoveFirst,"RIGHT",_p56._1),
         function (_p57) {
            var _p58 = _p57;
            return A2($Maybe.andThen,
            A2($Utils.maybeRemoveFirst,"TOP",_p58._1),
            function (_p59) {
               var _p60 = _p59;
               return A2($Maybe.andThen,
               A2($Utils.maybeRemoveFirst,"BOT",_p60._1),
               function (_p61) {
                  var _p62 = _p61;
                  var _p63 = {ctor: "_Tuple4"
                             ,_0: _p56._0.av_
                             ,_1: _p60._0.av_
                             ,_2: _p58._0.av_
                             ,_3: _p62._0.av_};
                  if (_p63.ctor === "_Tuple4" && _p63._0.ctor === "ANum" && _p63._0._0.ctor === "_Tuple2" && _p63._1.ctor === "ANum" && _p63._1._0.ctor === "_Tuple2" && _p63._2.ctor === "ANum" && _p63._2._0.ctor === "_Tuple2" && _p63._3.ctor === "ANum" && _p63._3._0.ctor === "_Tuple2")
                  {
                        return $Maybe.Just({ctor: "_Tuple5"
                                           ,_0: _p63._0._0._0
                                           ,_1: _p63._1._0._0
                                           ,_2: _p63._2._0._0
                                           ,_3: _p63._3._0._0
                                           ,_4: _p62._1});
                     } else {
                        return $Maybe.Nothing;
                     }
               });
            });
         });
      });
   };
   var specialAttrs = _U.list(["HIDDEN","ZONES"]);
   var removeSpecialAttrs = $List.filter(function (_p64) {
      var _p65 = _p64;
      return $Basics.not(A2($List.member,_p65._0,specialAttrs));
   });
   var strBounds = function (_p66) {
      var _p67 = _p66;
      return $Utils.spaces(A2($List.map,
      function (_p68) {
         return $Basics.toString($Basics.fst(_p68));
      },
      _U.list([_p67._0,_p67._1,_p67._2,_p67._3])));
   };
   var strTransformCmd = function (cmd) {
      var _p69 = cmd;
      switch (_p69.ctor)
      {case "Rot": var nums = A2($List.map,
           function (_p70) {
              return $Basics.toString($Basics.fst(_p70));
           },
           _U.list([_p69._0,_p69._1,_p69._2]));
           return A2($Basics._op["++"],
           "rotate",
           $Utils.parens($Utils.spaces(nums)));
         case "Scale": var nums = A2($List.map,
           function (_p71) {
              return $Basics.toString($Basics.fst(_p71));
           },
           _U.list([_p69._0,_p69._1]));
           return A2($Basics._op["++"],
           "scale",
           $Utils.parens($Utils.spaces(nums)));
         default: var nums = A2($List.map,
           function (_p72) {
              return $Basics.toString($Basics.fst(_p72));
           },
           _U.list([_p69._0,_p69._1]));
           return A2($Basics._op["++"],
           "translate",
           $Utils.parens($Utils.spaces(nums)));}
   };
   var strAPathCmds = function () {
      var strPt = function (_p73) {
         var _p74 = _p73;
         return A2($Basics._op["++"],
         $Basics.toString($Basics.fst(_p74._1._0)),
         A2($Basics._op["++"],
         " ",
         $Basics.toString($Basics.fst(_p74._1._1))));
      };
      var strNum = function (_p75) {
         var _p76 = _p75;
         return $Basics.toString(_p76._0);
      };
      var strPathCmd = function (c) {
         var _p77 = c;
         switch (_p77.ctor)
         {case "CmdZ": return _p77._0;
            case "CmdMLT": return $Utils.spaces(_U.list([_p77._0
                                                        ,strPt(_p77._1)]));
            case "CmdHV": return $Utils.spaces(_U.list([_p77._0
                                                       ,strNum(_p77._1)]));
            case "CmdC": return $Utils.spaces(A2($List._op["::"],
              _p77._0,
              A2($List.map,strPt,_U.list([_p77._1,_p77._2,_p77._3]))));
            case "CmdSQ": return $Utils.spaces(A2($List._op["::"],
              _p77._0,
              A2($List.map,strPt,_U.list([_p77._1,_p77._2]))));
            default: return $Utils.spaces(A2($List._op["::"],
              _p77._0,
              A2($Basics._op["++"],
              A2($List.map,
              strNum,
              _U.list([_p77._1,_p77._2,_p77._3,_p77._4,_p77._5])),
              _U.list([strPt(_p77._6)]))));}
      };
      return function (_p78) {
         return $Utils.spaces(A2($List.map,strPathCmd,_p78));
      };
   }();
   var matchCmd = F2(function (cmd,s) {
      var c = $Utils.unwrap1($String.toList(cmd));
      var cs = $String.toList(s);
      return A2($List.member,
      c,
      A2($Basics._op["++"],cs,A2($List.map,$Char.toLower,cs)));
   });
   var projConsts = F2(function (k,vs) {
      var _p79 = {ctor: "_Tuple2",_0: _U.eq(k,0),_1: vs};
      _v45_2: do {
         if (_p79.ctor === "_Tuple2") {
               if (_p79._0 === true) {
                     return {ctor: "_Tuple2",_0: _U.list([]),_1: vs};
                  } else {
                     if (_p79._1.ctor === "::") {
                           var _p80 = _p79._1._0.v_;
                           if (_p80.ctor === "VConst") {
                                 var _p81 = A2(projConsts,k - 1,_p79._1._1);
                                 var l1 = _p81._0;
                                 var l2 = _p81._1;
                                 return {ctor: "_Tuple2"
                                        ,_0: A2($List._op["::"],_p80._0,l1)
                                        ,_1: l2};
                              } else {
                                 return _U.crashCase("LangSvg",
                                 {start: {line: 304,column: 7},end: {line: 309,column: 35}},
                                 _p80)("projConsts");
                              }
                        } else {
                           break _v45_2;
                        }
                  }
            } else {
               break _v45_2;
            }
      } while (false);
      return _U.crashCase("LangSvg",
      {start: {line: 301,column: 3},end: {line: 311,column: 31}},
      _p79)("projConsts");
   });
   var addIdPoints = F3(function (cmd,counts,pts) {
      var c = $Utils.unwrap1($String.toList(cmd));
      if ($Char.isLower(c)) return {ctor: "_Tuple2"
                                   ,_0: counts
                                   ,_1: A2($List.map,
                                   F2(function (v0,v1) {
                                      return {ctor: "_Tuple2",_0: v0,_1: v1};
                                   })($Maybe.Nothing),
                                   pts)}; else if ($Char.isUpper(c)) {
               var _p84 = A3($List.foldl,
               F2(function (pt,_p85) {
                  var _p86 = _p85;
                  var _p87 = _p86._0;
                  var nextId = 1 + _p87.numPoints;
                  var acc1$ = _U.update(_p87,{numPoints: nextId});
                  var acc2$ = A2($List._op["::"],
                  {ctor: "_Tuple2",_0: $Maybe.Just(nextId),_1: pt},
                  _p86._1);
                  return {ctor: "_Tuple2",_0: acc1$,_1: acc2$};
               }),
               {ctor: "_Tuple2",_0: counts,_1: _U.list([])},
               pts);
               var counts$ = _p84._0;
               var l = _p84._1;
               return {ctor: "_Tuple2",_0: counts$,_1: $List.reverse(l)};
            } else return _U.crash("LangSvg",
            {start: {line: 298,column: 5}
            ,end: {line: 298,column: 16}})("addIdPoints");
   });
   _op["+++"] = F2(function (x,_p88) {
      var _p89 = _p88;
      return {ctor: "_Tuple2"
             ,_0: A2($List._op["::"],x,_p89._0)
             ,_1: _p89._1};
   });
   var strRgba_ = function (rgba) {
      return A2($Basics._op["++"],
      "rgba",
      $Utils.parens($Utils.commas(A2($List.map,
      $Basics.toString,
      rgba))));
   };
   var strRgba = function (_p90) {
      var _p91 = _p90;
      return strRgba_(A2($List.map,
      $Basics.fst,
      _U.list([_p91._0,_p91._1,_p91._2,_p91._3])));
   };
   var strPoint = function (_p92) {
      var _p93 = _p92;
      var _p94 = $Utils.unwrap2(A2($List.map,
      $Basics.fst,
      _U.list([_p93._0,_p93._1])));
      var x = _p94._0;
      var y = _p94._1;
      return A2($Basics._op["++"],
      $Basics.toString(x),
      A2($Basics._op["++"],",",$Basics.toString(y)));
   };
   var SvgNode = F3(function (a,b,c) {
      return {ctor: "SvgNode",_0: a,_1: b,_2: c};
   });
   var TextNode = function (a) {
      return {ctor: "TextNode",_0: a};
   };
   var maxStrokeWidthNum = 20;
   var maxColorNum = 500;
   var strAVal = function (a) {
      var _p95 = a.av_;
      switch (_p95.ctor)
      {case "AString": return _p95._0;
         case "ANum": return $Basics.toString($Basics.fst(_p95._0));
         case "APoints": return $Utils.spaces(A2($List.map,
           strPoint,
           _p95._0));
         case "ARgba": return strRgba(_p95._0);
         case "APath2": return strAPathCmds($Basics.fst(_p95._0));
         case "ATransform": return $Utils.spaces(A2($List.map,
           strTransformCmd,
           _p95._0));
         case "ABounds": return strBounds(_p95._0);
         default: if (_p95._0._1.ctor === "Nothing") {
                 return strRgba_($ColorNum.convert($Basics.fst(_p95._0._0)));
              } else {
                 var _p96 = A2($Utils.numToColor,
                 maxColorNum,
                 $Basics.fst(_p95._0._0));
                 var r = _p96._0;
                 var g = _p96._1;
                 var b = _p96._2;
                 return strRgba_(_U.list([$Basics.toFloat(r)
                                         ,$Basics.toFloat(g)
                                         ,$Basics.toFloat(b)
                                         ,_p95._0._1._0._0]));
              }}
   };
   var printAttr = function (_p97) {
      var _p98 = _p97;
      return A2($Basics._op["++"],
      _p98._0,
      A2($Basics._op["++"],
      "=",
      A3($Utils.delimit,"\'","\'",strAVal(_p98._1))));
   };
   var printAttrs = function (l) {
      var _p99 = l;
      if (_p99.ctor === "[]") {
            return "";
         } else {
            return A2($Basics._op["++"],
            " ",
            $Utils.spaces(A2($List.map,printAttr,l)));
         }
   };
   var PathCounts = function (a) {    return {numPoints: a};};
   var Trans = F2(function (a,b) {
      return {ctor: "Trans",_0: a,_1: b};
   });
   var Scale = F2(function (a,b) {
      return {ctor: "Scale",_0: a,_1: b};
   });
   var Rot = F3(function (a,b,c) {
      return {ctor: "Rot",_0: a,_1: b,_2: c};
   });
   var CmdA = F7(function (a,b,c,d,e,f,g) {
      return {ctor: "CmdA"
             ,_0: a
             ,_1: b
             ,_2: c
             ,_3: d
             ,_4: e
             ,_5: f
             ,_6: g};
   });
   var CmdSQ = F3(function (a,b,c) {
      return {ctor: "CmdSQ",_0: a,_1: b,_2: c};
   });
   var CmdC = F4(function (a,b,c,d) {
      return {ctor: "CmdC",_0: a,_1: b,_2: c,_3: d};
   });
   var CmdHV = F2(function (a,b) {
      return {ctor: "CmdHV",_0: a,_1: b};
   });
   var CmdMLT = F2(function (a,b) {
      return {ctor: "CmdMLT",_0: a,_1: b};
   });
   var CmdZ = function (a) {    return {ctor: "CmdZ",_0: a};};
   var valsToPath2_ = F2(function (counts,vs) {
      var _p100 = vs;
      if (_p100.ctor === "[]") {
            return {ctor: "_Tuple2",_0: _U.list([]),_1: counts};
         } else {
            var _p113 = _p100._1;
            var _p101 = _p100._0.v_;
            if (_p101.ctor === "VBase" && _p101._0.ctor === "VString") {
                  var _p111 = _p101._0._0;
                  if (A2(matchCmd,_p111,"Z")) return A2(_op["+++"],
                     CmdZ(_p111),
                     A2(valsToPath2_,counts,_p113)); else if (A2(matchCmd,
                     _p111,
                     "MLT")) {
                           var _p102 = A2($Utils.mapFst,
                           $Utils.unwrap2,
                           A2(projConsts,2,_p113));
                           var x = _p102._0._0;
                           var y = _p102._0._1;
                           var vs$$ = _p102._1;
                           var _p103 = A2($Utils.mapSnd,
                           $Utils.unwrap1,
                           A3(addIdPoints,
                           _p111,
                           counts,
                           _U.list([{ctor: "_Tuple2",_0: x,_1: y}])));
                           var counts$ = _p103._0;
                           var pt = _p103._1;
                           return A2(_op["+++"],
                           A2(CmdMLT,_p111,pt),
                           A2(valsToPath2_,counts$,vs$$));
                        } else if (A2(matchCmd,_p111,"HV")) {
                              var _p104 = A2($Utils.mapFst,
                              $Utils.unwrap1,
                              A2(projConsts,1,_p113));
                              var i = _p104._0;
                              var vs$$ = _p104._1;
                              return A2(_op["+++"],
                              A2(CmdHV,_p111,i),
                              A2(valsToPath2_,counts,vs$$));
                           } else if (A2(matchCmd,_p111,"C")) {
                                 var _p105 = A2($Utils.mapFst,
                                 $Utils.unwrap6,
                                 A2(projConsts,6,_p113));
                                 var x1 = _p105._0._0;
                                 var y1 = _p105._0._1;
                                 var x2 = _p105._0._2;
                                 var y2 = _p105._0._3;
                                 var x = _p105._0._4;
                                 var y = _p105._0._5;
                                 var vs$$ = _p105._1;
                                 var _p106 = A2($Utils.mapSnd,
                                 $Utils.unwrap3,
                                 A3(addIdPoints,
                                 _p111,
                                 counts,
                                 _U.list([{ctor: "_Tuple2",_0: x1,_1: y1}
                                         ,{ctor: "_Tuple2",_0: x2,_1: y2}
                                         ,{ctor: "_Tuple2",_0: x,_1: y}])));
                                 var counts$ = _p106._0;
                                 var pt1 = _p106._1._0;
                                 var pt2 = _p106._1._1;
                                 var pt3 = _p106._1._2;
                                 return A2(_op["+++"],
                                 A4(CmdC,_p111,pt1,pt2,pt3),
                                 A2(valsToPath2_,counts$,vs$$));
                              } else if (A2(matchCmd,_p111,"SQ")) {
                                    var _p107 = A2($Utils.mapFst,
                                    $Utils.unwrap4,
                                    A2(projConsts,4,_p113));
                                    var x1 = _p107._0._0;
                                    var y1 = _p107._0._1;
                                    var x = _p107._0._2;
                                    var y = _p107._0._3;
                                    var vs$$ = _p107._1;
                                    var _p108 = A2($Utils.mapSnd,
                                    $Utils.unwrap2,
                                    A3(addIdPoints,
                                    _p111,
                                    counts,
                                    _U.list([{ctor: "_Tuple2",_0: x1,_1: y1}
                                            ,{ctor: "_Tuple2",_0: x,_1: y}])));
                                    var counts$ = _p108._0;
                                    var pt1 = _p108._1._0;
                                    var pt2 = _p108._1._1;
                                    return A2(_op["+++"],
                                    A3(CmdSQ,_p111,pt1,pt2),
                                    A2(valsToPath2_,counts$,vs$$));
                                 } else if (A2(matchCmd,_p111,"A")) {
                                       var _p109 = A2($Utils.mapFst,
                                       $Utils.unwrap7,
                                       A2(projConsts,7,_p113));
                                       var rx = _p109._0._0;
                                       var ry = _p109._0._1;
                                       var axis = _p109._0._2;
                                       var flag = _p109._0._3;
                                       var sweep = _p109._0._4;
                                       var x = _p109._0._5;
                                       var y = _p109._0._6;
                                       var vs$$ = _p109._1;
                                       var _p110 = A2($Utils.mapSnd,
                                       $Utils.unwrap1,
                                       A3(addIdPoints,
                                       _p111,
                                       counts,
                                       _U.list([{ctor: "_Tuple2",_0: x,_1: y}])));
                                       var counts$ = _p110._0;
                                       var pt = _p110._1;
                                       return A2(_op["+++"],
                                       A7(CmdA,_p111,rx,ry,axis,flag,sweep,pt),
                                       A2(valsToPath2_,counts$,vs$$));
                                    } else return _U.crash("LangSvg",
                                    {start: {line: 277,column: 9}
                                    ,end: {line: 277,column: 20}})("valsToPath2_");
               } else {
                  return _U.crashCase("LangSvg",
                  {start: {line: 253,column: 13},end: {line: 279,column: 33}},
                  _p101)("valsToPath2_");
               }
         }
   });
   var valsToPath2 = valsToPath2_({numPoints: 0});
   var ABounds = function (a) {
      return {ctor: "ABounds",_0: a};
   };
   var ATransform = function (a) {
      return {ctor: "ATransform",_0: a};
   };
   var APath2 = function (a) {    return {ctor: "APath2",_0: a};};
   var AColorNum = function (a) {
      return {ctor: "AColorNum",_0: a};
   };
   var ARgba = function (a) {    return {ctor: "ARgba",_0: a};};
   var APoints = function (a) {
      return {ctor: "APoints",_0: a};
   };
   var AString = function (a) {
      return {ctor: "AString",_0: a};
   };
   var ANum = function (a) {    return {ctor: "ANum",_0: a};};
   var AVal = F2(function (a,b) {    return {av_: a,vtrace: b};});
   var aVal = A2($Basics.flip,AVal,_U.list([-1]));
   var aNum = function (_p114) {    return aVal(ANum(_p114));};
   var desugarShapeAttrs = F2(function (shape0,attrs0) {
      var mkNum = function (n) {
         return aNum({ctor: "_Tuple2",_0: n,_1: $Lang.dummyTrace});
      };
      return A2($Maybe.withDefault,
      {ctor: "_Tuple2",_0: shape0,_1: attrs0},
      function () {
         var _p115 = shape0;
         switch (_p115)
         {case "BOX": return A2($Utils.mapMaybe,
              function (_p116) {
                 var _p117 = _p116;
                 var _p119 = _p117._1;
                 var _p118 = _p117._0;
                 var newAttrs = _U.list([{ctor: "_Tuple2"
                                         ,_0: "x"
                                         ,_1: mkNum(_p118)}
                                        ,{ctor: "_Tuple2",_0: "y",_1: mkNum(_p119)}
                                        ,{ctor: "_Tuple2",_0: "width",_1: mkNum(_p117._2 - _p118)}
                                        ,{ctor: "_Tuple2",_0: "height",_1: mkNum(_p117._3 - _p119)}]);
                 return {ctor: "_Tuple2"
                        ,_0: "rect"
                        ,_1: A2($Basics._op["++"],newAttrs,_p117._4)};
              },
              getBoundsAttrs(attrs0));
            case "OVAL": return A2($Utils.mapMaybe,
              function (_p120) {
                 var _p121 = _p120;
                 var _p125 = _p121._1;
                 var _p124 = _p121._2;
                 var _p123 = _p121._0;
                 var _p122 = _p121._3;
                 var newAttrs = _U.list([{ctor: "_Tuple2"
                                         ,_0: "cx"
                                         ,_1: mkNum(_p123 + (_p124 - _p123) / 2)}
                                        ,{ctor: "_Tuple2"
                                         ,_0: "cy"
                                         ,_1: mkNum(_p125 + (_p122 - _p125) / 2)}
                                        ,{ctor: "_Tuple2",_0: "rx",_1: mkNum((_p124 - _p123) / 2)}
                                        ,{ctor: "_Tuple2",_0: "ry",_1: mkNum((_p122 - _p125) / 2)}]);
                 return {ctor: "_Tuple2"
                        ,_0: "ellipse"
                        ,_1: A2($Basics._op["++"],newAttrs,_p121._4)};
              },
              getBoundsAttrs(attrs0));
            default: return $Maybe.Nothing;}
      }());
   });
   var dummySvgNode = function () {
      var zero = aNum({ctor: "_Tuple2"
                      ,_0: 0
                      ,_1: $Lang.dummyTrace});
      return A3(SvgNode,
      "circle",
      A2($List.map,
      function (k) {
         return {ctor: "_Tuple2",_0: k,_1: zero};
      },
      _U.list(["cx","cy","r"])),
      _U.list([]));
   }();
   var aString = function (_p126) {
      return aVal(AString(_p126));
   };
   var addAttrs = F2(function (kind,attrs) {
      return _U.eq(kind,"svg") ? A2($List._op["::"],
      {ctor: "_Tuple2"
      ,_0: "xmlns"
      ,_1: aString("http://www.w3.org/2000/svg")},
      attrs) : attrs;
   });
   var printNode = F4(function (showGhosts,k,slate,i) {
      var _p127 = A2($Utils.justGet,i,slate);
      if (_p127.ctor === "TextNode") {
            return _p127._0;
         } else {
            var _p130 = _p127._2;
            var _p128 = A2(desugarShapeAttrs,_p127._0,_p127._1);
            var kind = _p128._0;
            var l1 = _p128._1;
            var _p129 = {ctor: "_Tuple2"
                        ,_0: showGhosts
                        ,_1: A2($Utils.maybeRemoveFirst,"HIDDEN",l1)};
            if (_p129.ctor === "_Tuple2" && _p129._0 === false && _p129._1.ctor === "Just")
            {
                  return "";
               } else {
                  if (_U.eq(_p130,_U.list([]))) {
                        var l1$ = A2(addAttrs,kind,removeSpecialAttrs(l1));
                        return A2($Basics._op["++"],
                        A3($Utils.delimit,
                        "<",
                        ">",
                        A2($Basics._op["++"],kind,printAttrs(l1$))),
                        A3($Utils.delimit,"</",">",kind));
                     } else {
                        var l1$ = A2(addAttrs,kind,removeSpecialAttrs(l1));
                        return A2($Basics._op["++"],
                        A3($Utils.delimit,
                        "<",
                        ">",
                        A2($Basics._op["++"],kind,printAttrs(l1$))),
                        A2($Basics._op["++"],
                        "\n",
                        A2($Basics._op["++"],
                        A4(printNodes,showGhosts,k + 1,slate,_p130),
                        A2($Basics._op["++"],
                        "\n",
                        A2($Basics._op["++"],
                        $Lang.tab(k),
                        A3($Utils.delimit,"</",">",kind))))));
                     }
               }
         }
   });
   var printNodes = F3(function (showGhosts,k,slate) {
      return function (_p131) {
         return $Utils.lines(A2($List.map,
         function (_p132) {
            return A2(F2(function (x,y) {
               return A2($Basics._op["++"],x,y);
            }),
            $Lang.tab(k),
            A4(printNode,showGhosts,k,slate,_p132));
         },
         _p131));
      };
   });
   var printSvg = F2(function (showGhosts,_p133) {
      var _p134 = _p133;
      var s = A4(printNode,showGhosts,0,_p134._1,_p134._0);
      return A4($Regex.replace,
      $Regex.All,
      $Regex.regex("[ ]+\\n"),
      function (_p135) {
         return "";
      },
      s);
   });
   var aTransform = function (_p136) {
      return aVal(ATransform(_p136));
   };
   var aColorNum = function (_p137) {
      return aVal(AColorNum(_p137));
   };
   var aPoints = function (_p138) {
      return aVal(APoints(_p138));
   };
   var aPath2 = function (_p139) {    return aVal(APath2(_p139));};
   var expectedButGotStr = F2(function (x,s) {
      return A2($Basics._op["++"],
      "expected ",
      A2($Basics._op["++"],x,A2($Basics._op["++"],", but got: ",s)));
   });
   var expectedButGot = F2(function (x,s) {
      return $Lang.crashWithMsg(A2(expectedButGotStr,x,s));
   });
   var valToPoint = function (v) {
      var _p140 = v.v_;
      if (_p140.ctor === "VList") {
            var _p141 = A2($List.map,
            function (_) {
               return _.v_;
            },
            _p140._0);
            if (_p141.ctor === "::" && _p141._0.ctor === "VConst" && _p141._1.ctor === "::" && _p141._1._0.ctor === "VConst" && _p141._1._1.ctor === "[]")
            {
                  return {ctor: "_Tuple2",_0: _p141._0._0,_1: _p141._1._0._0};
               } else {
                  return A2(expectedButGot,"a point",$Lang.strVal(v));
               }
         } else {
            return A2(expectedButGot,"a point",$Lang.strVal(v));
         }
   };
   var valsToRgba = function (vs) {
      var _p142 = A2($List.map,function (_) {    return _.v_;},vs);
      if (_p142.ctor === "::" && _p142._0.ctor === "VConst" && _p142._1.ctor === "::" && _p142._1._0.ctor === "VConst" && _p142._1._1.ctor === "::" && _p142._1._1._0.ctor === "VConst" && _p142._1._1._1.ctor === "::" && _p142._1._1._1._0.ctor === "VConst" && _p142._1._1._1._1.ctor === "[]")
      {
            return {ctor: "_Tuple4"
                   ,_0: _p142._0._0
                   ,_1: _p142._1._0._0
                   ,_2: _p142._1._1._0._0
                   ,_3: _p142._1._1._1._0._0};
         } else {
            return A2(expectedButGot,
            "rgba",
            $Lang.strVal($Lang.vList(vs)));
         }
   };
   var valToTransformCmd = function (v) {
      var _p143 = v.v_;
      if (_p143.ctor === "VList") {
            var _p144 = A2($List.map,
            function (_) {
               return _.v_;
            },
            _p143._0);
            if (_p144.ctor === "::" && _p144._0.ctor === "VBase" && _p144._0._0.ctor === "VString")
            {
                  var _p145 = {ctor: "_Tuple2"
                              ,_0: _p144._0._0._0
                              ,_1: _p144._1};
                  _v67_3: do {
                     if (_p145.ctor === "_Tuple2" && _p145._1.ctor === "::" && _p145._1._0.ctor === "VConst" && _p145._1._1.ctor === "::" && _p145._1._1._0.ctor === "VConst")
                     {
                           if (_p145._1._1._1.ctor === "::") {
                                 if (_p145._0 === "rotate" && _p145._1._1._1._0.ctor === "VConst" && _p145._1._1._1._1.ctor === "[]")
                                 {
                                       return A3(Rot,
                                       _p145._1._0._0,
                                       _p145._1._1._0._0,
                                       _p145._1._1._1._0._0);
                                    } else {
                                       break _v67_3;
                                    }
                              } else {
                                 switch (_p145._0)
                                 {case "scale": return A2(Scale,
                                      _p145._1._0._0,
                                      _p145._1._1._0._0);
                                    case "translate": return A2(Trans,
                                      _p145._1._0._0,
                                      _p145._1._1._0._0);
                                    default: break _v67_3;}
                              }
                        } else {
                           break _v67_3;
                        }
                  } while (false);
                  return A2(expectedButGot,"a transform command",$Lang.strVal(v));
               } else {
                  return A2(expectedButGot,
                  "a transform command",
                  $Lang.strVal(v));
               }
         } else {
            return A2(expectedButGot,
            "a transform command",
            $Lang.strVal(v));
         }
   };
   var valsToTransform = $List.map(valToTransformCmd);
   var valToBounds = function (vs) {
      var _p146 = A2($List.map,function (_) {    return _.v_;},vs);
      if (_p146.ctor === "::" && _p146._0.ctor === "VConst" && _p146._1.ctor === "::" && _p146._1._0.ctor === "VConst" && _p146._1._1.ctor === "::" && _p146._1._1._0.ctor === "VConst" && _p146._1._1._1.ctor === "::" && _p146._1._1._1._0.ctor === "VConst" && _p146._1._1._1._1.ctor === "[]")
      {
            return {ctor: "_Tuple4"
                   ,_0: _p146._0._0
                   ,_1: _p146._1._0._0
                   ,_2: _p146._1._1._0._0
                   ,_3: _p146._1._1._1._0._0};
         } else {
            return A2(expectedButGot,
            "bounds",
            $Lang.strVal($Lang.vList(vs)));
         }
   };
   var valToAttr = function (v) {
      var _p147 = v.v_;
      if (_p147.ctor === "VList" && _p147._0.ctor === "::" && _p147._0._1.ctor === "::" && _p147._0._1._1.ctor === "[]")
      {
            var _p158 = _p147._0._1._0;
            var _p148 = {ctor: "_Tuple2",_0: _p147._0._0.v_,_1: _p158.v_};
            if (_p148.ctor === "_Tuple2" && _p148._0.ctor === "VBase" && _p148._0._0.ctor === "VString")
            {
                  var _p156 = _p148._0._0._0;
                  var _p149 = function () {
                     var _p150 = {ctor: "_Tuple2",_0: _p156,_1: _p148._1};
                     _v71_12: do {
                        if (_p150.ctor === "_Tuple2") {
                              switch (_p150._1.ctor)
                              {case "VList": switch (_p150._0)
                                   {case "points": return {ctor: "_Tuple2"
                                                          ,_0: _p156
                                                          ,_1: APoints(A2($List.map,valToPoint,_p150._1._0))};
                                      case "fill":
                                      if (_p150._1._0.ctor === "::" && _p150._1._0._1.ctor === "::") {
                                              if (_p150._1._0._1._1.ctor === "::") {
                                                    if (_p150._1._0._1._1._1.ctor === "::" && _p150._1._0._1._1._1._1.ctor === "[]")
                                                    {
                                                          return {ctor: "_Tuple2"
                                                                 ,_0: _p156
                                                                 ,_1: ARgba(valsToRgba(_U.list([_p150._1._0._0
                                                                                               ,_p150._1._0._1._0
                                                                                               ,_p150._1._0._1._1._0
                                                                                               ,_p150._1._0._1._1._1._0])))};
                                                       } else {
                                                          break _v71_12;
                                                       }
                                                 } else {
                                                    var _p151 = {ctor: "_Tuple2"
                                                                ,_0: _p150._1._0._0.v_
                                                                ,_1: _p150._1._0._1._0.v_};
                                                    if (_p151.ctor === "_Tuple2" && _p151._0.ctor === "VConst" && _p151._1.ctor === "VConst")
                                                    {
                                                          return {ctor: "_Tuple2"
                                                                 ,_0: _p156
                                                                 ,_1: AColorNum({ctor: "_Tuple2"
                                                                                ,_0: _p151._0._0
                                                                                ,_1: $Maybe.Just(_p151._1._0)})};
                                                       } else {
                                                          return _U.crashCase("LangSvg",
                                                          {start: {line: 181,column: 11},end: {line: 183,column: 70}},
                                                          _p151)("valToAttr: fill");
                                                       }
                                                 }
                                           } else {
                                              break _v71_12;
                                           }
                                      case "stroke":
                                      if (_p150._1._0.ctor === "::" && _p150._1._0._1.ctor === "::") {
                                              if (_p150._1._0._1._1.ctor === "::") {
                                                    if (_p150._1._0._1._1._1.ctor === "::" && _p150._1._0._1._1._1._1.ctor === "[]")
                                                    {
                                                          return {ctor: "_Tuple2"
                                                                 ,_0: _p156
                                                                 ,_1: ARgba(valsToRgba(_U.list([_p150._1._0._0
                                                                                               ,_p150._1._0._1._0
                                                                                               ,_p150._1._0._1._1._0
                                                                                               ,_p150._1._0._1._1._1._0])))};
                                                       } else {
                                                          break _v71_12;
                                                       }
                                                 } else {
                                                    var _p153 = {ctor: "_Tuple2"
                                                                ,_0: _p150._1._0._0.v_
                                                                ,_1: _p150._1._0._1._0.v_};
                                                    if (_p153.ctor === "_Tuple2" && _p153._0.ctor === "VConst" && _p153._1.ctor === "VConst")
                                                    {
                                                          return {ctor: "_Tuple2"
                                                                 ,_0: _p156
                                                                 ,_1: AColorNum({ctor: "_Tuple2"
                                                                                ,_0: _p153._0._0
                                                                                ,_1: $Maybe.Just(_p153._1._0)})};
                                                       } else {
                                                          return _U.crashCase("LangSvg",
                                                          {start: {line: 185,column: 11},end: {line: 187,column: 72}},
                                                          _p153)("valToAttr: stroke");
                                                       }
                                                 }
                                           } else {
                                              break _v71_12;
                                           }
                                      case "d": return {ctor: "_Tuple2"
                                                       ,_0: _p156
                                                       ,_1: APath2(valsToPath2(_p150._1._0))};
                                      case "transform": return {ctor: "_Tuple2"
                                                               ,_0: _p156
                                                               ,_1: ATransform(valsToTransform(_p150._1._0))};
                                      case "BOUNDS": return {ctor: "_Tuple2"
                                                            ,_0: _p156
                                                            ,_1: ABounds(valToBounds(_p150._1._0))};
                                      default: break _v71_12;}
                                 case "VConst": switch (_p150._0)
                                   {case "fill": return {ctor: "_Tuple2"
                                                        ,_0: _p156
                                                        ,_1: AColorNum({ctor: "_Tuple2"
                                                                       ,_0: _p150._1._0
                                                                       ,_1: $Maybe.Nothing})};
                                      case "stroke": return {ctor: "_Tuple2"
                                                            ,_0: _p156
                                                            ,_1: AColorNum({ctor: "_Tuple2"
                                                                           ,_0: _p150._1._0
                                                                           ,_1: $Maybe.Nothing})};
                                      default: return {ctor: "_Tuple2"
                                                      ,_0: _p156
                                                      ,_1: ANum(_p150._1._0)};}
                                 case "VBase": if (_p150._1._0.ctor === "VString") {
                                         return {ctor: "_Tuple2"
                                                ,_0: _p156
                                                ,_1: AString(_p150._1._0._0)};
                                      } else {
                                         break _v71_12;
                                      }
                                 default: break _v71_12;}
                           } else {
                              break _v71_12;
                           }
                     } while (false);
                     return _U.crashCase("LangSvg",
                     {start: {line: 171,column: 7},end: {line: 198,column: 59}},
                     _p150)("valToAttr");
                  }();
                  var k$ = _p149._0;
                  var av_ = _p149._1;
                  return {ctor: "_Tuple2",_0: k$,_1: A2(AVal,av_,_p158.vtrace)};
               } else {
                  return _U.crashCase("LangSvg",
                  {start: {line: 168,column: 20},end: {line: 202,column: 30}},
                  _p148)("valToAttr");
               }
         } else {
            return _U.crashCase("LangSvg",
            {start: {line: 167,column: 15},end: {line: 204,column: 28}},
            _p147)("valToAttr");
         }
   };
   var valToIndexedTree_ = F2(function (v,_p160) {
      var _p161 = _p160;
      var _p172 = _p161._0;
      var _p171 = _p161._1;
      var _p162 = v.v_;
      if (_p162.ctor === "VList") {
            var _p163 = A2($List.map,
            function (_) {
               return _.v_;
            },
            _p162._0);
            _v76_2: do {
               if (_p163.ctor === "::" && _p163._0.ctor === "VBase" && _p163._0._0.ctor === "VString" && _p163._1.ctor === "::")
               {
                     if (_p163._1._1.ctor === "[]") {
                           if (_p163._0._0._0 === "TEXT" && _p163._1._0.ctor === "VBase" && _p163._1._0._0.ctor === "VString")
                           {
                                 return $Result.Ok({ctor: "_Tuple2"
                                                   ,_0: 1 + _p172
                                                   ,_1: A3($Dict.insert,_p172,TextNode(_p163._1._0._0._0),_p171)});
                              } else {
                                 break _v76_2;
                              }
                        } else {
                           if (_p163._1._0.ctor === "VList" && _p163._1._1._0.ctor === "VList" && _p163._1._1._1.ctor === "[]")
                           {
                                 var processChild = F2(function (vi,acc) {
                                    var _p164 = acc;
                                    if (_p164.ctor === "Err") {
                                          return acc;
                                       } else {
                                          return A2($Result.map,
                                          function (_p165) {
                                             var _p166 = _p165;
                                             var _p167 = _p166._0;
                                             var a_children$ = A2($List._op["::"],_p167 - 1,_p164._0._2);
                                             return {ctor: "_Tuple3",_0: _p167,_1: _p166._1,_2: a_children$};
                                          },
                                          A2(valToIndexedTree_,
                                          vi,
                                          {ctor: "_Tuple2",_0: _p164._0._0,_1: _p164._0._1}));
                                       }
                                 });
                                 return A2($Result.map,
                                 function (_p168) {
                                    var _p169 = _p168;
                                    var _p170 = _p169._0;
                                    var node = A3(SvgNode,
                                    _p163._0._0._0,
                                    A2($List.map,valToAttr,_p163._1._0._0),
                                    $List.reverse(_p169._2));
                                    return {ctor: "_Tuple2"
                                           ,_0: 1 + _p170
                                           ,_1: A3($Dict.insert,_p170,node,_p169._1)};
                                 },
                                 A3($List.foldl,
                                 processChild,
                                 $Result.Ok({ctor: "_Tuple3"
                                            ,_0: _p172
                                            ,_1: _p171
                                            ,_2: _U.list([])}),
                                 _p163._1._1._0._0));
                              } else {
                                 break _v76_2;
                              }
                        }
                  } else {
                     break _v76_2;
                  }
            } while (false);
            return $Result.Err(A2(expectedButGotStr,
            "an SVG node",
            $Lang.strVal(v)));
         } else {
            return $Result.Err(A2(expectedButGotStr,
            "an SVG node",
            $Lang.strVal(v)));
         }
   });
   var valToIndexedTree = function (v) {
      return A2($Result.map,
      function (_p173) {
         var _p174 = _p173;
         var rootId = _p174._0 - 1;
         return {ctor: "_Tuple2",_0: rootId,_1: _p174._1};
      },
      A2(valToIndexedTree_,
      v,
      {ctor: "_Tuple2",_0: 1,_1: $Dict.empty}));
   };
   var emptyTree = A2($Utils.fromOk,
   "LangSvg.emptyTree",
   valToIndexedTree($Lang.vList(_U.list([$Lang.vBase($Lang.VString("svg"))
                                        ,$Lang.vList(_U.list([]))
                                        ,$Lang.vList(_U.list([]))]))));
   var fetchEverything = F4(function (slideNumber,
   movieNumber,
   movieTime,
   val) {
      return A2($Result.andThen,
      A4(fetchEverything_,slideNumber,movieNumber,movieTime,val),
      function (_p175) {
         var _p176 = _p175;
         return A2($Result.map,
         function (indexedTree) {
            return {ctor: "_Tuple5"
                   ,_0: _p176._0
                   ,_1: _p176._1
                   ,_2: _p176._2
                   ,_3: _p176._3
                   ,_4: indexedTree};
         },
         valToIndexedTree(_p176._4));
      });
   });
   var resolveToIndexedTree = F4(function (slideNumber,
   movieNumber,
   movieTime,
   val) {
      return A2($Result.map,
      function (_p177) {
         var _p178 = _p177;
         return _p178._4;
      },
      A4(fetchEverything,slideNumber,movieNumber,movieTime,val));
   });
   var toNum = function (a) {
      var _p179 = a.av_;
      if (_p179.ctor === "ANum") {
            return _p179._0;
         } else {
            return A2(expectedButGot,"a number",strAVal(a));
         }
   };
   var toColorNum = function (a) {
      var _p180 = a.av_;
      if (_p180.ctor === "AColorNum") {
            return _p180._0;
         } else {
            return A2(expectedButGot,"a color number",strAVal(a));
         }
   };
   var toNumIsh = function (a) {
      var _p181 = a.av_;
      _v85_2: do {
         switch (_p181.ctor)
         {case "ANum": return _p181._0;
            case "AColorNum": if (_p181._0.ctor === "_Tuple2") {
                    return _p181._0._0;
                 } else {
                    break _v85_2;
                 }
            default: break _v85_2;}
      } while (false);
      return A2(expectedButGot,"a number or color number",strAVal(a));
   };
   var findNumishAttr = F3(function (id,attr,attrs) {
      return toNumIsh(A2(findAVal,attr,attrs));
   });
   var toPoints = function (a) {
      var _p182 = a.av_;
      if (_p182.ctor === "APoints") {
            return _p182._0;
         } else {
            return A2(expectedButGot,"a list of points",strAVal(a));
         }
   };
   var getPolyPoints = function (attrs) {
      var _p183 = A2($Utils.maybeFind,"points",attrs);
      if (_p183.ctor === "Just") {
            return toPoints(_p183._0);
         } else {
            return _U.crashCase("LangSvg",
            {start: {line: 552,column: 3},end: {line: 554,column: 45}},
            _p183)("getPolyPoints");
         }
   };
   var getPtCount = function (attrs) {
      return $List.length(getPolyPoints(attrs));
   };
   var getPolyPoint = F2(function (attrs,i) {
      return A2($Utils.geti,i,getPolyPoints(attrs));
   });
   var toPath = function (a) {
      var _p185 = a.av_;
      if (_p185.ctor === "APath2") {
            return _p185._0;
         } else {
            return A2(expectedButGot,"path commands",strAVal(a));
         }
   };
   var pathIndexPoints = function (nodeAttrs) {
      var cmds = $Basics.fst(toPath(A3($Utils.find,
      A2($Basics._op["++"],
      "pathPoints nodeAttrs looking for \"d\" in ",
      $Basics.toString(nodeAttrs)),
      nodeAttrs,
      "d")));
      var pts = A2($List.filterMap,
      function (_p186) {
         var _p187 = _p186;
         var _p188 = _p187._0;
         if (_p188.ctor === "Nothing") {
               return $Maybe.Nothing;
            } else {
               return $Maybe.Just({ctor: "_Tuple2"
                                  ,_0: _p188._0
                                  ,_1: _p187._1});
            }
      },
      A2($List.concatMap,
      function (cmd) {
         var _p189 = cmd;
         switch (_p189.ctor)
         {case "CmdZ": return _U.list([]);
            case "CmdMLT": return _U.list([_p189._1]);
            case "CmdHV": return _U.list([]);
            case "CmdC": return _U.list([_p189._1,_p189._2,_p189._3]);
            case "CmdSQ": return _U.list([_p189._1,_p189._2]);
            default: return _U.list([_p189._6]);}
      },
      cmds));
      return pts;
   };
   var getPathPoint = F2(function (attrs,i) {
      var _p190 = A2($Utils.maybeFind,i,pathIndexPoints(attrs));
      if (_p190.ctor === "Just") {
            return _p190._0;
         } else {
            return _U.crashCase("LangSvg",
            {start: {line: 558,column: 3},end: {line: 560,column: 42}},
            _p190)("getPathPoint");
         }
   });
   var toTransformRot = function (a) {
      var _p192 = a.av_;
      if (_p192.ctor === "ATransform" && _p192._0.ctor === "::" && _p192._0._0.ctor === "Rot" && _p192._0._1.ctor === "[]")
      {
            return {ctor: "_Tuple3"
                   ,_0: _p192._0._0._0
                   ,_1: _p192._0._0._1
                   ,_2: _p192._0._0._2};
         } else {
            return A2(expectedButGot,"a rotation transform",strAVal(a));
         }
   };
   var attr = $VirtualDom.attribute;
   var compileAttr = F2(function (k,v) {
      return A2(attr,k,strAVal(v));
   });
   var compileAttrs = $List.map($Basics.uncurry(compileAttr));
   return _elm.LangSvg.values = {_op: _op
                                ,attr: attr
                                ,foldSlateNodeInfo: foldSlateNodeInfo
                                ,maxColorNum: maxColorNum
                                ,maxStrokeWidthNum: maxStrokeWidthNum
                                ,emptyTree: emptyTree
                                ,dummySvgNode: dummySvgNode
                                ,valToIndexedTree: valToIndexedTree
                                ,printSvg: printSvg
                                ,compileAttr: compileAttr
                                ,compileAttrs: compileAttrs
                                ,desugarShapeAttrs: desugarShapeAttrs
                                ,strAVal: strAVal
                                ,aNum: aNum
                                ,aPoints: aPoints
                                ,aTransform: aTransform
                                ,toNum: toNum
                                ,toColorNum: toColorNum
                                ,toTransformRot: toTransformRot
                                ,toPath: toPath
                                ,valsToPath2: valsToPath2
                                ,findNumishAttr: findNumishAttr
                                ,findAVal: findAVal
                                ,getPolyPoints: getPolyPoints
                                ,getPolyPoint: getPolyPoint
                                ,getPtCount: getPtCount
                                ,pathIndexPoints: pathIndexPoints
                                ,getPathPoint: getPathPoint
                                ,maybeFindBounds: maybeFindBounds
                                ,maybeFindBlobId: maybeFindBlobId
                                ,justGetSvgNode: justGetSvgNode
                                ,resolveToIndexedTree: resolveToIndexedTree
                                ,resolveToMovieFrameVal: resolveToMovieFrameVal
                                ,resolveToMovieCount: resolveToMovieCount
                                ,fetchEverything: fetchEverything
                                ,AVal: AVal
                                ,PathCounts: PathCounts
                                ,ANum: ANum
                                ,AString: AString
                                ,APoints: APoints
                                ,ARgba: ARgba
                                ,AColorNum: AColorNum
                                ,APath2: APath2
                                ,ATransform: ATransform
                                ,ABounds: ABounds
                                ,CmdZ: CmdZ
                                ,CmdMLT: CmdMLT
                                ,CmdHV: CmdHV
                                ,CmdC: CmdC
                                ,CmdSQ: CmdSQ
                                ,CmdA: CmdA
                                ,Rot: Rot
                                ,Scale: Scale
                                ,Trans: Trans
                                ,TextNode: TextNode
                                ,SvgNode: SvgNode};
};
Elm.ShapeWidgets = Elm.ShapeWidgets || {};
Elm.ShapeWidgets.make = function (_elm) {
   "use strict";
   _elm.ShapeWidgets = _elm.ShapeWidgets || {};
   if (_elm.ShapeWidgets.values) return _elm.ShapeWidgets.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Regex = Elm.Regex.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var wOpacitySlider = 20;
   var wStrokeWidthSlider = 60;
   var wColorSlider = 250;
   var unparseZone = function (z) {
      var _p0 = z;
      switch (_p0.ctor)
      {case "ZInterior": return "Interior";
         case "ZPoint": switch (_p0._0.ctor)
           {case "Point": return A2($Basics._op["++"],
                "Point",
                $Basics.toString(_p0._0._0));
              case "TopLeft": return "TopLeft";
              case "TopRight": return "TopRight";
              case "BotLeft": return "BotLeft";
              case "BotRight": return "BotRight";
              case "TopEdge": return "TopEdge";
              case "RightEdge": return "RightEdge";
              case "BotEdge": return "BotEdge";
              case "LeftEdge": return "LeftEdge";
              case "Midpoint": return _U.crashCase("ShapeWidgets",
                {start: {line: 746,column: 3},end: {line: 772,column: 41}},
                _p0)(A2($Basics._op["++"],"unparseZone: ",$Basics.toString(z)));
              default: return _U.crashCase("ShapeWidgets",
                {start: {line: 746,column: 3},end: {line: 772,column: 41}},
                _p0)(A2($Basics._op["++"],
                "unparseZone: ",
                $Basics.toString(z)));}
         case "ZLineEdge": return "Edge";
         case "ZPolyEdge": return A2($Basics._op["++"],
           "Edge",
           $Basics.toString(_p0._0));
         case "ZOther": switch (_p0._0.ctor)
           {case "FillColor": return "FillBall";
              case "StrokeColor": return "StrokeBall";
              case "FillOpacity": return "FillOpacityBall";
              case "StrokeOpacity": return "StrokeOpacityBall";
              case "StrokeWidth": return "StrokeWidthBall";
              default: return "RotateBall";}
         default: return "SliderBall";}
   };
   var ZSlider = {ctor: "ZSlider"};
   var ZOther = function (a) {    return {ctor: "ZOther",_0: a};};
   var ZPolyEdge = function (a) {
      return {ctor: "ZPolyEdge",_0: a};
   };
   var ZLineEdge = {ctor: "ZLineEdge"};
   var toEdgeZone = function (s) {
      return A2($Utils.bindMaybe,
      function (suffix) {
         return _U.eq(suffix,
         "") ? $Maybe.Just(ZLineEdge) : $Maybe.Just(ZPolyEdge($Utils.fromOk_($String.toInt(suffix))));
      },
      A2($Utils.munchString,"Edge",s));
   };
   var ZPoint = function (a) {    return {ctor: "ZPoint",_0: a};};
   var ZInterior = {ctor: "ZInterior"};
   var toInteriorZone = function (s) {
      var _p3 = s;
      if (_p3 === "Interior") {
            return $Maybe.Just(ZInterior);
         } else {
            return $Maybe.Nothing;
         }
   };
   var BoxyNums = function (a) {
      return function (b) {
         return function (c) {
            return function (d) {
               return function (e) {
                  return function (f) {
                     return function (g) {
                        return function (h) {
                           return function (i) {
                              return function (j) {
                                 return function (k) {
                                    return {left: a
                                           ,top: b
                                           ,right: c
                                           ,bot: d
                                           ,width: e
                                           ,height: f
                                           ,cx: g
                                           ,cy: h
                                           ,rx: i
                                           ,ry: j
                                           ,r: k};
                                 };
                              };
                           };
                        };
                     };
                  };
               };
            };
         };
      };
   };
   var evaluateFeatureEquation = function (eqn) {
      var _p4 = eqn;
      _v2_2: do {
         if (_p4.ctor === "EqnNum") {
               if (_p4._0.ctor === "_Tuple2") {
                     return $Maybe.Just(_p4._0._0);
                  } else {
                     break _v2_2;
                  }
            } else {
               if (_p4._1.ctor === "::" && _p4._1._1.ctor === "::" && _p4._1._1._1.ctor === "[]")
               {
                     var maybePerformBinop = function (op) {
                        var maybeLeftResult = evaluateFeatureEquation(_p4._1._0);
                        var maybeRightResult = evaluateFeatureEquation(_p4._1._1._0);
                        var _p5 = {ctor: "_Tuple2"
                                  ,_0: maybeLeftResult
                                  ,_1: maybeRightResult};
                        if (_p5.ctor === "_Tuple2" && _p5._0.ctor === "Just" && _p5._1.ctor === "Just")
                        {
                              return $Maybe.Just(A2(op,_p5._0._0,_p5._1._0));
                           } else {
                              return $Maybe.Nothing;
                           }
                     };
                     var _p6 = _p4._0;
                     switch (_p6.ctor)
                     {case "Plus": return maybePerformBinop(F2(function (x,y) {
                             return x + y;
                          }));
                        case "Minus": return maybePerformBinop(F2(function (x,y) {
                             return x - y;
                          }));
                        case "Mult": return maybePerformBinop(F2(function (x,y) {
                             return x * y;
                          }));
                        case "Div": return maybePerformBinop(F2(function (x,y) {
                             return x / y;
                          }));
                        default: return $Maybe.Nothing;}
                  } else {
                     break _v2_2;
                  }
            }
      } while (false);
      return $Maybe.Nothing;
   };
   var evaluateFeatureEquation_ = function (_p7) {
      return A2($Utils.fromJust_,
      "evaluateFeatureEquation_",
      evaluateFeatureEquation(_p7));
   };
   var BoxyFeatureEquations = function (a) {
      return function (b) {
         return function (c) {
            return function (d) {
               return function (e) {
                  return function (f) {
                     return function (g) {
                        return function (h) {
                           return function (i) {
                              return function (j) {
                                 return function (k) {
                                    return {left: a
                                           ,top: b
                                           ,right: c
                                           ,bottom: d
                                           ,cx: e
                                           ,cy: f
                                           ,mWidth: g
                                           ,mHeight: h
                                           ,mRadius: i
                                           ,mRadiusX: j
                                           ,mRadiusY: k};
                                 };
                              };
                           };
                        };
                     };
                  };
               };
            };
         };
      };
   };
   var EqnOp = F2(function (a,b) {
      return {ctor: "EqnOp",_0: a,_1: b};
   });
   var plus = F2(function (a,b) {
      return A2(EqnOp,$Lang.Plus,_U.list([a,b]));
   });
   var minus = F2(function (a,b) {
      return A2(EqnOp,$Lang.Minus,_U.list([a,b]));
   });
   var div = F2(function (a,b) {
      return A2(EqnOp,$Lang.Div,_U.list([a,b]));
   });
   var EqnNum = function (a) {    return {ctor: "EqnNum",_0: a};};
   var two = EqnNum({ctor: "_Tuple2",_0: 2,_1: $Lang.dummyTrace});
   var boxyFeatureEquationsOf = F3(function (id,kind,attrs) {
      var get = function (attr) {
         return EqnNum(A3($LangSvg.findNumishAttr,id,attr,attrs));
      };
      var _p8 = kind;
      switch (_p8)
      {case "rect": return {left: get("x")
                           ,top: get("y")
                           ,right: A2(plus,get("x"),get("width"))
                           ,bottom: A2(plus,get("y"),get("height"))
                           ,cx: A2(plus,get("x"),A2(div,get("width"),two))
                           ,cy: A2(plus,get("y"),A2(div,get("height"),two))
                           ,mWidth: $Maybe.Just(get("width"))
                           ,mHeight: $Maybe.Just(get("height"))
                           ,mRadius: $Maybe.Nothing
                           ,mRadiusX: $Maybe.Nothing
                           ,mRadiusY: $Maybe.Nothing};
         case "BOX": return {left: get("LEFT")
                            ,top: get("TOP")
                            ,right: get("RIGHT")
                            ,bottom: get("BOT")
                            ,cx: A2(div,A2(plus,get("LEFT"),get("RIGHT")),two)
                            ,cy: A2(div,A2(plus,get("TOP"),get("BOT")),two)
                            ,mWidth: $Maybe.Just(A2(minus,get("RIGHT"),get("LEFT")))
                            ,mHeight: $Maybe.Just(A2(minus,get("BOT"),get("TOP")))
                            ,mRadius: $Maybe.Nothing
                            ,mRadiusX: $Maybe.Nothing
                            ,mRadiusY: $Maybe.Nothing};
         case "OVAL": return {left: get("LEFT")
                             ,top: get("TOP")
                             ,right: get("RIGHT")
                             ,bottom: get("BOT")
                             ,cx: A2(div,A2(plus,get("LEFT"),get("RIGHT")),two)
                             ,cy: A2(div,A2(plus,get("TOP"),get("BOT")),two)
                             ,mWidth: $Maybe.Nothing
                             ,mHeight: $Maybe.Nothing
                             ,mRadius: $Maybe.Nothing
                             ,mRadiusX: $Maybe.Just(A2(div,
                             A2(minus,get("RIGHT"),get("LEFT")),
                             two))
                             ,mRadiusY: $Maybe.Just(A2(div,
                             A2(minus,get("BOT"),get("TOP")),
                             two))};
         case "circle": return {left: A2(minus,get("cx"),get("r"))
                               ,top: A2(minus,get("cy"),get("r"))
                               ,right: A2(plus,get("cx"),get("r"))
                               ,bottom: A2(plus,get("cy"),get("r"))
                               ,cx: get("cx")
                               ,cy: get("cy")
                               ,mWidth: $Maybe.Nothing
                               ,mHeight: $Maybe.Nothing
                               ,mRadius: $Maybe.Just(get("r"))
                               ,mRadiusX: $Maybe.Nothing
                               ,mRadiusY: $Maybe.Nothing};
         case "ellipse": return {left: A2(minus,get("cx"),get("rx"))
                                ,top: A2(minus,get("cy"),get("ry"))
                                ,right: A2(plus,get("cx"),get("rx"))
                                ,bottom: A2(plus,get("cy"),get("ry"))
                                ,cx: get("cx")
                                ,cy: get("cy")
                                ,mWidth: $Maybe.Nothing
                                ,mHeight: $Maybe.Nothing
                                ,mRadius: $Maybe.Nothing
                                ,mRadiusX: $Maybe.Just(get("rx"))
                                ,mRadiusY: $Maybe.Just(get("ry"))};
         default: return _U.crashCase("ShapeWidgets",
           {start: {line: 560,column: 3},end: {line: 632,column: 59}},
           _p8)(A2($Basics._op["++"],"boxyFeatureEquationsOf: ",kind));}
   });
   var evaluateBoxyNums = F3(function (id,kind,attrs) {
      var equations = A3(boxyFeatureEquationsOf,id,kind,attrs);
      var _p10 = {ctor: "_Tuple6"
                 ,_0: evaluateFeatureEquation_(equations.left)
                 ,_1: evaluateFeatureEquation_(equations.top)
                 ,_2: evaluateFeatureEquation_(equations.right)
                 ,_3: evaluateFeatureEquation_(equations.bottom)
                 ,_4: evaluateFeatureEquation_(equations.cx)
                 ,_5: evaluateFeatureEquation_(equations.cy)};
      var left = _p10._0;
      var top = _p10._1;
      var right = _p10._2;
      var bot = _p10._3;
      var cx = _p10._4;
      var cy = _p10._5;
      var height = bot - top;
      var ry = height / 2;
      var width = right - left;
      var rx = width / 2;
      return {left: left
             ,top: top
             ,right: right
             ,bot: bot
             ,width: width
             ,height: height
             ,cx: cx
             ,cy: cy
             ,rx: rx
             ,ry: ry
             ,r: rx};
   });
   var assertString = F2(function (string,result) {
      return _U.eq(result,
      string) ? string : _U.crash("ShapeWidgets",
      {start: {line: 274,column: 8}
      ,end: {line: 274
            ,column: 19}})($Utils.spaces(_U.list(["assertString:"
                                                 ,result
                                                 ,"/= "
                                                 ,string])));
   });
   var selectedTypeWidget = "widget";
   var selectedTypeShapeFeature = "shapeFeature";
   var shapeKindRegexStr = "line|rect|circle|ellipse|polygon|path|box|oval";
   var xShapeFeatureRegex = $Regex.regex(A2($Basics._op["++"],
   "^(",
   A2($Basics._op["++"],shapeKindRegexStr,")(.*)X(\\d*)$")));
   var yShapeFeatureRegex = $Regex.regex(A2($Basics._op["++"],
   "^(",
   A2($Basics._op["++"],shapeKindRegexStr,")(.*)Y(\\d*)$")));
   var distanceFeatureRegex = $Regex.regex(A2($Basics._op["++"],
   "^(",
   A2($Basics._op["++"],
   shapeKindRegexStr,
   ")(Width|Height|R|RX|RY)$")));
   var strOtherFeature = function (otherFeature) {
      var _p11 = otherFeature;
      switch (_p11.ctor)
      {case "FillColor": return "fill";
         case "StrokeColor": return "stroke";
         case "FillOpacity": return "fillOpacity";
         case "StrokeOpacity": return "strokeOpacity";
         case "StrokeWidth": return "strokeWidth";
         default: return "rotation";}
   };
   var strDistanceFeature = function (distanceFeature) {
      var _p12 = distanceFeature;
      switch (_p12.ctor)
      {case "Width": return "Width";
         case "Height": return "Height";
         case "Radius": return "R";
         case "RadiusX": return "RX";
         default: return "RY";}
   };
   var strPointFeature = F2(function (pointFeature,xy) {
      var _p13 = pointFeature;
      switch (_p13.ctor)
      {case "TopLeft": return A2($Basics._op["++"],"TL",xy);
         case "TopRight": return A2($Basics._op["++"],"TR",xy);
         case "BotLeft": return A2($Basics._op["++"],"BL",xy);
         case "BotRight": return A2($Basics._op["++"],"BR",xy);
         case "TopEdge": return A2($Basics._op["++"],"TC",xy);
         case "RightEdge": return A2($Basics._op["++"],"CR",xy);
         case "BotEdge": return A2($Basics._op["++"],"BC",xy);
         case "LeftEdge": return A2($Basics._op["++"],"CL",xy);
         case "Center": return A2($Basics._op["++"],"C",xy);
         case "Point": return A2($Basics._op["++"],
           "Pt",
           A2($Basics._op["++"],xy,$Basics.toString(_p13._0)));
         default: return A2($Basics._op["++"],
           "Midpt",
           A2($Basics._op["++"],xy,$Basics.toString(_p13._0)));}
   });
   var strFeatureNum = F2(function (kind,featureNum) {
      var _p14 = {ctor: "_Tuple2",_0: kind,_1: featureNum};
      _v9_5: do {
         _v9_4: do {
            switch (_p14._1.ctor)
            {case "X":
               if (_p14._0 === "line" && _p14._1._0.ctor === "Point") {
                       switch (_p14._1._0._0)
                       {case 1: return "X1";
                          case 2: return "X2";
                          default: break _v9_4;}
                    } else {
                       break _v9_4;
                    }
               case "Y": if (_p14._0 === "line" && _p14._1._0.ctor === "Point")
                 {
                       switch (_p14._1._0._0)
                       {case 1: return "Y1";
                          case 2: return "Y2";
                          default: break _v9_5;}
                    } else {
                       break _v9_5;
                    }
               case "D": return strDistanceFeature(_p14._1._0);
               default: return strOtherFeature(_p14._1._0);}
         } while (false);
         return A2(strPointFeature,_p14._1._0,"X");
      } while (false);
      return A2(strPointFeature,_p14._1._0,"Y");
   });
   var unparseFeatureNum = F2(function (mKind,featureNum) {
      var _p15 = mKind;
      if (_p15.ctor === "Just") {
            var _p16 = _p15._0;
            return A2($Basics._op["++"],
            $String.toLower(_p16),
            A2(strFeatureNum,_p16,featureNum));
         } else {
            return A2(strFeatureNum,"XXX",featureNum);
         }
   });
   var sanityCheck = F3(function (string,kind,featureNum) {
      return A2(assertString,
      string,
      A2(unparseFeatureNum,$Maybe.Just(kind),featureNum));
   });
   var sanityCheckOther = F2(function (string,featureNum) {
      return A2(assertString,
      string,
      A2(unparseFeatureNum,$Maybe.Nothing,featureNum));
   });
   var featureEquationOf = F4(function (id,kind,attrs,featureNum) {
      var get = function (attr) {
         return EqnNum(A3($LangSvg.findNumishAttr,id,attr,attrs));
      };
      var crash = function (_p17) {
         var _p18 = _p17;
         var s = A2(unparseFeatureNum,$Maybe.Just(kind),featureNum);
         return _U.crash("ShapeWidgets",
         {start: {line: 452,column: 5}
         ,end: {line: 452
               ,column: 16}})($Utils.spaces(_U.list(["featureEquationOf:"
                                                    ,kind
                                                    ,s])));
      };
      var handleLine = function (_p19) {
         var _p20 = _p19;
         var _p21 = featureNum;
         _v13_6: do {
            switch (_p21.ctor)
            {case "X": switch (_p21._0.ctor)
                 {case "Point": switch (_p21._0._0)
                      {case 1: return get("x1");
                         case 2: return get("x2");
                         default: break _v13_6;}
                    case "Center": return A2(div,A2(plus,get("x1"),get("x2")),two);
                    default: break _v13_6;}
               case "Y": switch (_p21._0.ctor)
                 {case "Point": switch (_p21._0._0)
                      {case 1: return get("y1");
                         case 2: return get("y2");
                         default: break _v13_6;}
                    case "Center": return A2(div,A2(plus,get("y1"),get("y2")),two);
                    default: break _v13_6;}
               default: break _v13_6;}
         } while (false);
         return crash({ctor: "_Tuple0"});
      };
      var handleBoxyShape = function (_p22) {
         var _p23 = _p22;
         var equations = A3(boxyFeatureEquationsOf,id,kind,attrs);
         var _p24 = featureNum;
         _v15_19: do {
            switch (_p24.ctor)
            {case "X": switch (_p24._0.ctor)
                 {case "TopLeft": return equations.left;
                    case "TopRight": return equations.right;
                    case "BotLeft": return equations.left;
                    case "BotRight": return equations.right;
                    case "TopEdge": return equations.cx;
                    case "BotEdge": return equations.cx;
                    case "LeftEdge": return equations.left;
                    case "RightEdge": return equations.right;
                    case "Center": return equations.cx;
                    default: break _v15_19;}
               case "Y": switch (_p24._0.ctor)
                 {case "TopLeft": return equations.top;
                    case "TopRight": return equations.top;
                    case "BotLeft": return equations.bottom;
                    case "BotRight": return equations.bottom;
                    case "TopEdge": return equations.top;
                    case "BotEdge": return equations.bottom;
                    case "LeftEdge": return equations.cy;
                    case "RightEdge": return equations.cy;
                    case "Center": return equations.cy;
                    default: break _v15_19;}
               case "D": var _p26 = _p24._0;
                 var s = strDistanceFeature(_p26);
                 var cap = $Utils.spaces(_U.list(["shapeFeatureEquationOf:"
                                                 ,kind
                                                 ,s]));
                 var _p25 = _p26;
                 switch (_p25.ctor)
                 {case "Width": return A2($Utils.fromJust_,cap,equations.mWidth);
                    case "Height": return A2($Utils.fromJust_,
                      cap,
                      equations.mHeight);
                    case "Radius": return A2($Utils.fromJust_,
                      cap,
                      equations.mRadius);
                    case "RadiusX": return A2($Utils.fromJust_,
                      cap,
                      equations.mRadiusX);
                    default: return A2($Utils.fromJust_,cap,equations.mRadiusY);}
               default: break _v15_19;}
         } while (false);
         return crash({ctor: "_Tuple0"});
      };
      var handlePath = function (_p27) {
         var _p28 = _p27;
         var x = function (i) {
            return EqnNum($Basics.fst(A2($LangSvg.getPathPoint,
            attrs,
            i)));
         };
         var y = function (i) {
            return EqnNum($Basics.snd(A2($LangSvg.getPathPoint,
            attrs,
            i)));
         };
         var _p29 = featureNum;
         _v18_2: do {
            switch (_p29.ctor)
            {case "X": if (_p29._0.ctor === "Point") {
                       return x(_p29._0._0);
                    } else {
                       break _v18_2;
                    }
               case "Y": if (_p29._0.ctor === "Point") {
                       return y(_p29._0._0);
                    } else {
                       break _v18_2;
                    }
               default: break _v18_2;}
         } while (false);
         return crash({ctor: "_Tuple0"});
      };
      var handlePoly = function (_p30) {
         var _p31 = _p30;
         var ptCount = $LangSvg.getPtCount(attrs);
         var x = function (i) {
            return EqnNum($Basics.fst(A2($LangSvg.getPolyPoint,
            attrs,
            i)));
         };
         var y = function (i) {
            return EqnNum($Basics.snd(A2($LangSvg.getPolyPoint,
            attrs,
            i)));
         };
         var _p32 = featureNum;
         _v20_4: do {
            switch (_p32.ctor)
            {case "X": switch (_p32._0.ctor)
                 {case "Point": return x(_p32._0._0);
                    case "Midpoint": var _p33 = _p32._0._0;
                      var i2 = _U.eq(_p33,ptCount) ? 1 : _p33 + 1;
                      return A2(div,A2(plus,x(_p33),x(i2)),two);
                    default: break _v20_4;}
               case "Y": switch (_p32._0.ctor)
                 {case "Point": return y(_p32._0._0);
                    case "Midpoint": var _p34 = _p32._0._0;
                      var i2 = _U.eq(_p34,ptCount) ? 1 : _p34 + 1;
                      return A2(div,A2(plus,y(_p34),y(i2)),two);
                    default: break _v20_4;}
               default: break _v20_4;}
         } while (false);
         return crash({ctor: "_Tuple0"});
      };
      var _p35 = featureNum;
      if (_p35.ctor === "O") {
            switch (_p35._0.ctor)
            {case "FillColor": return get("fill");
               case "StrokeColor": return get("stroke");
               case "StrokeWidth": return get("stroke-width");
               case "FillOpacity": var _p36 = A2($Utils.find_,
                 attrs,
                 "fill").av_;
                 if (_p36.ctor === "AColorNum" && _p36._0.ctor === "_Tuple2" && _p36._0._1.ctor === "Just")
                 {
                       return EqnNum(_p36._0._1._0);
                    } else {
                       return _U.crashCase("ShapeWidgets",
                       {start: {line: 532,column: 7},end: {line: 534,column: 92}},
                       _p36)("featureEquationOf: fillOpacity");
                    }
               case "StrokeOpacity": var _p38 = A2($Utils.find_,
                 attrs,
                 "stroke").av_;
                 if (_p38.ctor === "AColorNum" && _p38._0.ctor === "_Tuple2" && _p38._0._1.ctor === "Just")
                 {
                       return EqnNum(_p38._0._1._0);
                    } else {
                       return _U.crashCase("ShapeWidgets",
                       {start: {line: 536,column: 7},end: {line: 538,column: 94}},
                       _p38)("featureEquationOf: strokeOpacity");
                    }
               default: var _p40 = $LangSvg.toTransformRot(A2($Utils.find_,
                 attrs,
                 "transform"));
                 var rot = _p40._0;
                 var cx = _p40._1;
                 var cy = _p40._2;
                 return EqnNum(rot);}
         } else {
            var _p41 = kind;
            switch (_p41)
            {case "line": return handleLine({ctor: "_Tuple0"});
               case "polygon": return handlePoly({ctor: "_Tuple0"});
               case "polyline": return handlePoly({ctor: "_Tuple0"});
               case "path": return handlePath({ctor: "_Tuple0"});
               case "rect": return handleBoxyShape({ctor: "_Tuple0"});
               case "BOX": return handleBoxyShape({ctor: "_Tuple0"});
               case "circle": return handleBoxyShape({ctor: "_Tuple0"});
               case "ellipse": return handleBoxyShape({ctor: "_Tuple0"});
               case "OVAL": return handleBoxyShape({ctor: "_Tuple0"});
               default: return crash({ctor: "_Tuple0"});}
         }
   });
   var O = function (a) {    return {ctor: "O",_0: a};};
   var D = function (a) {    return {ctor: "D",_0: a};};
   var Y = function (a) {    return {ctor: "Y",_0: a};};
   var X = function (a) {    return {ctor: "X",_0: a};};
   var getPointEquations = F4(function (nodeId,
   kind,
   attrs,
   pointFeature) {
      return {ctor: "_Tuple2"
             ,_0: A4(featureEquationOf,nodeId,kind,attrs,X(pointFeature))
             ,_1: A4(featureEquationOf,nodeId,kind,attrs,Y(pointFeature))};
   });
   var Rotation = {ctor: "Rotation"};
   var shapeRotation = A2(sanityCheckOther,"rotation",O(Rotation));
   var StrokeWidth = {ctor: "StrokeWidth"};
   var shapeStrokeWidth = A2(sanityCheckOther,
   "strokeWidth",
   O(StrokeWidth));
   var StrokeOpacity = {ctor: "StrokeOpacity"};
   var shapeStrokeOpacity = A2(sanityCheckOther,
   "strokeOpacity",
   O(StrokeOpacity));
   var StrokeColor = {ctor: "StrokeColor"};
   var shapeStroke = A2(sanityCheckOther,"stroke",O(StrokeColor));
   var FillOpacity = {ctor: "FillOpacity"};
   var shapeFillOpacity = A2(sanityCheckOther,
   "fillOpacity",
   O(FillOpacity));
   var FillColor = {ctor: "FillColor"};
   var shapeFill = A2(sanityCheckOther,"fill",O(FillColor));
   var toSliderZone = function (s) {
      var _p42 = s;
      switch (_p42)
      {case "FillBall": return $Maybe.Just(ZOther(FillColor));
         case "StrokeBall": return $Maybe.Just(ZOther(StrokeColor));
         case "FillOpacityBall": return $Maybe.Just(ZOther(FillOpacity));
         case "StrokeOpacityBall":
         return $Maybe.Just(ZOther(StrokeOpacity));
         case "StrokeWidthBall": return $Maybe.Just(ZOther(StrokeWidth));
         case "RotateBall": return $Maybe.Just(ZOther(Rotation));
         case "SliderBall": return $Maybe.Just(ZSlider);
         default: return $Maybe.Nothing;}
   };
   var RadiusY = {ctor: "RadiusY"};
   var RadiusX = {ctor: "RadiusX"};
   var Radius = {ctor: "Radius"};
   var Height = {ctor: "Height"};
   var Width = {ctor: "Width"};
   var parseDistanceFeature = function (matches) {
      var _p43 = matches;
      _v26_5: do {
         if (_p43.ctor === "::" && _p43._0.ctor === "Just" && _p43._1.ctor === "::" && _p43._1._0.ctor === "Just" && _p43._1._1.ctor === "[]")
         {
               switch (_p43._1._0._0)
               {case "Width": return Width;
                  case "Height": return Height;
                  case "R": return Radius;
                  case "RX": return RadiusX;
                  case "RY": return RadiusY;
                  default: break _v26_5;}
            } else {
               break _v26_5;
            }
      } while (false);
      return _U.crashCase("ShapeWidgets",
      {start: {line: 202,column: 3},end: {line: 209,column: 71}},
      _p43)(A2($Basics._op["++"],
      "parseDistanceFeature: ",
      $Basics.toString(matches)));
   };
   var Midpoint = function (a) {
      return {ctor: "Midpoint",_0: a};
   };
   var Point = function (a) {    return {ctor: "Point",_0: a};};
   var toPointZone = function (s) {
      return A2($Utils.bindMaybe,
      function (suffix) {
         return _U.eq(suffix,
         "") ? $Maybe.Nothing : $Maybe.Just(ZPoint(Point($Utils.fromOk_($String.toInt(suffix)))));
      },
      A2($Utils.munchString,"Point",s));
   };
   var Center = {ctor: "Center"};
   var evaluateLineFeatures = F2(function (id,attrs) {
      return $Utils.unwrap6(A2($List.map,
      function (_p45) {
         return evaluateFeatureEquation_(A4(featureEquationOf,
         id,
         "line",
         attrs,
         _p45));
      },
      _U.list([X(Point(1))
              ,Y(Point(1))
              ,X(Point(2))
              ,Y(Point(2))
              ,X(Center)
              ,Y(Center)])));
   });
   var LeftEdge = {ctor: "LeftEdge"};
   var BotEdge = {ctor: "BotEdge"};
   var RightEdge = {ctor: "RightEdge"};
   var TopEdge = {ctor: "TopEdge"};
   var BotRight = {ctor: "BotRight"};
   var BotLeft = {ctor: "BotLeft"};
   var TopRight = {ctor: "TopRight"};
   var TopLeft = {ctor: "TopLeft"};
   var parseShapeFeaturePoint = function (matches) {
      var _p46 = matches;
      _v27_13: do {
         if (_p46.ctor === "::" && _p46._0.ctor === "Just" && _p46._1.ctor === "::" && _p46._1._0.ctor === "Just" && _p46._1._1.ctor === "::" && _p46._1._1._0.ctor === "Just" && _p46._1._1._1.ctor === "[]")
         {
               switch (_p46._1._0._0)
               {case "TL": if (_p46._1._1._0._0 === "") {
                          return TopLeft;
                       } else {
                          break _v27_13;
                       }
                  case "TR": if (_p46._1._1._0._0 === "") {
                          return TopRight;
                       } else {
                          break _v27_13;
                       }
                  case "BL": if (_p46._1._1._0._0 === "") {
                          return BotLeft;
                       } else {
                          break _v27_13;
                       }
                  case "BR": if (_p46._1._1._0._0 === "") {
                          return BotRight;
                       } else {
                          break _v27_13;
                       }
                  case "TC": if (_p46._1._1._0._0 === "") {
                          return TopEdge;
                       } else {
                          break _v27_13;
                       }
                  case "CR": if (_p46._1._1._0._0 === "") {
                          return RightEdge;
                       } else {
                          break _v27_13;
                       }
                  case "BC": if (_p46._1._1._0._0 === "") {
                          return BotEdge;
                       } else {
                          break _v27_13;
                       }
                  case "CL": if (_p46._1._1._0._0 === "") {
                          return LeftEdge;
                       } else {
                          break _v27_13;
                       }
                  case "C": if (_p46._1._1._0._0 === "") {
                          return Center;
                       } else {
                          break _v27_13;
                       }
                  case "": switch (_p46._1._1._0._0)
                    {case "1": return Point(1);
                       case "2": return Point(2);
                       default: break _v27_13;}
                  case "Pt": return Point($Utils.parseInt(_p46._1._1._0._0));
                  case "Midpt":
                  return Midpoint($Utils.parseInt(_p46._1._1._0._0));
                  default: break _v27_13;}
            } else {
               break _v27_13;
            }
      } while (false);
      return _U.crashCase("ShapeWidgets",
      {start: {line: 212,column: 3},end: {line: 231,column: 59}},
      _p46)(A2($Basics._op["++"],
      "parsePoint: ",
      $Basics.toString(matches)));
   };
   var parseFeatureNum = function (shapeFeature) {
      if (A2($Regex.contains,distanceFeatureRegex,shapeFeature))
      return D(parseDistanceFeature(function (_) {
            return _.submatches;
         }($Utils.head_(A3($Regex.find,
         $Regex.AtMost(1),
         distanceFeatureRegex,
         shapeFeature))))); else if (A2($Regex.contains,
         xShapeFeatureRegex,
         shapeFeature)) return X(parseShapeFeaturePoint(function (_) {
               return _.submatches;
            }($Utils.head_(A3($Regex.find,
            $Regex.AtMost(1),
            xShapeFeatureRegex,
            shapeFeature))))); else if (A2($Regex.contains,
            yShapeFeatureRegex,
            shapeFeature)) return Y(parseShapeFeaturePoint(function (_) {
                  return _.submatches;
               }($Utils.head_(A3($Regex.find,
               $Regex.AtMost(1),
               yShapeFeatureRegex,
               shapeFeature))))); else {
                  var _p48 = shapeFeature;
                  switch (_p48)
                  {case "fill": return O(FillColor);
                     case "stroke": return O(StrokeColor);
                     case "fillOpacity": return O(FillOpacity);
                     case "strokeOpacity": return O(StrokeOpacity);
                     case "strokeWidth": return O(StrokeWidth);
                     case "rotation": return O(Rotation);
                     default: return _U.crashCase("ShapeWidgets",
                       {start: {line: 190,column: 5},end: {line: 199,column: 62}},
                       _p48)(A2($Basics._op["++"],"parseFeatureNum: ",shapeFeature));}
               }
   };
   var pointFeatureOf = function (_p50) {
      var _p51 = _p50;
      var _p52 = {ctor: "_Tuple2"
                 ,_0: parseFeatureNum(_p51._0)
                 ,_1: parseFeatureNum(_p51._1)};
      if (_p52.ctor === "_Tuple2" && _p52._0.ctor === "X" && _p52._1.ctor === "Y")
      {
            var _p53 = _p52._0._0;
            return _U.eq(_p53,
            _p52._1._0) ? $Maybe.Just(_p53) : $Maybe.Nothing;
         } else {
            return $Maybe.Nothing;
         }
   };
   var selectedPointFeatureOf = F2(function (selected1,selected2) {
      selectedPointFeatureOf: while (true) {
         var _p54 = selected1;
         var id1 = _p54._1;
         var feature1 = _p54._2;
         var _p55 = selected2;
         var id2 = _p55._1;
         var feature2 = _p55._2;
         if (!_U.eq(id1,id2)) return $Maybe.Nothing; else {
               var _p56 = pointFeatureOf({ctor: "_Tuple2"
                                         ,_0: feature1
                                         ,_1: feature2});
               if (_p56.ctor === "Just") {
                     return $Maybe.Just({ctor: "_Tuple2",_0: id1,_1: _p56._0});
                  } else {
                     var _v32 = selected2,_v33 = selected1;
                     selected1 = _v32;
                     selected2 = _v33;
                     continue selectedPointFeatureOf;
                  }
            }
      }
   });
   var featureEquation = F4(function (nodeId,
   kind,
   feature,
   nodeAttrs) {
      var featureNum = parseFeatureNum(feature);
      return A4(featureEquationOf,nodeId,kind,nodeAttrs,featureNum);
   });
   var toCardinalPointZone = function (s) {
      var _p57 = s;
      switch (_p57)
      {case "TopLeft": return $Maybe.Just(ZPoint(TopLeft));
         case "TopRight": return $Maybe.Just(ZPoint(TopRight));
         case "BotLeft": return $Maybe.Just(ZPoint(BotLeft));
         case "BotRight": return $Maybe.Just(ZPoint(BotRight));
         case "TopEdge": return $Maybe.Just(ZPoint(TopEdge));
         case "BotEdge": return $Maybe.Just(ZPoint(BotEdge));
         case "LeftEdge": return $Maybe.Just(ZPoint(LeftEdge));
         case "RightEdge": return $Maybe.Just(ZPoint(RightEdge));
         default: return $Maybe.Nothing;}
   };
   var realZoneOf = function (s) {
      return A2($Utils.plusMaybe,
      A2($Utils.plusMaybe,
      A2($Utils.plusMaybe,
      A2($Utils.plusMaybe,toInteriorZone(s),toCardinalPointZone(s)),
      toSliderZone(s)),
      toPointZone(s)),
      toEdgeZone(s));
   };
   var parseZone = function (s) {
      var _p58 = realZoneOf(s);
      if (_p58.ctor === "Just") {
            return _p58._0;
         } else {
            return _U.crashCase("ShapeWidgets",
            {start: {line: 776,column: 3},end: {line: 778,column: 49}},
            _p58)(A2($Basics._op["++"],"parseZone: ",s));
         }
   };
   var zoneToCrosshair = F2(function (shape,zone) {
      var _p60 = parseZone(zone);
      if (_p60.ctor === "ZPoint") {
            var _p61 = _p60._0;
            var xFeature = A2(unparseFeatureNum,$Maybe.Just(shape),X(_p61));
            var yFeature = A2(unparseFeatureNum,$Maybe.Just(shape),Y(_p61));
            return $Maybe.Just({ctor: "_Tuple2",_0: xFeature,_1: yFeature});
         } else {
            return $Maybe.Nothing;
         }
   });
   var OtherFeature = function (a) {
      return {ctor: "OtherFeature",_0: a};
   };
   var DistanceFeature = function (a) {
      return {ctor: "DistanceFeature",_0: a};
   };
   var PointFeature = function (a) {
      return {ctor: "PointFeature",_0: a};
   };
   var eightPointFeatures = A2($List.map,
   PointFeature,
   _U.list([TopLeft
           ,TopRight
           ,BotLeft
           ,BotRight
           ,TopEdge
           ,RightEdge
           ,BotEdge
           ,LeftEdge]));
   var ninePointFeatures = A2($List._op["::"],
   PointFeature(Center),
   eightPointFeatures);
   var simpleKindFeatures = _U.list([{ctor: "_Tuple2"
                                     ,_0: "rect"
                                     ,_1: A2($Basics._op["++"],
                                     ninePointFeatures,
                                     A2($List.map,DistanceFeature,_U.list([Width,Height])))}
                                    ,{ctor: "_Tuple2"
                                     ,_0: "BOX"
                                     ,_1: A2($Basics._op["++"],
                                     ninePointFeatures,
                                     A2($List.map,DistanceFeature,_U.list([Width,Height])))}
                                    ,{ctor: "_Tuple2"
                                     ,_0: "circle"
                                     ,_1: A2($Basics._op["++"],
                                     ninePointFeatures,
                                     A2($List.map,DistanceFeature,_U.list([Radius])))}
                                    ,{ctor: "_Tuple2"
                                     ,_0: "OVAL"
                                     ,_1: A2($Basics._op["++"],
                                     ninePointFeatures,
                                     A2($List.map,DistanceFeature,_U.list([RadiusX,RadiusY])))}
                                    ,{ctor: "_Tuple2"
                                     ,_0: "ellipse"
                                     ,_1: A2($Basics._op["++"],
                                     ninePointFeatures,
                                     A2($List.map,DistanceFeature,_U.list([RadiusX,RadiusY])))}
                                    ,{ctor: "_Tuple2"
                                     ,_0: "line"
                                     ,_1: A2($List.map,
                                     PointFeature,
                                     _U.list([Point(1),Point(2),Center]))}]);
   var polyKindFeatures = F2(function (kind,attrs) {
      var cap = "polyKindFeatures";
      var err = function (s) {
         return _U.crash("ShapeWidgets",
         {start: {line: 58,column: 15}
         ,end: {line: 58,column: 26}})($Utils.spaces(_U.list([cap
                                                             ,kind
                                                             ,": "
                                                             ,s])));
      };
      if (_U.eq(kind,"polygon")) {
            var _p62 = A3($Utils.find,cap,attrs,"points").av_;
            if (_p62.ctor === "APoints") {
                  return A2($List.concatMap,
                  function (i) {
                     return _U.list([PointFeature(Point(i))
                                    ,PointFeature(Midpoint(i))]);
                  },
                  _U.range(1,$List.length(_p62._0)));
               } else {
                  return err("polyKindFeatures: points not found");
               }
         } else if (_U.eq(kind,"path")) {
               var _p63 = A3($Utils.find,cap,attrs,"d").av_;
               if (_p63.ctor === "APath2" && _p63._0.ctor === "_Tuple2") {
                     return A2($List.concatMap,
                     function (i) {
                        return _U.list([PointFeature(Point(i))]);
                     },
                     _U.range(1,_p63._0._1.numPoints));
                  } else {
                     return err("polyKindFeatures: d not found");
                  }
            } else return err(A2($Basics._op["++"],
            "polyKindFeatures: ",
            kind));
   });
   var featuresOfShape = F2(function (kind,attrs) {
      var _p64 = A2($Utils.maybeFind,kind,simpleKindFeatures);
      if (_p64.ctor === "Just") {
            return _p64._0;
         } else {
            return A2(polyKindFeatures,kind,attrs);
         }
   });
   var pointFeaturesOfShape = F2(function (kind,attrs) {
      return A2($List.concatMap,
      function (feature) {
         var _p65 = feature;
         if (_p65.ctor === "PointFeature") {
               return _U.list([_p65._0]);
            } else {
               return _U.list([]);
            }
      },
      A2(featuresOfShape,kind,attrs));
   });
   var getPrimitivePointEquations = F2(function (_p66,nodeId) {
      var _p67 = _p66;
      var _p68 = A3($Utils.justGet_,
      "LangSvg.getPrimitivePoints",
      nodeId,
      _p67._1);
      if (_p68.ctor === "SvgNode") {
            var _p71 = _p68._0;
            var _p70 = _p68._1;
            return A2($List.concatMap,
            function (pointFeature) {
               var _p69 = A4(getPointEquations,
               nodeId,
               _p71,
               _p70,
               pointFeature);
               if (_p69.ctor === "_Tuple2" && _p69._0.ctor === "EqnNum" && _p69._1.ctor === "EqnNum")
               {
                     return _U.list([{ctor: "_Tuple2"
                                     ,_0: _p69._0._0
                                     ,_1: _p69._1._0}]);
                  } else {
                     return _U.list([]);
                  }
            },
            A2(pointFeaturesOfShape,_p71,_p70));
         } else {
            return _U.crashCase("ShapeWidgets",
            {start: {line: 716,column: 3},end: {line: 724,column: 47}},
            _p68)("LangSvg.getPrimitivePoints");
         }
   });
   return _elm.ShapeWidgets.values = {_op: _op
                                     ,PointFeature: PointFeature
                                     ,DistanceFeature: DistanceFeature
                                     ,OtherFeature: OtherFeature
                                     ,TopLeft: TopLeft
                                     ,TopRight: TopRight
                                     ,BotLeft: BotLeft
                                     ,BotRight: BotRight
                                     ,TopEdge: TopEdge
                                     ,RightEdge: RightEdge
                                     ,BotEdge: BotEdge
                                     ,LeftEdge: LeftEdge
                                     ,Center: Center
                                     ,Point: Point
                                     ,Midpoint: Midpoint
                                     ,Width: Width
                                     ,Height: Height
                                     ,Radius: Radius
                                     ,RadiusX: RadiusX
                                     ,RadiusY: RadiusY
                                     ,FillColor: FillColor
                                     ,FillOpacity: FillOpacity
                                     ,StrokeColor: StrokeColor
                                     ,StrokeOpacity: StrokeOpacity
                                     ,StrokeWidth: StrokeWidth
                                     ,Rotation: Rotation
                                     ,eightPointFeatures: eightPointFeatures
                                     ,ninePointFeatures: ninePointFeatures
                                     ,simpleKindFeatures: simpleKindFeatures
                                     ,polyKindFeatures: polyKindFeatures
                                     ,featuresOfShape: featuresOfShape
                                     ,pointFeaturesOfShape: pointFeaturesOfShape
                                     ,X: X
                                     ,Y: Y
                                     ,D: D
                                     ,O: O
                                     ,unparseFeatureNum: unparseFeatureNum
                                     ,strFeatureNum: strFeatureNum
                                     ,strPointFeature: strPointFeature
                                     ,strDistanceFeature: strDistanceFeature
                                     ,strOtherFeature: strOtherFeature
                                     ,shapeKindRegexStr: shapeKindRegexStr
                                     ,xShapeFeatureRegex: xShapeFeatureRegex
                                     ,yShapeFeatureRegex: yShapeFeatureRegex
                                     ,distanceFeatureRegex: distanceFeatureRegex
                                     ,parseFeatureNum: parseFeatureNum
                                     ,parseDistanceFeature: parseDistanceFeature
                                     ,parseShapeFeaturePoint: parseShapeFeaturePoint
                                     ,selectedTypeShapeFeature: selectedTypeShapeFeature
                                     ,selectedTypeWidget: selectedTypeWidget
                                     ,selectedPointFeatureOf: selectedPointFeatureOf
                                     ,pointFeatureOf: pointFeatureOf
                                     ,assertString: assertString
                                     ,sanityCheck: sanityCheck
                                     ,sanityCheckOther: sanityCheckOther
                                     ,shapeFill: shapeFill
                                     ,shapeStroke: shapeStroke
                                     ,shapeFillOpacity: shapeFillOpacity
                                     ,shapeStrokeOpacity: shapeStrokeOpacity
                                     ,shapeStrokeWidth: shapeStrokeWidth
                                     ,shapeRotation: shapeRotation
                                     ,EqnNum: EqnNum
                                     ,EqnOp: EqnOp
                                     ,BoxyFeatureEquations: BoxyFeatureEquations
                                     ,two: two
                                     ,plus: plus
                                     ,minus: minus
                                     ,div: div
                                     ,featureEquation: featureEquation
                                     ,featureEquationOf: featureEquationOf
                                     ,boxyFeatureEquationsOf: boxyFeatureEquationsOf
                                     ,evaluateFeatureEquation: evaluateFeatureEquation
                                     ,evaluateFeatureEquation_: evaluateFeatureEquation_
                                     ,evaluateLineFeatures: evaluateLineFeatures
                                     ,BoxyNums: BoxyNums
                                     ,evaluateBoxyNums: evaluateBoxyNums
                                     ,getPointEquations: getPointEquations
                                     ,getPrimitivePointEquations: getPrimitivePointEquations
                                     ,ZInterior: ZInterior
                                     ,ZPoint: ZPoint
                                     ,ZLineEdge: ZLineEdge
                                     ,ZPolyEdge: ZPolyEdge
                                     ,ZOther: ZOther
                                     ,ZSlider: ZSlider
                                     ,unparseZone: unparseZone
                                     ,parseZone: parseZone
                                     ,realZoneOf: realZoneOf
                                     ,toInteriorZone: toInteriorZone
                                     ,toCardinalPointZone: toCardinalPointZone
                                     ,toSliderZone: toSliderZone
                                     ,toPointZone: toPointZone
                                     ,toEdgeZone: toEdgeZone
                                     ,zoneToCrosshair: zoneToCrosshair
                                     ,wColorSlider: wColorSlider
                                     ,wStrokeWidthSlider: wStrokeWidthSlider
                                     ,wOpacitySlider: wOpacitySlider};
};
Elm.LocEqn = Elm.LocEqn || {};
Elm.LocEqn.make = function (_elm) {
   "use strict";
   _elm.LocEqn = _elm.LocEqn || {};
   if (_elm.LocEqn.values) return _elm.LocEqn.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm);
   var _op = {};
   var locEqnEval_ = function (eqn) {
      var _p0 = eqn;
      switch (_p0.ctor)
      {case "LocEqnConst": return _p0._0;
         case "LocEqnLoc": return _U.crashCase("LocEqn",
           {start: {line: 284,column: 3},end: {line: 295,column: 101}},
           _p0)("shouldn\'t have locs in constantified eqn");
         default:
         if (_p0._1.ctor === "::" && _p0._1._1.ctor === "::" && _p0._1._1._1.ctor === "[]")
           {
                 var _p5 = _p0._0;
                 var _p2 = {ctor: "_Tuple2"
                           ,_0: locEqnEval_(_p0._1._0)
                           ,_1: locEqnEval_(_p0._1._1._0)};
                 var leftEvaled = _p2._0;
                 var rightEvaled = _p2._1;
                 var _p3 = _p5;
                 switch (_p3.ctor)
                 {case "Plus": return leftEvaled + rightEvaled;
                    case "Minus": return leftEvaled - rightEvaled;
                    case "Mult": return leftEvaled * rightEvaled;
                    case "Div": return leftEvaled / rightEvaled;
                    default: return _U.crashCase("LocEqn",
                      {start: {line: 289,column: 7},end: {line: 294,column: 77}},
                      _p3)(A2($Basics._op["++"],
                      "Unknown loc equation op: ",
                      $Basics.toString(_p5)));}
              } else {
                 return _U.crashCase("LocEqn",
                 {start: {line: 284,column: 3},end: {line: 295,column: 101}},
                 _p0)(A2($Basics._op["++"],
                 "Loc equation only supports binary operations, but got: ",
                 $Basics.toString(eqn)));
              }}
   };
   var locEqnLocIds = function (eqn) {
      var _p7 = eqn;
      switch (_p7.ctor)
      {case "LocEqnConst": return $Set.empty;
         case "LocEqnLoc": return $Set.singleton(_p7._0);
         default: return A3($List.foldl,
           F2(function (child,locs) {
              return A2($Set.union,locs,locEqnLocIds(child));
           }),
           $Set.empty,
           _p7._1);}
   };
   var LocEqnOp = F2(function (a,b) {
      return {ctor: "LocEqnOp",_0: a,_1: b};
   });
   var LocEqnLoc = function (a) {
      return {ctor: "LocEqnLoc",_0: a};
   };
   var traceToLocEquation = function (trace) {
      var _p8 = trace;
      if (_p8.ctor === "TrLoc") {
            if (_p8._0._0 === 0) {
                  return _U.crashCase("LocEqn",
                  {start: {line: 299,column: 3},end: {line: 309,column: 55}},
                  _p8)(A2($Basics._op["++"],
                  "traceToLocEquation: Found locId of 0 in trace. ",
                  $Basics.toString(trace)));
               } else {
                  return LocEqnLoc(_p8._0._0);
               }
         } else {
            return A2(LocEqnOp,
            _p8._0,
            A2($List.map,traceToLocEquation,_p8._1));
         }
   };
   var LocEqnConst = function (a) {
      return {ctor: "LocEqnConst",_0: a};
   };
   var constantifyLocs = F2(function (locIdToNum,eqn) {
      var _p10 = eqn;
      switch (_p10.ctor)
      {case "LocEqnConst": return eqn;
         case "LocEqnLoc": var _p11 = A2($Dict.get,_p10._0,locIdToNum);
           if (_p11.ctor === "Just") {
                 return LocEqnConst(_p11._0);
              } else {
                 return eqn;
              }
         default: return A2(LocEqnOp,
           _p10._0,
           A2($List.map,constantifyLocs(locIdToNum),_p10._1));}
   });
   var locEqnEval = F2(function (locIdToNum,eqn) {
      return locEqnEval_(A2(constantifyLocs,locIdToNum,eqn));
   });
   var debugLog = $Config.debugLog($Config.debugSync);
   var locEqnSimplify = function (eqn) {
      var simplified = function () {
         var _p12 = eqn;
         switch (_p12.ctor)
         {case "LocEqnConst": return eqn;
            case "LocEqnLoc": return eqn;
            default: var _p30 = _p12._0;
              var children$ = A2($List.map,locEqnSimplify,_p12._1);
              var eqn$ = A2(LocEqnOp,_p30,children$);
              var _p13 = children$;
              if (_p13.ctor === "::" && _p13._1.ctor === "::" && _p13._1._1.ctor === "[]")
              {
                    var _p28 = _p13._1._0;
                    var _p27 = _p13._0;
                    var _p14 = _p30;
                    switch (_p14.ctor)
                    {case "Plus": var _p15 = {ctor: "_Tuple2",_0: _p27,_1: _p28};
                         _v9_5: do {
                            _v9_3: do {
                               _v9_2: do {
                                  _v9_1: do {
                                     _v9_0: do {
                                        if (_p15.ctor === "_Tuple2") {
                                              switch (_p15._0.ctor)
                                              {case "LocEqnOp": switch (_p15._1.ctor)
                                                   {case "LocEqnConst": if (_p15._1._0 === 0) {
                                                              break _v9_1;
                                                           } else {
                                                              if (_p15._0._0.ctor === "Minus" && _p15._0._1.ctor === "::" && _p15._0._1._1.ctor === "::" && _p15._0._1._1._1.ctor === "[]")
                                                              {
                                                                    break _v9_2;
                                                                 } else {
                                                                    break _v9_5;
                                                                 }
                                                           }
                                                      case "LocEqnOp":
                                                      if (_p15._0._0.ctor === "Minus" && _p15._0._1.ctor === "::" && _p15._0._1._1.ctor === "::" && _p15._0._1._1._1.ctor === "[]")
                                                        {
                                                              break _v9_2;
                                                           } else {
                                                              if (_p15._1._0.ctor === "Minus" && _p15._1._1.ctor === "::" && _p15._1._1._1.ctor === "::" && _p15._1._1._1._1.ctor === "[]")
                                                              {
                                                                    break _v9_3;
                                                                 } else {
                                                                    break _v9_5;
                                                                 }
                                                           }
                                                      default:
                                                      if (_p15._0._0.ctor === "Minus" && _p15._0._1.ctor === "::" && _p15._0._1._1.ctor === "::" && _p15._0._1._1._1.ctor === "[]")
                                                        {
                                                              break _v9_2;
                                                           } else {
                                                              break _v9_5;
                                                           }}
                                                 case "LocEqnConst": switch (_p15._1.ctor)
                                                   {case "LocEqnOp": if (_p15._0._0 === 0) {
                                                              break _v9_0;
                                                           } else {
                                                              if (_p15._1._0.ctor === "Minus" && _p15._1._1.ctor === "::" && _p15._1._1._1.ctor === "::" && _p15._1._1._1._1.ctor === "[]")
                                                              {
                                                                    break _v9_3;
                                                                 } else {
                                                                    break _v9_5;
                                                                 }
                                                           }
                                                      case "LocEqnConst": if (_p15._0._0 === 0) {
                                                              break _v9_0;
                                                           } else {
                                                              if (_p15._1._0 === 0) {
                                                                    break _v9_1;
                                                                 } else {
                                                                    return LocEqnConst(_p15._0._0 + _p15._1._0);
                                                                 }
                                                           }
                                                      default: if (_p15._0._0 === 0) {
                                                              break _v9_0;
                                                           } else {
                                                              break _v9_5;
                                                           }}
                                                 default: switch (_p15._1.ctor)
                                                   {case "LocEqnConst": if (_p15._1._0 === 0) {
                                                              break _v9_1;
                                                           } else {
                                                              break _v9_5;
                                                           }
                                                      case "LocEqnOp":
                                                      if (_p15._1._0.ctor === "Minus" && _p15._1._1.ctor === "::" && _p15._1._1._1.ctor === "::" && _p15._1._1._1._1.ctor === "[]")
                                                        {
                                                              break _v9_3;
                                                           } else {
                                                              break _v9_5;
                                                           }
                                                      default: break _v9_5;}}
                                           } else {
                                              break _v9_5;
                                           }
                                     } while (false);
                                     return _p28;
                                  } while (false);
                                  return _p27;
                               } while (false);
                               return _U.eq(_p15._0._1._1._0,_p15._1) ? _p15._0._1._0 : eqn$;
                            } while (false);
                            return _U.eq(_p15._1._1._1._0,_p15._0) ? _p15._1._1._0 : eqn$;
                         } while (false);
                         return eqn$;
                       case "Minus": var _p16 = {ctor: "_Tuple2",_0: _p27,_1: _p28};
                         _v10_10: do {
                            _v10_7: do {
                               _v10_6: do {
                                  _v10_0: do {
                                     if (_p16.ctor === "_Tuple2") {
                                           switch (_p16._1.ctor)
                                           {case "LocEqnOp":
                                              if (_p16._1._1.ctor === "::" && _p16._1._1._1.ctor === "::" && _p16._1._1._1._1.ctor === "[]")
                                                {
                                                      switch (_p16._1._0.ctor)
                                                      {case "Mult": switch (_p16._0.ctor)
                                                           {case "LocEqnConst": if (_p16._0._0 === 0) {
                                                                      if (_p16._1._1._0.ctor === "LocEqnConst") {
                                                                            return A2(LocEqnOp,
                                                                            $Lang.Mult,
                                                                            _U.list([LocEqnConst(0 - _p16._1._1._0._0),_p16._1._1._1._0]));
                                                                         } else {
                                                                            if (_p16._1._1._1._0.ctor === "LocEqnConst") {
                                                                                  return A2(LocEqnOp,
                                                                                  $Lang.Mult,
                                                                                  _U.list([LocEqnConst(0 - _p16._1._1._1._0._0),_p16._1._1._0]));
                                                                               } else {
                                                                                  break _v10_10;
                                                                               }
                                                                         }
                                                                   } else {
                                                                      break _v10_10;
                                                                   }
                                                              case "LocEqnOp":
                                                              if (_p16._0._0.ctor === "Plus" && _p16._0._1.ctor === "::" && _p16._0._1._1.ctor === "::" && _p16._0._1._1._1.ctor === "[]")
                                                                {
                                                                      break _v10_7;
                                                                   } else {
                                                                      break _v10_10;
                                                                   }
                                                              default: break _v10_10;}
                                                         case "Div": switch (_p16._0.ctor)
                                                           {case "LocEqnConst":
                                                              if (_p16._0._0 === 0 && _p16._1._1._0.ctor === "LocEqnConst") {
                                                                      return A2(LocEqnOp,
                                                                      $Lang.Div,
                                                                      _U.list([LocEqnConst(0 - _p16._1._1._0._0),_p16._1._1._1._0]));
                                                                   } else {
                                                                      break _v10_10;
                                                                   }
                                                              case "LocEqnOp":
                                                              if (_p16._0._0.ctor === "Plus" && _p16._0._1.ctor === "::" && _p16._0._1._1.ctor === "::" && _p16._0._1._1._1.ctor === "[]")
                                                                {
                                                                      break _v10_7;
                                                                   } else {
                                                                      break _v10_10;
                                                                   }
                                                              default: break _v10_10;}
                                                         case "Minus": switch (_p16._0.ctor)
                                                           {case "LocEqnConst": if (_p16._0._0 === 0) {
                                                                      if (_p16._1._1._0.ctor === "LocEqnConst" && _p16._1._1._0._0 === 0)
                                                                      {
                                                                            return _p16._1._1._1._0;
                                                                         } else {
                                                                            return A2(LocEqnOp,
                                                                            $Lang.Minus,
                                                                            _U.list([_p16._1._1._1._0,_p16._1._1._0]));
                                                                         }
                                                                   } else {
                                                                      break _v10_6;
                                                                   }
                                                              case "LocEqnOp": break _v10_6;
                                                              default: break _v10_6;}
                                                         case "Plus":
                                                         if (_p16._0.ctor === "LocEqnOp" && _p16._0._0.ctor === "Plus" && _p16._0._1.ctor === "::" && _p16._0._1._1.ctor === "::" && _p16._0._1._1._1.ctor === "[]")
                                                           {
                                                                 break _v10_7;
                                                              } else {
                                                                 var _p22 = _p16._0;
                                                                 var _p21 = _p16._1._1._1._0;
                                                                 var _p20 = _p16._1._1._0;
                                                                 return _U.eq(_p21,_p22) ? A2(LocEqnOp,
                                                                 $Lang.Minus,
                                                                 _U.list([LocEqnConst(0),_p20])) : _U.eq(_p20,
                                                                 _p22) ? A2(LocEqnOp,
                                                                 $Lang.Minus,
                                                                 _U.list([LocEqnConst(0),_p21])) : eqn$;
                                                              }
                                                         default:
                                                         if (_p16._0.ctor === "LocEqnOp" && _p16._0._0.ctor === "Plus" && _p16._0._1.ctor === "::" && _p16._0._1._1.ctor === "::" && _p16._0._1._1._1.ctor === "[]")
                                                           {
                                                                 break _v10_7;
                                                              } else {
                                                                 break _v10_10;
                                                              }}
                                                   } else {
                                                      if (_p16._0.ctor === "LocEqnOp" && _p16._0._0.ctor === "Plus" && _p16._0._1.ctor === "::" && _p16._0._1._1.ctor === "::" && _p16._0._1._1._1.ctor === "[]")
                                                      {
                                                            break _v10_7;
                                                         } else {
                                                            break _v10_10;
                                                         }
                                                   }
                                              case "LocEqnConst": switch (_p16._0.ctor)
                                                {case "LocEqnOp": if (_p16._1._0 === 0) {
                                                           break _v10_0;
                                                        } else {
                                                           if (_p16._0._0.ctor === "Plus" && _p16._0._1.ctor === "::" && _p16._0._1._1.ctor === "::" && _p16._0._1._1._1.ctor === "[]")
                                                           {
                                                                 break _v10_7;
                                                              } else {
                                                                 break _v10_10;
                                                              }
                                                        }
                                                   case "LocEqnConst": if (_p16._1._0 === 0) {
                                                           break _v10_0;
                                                        } else {
                                                           return LocEqnConst(_p16._0._0 - _p16._1._0);
                                                        }
                                                   default: if (_p16._1._0 === 0) {
                                                           break _v10_0;
                                                        } else {
                                                           break _v10_10;
                                                        }}
                                              default:
                                              if (_p16._0.ctor === "LocEqnOp" && _p16._0._0.ctor === "Plus" && _p16._0._1.ctor === "::" && _p16._0._1._1.ctor === "::" && _p16._0._1._1._1.ctor === "[]")
                                                {
                                                      break _v10_7;
                                                   } else {
                                                      break _v10_10;
                                                   }}
                                        } else {
                                           break _v10_10;
                                        }
                                  } while (false);
                                  return _p27;
                               } while (false);
                               return A2(LocEqnOp,
                               $Lang.Plus,
                               _U.list([_p16._0
                                       ,A2(LocEqnOp,
                                       $Lang.Minus,
                                       _U.list([_p16._1._1._1._0,_p16._1._1._0]))]));
                            } while (false);
                            var _p19 = _p16._1;
                            var _p18 = _p16._0._1._1._0;
                            var _p17 = _p16._0._1._0;
                            return _U.eq(_p18,_p19) ? _p17 : _U.eq(_p17,_p19) ? _p18 : eqn$;
                         } while (false);
                         return _U.eq(_p27,_p28) ? LocEqnConst(0) : eqn$;
                       case "Mult": var _p23 = {ctor: "_Tuple2",_0: _p27,_1: _p28};
                         _v11_11: do {
                            _v11_3: do {
                               _v11_2: do {
                                  _v11_1: do {
                                     _v11_0: do {
                                        if (_p23.ctor === "_Tuple2") {
                                              switch (_p23._0.ctor)
                                              {case "LocEqnConst": switch (_p23._1.ctor)
                                                   {case "LocEqnConst": switch (_p23._0._0)
                                                        {case 1: break _v11_0;
                                                           case 0: switch (_p23._1._0)
                                                             {case 1: break _v11_1;
                                                                case 0: break _v11_2;
                                                                default: break _v11_2;}
                                                           default: switch (_p23._1._0)
                                                             {case 1: break _v11_1;
                                                                case 0: break _v11_3;
                                                                default: return LocEqnConst(_p23._0._0 * _p23._1._0);}}
                                                      case "LocEqnOp":
                                                      if (_p23._1._1.ctor === "::" && _p23._1._1._1.ctor === "::" && _p23._1._1._1._1.ctor === "[]")
                                                        {
                                                              switch (_p23._1._0.ctor)
                                                              {case "Minus": switch (_p23._0._0)
                                                                   {case 1: break _v11_0;
                                                                      case 0: break _v11_2;
                                                                      case -1: return A2(LocEqnOp,
                                                                        $Lang.Minus,
                                                                        _U.list([_p23._1._1._1._0,_p23._1._1._0]));
                                                                      default: break _v11_11;}
                                                                 case "Mult": switch (_p23._0._0)
                                                                   {case 1: break _v11_0;
                                                                      case 0: break _v11_2;
                                                                      default: if (_p23._1._1._0.ctor === "LocEqnConst") {
                                                                              return A2(LocEqnOp,
                                                                              $Lang.Mult,
                                                                              _U.list([LocEqnConst(_p23._0._0 * _p23._1._1._0._0)
                                                                                      ,_p23._1._1._1._0]));
                                                                           } else {
                                                                              if (_p23._1._1._1._0.ctor === "LocEqnConst") {
                                                                                    return A2(LocEqnOp,
                                                                                    $Lang.Mult,
                                                                                    _U.list([LocEqnConst(_p23._0._0 * _p23._1._1._1._0._0)
                                                                                            ,_p23._1._1._0]));
                                                                                 } else {
                                                                                    break _v11_11;
                                                                                 }
                                                                           }}
                                                                 default: switch (_p23._0._0)
                                                                   {case 1: break _v11_0;
                                                                      case 0: break _v11_2;
                                                                      default: break _v11_11;}}
                                                           } else {
                                                              switch (_p23._0._0)
                                                              {case 1: break _v11_0;
                                                                 case 0: break _v11_2;
                                                                 default: break _v11_11;}
                                                           }
                                                      default: switch (_p23._0._0)
                                                        {case 1: break _v11_0;
                                                           case 0: break _v11_2;
                                                           default: break _v11_11;}}
                                                 case "LocEqnOp": if (_p23._1.ctor === "LocEqnConst") {
                                                         if (_p23._0._1.ctor === "::" && _p23._0._1._1.ctor === "::" && _p23._0._1._1._1.ctor === "[]")
                                                         {
                                                               switch (_p23._0._0.ctor)
                                                               {case "Minus": switch (_p23._1._0)
                                                                    {case 1: break _v11_1;
                                                                       case 0: break _v11_3;
                                                                       case -1: return A2(LocEqnOp,
                                                                         $Lang.Minus,
                                                                         _U.list([_p23._0._1._1._0,_p23._0._1._0]));
                                                                       default: break _v11_11;}
                                                                  case "Mult": switch (_p23._1._0)
                                                                    {case 1: break _v11_1;
                                                                       case 0: break _v11_3;
                                                                       default: if (_p23._0._1._0.ctor === "LocEqnConst") {
                                                                               return A2(LocEqnOp,
                                                                               $Lang.Mult,
                                                                               _U.list([LocEqnConst(_p23._1._0 * _p23._0._1._0._0)
                                                                                       ,_p23._0._1._1._0]));
                                                                            } else {
                                                                               if (_p23._0._1._1._0.ctor === "LocEqnConst") {
                                                                                     return A2(LocEqnOp,
                                                                                     $Lang.Mult,
                                                                                     _U.list([LocEqnConst(_p23._1._0 * _p23._0._1._1._0._0)
                                                                                             ,_p23._0._1._0]));
                                                                                  } else {
                                                                                     break _v11_11;
                                                                                  }
                                                                            }}
                                                                  default: switch (_p23._1._0)
                                                                    {case 1: break _v11_1;
                                                                       case 0: break _v11_3;
                                                                       default: break _v11_11;}}
                                                            } else {
                                                               switch (_p23._1._0)
                                                               {case 1: break _v11_1;
                                                                  case 0: break _v11_3;
                                                                  default: break _v11_11;}
                                                            }
                                                      } else {
                                                         break _v11_11;
                                                      }
                                                 default: if (_p23._1.ctor === "LocEqnConst") {
                                                         switch (_p23._1._0)
                                                         {case 1: break _v11_1;
                                                            case 0: break _v11_3;
                                                            default: break _v11_11;}
                                                      } else {
                                                         break _v11_11;
                                                      }}
                                           } else {
                                              break _v11_11;
                                           }
                                     } while (false);
                                     return _p28;
                                  } while (false);
                                  return _p27;
                               } while (false);
                               return LocEqnConst(0);
                            } while (false);
                            return LocEqnConst(0);
                         } while (false);
                         return eqn$;
                       case "Div": var _p24 = {ctor: "_Tuple2",_0: _p27,_1: _p28};
                         _v12_5: do {
                            _v12_1: do {
                               _v12_0: do {
                                  if (_p24.ctor === "_Tuple2") {
                                        if (_p24._1.ctor === "LocEqnConst") {
                                              if (_p24._0.ctor === "LocEqnConst") {
                                                    switch (_p24._1._0)
                                                    {case 1: break _v12_0;
                                                       case -1: break _v12_1;
                                                       default: var _p25 = _p24._1._0;
                                                         return !_U.eq(_p25,0) ? LocEqnConst(_p24._0._0 / _p25) : eqn$;}
                                                 } else {
                                                    switch (_p24._1._0)
                                                    {case 1: break _v12_0;
                                                       case -1: break _v12_1;
                                                       default: var _p26 = _p24._1._0;
                                                         return !_U.eq(_p26,0) ? A2(LocEqnOp,
                                                         $Lang.Mult,
                                                         _U.list([LocEqnConst(1 / _p26),_p27])) : eqn$;}
                                                 }
                                           } else {
                                              if (_p24._0.ctor === "LocEqnConst" && _p24._0._0 === 0) {
                                                    return LocEqnConst(0);
                                                 } else {
                                                    break _v12_5;
                                                 }
                                           }
                                     } else {
                                        break _v12_5;
                                     }
                               } while (false);
                               return _p27;
                            } while (false);
                            return A2(LocEqnOp,$Lang.Mult,_U.list([LocEqnConst(-1),_p27]));
                         } while (false);
                         return _U.eq(_p27,_p28) && !_U.eq(_p28,
                         LocEqnConst(0)) ? LocEqnConst(1) : eqn$;
                       default: return eqn$;}
                 } else {
                    return _U.crashCase("LocEqn",
                    {start: {line: 40,column: 9},end: {line: 133,column: 86}},
                    _p13)(A2($Basics._op["++"],
                    "locEqnSimplify: op without 2 children ",
                    $Basics.toString(eqn)));
                 }}
      }();
      return _U.eq(simplified,eqn) ? eqn : A2(debugLog,
      "double simplification",
      locEqnSimplify(simplified));
   };
   var locEqnTerms = F2(function (targetLocId,eqn) {
      var _p31 = eqn;
      switch (_p31.ctor)
      {case "LocEqnConst": return $Maybe.Just({ctor: "_Tuple3"
                                              ,_0: 1
                                              ,_1: LocEqnConst(0)
                                              ,_2: eqn});
         case "LocEqnLoc": return _U.eq(_p31._0,
           targetLocId) ? $Maybe.Just({ctor: "_Tuple3"
                                      ,_0: 1
                                      ,_1: LocEqnConst(1)
                                      ,_2: LocEqnConst(0)}) : $Maybe.Just({ctor: "_Tuple3"
                                                                          ,_0: 1
                                                                          ,_1: LocEqnConst(0)
                                                                          ,_2: eqn});
         default: var children$ = A2($List.map,
           locEqnTerms(targetLocId),
           _p31._1);
           var result = function () {
              var _p32 = children$;
              if (_p32.ctor === "::" && _p32._0.ctor === "Just" && _p32._0._0.ctor === "_Tuple3" && _p32._1.ctor === "::" && _p32._1._0.ctor === "Just" && _p32._1._0._0.ctor === "_Tuple3" && _p32._1._1.ctor === "[]")
              {
                    var _p41 = _p32._1._0._0._2;
                    var _p40 = _p32._1._0._0._0;
                    var _p39 = _p32._1._0._0._1;
                    var _p38 = _p32._0._0._2;
                    var _p37 = _p32._0._0._0;
                    var _p36 = _p32._0._0._1;
                    var _p33 = _p31._0;
                    switch (_p33.ctor)
                    {case "Plus": return _U.eq(_p37,
                         _p40) ? $Maybe.Just({ctor: "_Tuple3"
                                             ,_0: _p37
                                             ,_1: A2(LocEqnOp,$Lang.Plus,_U.list([_p36,_p39]))
                                             ,_2: A2(LocEqnOp,
                                             $Lang.Plus,
                                             _U.list([_p38,_p41]))}) : $Maybe.Nothing;
                       case "Minus": return _U.eq(_p37,
                         _p40) ? $Maybe.Just({ctor: "_Tuple3"
                                             ,_0: _p37
                                             ,_1: A2(LocEqnOp,$Lang.Minus,_U.list([_p36,_p39]))
                                             ,_2: A2(LocEqnOp,
                                             $Lang.Minus,
                                             _U.list([_p38,_p41]))}) : $Maybe.Nothing;
                       case "Mult": var _p34 = {ctor: "_Tuple4"
                                               ,_0: _p36
                                               ,_1: _p38
                                               ,_2: _p39
                                               ,_3: _p41};
                         _v16_3: do {
                            if (_p34.ctor === "_Tuple4") {
                                  if (_p34._0.ctor === "LocEqnConst" && _p34._0._0 === 0) {
                                        return $Maybe.Just({ctor: "_Tuple3"
                                                           ,_0: _p40
                                                           ,_1: A2(LocEqnOp,$Lang.Mult,_U.list([_p38,_p39]))
                                                           ,_2: A2(LocEqnOp,$Lang.Mult,_U.list([_p38,_p41]))});
                                     } else {
                                        if (_p34._2.ctor === "LocEqnConst" && _p34._2._0 === 0) {
                                              return $Maybe.Just({ctor: "_Tuple3"
                                                                 ,_0: _p37
                                                                 ,_1: A2(LocEqnOp,$Lang.Mult,_U.list([_p36,_p41]))
                                                                 ,_2: A2(LocEqnOp,$Lang.Mult,_U.list([_p38,_p41]))});
                                           } else {
                                              if (_p34._1.ctor === "LocEqnConst" && _p34._1._0 === 0 && _p34._3.ctor === "LocEqnConst" && _p34._3._0 === 0)
                                              {
                                                    var newPow = _p37 + _p40;
                                                    return _U.eq(newPow,0) ? $Maybe.Just({ctor: "_Tuple3"
                                                                                         ,_0: 1
                                                                                         ,_1: LocEqnConst(0)
                                                                                         ,_2: LocEqnConst(1)}) : $Maybe.Just({ctor: "_Tuple3"
                                                                                                                             ,_0: newPow
                                                                                                                             ,_1: A2(LocEqnOp,
                                                                                                                             $Lang.Mult,
                                                                                                                             _U.list([_p36,_p39]))
                                                                                                                             ,_2: LocEqnConst(0)});
                                                 } else {
                                                    break _v16_3;
                                                 }
                                           }
                                     }
                               } else {
                                  break _v16_3;
                               }
                         } while (false);
                         return $Maybe.Nothing;
                       case "Div": var _p35 = {ctor: "_Tuple4"
                                              ,_0: _p36
                                              ,_1: _p38
                                              ,_2: _p39
                                              ,_3: _p41};
                         _v17_4: do {
                            _v17_3: do {
                               if (_p35.ctor === "_Tuple4") {
                                     if (_p35._2.ctor === "LocEqnConst") {
                                           if (_p35._3.ctor === "LocEqnConst" && _p35._3._0 === 0) {
                                                 switch (_p35._2._0)
                                                 {case 0: return $Maybe.Nothing;
                                                    case 1: if (_p35._0.ctor === "LocEqnConst" && _p35._0._0 === 0)
                                                      {
                                                            return $Maybe.Just({ctor: "_Tuple3"
                                                                               ,_0: 0 - _p40
                                                                               ,_1: A2(LocEqnOp,$Lang.Div,_U.list([_p38,_p39]))
                                                                               ,_2: LocEqnConst(0)});
                                                         } else {
                                                            if (_p35._1.ctor === "LocEqnConst" && _p35._1._0 === 0) {
                                                                  break _v17_3;
                                                               } else {
                                                                  break _v17_4;
                                                               }
                                                         }
                                                    default: if (_p35._1.ctor === "LocEqnConst" && _p35._1._0 === 0)
                                                      {
                                                            break _v17_3;
                                                         } else {
                                                            break _v17_4;
                                                         }}
                                              } else {
                                                 if (_p35._2._0 === 0) {
                                                       return $Maybe.Just({ctor: "_Tuple3"
                                                                          ,_0: _p37
                                                                          ,_1: A2(LocEqnOp,$Lang.Div,_U.list([_p36,_p41]))
                                                                          ,_2: A2(LocEqnOp,$Lang.Div,_U.list([_p38,_p41]))});
                                                    } else {
                                                       break _v17_4;
                                                    }
                                              }
                                        } else {
                                           if (_p35._1.ctor === "LocEqnConst" && _p35._1._0 === 0 && _p35._3.ctor === "LocEqnConst" && _p35._3._0 === 0)
                                           {
                                                 break _v17_3;
                                              } else {
                                                 break _v17_4;
                                              }
                                        }
                                  } else {
                                     break _v17_4;
                                  }
                            } while (false);
                            return _U.eq(_p37,_p40) ? $Maybe.Just({ctor: "_Tuple3"
                                                                  ,_0: 1
                                                                  ,_1: LocEqnConst(0)
                                                                  ,_2: A2(LocEqnOp,
                                                                  $Lang.Div,
                                                                  _U.list([_p36,_p39]))}) : $Maybe.Just({ctor: "_Tuple3"
                                                                                                        ,_0: _p40 - _p37
                                                                                                        ,_1: A2(LocEqnOp,$Lang.Div,_U.list([_p36,_p39]))
                                                                                                        ,_2: LocEqnConst(0)});
                         } while (false);
                         return _U.eq(_p37,_p40) && (_U.eq(_p36,_p39) && _U.eq(_p38,
                         _p41)) ? $Maybe.Just({ctor: "_Tuple3"
                                              ,_0: 1
                                              ,_1: LocEqnConst(0)
                                              ,_2: LocEqnConst(1)}) : $Maybe.Nothing;
                       default: return $Maybe.Nothing;}
                 } else {
                    return $Maybe.Nothing;
                 }
           }();
           var _p42 = result;
           if (_p42.ctor === "Just") {
                 return $Maybe.Just({ctor: "_Tuple3"
                                    ,_0: _p42._0._0
                                    ,_1: locEqnSimplify(_p42._0._1)
                                    ,_2: locEqnSimplify(_p42._0._2)});
              } else {
                 return $Maybe.Nothing;
              }}
   });
   var locEqnToLittle = F2(function (locIdToLittle,eqn) {
      var _p43 = eqn;
      switch (_p43.ctor)
      {case "LocEqnConst": return A2($Basics._op["++"],
           $Basics.toString(_p43._0),
           "!");
         case "LocEqnLoc": var _p46 = _p43._0;
           var _p44 = A2($Dict.get,_p46,locIdToLittle);
           if (_p44.ctor === "Just") {
                 return _p44._0;
              } else {
                 var _p45 = A2(debugLog,"missing locId",_p46);
                 return "?";
              }
         default: var childLittleStrs = A2($List.map,
           locEqnToLittle(locIdToLittle),
           _p43._1);
           return A2($Basics._op["++"],
           "(",
           A2($Basics._op["++"],
           $Lang.strOp(_p43._0),
           A2($Basics._op["++"],
           " ",
           A2($Basics._op["++"],
           A2($String.join," ",childLittleStrs),
           ")"))));}
   });
   return _elm.LocEqn.values = {_op: _op
                               ,debugLog: debugLog
                               ,LocEqnConst: LocEqnConst
                               ,LocEqnLoc: LocEqnLoc
                               ,LocEqnOp: LocEqnOp
                               ,locEqnSimplify: locEqnSimplify
                               ,locEqnTerms: locEqnTerms
                               ,locEqnLocIds: locEqnLocIds
                               ,locEqnEval: locEqnEval
                               ,locEqnEval_: locEqnEval_
                               ,traceToLocEquation: traceToLocEquation
                               ,constantifyLocs: constantifyLocs
                               ,locEqnToLittle: locEqnToLittle};
};
Elm.Solver = Elm.Solver || {};
Elm.Solver.make = function (_elm) {
   "use strict";
   _elm.Solver = _elm.Solver || {};
   if (_elm.Solver.values) return _elm.Solver.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Eval = Elm.Eval.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $List = Elm.List.make(_elm),
   $LocEqn = Elm.LocEqn.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var isNumBinop = F2(function (x,y) {
      return !_U.eq(x,y);
   })($Lang.Lt);
   var evalLoc = F2(function (subst,tr) {
      var _p0 = tr;
      if (_p0.ctor === "TrOp") {
            return $Maybe.Nothing;
         } else {
            return $Maybe.Just(A2($Dict.get,_p0._0._0,subst));
         }
   });
   var evalTrace = F2(function (subst,t) {
      var _p1 = t;
      if (_p1.ctor === "TrLoc") {
            return A2($Dict.get,_p1._0._0,subst);
         } else {
            return A2($Utils.mapMaybe,
            A2($Eval.evalDelta,_U.list([]),_p1._0),
            $Utils.projJusts(A2($List.map,evalTrace(subst),_p1._1)));
         }
   });
   var termSolve = F2(function (subst,_p2) {
      var _p3 = _p2;
      var locEqn = $LocEqn.traceToLocEquation(_p3._1);
      var locIds = $Set.toList($LocEqn.locEqnLocIds(locEqn));
      var targetLocId = A2($Utils.fromJust_,
      "subst should be missing a locId",
      A2($Utils.findFirst,
      function (locId) {
         return _U.eq(A2($Dict.get,locId,subst),$Maybe.Nothing);
      },
      locIds));
      var _p4 = A2($LocEqn.locEqnTerms,
      targetLocId,
      A2($LocEqn.LocEqnOp,
      $Lang.Minus,
      _U.list([locEqn,$LocEqn.LocEqnConst(_p3._0)])));
      if (_p4.ctor === "Just") {
            var coeffEvaled = A2($LocEqn.locEqnEval,subst,_p4._0._1);
            var restEvaled = A2($LocEqn.locEqnEval,subst,_p4._0._2);
            var newLocValue = Math.pow((0 - restEvaled) / coeffEvaled,
            1 / _p4._0._0);
            return $Basics.isNaN(newLocValue) || $Basics.isInfinite(newLocValue) ? $Maybe.Nothing : $Maybe.Just(newLocValue);
         } else {
            return $Maybe.Nothing;
         }
   });
   var debugLog = $Config.debugLog($Config.debugSync);
   var maybeFloat = function (n) {
      var thresh = 1000;
      return $Basics.isNaN(n) || $Basics.isInfinite(n) ? A2(debugLog,
      "maybeFloat Nothing",
      $Maybe.Nothing) : _U.cmp($Basics.abs(n),
      thresh) > 0 ? A2(debugLog,
      "maybeFloat (above thresh)",
      $Maybe.Nothing) : $Maybe.Just(n);
   };
   var solveR = F3(function (op,n,i) {
      var _p5 = op;
      switch (_p5.ctor)
      {case "Plus": return maybeFloat(n - i);
         case "Minus": return maybeFloat(i - n);
         case "Mult": return maybeFloat(n / i);
         case "Div": return maybeFloat(i / n);
         case "Pow": return $Maybe.Just(A2($Basics.logBase,i,n));
         case "Mod": return $Maybe.Nothing;
         case "ArcTan2": return maybeFloat($Basics.tan(n) * i);
         default: return _U.crashCase("Solver",
           {start: {line: 146,column: 17},end: {line: 154,column: 34}},
           _p5)("solveR");}
   });
   var solveL = F3(function (op,n,j) {
      var _p7 = op;
      switch (_p7.ctor)
      {case "Plus": return maybeFloat(n - j);
         case "Minus": return maybeFloat(j + n);
         case "Mult": return maybeFloat(n / j);
         case "Div": return maybeFloat(j * n);
         case "Pow": return $Maybe.Just(Math.pow(n,1 / j));
         case "Mod": return $Maybe.Nothing;
         case "ArcTan2": return maybeFloat(j / $Basics.tan(n));
         default: return _U.crashCase("Solver",
           {start: {line: 157,column: 17},end: {line: 165,column: 32}},
           _p7)("solveL");}
   });
   var solveTopDown = F2(function (subst,_p9) {
      var _p10 = _p9;
      var _p23 = _p10._1;
      var _p22 = _p10._0;
      var _p11 = _p23;
      _v7_3: do {
         if (_p11.ctor === "TrLoc") {
               if (_p11._0.ctor === "_Tuple3") {
                     var _p12 = A2($Dict.get,_p11._0._0,subst);
                     if (_p12.ctor === "Nothing") {
                           return $Maybe.Just(_p22);
                        } else {
                           return $Maybe.Nothing;
                        }
                  } else {
                     break _v7_3;
                  }
            } else {
               if (_p11._1.ctor === "::") {
                     if (_p11._1._1.ctor === "::") {
                           if (_p11._1._1._1.ctor === "[]") {
                                 var _p17 = _p11._1._1._0;
                                 var _p16 = _p11._1._0;
                                 var _p15 = _p11._0;
                                 var left = {ctor: "_Tuple2"
                                            ,_0: A2(evalTrace,subst,_p16)
                                            ,_1: A2(evalLoc,subst,_p17)};
                                 var right = {ctor: "_Tuple2"
                                             ,_0: A2(evalLoc,subst,_p16)
                                             ,_1: A2(evalTrace,subst,_p17)};
                                 var _p13 = {ctor: "_Tuple3"
                                            ,_0: isNumBinop(_p15)
                                            ,_1: left
                                            ,_2: right};
                                 _v9_4: do {
                                    _v9_3: do {
                                       _v9_2: do {
                                          _v9_0: do {
                                             if (_p13.ctor === "_Tuple3" && _p13._0 === true) {
                                                   if (_p13._1.ctor === "_Tuple2" && _p13._1._0.ctor === "Just")
                                                   {
                                                         if (_p13._1._1.ctor === "Just") {
                                                               if (_p13._2.ctor === "_Tuple2") {
                                                                     if (_p13._2._0.ctor === "Just") {
                                                                           if (_p13._1._1._0.ctor === "Nothing") {
                                                                                 break _v9_0;
                                                                              } else {
                                                                                 if (_p13._2._0._0.ctor === "Nothing" && _p13._2._1.ctor === "Just")
                                                                                 {
                                                                                       break _v9_2;
                                                                                    } else {
                                                                                       break _v9_4;
                                                                                    }
                                                                              }
                                                                        } else {
                                                                           if (_p13._1._1._0.ctor === "Nothing") {
                                                                                 break _v9_0;
                                                                              } else {
                                                                                 if (_p13._2._1.ctor === "Just") {
                                                                                       break _v9_3;
                                                                                    } else {
                                                                                       break _v9_4;
                                                                                    }
                                                                              }
                                                                        }
                                                                  } else {
                                                                     if (_p13._1._1._0.ctor === "Nothing") {
                                                                           break _v9_0;
                                                                        } else {
                                                                           break _v9_4;
                                                                        }
                                                                  }
                                                            } else {
                                                               return A2($Utils.bindMaybe,
                                                               function (n) {
                                                                  return A2(solveTopDown,
                                                                  subst,
                                                                  {ctor: "_Tuple2",_0: n,_1: _p17});
                                                               },
                                                               A3(solveR,_p15,_p22,_p13._1._0._0));
                                                            }
                                                      } else {
                                                         if (_p13._2.ctor === "_Tuple2") {
                                                               if (_p13._2._0.ctor === "Just") {
                                                                     if (_p13._2._0._0.ctor === "Nothing" && _p13._2._1.ctor === "Just")
                                                                     {
                                                                           break _v9_2;
                                                                        } else {
                                                                           break _v9_4;
                                                                        }
                                                                  } else {
                                                                     if (_p13._2._1.ctor === "Just") {
                                                                           break _v9_3;
                                                                        } else {
                                                                           break _v9_4;
                                                                        }
                                                                  }
                                                            } else {
                                                               break _v9_4;
                                                            }
                                                      }
                                                } else {
                                                   break _v9_4;
                                                }
                                          } while (false);
                                          return A3(solveR,_p15,_p22,_p13._1._0._0);
                                       } while (false);
                                       return A3(solveL,_p15,_p22,_p13._2._1._0);
                                    } while (false);
                                    return A2($Utils.bindMaybe,
                                    function (n) {
                                       return A2(solveTopDown,
                                       subst,
                                       {ctor: "_Tuple2",_0: n,_1: _p16});
                                    },
                                    A3(solveL,_p15,_p22,_p13._2._1._0));
                                 } while (false);
                                 var _p14 = A2(debugLog,
                                 "Sync.solveTopDown",
                                 $Lang.strTrace(_p23));
                                 return $Maybe.Nothing;
                              } else {
                                 break _v7_3;
                              }
                        } else {
                           var _p18 = A2(evalTrace,subst,_p11._1._0);
                           if (_p18.ctor === "Just") {
                                 return $Maybe.Nothing;
                              } else {
                                 var _p19 = _p11._0;
                                 switch (_p19.ctor)
                                 {case "Cos": return maybeFloat($Basics.acos(_p22));
                                    case "Sin": return maybeFloat($Basics.asin(_p22));
                                    case "ArcCos": return $Maybe.Just($Basics.cos(_p22));
                                    case "ArcSin": return $Maybe.Just($Basics.sin(_p22));
                                    case "Sqrt": return $Maybe.Just(_p22 * _p22);
                                    case "Round": return $Maybe.Nothing;
                                    case "Floor": return $Maybe.Nothing;
                                    case "Ceil": return $Maybe.Nothing;
                                    default: var _p20 = A2(debugLog,"TODO solveTopDown",_p23);
                                      return $Maybe.Nothing;}
                              }
                        }
                  } else {
                     break _v7_3;
                  }
            }
      } while (false);
      var _p21 = A2(debugLog,"TODO solveTopDown",_p23);
      return $Maybe.Nothing;
   });
   var solve = F2(function (subst,eqn) {
      return A2($Utils.plusMaybe,
      A2(termSolve,subst,eqn),
      A2(solveTopDown,subst,eqn));
   });
   var simpleSolve = F2(function (subst,_p24) {
      var _p25 = _p24;
      var _p32 = _p25._1;
      var walkTrace = function (t) {
         var _p26 = t;
         _v13_2: do {
            if (_p26.ctor === "TrLoc") {
                  if (_p26._0.ctor === "_Tuple3") {
                        var _p27 = A2($Dict.get,_p26._0._0,subst);
                        if (_p27.ctor === "Nothing") {
                              return $Maybe.Just({ctor: "_Tuple2",_0: 0,_1: 1});
                           } else {
                              return $Maybe.Just({ctor: "_Tuple2",_0: _p27._0,_1: 0});
                           }
                     } else {
                        break _v13_2;
                     }
               } else {
                  if (_p26._0.ctor === "Plus") {
                        var foo = F2(function (mx,macc) {
                           var _p28 = {ctor: "_Tuple2",_0: mx,_1: macc};
                           if (_p28.ctor === "_Tuple2" && _p28._0.ctor === "Just" && _p28._0._0.ctor === "_Tuple2" && _p28._1.ctor === "Just" && _p28._1._0.ctor === "_Tuple2")
                           {
                                 return $Maybe.Just({ctor: "_Tuple2"
                                                    ,_0: _p28._0._0._0 + _p28._1._0._0
                                                    ,_1: _p28._0._0._1 + _p28._1._0._1});
                              } else {
                                 return $Maybe.Nothing;
                              }
                        });
                        return A3($List.foldl,
                        foo,
                        $Maybe.Just({ctor: "_Tuple2",_0: 0,_1: 0}),
                        A2($List.map,walkTrace,_p26._1));
                     } else {
                        break _v13_2;
                     }
               }
         } while (false);
         var _p29 = A2(debugLog,"Sync.simpleSolve",$Lang.strTrace(_p32));
         return $Maybe.Nothing;
      };
      return A2($Utils.mapMaybe,
      function (_p30) {
         var _p31 = _p30;
         return (_p25._0 - _p31._0) / _p31._1;
      },
      walkTrace(_p32));
   });
   return _elm.Solver.values = {_op: _op,solve: solve};
};
Elm.Sync = Elm.Sync || {};
Elm.Sync.make = function (_elm) {
   "use strict";
   _elm.Sync = _elm.Sync || {};
   if (_elm.Sync.values) return _elm.Sync.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Ace = Elm.Ace.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Either = Elm.Either.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangParser2 = Elm.LangParser2.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $OurParser2 = Elm.OurParser2.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $ShapeWidgets = Elm.ShapeWidgets.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Solver = Elm.Solver.make(_elm),
   $String = Elm.String.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var acePos = function (p) {
      return {row: p.line,column: p.col};
   };
   var aceRange = function (x) {
      return {start: acePos(x.start),end: acePos(x.end)};
   };
   var makeHighlight = F3(function (subst,color,_p0) {
      var _p1 = _p0;
      var _p2 = A2($Dict.get,_p1._0,subst);
      if (_p2.ctor === "Just") {
            return {color: color,range: aceRange(_p2._0)};
         } else {
            return _U.crashCase("Sync",
            {start: {line: 1180,column: 3},end: {line: 1182,column: 63}},
            _p2)("makeHighlight: locid not in subst");
         }
   });
   var red = "salmon";
   var green = "limegreen";
   var yellow = "khaki";
   var highlightChanges = F3(function (initSubstPlus,
   locs,
   changes) {
      var _p4 = function () {
         var f = F2(function (loc,_p5) {
            var _p6 = _p5;
            var _p14 = _p6._1;
            var _p13 = _p6._0;
            var _p7 = loc;
            var locid = _p7._0;
            var highlight = function (c) {
               return A3(makeHighlight,initSubstPlus,c,loc);
            };
            var _p8 = {ctor: "_Tuple2"
                      ,_0: A2($Dict.get,locid,initSubstPlus)
                      ,_1: A2($Dict.get,locid,changes)};
            if (_p8._0.ctor === "Nothing") {
                  return _U.crashCase("Sync",
                  {start: {line: 1243,column: 7},end: {line: 1253,column: 49}},
                  _p8)("Controller.highlightChanges");
               } else {
                  if (_p8._1.ctor === "Nothing") {
                        return {ctor: "_Tuple2"
                               ,_0: A2($List._op["::"],highlight(yellow),_p13)
                               ,_1: _p14};
                     } else {
                        if (_p8._1._0.ctor === "Nothing") {
                              return {ctor: "_Tuple2"
                                     ,_0: A2($List._op["::"],highlight(red),_p13)
                                     ,_1: _p14};
                           } else {
                              var _p12 = _p8._1._0._0;
                              var _p11 = _p8._0._0;
                              if (_U.eq(_p12,_p11.val)) return {ctor: "_Tuple2"
                                                               ,_0: A2($List._op["::"],highlight(yellow),_p13)
                                                               ,_1: _p14}; else {
                                    var _p10 = {ctor: "_Tuple2"
                                               ,_0: $Lang.strNum(_p11.val)
                                               ,_1: $Lang.strNum(_p12)};
                                    var s = _p10._0;
                                    var s$ = _p10._1;
                                    var x = {ctor: "_Tuple2"
                                            ,_0: acePos(_p11.start)
                                            ,_1: $String.length(s$) - $String.length(s)};
                                    return {ctor: "_Tuple2"
                                           ,_0: A2($List._op["::"],highlight(green),_p13)
                                           ,_1: A2($List._op["::"],x,_p14)};
                                 }
                           }
                     }
               }
         });
         return A3($List.foldl,
         f,
         {ctor: "_Tuple2",_0: _U.list([]),_1: _U.list([])},
         $Set.toList(locs));
      }();
      var hi = _p4._0;
      var stringOffsets = _p4._1;
      var hi$ = function () {
         var g = F2(function (_p16,_p15) {
            var _p17 = _p16;
            var _p21 = _p17._0;
            var _p18 = _p15;
            var _p20 = _p18._0;
            var _p19 = _p18._1;
            var bump = function (pos) {
               return _U.update(pos,{column: pos.column + _p17._1});
            };
            var ret = function (new$) {
               return {ctor: "_Tuple2",_0: _p20,_1: new$};
            };
            return ret(!_U.eq(_p21.row,
            _p20.start.row) ? _p19 : _U.cmp(_p21.column,
            _p20.start.column) > 0 ? _p19 : _U.eq(_p21.column,
            _p20.start.column) ? {start: _p19.start
                                 ,end: bump(_p19.end)} : _U.cmp(_p21.column,
            _p20.start.column) < 0 ? {start: bump(_p19.start)
                                     ,end: bump(_p19.end)} : _U.crash("Sync",
            {start: {line: 1268,column: 11}
            ,end: {line: 1268,column: 22}})("highlightChanges"));
         });
         return A3($Basics.flip,
         $List.map,
         hi,
         function (_p22) {
            var _p23 = _p22;
            var _p25 = _p23.range;
            var _p24 = A3($List.foldl,
            g,
            {ctor: "_Tuple2",_0: _p25,_1: _p25},
            stringOffsets);
            var range$ = _p24._1;
            return {color: _p23.color,range: range$};
         });
      }();
      return hi$;
   });
   var gray = "lightgray";
   var opacityNumPlus = F2(function (n,dx) {
      var clamp = A2($Utils.clamp,0.0,1.0);
      var scale = 1 / $ShapeWidgets.wOpacitySlider;
      return clamp(n + scale * $Basics.toFloat(dx));
   });
   var strokeWidthNumPlus = F2(function (n,dx) {
      var scale = 1 / ($ShapeWidgets.wStrokeWidthSlider / $LangSvg.maxStrokeWidthNum);
      var clamp = function (_p26) {
         return $Basics.toFloat($Basics.round(A3($Utils.clamp,
         0,
         $LangSvg.maxStrokeWidthNum,
         _p26)));
      };
      return clamp(n + scale * $Basics.toFloat(dx));
   });
   var colorNumPlus = F2(function (n,dx) {
      var scale = 1 / ($ShapeWidgets.wColorSlider / $LangSvg.maxColorNum);
      var clamp = A2($Utils.clamp,0,$LangSvg.maxColorNum - 1);
      return clamp(n + scale * $Basics.toFloat(dx));
   });
   var addInteriorZone_ = F5(function (finishTrigger,
   pointX,
   pointY,
   indexedPoints,
   result) {
      var xTraces = A2($List.map,
      function (_p27) {
         return $Basics.snd($Basics.fst($Basics.snd(_p27)));
      },
      indexedPoints);
      var yTraces = A2($List.map,
      function (_p28) {
         return $Basics.snd($Basics.snd($Basics.snd(_p28)));
      },
      indexedPoints);
      return A4(finishTrigger,
      $ShapeWidgets.ZInterior,
      A2($Basics._op["++"],xTraces,yTraces),
      function (assignedMaybeLocs) {
         var _p29 = $Utils.projJusts(assignedMaybeLocs);
         if (_p29.ctor === "Nothing") {
               return _U.list([]);
            } else {
               var _p33 = _p29._0;
               var n = $List.length(_p33);
               var xLocs = A2($List.take,n / 2 | 0,_p33);
               var yLocs = A2($List.drop,n / 2 | 0,_p33);
               var stuff = A2($Utils.zip,
               A2($Utils.zip,xLocs,yLocs),
               indexedPoints);
               return A3($List.foldl,
               F2(function (_p30,acc) {
                  var _p31 = _p30;
                  var _p32 = _p31._1._0;
                  return A2($Basics._op["++"],
                  A4(pointX,
                  _p32,
                  $Maybe.Just(_p31._0._0),
                  _p31._1._1._0._0,
                  _p31._1._1._0._1),
                  A2($Basics._op["++"],
                  A4(pointY,
                  _p32,
                  $Maybe.Just(_p31._0._1),
                  _p31._1._1._1._0,
                  _p31._1._1._1._1),
                  acc));
               }),
               _U.list([]),
               stuff);
            }
      },
      result);
   });
   var addEdgeZones_ = F5(function (finishTrigger,
   pointX,
   pointY,
   edges,
   result) {
      return A3($List.foldl,
      F2(function (_p34,acc) {
         var _p35 = _p34;
         var _p44 = _p35._1._1._1._1;
         var _p43 = _p35._0._1._1._1;
         var _p42 = _p35._1._1._0._1;
         var _p41 = _p35._0._1._0._1;
         var _p40 = _p35._1._0;
         var _p39 = _p35._0._0;
         return A4(finishTrigger,
         $ShapeWidgets.ZPolyEdge(_p39),
         _U.list([_p41,_p43,_p42,_p44]),
         function (_p36) {
            return function (_p37) {
               var _p38 = _p37;
               return A2($Basics._op["++"],
               A4(pointX,_p39,_p38._0,_p35._0._1._0._0,_p41),
               A2($Basics._op["++"],
               A4(pointY,_p39,_p38._1,_p35._0._1._1._0,_p43),
               A2($Basics._op["++"],
               A4(pointX,_p40,_p38._2,_p35._1._1._0._0,_p42),
               A4(pointY,_p40,_p38._3,_p35._1._1._1._0,_p44))));
            }($Utils.unwrap4(_p36));
         },
         acc);
      }),
      result,
      edges);
   });
   var addPointZones_ = F5(function (finishTrigger,
   pointX,
   pointY,
   indexedPoints,
   result) {
      return A3($List.foldl,
      F2(function (_p45,acc) {
         var _p46 = _p45;
         var _p52 = _p46._1._1._1;
         var _p51 = _p46._1._0._1;
         var _p50 = _p46._0;
         return A4(finishTrigger,
         $ShapeWidgets.ZPoint($ShapeWidgets.Point(_p50)),
         _U.list([_p51,_p52]),
         function (_p47) {
            return function (_p48) {
               var _p49 = _p48;
               return A2($Basics._op["++"],
               A4(pointX,_p50,_p49._0,_p46._1._0._0,_p51),
               A4(pointY,_p50,_p49._1,_p46._1._1._0,_p52));
            }($Utils.unwrap2(_p47));
         },
         acc);
      }),
      result,
      indexedPoints);
   });
   var mapMaybeToList = F2(function (mx,f) {
      var _p53 = mx;
      if (_p53.ctor === "Nothing") {
            return _U.list([]);
         } else {
            return _U.list([f(_p53._0)]);
         }
   });
   var solveOne = F4(function (subst,_p54,n$,t) {
      var _p55 = _p54;
      var subst$ = A2($Dict.remove,_p55._0,subst);
      var maybeSolution = A2($Solver.solve,
      subst$,
      {ctor: "_Tuple2",_0: n$,_1: t});
      return maybeSolution;
   });
   var pointX_ = F5(function (subst,i,xMaybeLoc,x,xTrace) {
      return A2(mapMaybeToList,
      xMaybeLoc,
      function (xLoc) {
         return {ctor: "_Tuple5"
                ,_0: A2($Basics._op["++"],"X",$Basics.toString(i))
                ,_1: "dx"
                ,_2: xLoc
                ,_3: xTrace
                ,_4: F2(function (_p57,_p56) {
                   var _p58 = _p56;
                   return A4(solveOne,
                   subst,
                   xLoc,
                   x + $Basics.toFloat(_p58._0),
                   xTrace);
                })};
      });
   });
   var pointY_ = F5(function (subst,i,yMaybeLoc,y,yTrace) {
      return A2(mapMaybeToList,
      yMaybeLoc,
      function (yLoc) {
         return {ctor: "_Tuple5"
                ,_0: A2($Basics._op["++"],"Y",$Basics.toString(i))
                ,_1: "dy"
                ,_2: yLoc
                ,_3: yTrace
                ,_4: F2(function (_p60,_p59) {
                   var _p61 = _p59;
                   return A4(solveOne,
                   subst,
                   yLoc,
                   y + $Basics.toFloat(_p61._1),
                   yTrace);
                })};
      });
   });
   var LiveInfo = F3(function (a,b,c) {
      return {shapeTriggers: a,widgetTriggers: b,initSubstPlus: c};
   });
   var convertEmptyToNonEmpty = function (locList) {
      var _p62 = locList;
      if (_p62.ctor === "[]") {
            return _U.list([$Maybe.Nothing]);
         } else {
            return A2($List.map,$Maybe.Just,locList);
         }
   };
   var coerceMaybeLoc = function (m) {
      var _p63 = m;
      if (_p63.ctor === "Just") {
            return _p63._0;
         } else {
            return $Lang.dummyLoc;
         }
   };
   var coerceMaybeLocList = $List.map(coerceMaybeLoc);
   var getCount = F2(function (x,dict) {
      return A2($Maybe.withDefault,0,A2($Dict.get,x,dict));
   });
   var updateCount = F2(function (x,dict) {
      return A3($Dict.insert,x,1 + A2(getCount,x,dict),dict);
   });
   var updateFairCount = F2(function (x,dict) {
      return A2(updateCount,coerceMaybeLocList(x),dict);
   });
   var addCount = F3(function (k,x,dict) {
      return A3($Dict.insert,x,k + A2(getCount,x,dict),dict);
   });
   var getFairCount = F2(function (x,dict) {
      return A2(getCount,coerceMaybeLocList(x),dict);
   });
   var chooseFairLocationAssignment = F2(function (locSets,
   fairCounts) {
      var noAssignment = function (_p64) {
         var _p65 = _p64;
         var allNothings = A2($List.repeat,
         $List.length(locSets),
         $Maybe.Nothing);
         return {ctor: "_Tuple2",_0: allNothings,_1: fairCounts};
      };
      var numCandidates = A3($List.foldl,
      F2(function (x,y) {    return x * y;}),
      1,
      A2($List.map,$Set.size,locSets));
      if (_U.cmp(numCandidates,100) > 0)
      return noAssignment({ctor: "_Tuple0"}); else {
            var sorted = A2($List.sortBy,
            function (assignment) {
               return A2(getFairCount,assignment,fairCounts);
            },
            $Utils.oneOfEach(A2($List.map,
            convertEmptyToNonEmpty,
            A2($List.map,$Set.toList,locSets))));
            var _p66 = sorted;
            if (_p66.ctor === "[]") {
                  return noAssignment({ctor: "_Tuple0"});
               } else {
                  var _p67 = _p66._0;
                  var fairCounts$ = A2(updateFairCount,_p67,fairCounts);
                  return {ctor: "_Tuple2",_0: _p67,_1: fairCounts$};
               }
         }
   });
   var chooseBiased = F2(function (biasCounts,locSet) {
      var sorted = A2($List.sortBy,
      function (loc) {
         return A2(getCount,loc,biasCounts);
      },
      $Set.toList(locSet));
      var _p68 = sorted;
      if (_p68.ctor === "::") {
            return $Maybe.Just(_p68._0);
         } else {
            return $Maybe.Nothing;
         }
   });
   var Options = F3(function (a,b,c) {
      return {thawedByDefault: a,feelingLucky: b,unfreezeAll: c};
   });
   var heuristicModes = 3;
   var _p69 = $Utils.unwrap3(_U.range(0,heuristicModes - 1));
   var heuristicsNone = _p69._0;
   var heuristicsFair = _p69._1;
   var heuristicsBiased = _p69._2;
   var defaultOptions = {thawedByDefault: true
                        ,feelingLucky: heuristicsBiased
                        ,unfreezeAll: false};
   var locsOfTrace = function (opts) {
      var frozenByDefault = $Basics.not(opts.thawedByDefault);
      var notUnfreezeAll = $Basics.not(opts.unfreezeAll);
      var foo = function (t) {
         var _p70 = t;
         if (_p70.ctor === "TrLoc") {
               var _p72 = _p70._0;
               var _p71 = _p72;
               var b = _p71._1;
               return $LangParser2.isPreludeLoc(_p72) ? $Set.empty : _U.eq(b,
               $Lang.frozen) && notUnfreezeAll ? $Set.empty : _U.eq(b,
               $Lang.unann) && frozenByDefault ? $Set.empty : $Set.singleton(_p72);
            } else {
               return A3($List.foldl,
               $Set.union,
               $Set.empty,
               A2($List.map,foo,_p70._1));
            }
      };
      return function (tr) {
         var s = foo(tr);
         return _U.eq(opts.feelingLucky,
         heuristicsNone) ? _U.cmp($List.length($Set.toList(s)),
         1) < 1 ? s : $Set.empty : s;
      };
   };
   var locsOfTraces = F2(function (options,traces) {
      return A3($List.foldl,
      F2(function (t,acc) {
         return A2($Set.union,acc,A2(locsOfTrace,options,t));
      }),
      $Set.empty,
      traces);
   });
   var pickLocs = F3(function (options,maybeCounts,traces) {
      var locSets = A2($List.map,locsOfTrace(options),traces);
      var allLocs = A3($List.foldl,$Set.union,$Set.empty,locSets);
      var _p73 = function () {
         var _p74 = maybeCounts;
         if (_p74.ctor === "Nothing") {
               return {ctor: "_Tuple2"
                      ,_0: A2($List.map,$Basics.always($Maybe.Nothing),locSets)
                      ,_1: $Maybe.Nothing};
            } else {
               if (_p74._0.ctor === "Left") {
                     var _p75 = _p74._0._0;
                     return {ctor: "_Tuple2"
                            ,_0: A2($List.map,chooseBiased(_p75),locSets)
                            ,_1: $Maybe.Just($Either.Left(_p75))};
                  } else {
                     return A2($Utils.mapSnd,
                     function (_p76) {
                        return $Maybe.Just($Either.Right(_p76));
                     },
                     A2(chooseFairLocationAssignment,locSets,_p74._0._0));
                  }
            }
      }();
      var assignedMaybeLocs = _p73._0;
      var maybeCounts$ = _p73._1;
      return {ctor: "_Tuple3"
             ,_0: assignedMaybeLocs
             ,_1: allLocs
             ,_2: maybeCounts$};
   });
   var addTrigger = F5(function (options,
   key,
   traces,
   makeTrigger,
   _p77) {
      var _p78 = _p77;
      var _p79 = A3(pickLocs,options,_p78._1,traces);
      var assignedMaybeLocs = _p79._0;
      var allLocs = _p79._1;
      var maybeCounts$ = _p79._2;
      var trigger = makeTrigger(assignedMaybeLocs);
      var yellowLocs = A3($List.foldl,
      F2(function (triggerElt,acc) {
         var _p80 = triggerElt;
         var loc = _p80._2;
         return A2($Set.insert,loc,acc);
      }),
      $Set.empty,
      trigger);
      var grayLocs = A2($Set.diff,allLocs,yellowLocs);
      var dict$ = A3($Dict.insert,
      key,
      {ctor: "_Tuple3",_0: trigger,_1: yellowLocs,_2: grayLocs},
      _p78._0);
      return {ctor: "_Tuple2",_0: dict$,_1: maybeCounts$};
   });
   var addShapeZoneTrigger = F3(function (options,id,realZone) {
      return A2(addTrigger,
      options,
      {ctor: "_Tuple2"
      ,_0: id
      ,_1: $ShapeWidgets.unparseZone(realZone)});
   });
   var computeRectTriggers = F3(function (_p82,maybeCounts,_p81) {
      var _p83 = _p82;
      var _p118 = _p83._1;
      var _p84 = _p81;
      var finishTrigger = A2(addShapeZoneTrigger,_p83._0,_p84._0);
      var _p85 = $Utils.unwrap4(A2($List.map,
      function (_p86) {
         return $LangSvg.toNum(A2($Utils.find_,_p84._2,_p86));
      },
      _U.list(["x","y","width","height"])));
      var x = _p85._0._0;
      var xTrace = _p85._0._1;
      var y = _p85._1._0;
      var yTrace = _p85._1._1;
      var w = _p85._2._0;
      var wTrace = _p85._2._1;
      var h = _p85._3._0;
      var hTrace = _p85._3._1;
      var leftEdge = F2(function (xMaybeLoc,wMaybeLoc) {
         return A2($Basics._op["++"],
         A2(mapMaybeToList,
         xMaybeLoc,
         function (xLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "x"
                   ,_1: "dx"
                   ,_2: xLoc
                   ,_3: xTrace
                   ,_4: F2(function (_p88,_p87) {
                      var _p89 = _p87;
                      return A4(solveOne,
                      _p118,
                      xLoc,
                      x + $Basics.toFloat(_p89._0),
                      xTrace);
                   })};
         }),
         A2(mapMaybeToList,
         wMaybeLoc,
         function (wLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "width"
                   ,_1: "dx"
                   ,_2: wLoc
                   ,_3: wTrace
                   ,_4: F2(function (_p91,_p90) {
                      var _p92 = _p90;
                      return A4(solveOne,
                      _p118,
                      wLoc,
                      w - $Basics.toFloat(_p92._0),
                      wTrace);
                   })};
         }));
      });
      var rightEdge = function (wMaybeLoc) {
         return A2(mapMaybeToList,
         wMaybeLoc,
         function (wLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "width"
                   ,_1: "dx"
                   ,_2: wLoc
                   ,_3: wTrace
                   ,_4: F2(function (_p94,_p93) {
                      var _p95 = _p93;
                      return A4(solveOne,
                      _p118,
                      wLoc,
                      w + $Basics.toFloat(_p95._0),
                      wTrace);
                   })};
         });
      };
      var topEdge = F2(function (yMaybeLoc,hMaybeLoc) {
         return A2($Basics._op["++"],
         A2(mapMaybeToList,
         yMaybeLoc,
         function (yLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "y"
                   ,_1: "dy"
                   ,_2: yLoc
                   ,_3: yTrace
                   ,_4: F2(function (_p97,_p96) {
                      var _p98 = _p96;
                      return A4(solveOne,
                      _p118,
                      yLoc,
                      y + $Basics.toFloat(_p98._1),
                      yTrace);
                   })};
         }),
         A2(mapMaybeToList,
         hMaybeLoc,
         function (hLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "height"
                   ,_1: "dy"
                   ,_2: hLoc
                   ,_3: hTrace
                   ,_4: F2(function (_p100,_p99) {
                      var _p101 = _p99;
                      return A4(solveOne,
                      _p118,
                      hLoc,
                      h - $Basics.toFloat(_p101._1),
                      hTrace);
                   })};
         }));
      });
      var botEdge = function (hMaybeLoc) {
         return A2(mapMaybeToList,
         hMaybeLoc,
         function (hLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "height"
                   ,_1: "dy"
                   ,_2: hLoc
                   ,_3: hTrace
                   ,_4: F2(function (_p103,_p102) {
                      var _p104 = _p102;
                      return A4(solveOne,
                      _p118,
                      hLoc,
                      h + $Basics.toFloat(_p104._1),
                      hTrace);
                   })};
         });
      };
      return A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.LeftEdge),
      _U.list([xTrace,wTrace]),
      function (assignedMaybeLocs) {
         var _p105 = $Utils.unwrap2(assignedMaybeLocs);
         var xMaybeLoc = _p105._0;
         var wMaybeLoc = _p105._1;
         return A2(leftEdge,xMaybeLoc,wMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotLeft),
      _U.list([xTrace,wTrace,hTrace]),
      function (assignedMaybeLocs) {
         var _p106 = $Utils.unwrap3(assignedMaybeLocs);
         var xMaybeLoc = _p106._0;
         var wMaybeLoc = _p106._1;
         var hMaybeLoc = _p106._2;
         return A2($Basics._op["++"],
         A2(leftEdge,xMaybeLoc,wMaybeLoc),
         botEdge(hMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotEdge),
      _U.list([hTrace]),
      function (assignedMaybeLocs) {
         var hMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return botEdge(hMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotRight),
      _U.list([wTrace,hTrace]),
      function (assignedMaybeLocs) {
         var _p107 = $Utils.unwrap2(assignedMaybeLocs);
         var wMaybeLoc = _p107._0;
         var hMaybeLoc = _p107._1;
         return A2($Basics._op["++"],
         rightEdge(wMaybeLoc),
         botEdge(hMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.RightEdge),
      _U.list([wTrace]),
      function (assignedMaybeLocs) {
         var wMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return rightEdge(wMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopRight),
      _U.list([yTrace,wTrace,hTrace]),
      function (assignedMaybeLocs) {
         var _p108 = $Utils.unwrap3(assignedMaybeLocs);
         var yMaybeLoc = _p108._0;
         var wMaybeLoc = _p108._1;
         var hMaybeLoc = _p108._2;
         return A2($Basics._op["++"],
         A2(topEdge,yMaybeLoc,hMaybeLoc),
         rightEdge(wMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopEdge),
      _U.list([yTrace,hTrace]),
      function (assignedMaybeLocs) {
         var _p109 = $Utils.unwrap2(assignedMaybeLocs);
         var yMaybeLoc = _p109._0;
         var hMaybeLoc = _p109._1;
         return A2(topEdge,yMaybeLoc,hMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopLeft),
      _U.list([xTrace,yTrace,wTrace,hTrace]),
      function (assignedMaybeLocs) {
         var _p110 = $Utils.unwrap4(assignedMaybeLocs);
         var xMaybeLoc = _p110._0;
         var yMaybeLoc = _p110._1;
         var wMaybeLoc = _p110._2;
         var hMaybeLoc = _p110._3;
         return A2($Basics._op["++"],
         A2(leftEdge,xMaybeLoc,wMaybeLoc),
         A2(topEdge,yMaybeLoc,hMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZInterior,
      _U.list([xTrace,yTrace]),
      function (assignedMaybeLocs) {
         var _p111 = $Utils.unwrap2(assignedMaybeLocs);
         var xMaybeLoc = _p111._0;
         var yMaybeLoc = _p111._1;
         return A2($Basics._op["++"],
         A2(mapMaybeToList,
         xMaybeLoc,
         function (xLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "x"
                   ,_1: "dx"
                   ,_2: xLoc
                   ,_3: xTrace
                   ,_4: F2(function (_p113,_p112) {
                      var _p114 = _p112;
                      return A4(solveOne,
                      _p118,
                      xLoc,
                      x + $Basics.toFloat(_p114._0),
                      xTrace);
                   })};
         }),
         A2(mapMaybeToList,
         yMaybeLoc,
         function (yLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "y"
                   ,_1: "dy"
                   ,_2: yLoc
                   ,_3: yTrace
                   ,_4: F2(function (_p116,_p115) {
                      var _p117 = _p115;
                      return A4(solveOne,
                      _p118,
                      yLoc,
                      y + $Basics.toFloat(_p117._1),
                      yTrace);
                   })};
         }));
      },
      {ctor: "_Tuple2",_0: $Dict.empty,_1: maybeCounts})))))))));
   });
   var computeLineTriggers = F3(function (_p120,
   maybeCounts,
   _p119) {
      var _p121 = _p120;
      var _p135 = _p121._1;
      var _p122 = _p119;
      var finishTrigger = A2(addShapeZoneTrigger,_p121._0,_p122._0);
      var _p123 = $Utils.unwrap4(A2($List.map,
      function (_p124) {
         return $LangSvg.toNum(A2($Utils.find_,_p122._2,_p124));
      },
      _U.list(["x1","y1","x2","y2"])));
      var x1 = _p123._0._0;
      var x1Trace = _p123._0._1;
      var y1 = _p123._1._0;
      var y1Trace = _p123._1._1;
      var x2 = _p123._2._0;
      var x2Trace = _p123._2._1;
      var y2 = _p123._3._0;
      var y2Trace = _p123._3._1;
      var point = F3(function (i,xMaybeLoc,yMaybeLoc) {
         var _p125 = _U.eq(i,1) ? {ctor: "_Tuple4"
                                  ,_0: x1
                                  ,_1: x1Trace
                                  ,_2: y1
                                  ,_3: y1Trace} : {ctor: "_Tuple4"
                                                  ,_0: x2
                                                  ,_1: x2Trace
                                                  ,_2: y2
                                                  ,_3: y2Trace};
         var x = _p125._0;
         var xTrace = _p125._1;
         var y = _p125._2;
         var yTrace = _p125._3;
         return A2($Basics._op["++"],
         A2(mapMaybeToList,
         xMaybeLoc,
         function (xLoc) {
            return {ctor: "_Tuple5"
                   ,_0: A2($Basics._op["++"],"x",$Basics.toString(i))
                   ,_1: "dx"
                   ,_2: xLoc
                   ,_3: xTrace
                   ,_4: F2(function (_p127,_p126) {
                      var _p128 = _p126;
                      return A4(solveOne,
                      _p135,
                      xLoc,
                      x + $Basics.toFloat(_p128._0),
                      xTrace);
                   })};
         }),
         A2(mapMaybeToList,
         yMaybeLoc,
         function (yLoc) {
            return {ctor: "_Tuple5"
                   ,_0: A2($Basics._op["++"],"y",$Basics.toString(i))
                   ,_1: "dy"
                   ,_2: yLoc
                   ,_3: yTrace
                   ,_4: F2(function (_p130,_p129) {
                      var _p131 = _p129;
                      return A4(solveOne,
                      _p135,
                      yLoc,
                      y + $Basics.toFloat(_p131._1),
                      yTrace);
                   })};
         }));
      });
      return A4(finishTrigger,
      $ShapeWidgets.ZLineEdge,
      _U.list([x1Trace,y1Trace,x2Trace,y2Trace]),
      function (assignedMaybeLocs) {
         var _p132 = $Utils.unwrap4(assignedMaybeLocs);
         var xMaybeLoc1 = _p132._0;
         var yMaybeLoc1 = _p132._1;
         var xMaybeLoc2 = _p132._2;
         var yMaybeLoc2 = _p132._3;
         return A2($Basics._op["++"],
         A3(point,1,xMaybeLoc1,yMaybeLoc1),
         A3(point,2,xMaybeLoc2,yMaybeLoc2));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.Point(2)),
      _U.list([x2Trace,y2Trace]),
      function (assignedMaybeLocs) {
         var _p133 = $Utils.unwrap2(assignedMaybeLocs);
         var xMaybeLoc2 = _p133._0;
         var yMaybeLoc2 = _p133._1;
         return A3(point,2,xMaybeLoc2,yMaybeLoc2);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.Point(1)),
      _U.list([x1Trace,y1Trace]),
      function (assignedMaybeLocs) {
         var _p134 = $Utils.unwrap2(assignedMaybeLocs);
         var xMaybeLoc1 = _p134._0;
         var yMaybeLoc1 = _p134._1;
         return A3(point,1,xMaybeLoc1,yMaybeLoc1);
      },
      {ctor: "_Tuple2",_0: $Dict.empty,_1: maybeCounts})));
   });
   var computeEllipseTriggers = F3(function (_p137,
   maybeCounts,
   _p136) {
      var _p138 = _p137;
      var _p165 = _p138._1;
      var _p139 = _p136;
      var finishTrigger = A2(addShapeZoneTrigger,_p138._0,_p139._0);
      var _p140 = $Utils.unwrap4(A2($List.map,
      function (_p141) {
         return $LangSvg.toNum(A2($Utils.find_,_p139._2,_p141));
      },
      _U.list(["cx","cy","rx","ry"])));
      var cx = _p140._0._0;
      var cxTrace = _p140._0._1;
      var cy = _p140._1._0;
      var cyTrace = _p140._1._1;
      var rx = _p140._2._0;
      var rxTrace = _p140._2._1;
      var ry = _p140._3._0;
      var ryTrace = _p140._3._1;
      var leftEdge = function (rxMaybeLoc) {
         return A2(mapMaybeToList,
         rxMaybeLoc,
         function (rxLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "rx"
                   ,_1: "dx"
                   ,_2: rxLoc
                   ,_3: rxTrace
                   ,_4: F2(function (_p143,_p142) {
                      var _p144 = _p142;
                      return A4(solveOne,
                      _p165,
                      rxLoc,
                      rx - $Basics.toFloat(_p144._0),
                      rxTrace);
                   })};
         });
      };
      var rightEdge = function (rxMaybeLoc) {
         return A2(mapMaybeToList,
         rxMaybeLoc,
         function (rxLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "rx"
                   ,_1: "dx"
                   ,_2: rxLoc
                   ,_3: rxTrace
                   ,_4: F2(function (_p146,_p145) {
                      var _p147 = _p145;
                      return A4(solveOne,
                      _p165,
                      rxLoc,
                      rx + $Basics.toFloat(_p147._0),
                      rxTrace);
                   })};
         });
      };
      var topEdge = function (ryMaybeLoc) {
         return A2(mapMaybeToList,
         ryMaybeLoc,
         function (ryLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "ry"
                   ,_1: "dy"
                   ,_2: ryLoc
                   ,_3: ryTrace
                   ,_4: F2(function (_p149,_p148) {
                      var _p150 = _p148;
                      return A4(solveOne,
                      _p165,
                      ryLoc,
                      ry - $Basics.toFloat(_p150._1),
                      ryTrace);
                   })};
         });
      };
      var botEdge = function (ryMaybeLoc) {
         return A2(mapMaybeToList,
         ryMaybeLoc,
         function (ryLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "ry"
                   ,_1: "dy"
                   ,_2: ryLoc
                   ,_3: ryTrace
                   ,_4: F2(function (_p152,_p151) {
                      var _p153 = _p151;
                      return A4(solveOne,
                      _p165,
                      ryLoc,
                      ry + $Basics.toFloat(_p153._1),
                      ryTrace);
                   })};
         });
      };
      return A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.LeftEdge),
      _U.list([rxTrace]),
      function (assignedMaybeLocs) {
         var leftMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return leftEdge(leftMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotLeft),
      _U.list([rxTrace,ryTrace]),
      function (assignedMaybeLocs) {
         var _p154 = $Utils.unwrap2(assignedMaybeLocs);
         var leftMaybeLoc = _p154._0;
         var botMaybeLoc = _p154._1;
         return A2($Basics._op["++"],
         leftEdge(leftMaybeLoc),
         botEdge(botMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotEdge),
      _U.list([ryTrace]),
      function (assignedMaybeLocs) {
         var botMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return botEdge(botMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotRight),
      _U.list([rxTrace,ryTrace]),
      function (assignedMaybeLocs) {
         var _p155 = $Utils.unwrap2(assignedMaybeLocs);
         var rightMaybeLoc = _p155._0;
         var botMaybeLoc = _p155._1;
         return A2($Basics._op["++"],
         rightEdge(rightMaybeLoc),
         botEdge(botMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.RightEdge),
      _U.list([rxTrace]),
      function (assignedMaybeLocs) {
         var rightMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return rightEdge(rightMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopRight),
      _U.list([rxTrace,ryTrace]),
      function (assignedMaybeLocs) {
         var _p156 = $Utils.unwrap2(assignedMaybeLocs);
         var rightMaybeLoc = _p156._0;
         var topMaybeLoc = _p156._1;
         return A2($Basics._op["++"],
         rightEdge(rightMaybeLoc),
         topEdge(topMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopEdge),
      _U.list([ryTrace]),
      function (assignedMaybeLocs) {
         var topMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return topEdge(topMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopLeft),
      _U.list([rxTrace,ryTrace]),
      function (assignedMaybeLocs) {
         var _p157 = $Utils.unwrap2(assignedMaybeLocs);
         var leftMaybeLoc = _p157._0;
         var topMaybeLoc = _p157._1;
         return A2($Basics._op["++"],
         leftEdge(leftMaybeLoc),
         topEdge(topMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZInterior,
      _U.list([cxTrace,cyTrace]),
      function (assignedMaybeLocs) {
         var _p158 = $Utils.unwrap2(assignedMaybeLocs);
         var cxMaybeLoc = _p158._0;
         var cyMaybeLoc = _p158._1;
         return A2($Basics._op["++"],
         A2(mapMaybeToList,
         cxMaybeLoc,
         function (cxLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "cx"
                   ,_1: "dx"
                   ,_2: cxLoc
                   ,_3: cxTrace
                   ,_4: F2(function (_p160,_p159) {
                      var _p161 = _p159;
                      return A4(solveOne,
                      _p165,
                      cxLoc,
                      cx + $Basics.toFloat(_p161._0),
                      cxTrace);
                   })};
         }),
         A2(mapMaybeToList,
         cyMaybeLoc,
         function (cyLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "cy"
                   ,_1: "dy"
                   ,_2: cyLoc
                   ,_3: cyTrace
                   ,_4: F2(function (_p163,_p162) {
                      var _p164 = _p162;
                      return A4(solveOne,
                      _p165,
                      cyLoc,
                      cy + $Basics.toFloat(_p164._1),
                      cyTrace);
                   })};
         }));
      },
      {ctor: "_Tuple2",_0: $Dict.empty,_1: maybeCounts})))))))));
   });
   var computeCircleTriggers = F3(function (_p167,
   maybeCounts,
   _p166) {
      var _p168 = _p167;
      var _p194 = _p168._1;
      var _p169 = _p166;
      var finishTrigger = A2(addShapeZoneTrigger,_p168._0,_p169._0);
      var co = F2(function (x,y) {    return x * y;})(1);
      var contra = F2(function (x,y) {    return x * y;})(-1);
      var _p170 = $Utils.unwrap3(A2($List.map,
      function (_p171) {
         return $LangSvg.toNum(A2($Utils.find_,_p169._2,_p171));
      },
      _U.list(["cx","cy","r"])));
      var cx = _p170._0._0;
      var cxTrace = _p170._0._1;
      var cy = _p170._1._0;
      var cyTrace = _p170._1._1;
      var r = _p170._2._0;
      var rTrace = _p170._2._1;
      var leftEdge = function (rMaybeLoc) {
         return A2(mapMaybeToList,
         rMaybeLoc,
         function (rLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "r"
                   ,_1: "dx"
                   ,_2: rLoc
                   ,_3: rTrace
                   ,_4: F2(function (_p173,_p172) {
                      var _p174 = _p172;
                      return A4(solveOne,
                      _p194,
                      rLoc,
                      r - $Basics.toFloat(_p174._0),
                      rTrace);
                   })};
         });
      };
      var rightEdge = function (rMaybeLoc) {
         return A2(mapMaybeToList,
         rMaybeLoc,
         function (rLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "r"
                   ,_1: "dx"
                   ,_2: rLoc
                   ,_3: rTrace
                   ,_4: F2(function (_p176,_p175) {
                      var _p177 = _p175;
                      return A4(solveOne,
                      _p194,
                      rLoc,
                      r + $Basics.toFloat(_p177._0),
                      rTrace);
                   })};
         });
      };
      var topEdge = function (rMaybeLoc) {
         return A2(mapMaybeToList,
         rMaybeLoc,
         function (rLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "r"
                   ,_1: "dy"
                   ,_2: rLoc
                   ,_3: rTrace
                   ,_4: F2(function (_p179,_p178) {
                      var _p180 = _p178;
                      return A4(solveOne,
                      _p194,
                      rLoc,
                      r - $Basics.toFloat(_p180._1),
                      rTrace);
                   })};
         });
      };
      var botEdge = function (rMaybeLoc) {
         return A2(mapMaybeToList,
         rMaybeLoc,
         function (rLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "r"
                   ,_1: "dy"
                   ,_2: rLoc
                   ,_3: rTrace
                   ,_4: F2(function (_p182,_p181) {
                      var _p183 = _p181;
                      return A4(solveOne,
                      _p194,
                      rLoc,
                      r + $Basics.toFloat(_p183._1),
                      rTrace);
                   })};
         });
      };
      var corner = F3(function (rMaybeLoc,fx,fy) {
         return A2(mapMaybeToList,
         rMaybeLoc,
         function (rLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "r"
                   ,_1: "dxy"
                   ,_2: rLoc
                   ,_3: rTrace
                   ,_4: F2(function (_p185,_p184) {
                      var _p186 = _p184;
                      var d = A2($Basics.max,fx(_p186._0),fy(_p186._1));
                      return A4(solveOne,_p194,rLoc,r + $Basics.toFloat(d),rTrace);
                   })};
         });
      });
      return A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.LeftEdge),
      _U.list([rTrace]),
      function (assignedMaybeLocs) {
         var rMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return leftEdge(rMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotLeft),
      _U.list([rTrace]),
      function (assignedMaybeLocs) {
         var rMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return A3(corner,rMaybeLoc,contra,co);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotEdge),
      _U.list([rTrace]),
      function (assignedMaybeLocs) {
         var rMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return botEdge(rMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotRight),
      _U.list([rTrace]),
      function (assignedMaybeLocs) {
         var rMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return A3(corner,rMaybeLoc,co,co);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.RightEdge),
      _U.list([rTrace]),
      function (assignedMaybeLocs) {
         var rMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return rightEdge(rMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopRight),
      _U.list([rTrace]),
      function (assignedMaybeLocs) {
         var rMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return A3(corner,rMaybeLoc,co,contra);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopEdge),
      _U.list([rTrace]),
      function (assignedMaybeLocs) {
         var rMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return topEdge(rMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopLeft),
      _U.list([rTrace]),
      function (assignedMaybeLocs) {
         var rMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return A3(corner,rMaybeLoc,contra,contra);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZInterior,
      _U.list([cxTrace,cyTrace]),
      function (assignedMaybeLocs) {
         var _p187 = $Utils.unwrap2(assignedMaybeLocs);
         var cxMaybeLoc = _p187._0;
         var cyMaybeLoc = _p187._1;
         return A2($Basics._op["++"],
         A2(mapMaybeToList,
         cxMaybeLoc,
         function (cxLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "cx"
                   ,_1: "dx"
                   ,_2: cxLoc
                   ,_3: cxTrace
                   ,_4: F2(function (_p189,_p188) {
                      var _p190 = _p188;
                      return A4(solveOne,
                      _p194,
                      cxLoc,
                      cx + $Basics.toFloat(_p190._0),
                      cxTrace);
                   })};
         }),
         A2(mapMaybeToList,
         cyMaybeLoc,
         function (cyLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "cy"
                   ,_1: "dy"
                   ,_2: cyLoc
                   ,_3: cyTrace
                   ,_4: F2(function (_p192,_p191) {
                      var _p193 = _p191;
                      return A4(solveOne,
                      _p194,
                      cyLoc,
                      cy + $Basics.toFloat(_p193._1),
                      cyTrace);
                   })};
         }));
      },
      {ctor: "_Tuple2",_0: $Dict.empty,_1: maybeCounts})))))))));
   });
   var computeBoxOrOvalTriggers = F3(function (_p196,
   maybeCounts,
   _p195) {
      var _p197 = _p196;
      var _p218 = _p197._1;
      var _p198 = _p195;
      var finishTrigger = A2(addShapeZoneTrigger,_p197._0,_p198._0);
      var _p199 = $Utils.unwrap4(A2($List.map,
      function (_p200) {
         return $LangSvg.toNum(A2($Utils.find_,_p198._2,_p200));
      },
      _U.list(["LEFT","TOP","RIGHT","BOT"])));
      var left = _p199._0._0;
      var leftTrace = _p199._0._1;
      var top = _p199._1._0;
      var topTrace = _p199._1._1;
      var right = _p199._2._0;
      var rightTrace = _p199._2._1;
      var bot = _p199._3._0;
      var botTrace = _p199._3._1;
      var leftEdge = function (leftMaybeLoc) {
         return A2(mapMaybeToList,
         leftMaybeLoc,
         function (leftLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "LEFT"
                   ,_1: "dx"
                   ,_2: leftLoc
                   ,_3: leftTrace
                   ,_4: F2(function (_p202,_p201) {
                      var _p203 = _p201;
                      return A4(solveOne,
                      _p218,
                      leftLoc,
                      left + $Basics.toFloat(_p203._0),
                      leftTrace);
                   })};
         });
      };
      var rightEdge = function (rightMaybeLoc) {
         return A2(mapMaybeToList,
         rightMaybeLoc,
         function (rightLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "RIGHT"
                   ,_1: "dx"
                   ,_2: rightLoc
                   ,_3: rightTrace
                   ,_4: F2(function (_p205,_p204) {
                      var _p206 = _p204;
                      return A4(solveOne,
                      _p218,
                      rightLoc,
                      right + $Basics.toFloat(_p206._0),
                      rightTrace);
                   })};
         });
      };
      var topEdge = function (topMaybeLoc) {
         return A2(mapMaybeToList,
         topMaybeLoc,
         function (topLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "TOP"
                   ,_1: "dy"
                   ,_2: topLoc
                   ,_3: topTrace
                   ,_4: F2(function (_p208,_p207) {
                      var _p209 = _p207;
                      return A4(solveOne,
                      _p218,
                      topLoc,
                      top + $Basics.toFloat(_p209._1),
                      topTrace);
                   })};
         });
      };
      var botEdge = function (botMaybeLoc) {
         return A2(mapMaybeToList,
         botMaybeLoc,
         function (botLoc) {
            return {ctor: "_Tuple5"
                   ,_0: "BOT"
                   ,_1: "dy"
                   ,_2: botLoc
                   ,_3: botTrace
                   ,_4: F2(function (_p211,_p210) {
                      var _p212 = _p210;
                      return A4(solveOne,
                      _p218,
                      botLoc,
                      bot + $Basics.toFloat(_p212._1),
                      botTrace);
                   })};
         });
      };
      return A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.LeftEdge),
      _U.list([leftTrace]),
      function (assignedMaybeLocs) {
         var leftMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return leftEdge(leftMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotLeft),
      _U.list([leftTrace,botTrace]),
      function (assignedMaybeLocs) {
         var _p213 = $Utils.unwrap2(assignedMaybeLocs);
         var leftMaybeLoc = _p213._0;
         var botMaybeLoc = _p213._1;
         return A2($Basics._op["++"],
         leftEdge(leftMaybeLoc),
         botEdge(botMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotEdge),
      _U.list([botTrace]),
      function (assignedMaybeLocs) {
         var botMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return botEdge(botMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.BotRight),
      _U.list([rightTrace,botTrace]),
      function (assignedMaybeLocs) {
         var _p214 = $Utils.unwrap2(assignedMaybeLocs);
         var rightMaybeLoc = _p214._0;
         var botMaybeLoc = _p214._1;
         return A2($Basics._op["++"],
         rightEdge(rightMaybeLoc),
         botEdge(botMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.RightEdge),
      _U.list([rightTrace]),
      function (assignedMaybeLocs) {
         var rightMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return rightEdge(rightMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopRight),
      _U.list([rightTrace,topTrace]),
      function (assignedMaybeLocs) {
         var _p215 = $Utils.unwrap2(assignedMaybeLocs);
         var rightMaybeLoc = _p215._0;
         var topMaybeLoc = _p215._1;
         return A2($Basics._op["++"],
         rightEdge(rightMaybeLoc),
         topEdge(topMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopEdge),
      _U.list([topTrace]),
      function (assignedMaybeLocs) {
         var topMaybeLoc = $Utils.unwrap1(assignedMaybeLocs);
         return topEdge(topMaybeLoc);
      },
      A4(finishTrigger,
      $ShapeWidgets.ZPoint($ShapeWidgets.TopLeft),
      _U.list([leftTrace,topTrace]),
      function (assignedMaybeLocs) {
         var _p216 = $Utils.unwrap2(assignedMaybeLocs);
         var leftMaybeLoc = _p216._0;
         var topMaybeLoc = _p216._1;
         return A2($Basics._op["++"],
         leftEdge(leftMaybeLoc),
         topEdge(topMaybeLoc));
      },
      A4(finishTrigger,
      $ShapeWidgets.ZInterior,
      _U.list([leftTrace,topTrace,rightTrace,botTrace]),
      function (assignedMaybeLocs) {
         var _p217 = $Utils.unwrap4(assignedMaybeLocs);
         var leftMaybeLoc = _p217._0;
         var topMaybeLoc = _p217._1;
         var rightMaybeLoc = _p217._2;
         var botMaybeLoc = _p217._3;
         return A2($Basics._op["++"],
         leftEdge(leftMaybeLoc),
         A2($Basics._op["++"],
         topEdge(topMaybeLoc),
         A2($Basics._op["++"],
         rightEdge(rightMaybeLoc),
         botEdge(botMaybeLoc))));
      },
      {ctor: "_Tuple2",_0: $Dict.empty,_1: maybeCounts})))))))));
   });
   var computePolyTriggers = F3(function (_p220,
   maybeCounts,
   _p219) {
      var _p221 = _p220;
      var _p223 = _p221._1;
      var _p222 = _p219;
      var finishTrigger = A2(addShapeZoneTrigger,_p221._0,_p222._0);
      var pointX = pointX_(_p223);
      var pointY = pointY_(_p223);
      var addPointZones = A3(addPointZones_,
      finishTrigger,
      pointX,
      pointY);
      var addEdgeZones = A3(addEdgeZones_,
      finishTrigger,
      pointX,
      pointY);
      var addInteriorZone = A3(addInteriorZone_,
      finishTrigger,
      pointX,
      pointY);
      var indexedPoints = A2($Utils.mapi,
      $Basics.identity,
      $LangSvg.getPolyPoints(_p222._2));
      var edges = function () {
         if (_U.eq(_p222._1,"polygon"))
         return $Utils.selfZipCircConsecPairs(indexedPoints); else {
               var n = $List.length(indexedPoints);
               return $Utils.selfZipCircConsecPairs(A2($List.take,
               n - 1,
               indexedPoints));
            }
      }();
      return A2(addInteriorZone,
      indexedPoints,
      A2(addEdgeZones,
      edges,
      A2(addPointZones,
      indexedPoints,
      {ctor: "_Tuple2",_0: $Dict.empty,_1: maybeCounts})));
   });
   var computePathTriggers = F3(function (_p225,
   maybeCounts,
   _p224) {
      var _p226 = _p225;
      var _p228 = _p226._1;
      var _p227 = _p224;
      var finishTrigger = A2(addShapeZoneTrigger,_p226._0,_p227._0);
      var pointX = pointX_(_p228);
      var pointY = pointY_(_p228);
      var addPointZones = A3(addPointZones_,
      finishTrigger,
      pointX,
      pointY);
      var addEdgeZones = A3(addEdgeZones_,
      finishTrigger,
      pointX,
      pointY);
      var addInteriorZone = A3(addInteriorZone_,
      finishTrigger,
      pointX,
      pointY);
      var indexedPoints = $LangSvg.pathIndexPoints(_p227._2);
      return A2(addInteriorZone,
      indexedPoints,
      A2(addPointZones,
      indexedPoints,
      {ctor: "_Tuple2",_0: $Dict.empty,_1: maybeCounts}));
   });
   var computeFillAndStrokeTriggers = F3(function (_p230,
   maybeCounts,
   _p229) {
      var _p231 = _p230;
      var _p276 = _p231._1;
      var _p232 = _p229;
      var _p275 = _p232._2;
      var finishTrigger = A2(addShapeZoneTrigger,_p231._0,_p232._0);
      var maybeAddColorTrigger = F3(function (realZone,
      fillOrStroke,
      _p233) {
         var _p234 = _p233;
         var _p241 = _p234._1;
         var _p240 = _p234._0;
         var _p235 = A2($Utils.mapMaybe,
         function (_) {
            return _.av_;
         },
         A2($Utils.maybeFind,fillOrStroke,_p275));
         if (_p235.ctor === "Just" && _p235._0.ctor === "AColorNum" && _p235._0._0.ctor === "_Tuple2" && _p235._0._0._0.ctor === "_Tuple2")
         {
               var _p239 = _p235._0._0._0._1;
               return A4(finishTrigger,
               realZone,
               _U.list([_p239]),
               function (assignedMaybeLocs) {
                  var maybeLoc = $Utils.unwrap1(assignedMaybeLocs);
                  return A2(mapMaybeToList,
                  maybeLoc,
                  function (colorLoc) {
                     return {ctor: "_Tuple5"
                            ,_0: fillOrStroke
                            ,_1: "dx"
                            ,_2: colorLoc
                            ,_3: _p239
                            ,_4: F2(function (_p237,_p236) {
                               var _p238 = _p236;
                               var color$ = A2(colorNumPlus,_p235._0._0._0._0,_p238._0);
                               return A4(solveOne,_p276,colorLoc,color$,_p239);
                            })};
                  });
               },
               {ctor: "_Tuple2",_0: _p240,_1: _p241});
            } else {
               return {ctor: "_Tuple2",_0: _p240,_1: _p241};
            }
      });
      var maybeAddOpacityTrigger = F3(function (realZone,
      fillOrStroke,
      _p242) {
         var _p243 = _p242;
         var _p250 = _p243._1;
         var _p249 = _p243._0;
         var _p244 = A2($Utils.mapMaybe,
         function (_) {
            return _.av_;
         },
         A2($Utils.maybeFind,fillOrStroke,_p275));
         if (_p244.ctor === "Just" && _p244._0.ctor === "AColorNum" && _p244._0._0.ctor === "_Tuple2" && _p244._0._0._1.ctor === "Just" && _p244._0._0._1._0.ctor === "_Tuple2")
         {
               var _p248 = _p244._0._0._1._0._1;
               return A4(finishTrigger,
               realZone,
               _U.list([_p248]),
               function (assignedMaybeLocs) {
                  var maybeLoc = $Utils.unwrap1(assignedMaybeLocs);
                  return A2(mapMaybeToList,
                  maybeLoc,
                  function (opacityLoc) {
                     return {ctor: "_Tuple5"
                            ,_0: A2($Basics._op["++"],fillOrStroke,"Opacity")
                            ,_1: "dx"
                            ,_2: opacityLoc
                            ,_3: _p248
                            ,_4: F2(function (_p246,_p245) {
                               var _p247 = _p245;
                               var opacity$ = A2(opacityNumPlus,_p244._0._0._1._0._0,_p247._0);
                               return A4(solveOne,_p276,opacityLoc,opacity$,_p248);
                            })};
                  });
               },
               {ctor: "_Tuple2",_0: _p249,_1: _p250});
            } else {
               return {ctor: "_Tuple2",_0: _p249,_1: _p250};
            }
      });
      var maybeAddStrokeWidthTrigger = F2(function (realZone,_p251) {
         var _p252 = _p251;
         var _p259 = _p252._1;
         var _p258 = _p252._0;
         var _p253 = A2($Utils.mapMaybe,
         function (_) {
            return _.av_;
         },
         A2($Utils.maybeFind,"stroke-width",_p275));
         if (_p253.ctor === "Just" && _p253._0.ctor === "ANum" && _p253._0._0.ctor === "_Tuple2")
         {
               var _p257 = _p253._0._0._1;
               return A4(finishTrigger,
               realZone,
               _U.list([_p257]),
               function (assignedMaybeLocs) {
                  var maybeLoc = $Utils.unwrap1(assignedMaybeLocs);
                  return A2(mapMaybeToList,
                  maybeLoc,
                  function (widthLoc) {
                     return {ctor: "_Tuple5"
                            ,_0: "stroke-width"
                            ,_1: "dx"
                            ,_2: widthLoc
                            ,_3: _p257
                            ,_4: F2(function (_p255,_p254) {
                               var _p256 = _p254;
                               var width$ = A2(strokeWidthNumPlus,_p253._0._0._0,_p256._0);
                               return A4(solveOne,_p276,widthLoc,width$,_p257);
                            })};
                  });
               },
               {ctor: "_Tuple2",_0: _p258,_1: _p259});
            } else {
               return {ctor: "_Tuple2",_0: _p258,_1: _p259};
            }
      });
      var maybeAddRotationTrigger = F2(function (realZone,_p260) {
         var _p261 = _p260;
         var _p274 = _p261._1;
         var _p273 = _p261._0;
         var _p262 = A2($Utils.mapMaybe,
         function (_) {
            return _.av_;
         },
         A2($Utils.maybeFind,"transform",_p275));
         if (_p262.ctor === "Just" && _p262._0.ctor === "ATransform" && _p262._0._0.ctor === "::" && _p262._0._0._0.ctor === "Rot" && _p262._0._0._0._0.ctor === "_Tuple2" && _p262._0._0._0._1.ctor === "_Tuple2" && _p262._0._0._0._2.ctor === "_Tuple2" && _p262._0._0._1.ctor === "[]")
         {
               var _p272 = _p262._0._0._0._0._1;
               var _p271 = _p262._0._0._0._2._0;
               var _p270 = _p262._0._0._0._1._0;
               return A4(finishTrigger,
               realZone,
               _U.list([_p272]),
               function (assignedMaybeLocs) {
                  var maybeLoc = $Utils.unwrap1(assignedMaybeLocs);
                  return A2(mapMaybeToList,
                  maybeLoc,
                  function (rotLoc) {
                     return {ctor: "_Tuple5"
                            ,_0: "transformRot"
                            ,_1: "dxy"
                            ,_2: rotLoc
                            ,_3: _p272
                            ,_4: F2(function (_p264,_p263) {
                               var _p265 = _p264;
                               var _p269 = _p265._1;
                               var _p268 = _p265._0;
                               var _p266 = _p263;
                               var _p267 = {ctor: "_Tuple2"
                                           ,_0: _p268 + _p266._0
                                           ,_1: _p269 + _p266._1};
                               var mx1 = _p267._0;
                               var my1 = _p267._1;
                               var radToDeg = $Utils.radiansToDegrees;
                               var a0 = radToDeg(A2($Basics.atan2,
                               _p271 - $Basics.toFloat(_p269),
                               $Basics.toFloat(_p268) - _p270));
                               var a1 = radToDeg(A2($Basics.atan2,
                               _p271 - $Basics.toFloat(my1),
                               $Basics.toFloat(mx1) - _p270));
                               return A4(solveOne,
                               _p276,
                               rotLoc,
                               _p262._0._0._0._0._0 + (a0 - a1),
                               _p272);
                            })};
                  });
               },
               {ctor: "_Tuple2",_0: _p273,_1: _p274});
            } else {
               return {ctor: "_Tuple2",_0: _p273,_1: _p274};
            }
      });
      return A2(maybeAddRotationTrigger,
      $ShapeWidgets.ZOther($ShapeWidgets.Rotation),
      A2(maybeAddStrokeWidthTrigger,
      $ShapeWidgets.ZOther($ShapeWidgets.StrokeWidth),
      A3(maybeAddColorTrigger,
      $ShapeWidgets.ZOther($ShapeWidgets.StrokeOpacity),
      "stroke",
      A3(maybeAddColorTrigger,
      $ShapeWidgets.ZOther($ShapeWidgets.FillOpacity),
      "fill",
      A3(maybeAddColorTrigger,
      $ShapeWidgets.ZOther($ShapeWidgets.StrokeColor),
      "stroke",
      A3(maybeAddColorTrigger,
      $ShapeWidgets.ZOther($ShapeWidgets.FillColor),
      "fill",
      {ctor: "_Tuple2",_0: $Dict.empty,_1: maybeCounts}))))));
   });
   var computeShapeTriggers = F3(function (info,
   slate,
   initMaybeCounts) {
      var processNode = F2(function (nodeInfo,_p277) {
         var _p278 = _p277;
         var _p286 = _p278._1;
         var _p285 = _p278._0;
         var _p279 = nodeInfo;
         if (_p279.ctor === "Left") {
               return {ctor: "_Tuple2",_0: _p285,_1: _p286};
            } else {
               var _p284 = _p279._0;
               var _p280 = function () {
                  var _p281 = _p284;
                  var kind = _p281._1;
                  var _p282 = kind;
                  switch (_p282)
                  {case "line": return A3(computeLineTriggers,info,_p286,_p284);
                     case "rect": return A3(computeRectTriggers,info,_p286,_p284);
                     case "ellipse": return A3(computeEllipseTriggers,
                       info,
                       _p286,
                       _p284);
                     case "circle": return A3(computeCircleTriggers,
                       info,
                       _p286,
                       _p284);
                     case "BOX": return A3(computeBoxOrOvalTriggers,
                       info,
                       _p286,
                       _p284);
                     case "OVAL": return A3(computeBoxOrOvalTriggers,
                       info,
                       _p286,
                       _p284);
                     case "polygon": return A3(computePolyTriggers,info,_p286,_p284);
                     case "polyline": return A3(computePolyTriggers,
                       info,
                       _p286,
                       _p284);
                     case "path": return A3(computePathTriggers,info,_p286,_p284);
                     default: return {ctor: "_Tuple2",_0: $Dict.empty,_1: _p286};}
               }();
               var directZoneTriggers = _p280._0;
               var maybeCounts$ = _p280._1;
               var _p283 = A3(computeFillAndStrokeTriggers,info,_p286,_p284);
               var sliderZoneTriggers = _p283._0;
               var maybeCounts$$ = _p283._1;
               var dict$ = A2($Dict.union,
               sliderZoneTriggers,
               A2($Dict.union,directZoneTriggers,_p285));
               return {ctor: "_Tuple2",_0: dict$,_1: maybeCounts$};
            }
      });
      return A3($LangSvg.foldSlateNodeInfo,
      slate,
      {ctor: "_Tuple2",_0: $Dict.empty,_1: initMaybeCounts},
      processNode);
   });
   var addWidgetTrigger = F3(function (options,id,caption) {
      return A2(addTrigger,
      options,
      {ctor: "_Tuple2",_0: id,_1: caption});
   });
   var computeWidgetTriggers = F3(function (_p287,
   widgets,
   initMaybeCounts) {
      var _p288 = _p287;
      var _p318 = _p288._1;
      var _p317 = _p288._0;
      var wSlider = $Config.params.mainSection.uiWidgets.wSlider;
      var processWidget = F2(function (_p289,accResult) {
         var _p290 = _p289;
         var _p316 = _p290._0;
         var _p291 = _p290._1;
         switch (_p291.ctor)
         {case "WNumSlider": var _p298 = _p291._0;
              var _p297 = _p291._1;
              var _p296 = _p291._4;
              var updateX = function (dx) {
                 return A3($Basics.clamp,
                 _p298,
                 _p297,
                 _p291._3 + $Basics.toFloat(dx) / $Basics.toFloat(wSlider) * (_p297 - _p298));
              };
              var options$ = _U.update(_p317,{unfreezeAll: true});
              return A6(addWidgetTrigger,
              options$,
              _p316,
              "Num",
              _U.list([$Lang.TrLoc(_p296)]),
              function (_p292) {
                 return function (maybeLoc) {
                    return A2(mapMaybeToList,
                    maybeLoc,
                    function (loc$) {
                       return {ctor: "_Tuple5"
                              ,_0: ""
                              ,_1: "dx"
                              ,_2: loc$
                              ,_3: $Lang.TrLoc(_p296)
                              ,_4: F2(function (_p294,_p293) {
                                 var _p295 = _p293;
                                 return A4(solveOne,
                                 _p318,
                                 loc$,
                                 updateX(_p295._0),
                                 $Lang.TrLoc(_p296));
                              })};
                    });
                 }($Utils.unwrap1(_p292));
              },
              accResult);
            case "WIntSlider": var _p304 = _p291._4;
              var _p299 = {ctor: "_Tuple3"
                          ,_0: $Basics.toFloat(_p291._0)
                          ,_1: $Basics.toFloat(_p291._1)
                          ,_2: $Basics.toFloat(_p291._3)};
              var minVal = _p299._0;
              var maxVal = _p299._1;
              var curVal = _p299._2;
              var updateX = function (dx) {
                 return $Basics.toFloat($Basics.round(A3($Basics.clamp,
                 minVal,
                 maxVal,
                 curVal + $Basics.toFloat(dx) / $Basics.toFloat(wSlider) * (maxVal - minVal))));
              };
              var options$ = _U.update(_p317,{unfreezeAll: true});
              return A6(addWidgetTrigger,
              options$,
              _p316,
              "Int",
              _U.list([$Lang.TrLoc(_p304)]),
              function (_p300) {
                 return function (maybeLoc) {
                    return A2(mapMaybeToList,
                    maybeLoc,
                    function (loc$) {
                       return {ctor: "_Tuple5"
                              ,_0: ""
                              ,_1: "dx"
                              ,_2: loc$
                              ,_3: $Lang.TrLoc(_p304)
                              ,_4: F2(function (_p302,_p301) {
                                 var _p303 = _p301;
                                 return A4(solveOne,
                                 _p318,
                                 loc$,
                                 updateX(_p303._0),
                                 $Lang.TrLoc(_p304));
                              })};
                    });
                 }($Utils.unwrap1(_p300));
              },
              accResult);
            default: var _p315 = _p291._1._1;
              var _p314 = _p291._0._1;
              return A6(addWidgetTrigger,
              _p317,
              _p316,
              "Point",
              _U.list([_p314,_p315]),
              function (_p305) {
                 return function (_p306) {
                    var _p307 = _p306;
                    return A2($Basics._op["++"],
                    A2(mapMaybeToList,
                    _p307._0,
                    function (xLoc) {
                       return {ctor: "_Tuple5"
                              ,_0: ""
                              ,_1: "dx"
                              ,_2: xLoc
                              ,_3: _p314
                              ,_4: F2(function (_p309,_p308) {
                                 var _p310 = _p308;
                                 return A4(solveOne,
                                 _p318,
                                 xLoc,
                                 _p291._0._0 + $Basics.toFloat(_p310._0),
                                 _p314);
                              })};
                    }),
                    A2(mapMaybeToList,
                    _p307._1,
                    function (yLoc) {
                       return {ctor: "_Tuple5"
                              ,_0: ""
                              ,_1: "dy"
                              ,_2: yLoc
                              ,_3: _p315
                              ,_4: F2(function (_p312,_p311) {
                                 var _p313 = _p311;
                                 return A4(solveOne,
                                 _p318,
                                 yLoc,
                                 _p291._1._0 + $Basics.toFloat(_p313._1),
                                 _p315);
                              })};
                    }));
                 }($Utils.unwrap2(_p305));
              },
              accResult);}
      });
      var indexedWidgets = A2($Utils.mapi,$Basics.identity,widgets);
      return A3($List.foldl,
      processWidget,
      {ctor: "_Tuple2",_0: $Dict.empty,_1: initMaybeCounts},
      indexedWidgets);
   });
   var toggleHeuristicMode = function (x) {
      var i = A2($Basics._op["%"],1 + x,heuristicModes);
      return i;
   };
   var debugLog = $Config.debugLog($Config.debugSync);
   var syncOptionsOf = F2(function (oldOptions,e) {
      var _p319 = A2($Utils.maybeFind,
      "unannotated-numbers",
      $Lang.getOptions(e));
      if (_p319.ctor === "Nothing") {
            return oldOptions;
         } else {
            var _p321 = _p319._0;
            if (_U.eq(_p321,"n?")) return _U.update(oldOptions,
               {thawedByDefault: true}); else if (_U.eq(_p321,"n!"))
               return _U.update(oldOptions,{thawedByDefault: false}); else {
                     var _p320 = A2(debugLog,"invalid sync option: ",_p321);
                     return oldOptions;
                  }
         }
   });
   var tracesOfAVal = function (aval) {
      var _p322 = aval.av_;
      _v93_7: do {
         switch (_p322.ctor)
         {case "ANum": if (_p322._0.ctor === "_Tuple2") {
                    return _U.list([_p322._0._1]);
                 } else {
                    break _v93_7;
                 }
            case "AColorNum":
            if (_p322._0.ctor === "_Tuple2" && _p322._0._0.ctor === "_Tuple2")
              {
                    if (_p322._0._1.ctor === "Nothing") {
                          return _U.list([_p322._0._0._1]);
                       } else {
                          if (_p322._0._1._0.ctor === "_Tuple2") {
                                return _U.list([_p322._0._0._1,_p322._0._1._0._1]);
                             } else {
                                break _v93_7;
                             }
                       }
                 } else {
                    break _v93_7;
                 }
            case "APoints": return A2($List.concatMap,
              function (_p323) {
                 var _p324 = _p323;
                 return _U.list([_p324._0._1,_p324._1._1]);
              },
              _p322._0);
            case "ATransform":
            if (_p322._0.ctor === "::" && _p322._0._0.ctor === "Rot" && _p322._0._0._0.ctor === "_Tuple2" && _p322._0._0._1.ctor === "_Tuple2" && _p322._0._0._2.ctor === "_Tuple2" && _p322._0._1.ctor === "[]")
              {
                    return _U.list([_p322._0._0._0._1
                                   ,_p322._0._0._1._1
                                   ,_p322._0._0._2._1]);
                 } else {
                    break _v93_7;
                 }
            case "AString": return _U.list([]);
            case "ARgba": return _U.list([]);
            default: break _v93_7;}
      } while (false);
      var _p325 = A2(debugLog,"tracesOfAVal?",$LangSvg.strAVal(aval));
      return _U.list([]);
   };
   var getLocationCounts = F2(function (options,_p326) {
      var _p327 = _p326;
      var weightedScore = F3(function (kind,_p328,acc) {
         var _p329 = _p328;
         var _p331 = _p329._1;
         var k = function () {
            var _p330 = {ctor: "_Tuple3"
                        ,_0: kind
                        ,_1: _p329._0
                        ,_2: _p331.av_};
            _v97_4: do {
               if (_p330.ctor === "_Tuple3" && _p330._0 === "BOX" && _p330._2.ctor === "ANum" && _p330._2._0.ctor === "_Tuple2" && _p330._2._0._1.ctor === "TrLoc")
               {
                     switch (_p330._1)
                     {case "LEFT": return 2;
                        case "RIGHT": return 2;
                        case "TOP": return 2;
                        case "BOT": return 2;
                        default: break _v97_4;}
                  } else {
                     break _v97_4;
                  }
            } while (false);
            return 1;
         }();
         return A3($Set.foldl,
         addCount(k),
         acc,
         A2(locsOfTraces,options,tracesOfAVal(_p331)));
      });
      var addTriggerNode = F2(function (nodeInfo,acc) {
         var _p332 = nodeInfo;
         if (_p332.ctor === "Left") {
               return acc;
            } else {
               return A3($List.foldl,
               weightedScore(_p332._0._1),
               acc,
               _p332._0._2);
            }
      });
      var addTriggerWidget = F2(function (widget,acc) {
         var _p333 = widget;
         switch (_p333.ctor)
         {case "WIntSlider": return A2(updateCount,_p333._4,acc);
            case "WNumSlider": return A2(updateCount,_p333._4,acc);
            default: return A3($Set.foldl,
              updateCount,
              acc,
              A2(locsOfTraces,options,_U.list([_p333._0._1,_p333._1._1])));}
      });
      var d = A3($LangSvg.foldSlateNodeInfo,
      _p327._0,
      $Dict.empty,
      addTriggerNode);
      var d$ = A3($List.foldl,addTriggerWidget,d,_p327._1);
      return d$;
   });
   var prepareLiveUpdates = F6(function (options,
   slideNumber,
   movieNumber,
   movieTime,
   e,
   _p334) {
      var _p335 = _p334;
      var _p339 = _p335._1;
      var _p338 = _p335._0;
      var initSubstPlus = $LangParser2.substPlusOf(e);
      var initSubst = A2($Dict.map,
      $Basics.always(function (_) {    return _.val;}),
      initSubstPlus);
      var maybeCounts = _U.eq(options.feelingLucky,
      heuristicsFair) ? $Maybe.Just($Either.Right($Dict.empty)) : _U.eq(options.feelingLucky,
      heuristicsBiased) ? $Maybe.Just($Either.Left(A2(getLocationCounts,
      options,
      {ctor: "_Tuple2",_0: _p338,_1: _p339}))) : $Maybe.Nothing;
      var _p336 = A3(computeShapeTriggers,
      {ctor: "_Tuple2",_0: options,_1: initSubst},
      _p338,
      maybeCounts);
      var shapeTriggers = _p336._0;
      var maybeCounts$ = _p336._1;
      var _p337 = A3(computeWidgetTriggers,
      {ctor: "_Tuple2",_0: options,_1: initSubst},
      _p339,
      maybeCounts$);
      var widgetTriggers = _p337._0;
      var maybeCounts$$ = _p337._1;
      return $Result.Ok({initSubstPlus: initSubstPlus
                        ,shapeTriggers: shapeTriggers
                        ,widgetTriggers: widgetTriggers});
   });
   var tracesOfAVals = function (avals) {
      return A3($List.foldl,
      F2(function (av,acc) {
         return A2($Basics._op["++"],tracesOfAVal(av),acc);
      }),
      _U.list([]),
      avals);
   };
   var lookupZoneKey = F2(function (zoneKey,info) {
      var errorString = A2($Basics._op["++"],
      "lookupZoneKey: ",
      $Basics.toString(zoneKey));
      var $default = function () {
         var _p340 = A2(debugLog,errorString,"able to avoid this?");
         return {ctor: "_Tuple3"
                ,_0: _U.list([])
                ,_1: $Set.empty
                ,_2: $Set.empty};
      }();
      var wrap = $Maybe.withDefault($default);
      var _p341 = zoneKey;
      if (_p341.ctor === "Left") {
            return wrap(A2($Dict.get,
            {ctor: "_Tuple2",_0: _p341._0._0,_1: _p341._0._2},
            info.shapeTriggers));
         } else {
            return wrap(A2($Dict.get,
            {ctor: "_Tuple2",_0: _p341._0._0,_1: _p341._0._1},
            info.widgetTriggers));
         }
   });
   var prepareLiveTrigger = F5(function (info,
   exp,
   zoneKey,
   _p343,
   _p342) {
      var _p344 = _p343;
      var _p345 = _p342;
      var _p346 = A2(lookupZoneKey,zoneKey,info);
      var trigger = _p346._0;
      var yellowLocs = _p346._1;
      var initSubst = A2($Dict.map,
      $Basics.always(function (_) {    return _.val;}),
      info.initSubstPlus);
      var updates = A3($List.foldl,
      F2(function (triggerElement,acc) {
         var _p347 = triggerElement;
         var k = _p347._2._0;
         var updateFunction = _p347._4;
         var _p348 = {ctor: "_Tuple2"
                     ,_0: A2($Dict.get,k,acc)
                     ,_1: A2(updateFunction,
                     {ctor: "_Tuple2",_0: _p344._0,_1: _p344._1},
                     {ctor: "_Tuple2",_0: _p345._0,_1: _p345._1})};
         if (_p348._0.ctor === "Nothing") {
               return A3($Dict.insert,k,_p348._1,acc);
            } else {
               if (_p348._0._0.ctor === "Nothing") {
                     return A3($Dict.insert,k,_p348._1,acc);
                  } else {
                     if (_p348._1.ctor === "Nothing") {
                           return acc;
                        } else {
                           return acc;
                        }
                  }
            }
      }),
      $Dict.empty,
      trigger);
      var newSubst = A3($Dict.foldl,
      F3(function (k,maybeNum,acc) {
         var _p349 = maybeNum;
         if (_p349.ctor === "Nothing") {
               return acc;
            } else {
               return A3($Dict.insert,k,_p349._0,acc);
            }
      }),
      initSubst,
      updates);
      var highlights = A3(highlightChanges,
      info.initSubstPlus,
      yellowLocs,
      updates);
      var exp$ = A2($Lang.applyLocSubst,newSubst,exp);
      return {ctor: "_Tuple2",_0: exp$,_1: highlights};
   });
   var yellowAndGrayHighlights = F2(function (zoneKey,info) {
      var subst = info.initSubstPlus;
      var _p350 = A2(lookupZoneKey,zoneKey,info);
      var yellowLocs = _p350._1;
      var grayLocs = _p350._2;
      return A2($Basics._op["++"],
      A2($List.map,
      A2(makeHighlight,subst,yellow),
      $Set.toList(yellowLocs)),
      A2($List.map,
      A2(makeHighlight,subst,gray),
      $Set.toList(grayLocs)));
   });
   var hoverInfo = F2(function (zoneKey,info) {
      var line1 = function () {
         var _p351 = zoneKey;
         if (_p351.ctor === "Left") {
               return A2($Basics._op["++"],
               A2($Basics._op["++"],_p351._0._1,$Basics.toString(_p351._0._0)),
               A2($Basics._op["++"]," ",_p351._0._2));
            } else {
               return A2($Basics._op["++"],
               _p351._0._1,
               A2($Basics._op["++"],"Slider",$Basics.toString(_p351._0._0)));
            }
      }();
      var maybeLine2 = function () {
         var _p352 = A2(lookupZoneKey,zoneKey,info);
         var triggerElements = _p352._0;
         if (_U.eq(triggerElements,_U.list([]))) return $Maybe.Nothing;
         else {
               var _p353 = A2($List.partition,
               function (_p354) {
                  var _p355 = _p354;
                  return _U.eq(_p355._1,"dx");
               },
               triggerElements);
               var dxElements = _p353._0;
               var list2 = _p353._1;
               var _p356 = A2($List.partition,
               function (_p357) {
                  var _p358 = _p357;
                  return _U.eq(_p358._1,"dy");
               },
               list2);
               var dyElements = _p356._0;
               var list3 = _p356._1;
               var _p359 = A2($List.partition,
               function (_p360) {
                  var _p361 = _p360;
                  return _U.eq(_p361._1,"dxy");
               },
               list3);
               var dxyElements = _p359._0;
               var otherElements = _p359._1;
               var strElements = F2(function (caption,elements) {
                  var foo = function (_p362) {
                     var _p363 = _p362;
                     var _p365 = _p363._2._2;
                     var _p364 = _p363._2._0;
                     var n = A3($Utils.justGet_,
                     A2($Basics._op["++"],"hoverInfo: ",$Basics.toString(_p364)),
                     _p364,
                     info.initSubstPlus);
                     var locName = _U.eq(_p365,"") ? A2($Basics._op["++"],
                     "loc_",
                     $Basics.toString(_p364)) : _p365;
                     return A2($Basics._op["++"],
                     locName,
                     $Utils.parens(A2($String.left,4,$Basics.toString(n.val))));
                  };
                  var _p366 = elements;
                  if (_p366.ctor === "[]") {
                        return _U.list([]);
                     } else {
                        return _U.list([A2($Basics._op["++"],
                        $Utils.bracks(caption),
                        A2($Basics._op["++"],
                        " ",
                        $Utils.spaces(A2($List.map,foo,elements))))]);
                     }
               });
               return $Maybe.Just($Utils.spaces($List.concat(_U.list([A2(strElements,
                                                                     "dx",
                                                                     dxElements)
                                                                     ,A2(strElements,"dy",dyElements)
                                                                     ,A2(strElements,"dxy",dxyElements)
                                                                     ,A2(strElements,"...",otherElements)]))));
            }
      }();
      return {ctor: "_Tuple2",_0: line1,_1: maybeLine2};
   });
   return _elm.Sync.values = {_op: _op
                             ,defaultOptions: defaultOptions
                             ,syncOptionsOf: syncOptionsOf
                             ,heuristicsNone: heuristicsNone
                             ,heuristicsFair: heuristicsFair
                             ,heuristicsBiased: heuristicsBiased
                             ,toggleHeuristicMode: toggleHeuristicMode
                             ,locsOfTrace: locsOfTrace
                             ,prepareLiveUpdates: prepareLiveUpdates
                             ,prepareLiveTrigger: prepareLiveTrigger
                             ,yellowAndGrayHighlights: yellowAndGrayHighlights
                             ,hoverInfo: hoverInfo
                             ,Options: Options
                             ,LiveInfo: LiveInfo};
};
Elm.ExamplesGenerated = Elm.ExamplesGenerated || {};
Elm.ExamplesGenerated.make = function (_elm) {
   "use strict";
   _elm.ExamplesGenerated = _elm.ExamplesGenerated || {};
   if (_elm.ExamplesGenerated.values)
   return _elm.ExamplesGenerated.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Eval = Elm.Eval.make(_elm),
   $LangParser2 = Elm.LangParser2.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $PreludeGenerated = Elm.PreludeGenerated.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Types = Elm.Types.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var coffee_UIST = "\n(def mug (\\(outer_color strokeWidth3280 color strokeWidth3239 strokeColor strokeWidth3142 x0 y0 [left top right bot])\n  (def bounds [left top right bot])\n  (def rFrac 0.2!)\n  (def [outer_right outer_left] [ (scaleBetween left right 1)(scaleBetween left right 0.3575757575757576)])\n  (def outer_x_radius (/ (- outer_right outer_left) 2!))\n  (def [rect3_top outer_bot outer_top] [ (scaleBetween top bot 0.3620689655172414) (scaleBetween top bot 0.9224137931034483) (scaleBetween top bot 0.4396551724137931)])\n  (def outer_ellipseRY (/ (- outer_bot outer_top) 2!))\n\n  (def outer\n    (let bounds [outer_left outer_top outer_right outer_bot]\n    (let [ strokeColor strokeWidth] [ \'black\' strokeWidth3280]\n      [ (oval outer_color strokeColor strokeWidth bounds) ])))\n\n  (def inner\n    (let [left top right bot] [(+ outer_left (* rFrac outer_x_radius)) (+ outer_top (* rFrac outer_ellipseRY)) (- outer_right (* rFrac outer_x_radius)) (- outer_bot (* rFrac outer_ellipseRY))]\n    (let bounds [left top right bot]\n    (let [color strokeColor strokeWidth] [color \'black\' strokeWidth3239]\n      [ (oval color strokeColor strokeWidth bounds) ]))))\n\n  (def rect3\n    (let [left right bot] [(scaleBetween left right 0) (+ (+ outer_left (* 0.1! (- outer_right outer_left))) (* 0.5! (- (- outer_right (* 0.1! (- outer_right outer_left))) (+ outer_left (* 0.1! (- outer_right outer_left)))))) (* 2! (- (+ (+ outer_top (* 0.1! (- outer_bot outer_top))) (* 0.5! (- (- outer_bot (* 0.1! (- outer_bot outer_top))) (+ outer_top (* 0.1! (- outer_bot outer_top)))))) (* 0.5! rect3_top)))]\n    (let bounds [left rect3_top right bot]\n      [ (rectangle outer_color \'black\' 0 0 bounds) ])))\n\n  (def steam (\\(left top right bot)\n    (let bounds [left top right bot]\n    (let [strokeColor strokeWidth color] [strokeColor strokeWidth3142 \'white\']\n    (let dPcts [\'M\' x0 y0 \'C\' 0 0.4925373134328358? 0.8076923076923077? 0.6119402985074627? 0.4230769230769231? 1 \'C\' 1 0.7313432835820896? 0.4230769230769231? 0.6417910447761194? x0 y0]\n      [ (stretchyPath bounds color strokeColor strokeWidth dPcts) ])))))\n\n  [ (group bounds (concat [ outer inner rect3 (steam(scaleBetween left right 0.012121212121212121) (scaleBetween top bot 0.02586206896551724) (scaleBetween left right 0.1696969696969697) (scaleBetween top bot 0.3146551724137931)) (steam(scaleBetween left right 0.2606060606060606) (scaleBetween top bot 0) (scaleBetween left right 0.41818181818181815) (scaleBetween top bot 0.28879310344827586)) (steam(scaleBetween left right 0.5212121212121212) (scaleBetween top bot 0.02586206896551724) (scaleBetween left right 0.6787878787878788) (scaleBetween top bot 0.3146551724137931)) ])) ]))\n\n(blobs [\n  (withBounds [27 27 192 259] (mug 164 0 481 0 102 5 0.8846153846153846? 0))\n  (withBounds [299 214 406 322] (mug 164 0 481 0 102 5 0.8846153846153846? 0))\n  (withBounds [143 380 193 442] (mug 164 0 481 0 102 5 0.8846153846153846? 0))\n])\n\n";
   var botanic_UIST = "\n(def newGroup4 (\\(leftLeaf_strokeWidth leftLeaf_color leftLeaf_strokeColor leftLeaf_dPcts_k3164 leftLeaf_dPcts_k3166 centerLeftPct leftRightPct leftTopPct leftMidPct x03451 y03450 x03401 y03400 y03344 dPcts_k3058 [left top right bot])\n  (def bounds [left top right bot])\n  (def centerRightPct (- 1! centerLeftPct))\n  (def rightLeftPct (- 1! leftRightPct))\n  (def rightTopPct (- 1! leftTopPct))\n  (def rightMidPct (- 1! leftMidPct))\n\n  (def leftLeaf\n    (let k3186 0!\n    (let [left top right bot] [ left (scaleBetween top bot k3186) (scaleBetween left right leftRightPct) bot]\n    (let bounds [left top right bot]\n    (let [x0 y0] [x03451 y03450]\n    (let dPcts [\'M\' x0 y0 \'Q\' leftMidPct leftLeaf_dPcts_k3166 0 leftLeaf_dPcts_k3164 \'Q\' leftTopPct 0 x0 y0]\n      [ (stretchyPath bounds leftLeaf_color leftLeaf_strokeColor leftLeaf_strokeWidth dPcts) ]))))))\n\n  (def rightLeaf\n    (let k3132 1!\n    (let [left top right bot] [ (scaleBetween left right rightLeftPct) top right (scaleBetween top bot k3132)]\n    (let bounds [left top right bot]\n    (let [x0 y0] [x03401 y03400]\n    (let dPcts [\'M\' x0 y0 \'Q\' rightMidPct leftLeaf_dPcts_k3166 1 leftLeaf_dPcts_k3164 \'Q\' rightTopPct 0 x0 y0]\n      [ (stretchyPath bounds leftLeaf_color leftLeaf_strokeColor leftLeaf_strokeWidth dPcts) ]))))))\n\n  (def centerLeaf\n    (let [left top right bot] [ (scaleBetween left right centerLeftPct) (scaleBetween top bot 0.1166930482692767) (scaleBetween left right centerRightPct) (scaleBetween top bot 0.6433647887474833)]\n    (let bounds [left top right bot]\n    (let [x0 y0] [0.5! y03344]\n    (let dPcts [\'M\' x0 y0 \'L\' 0 dPcts_k3058 \'Q\' 0.5! 0 1 dPcts_k3058 \'Z\']\n      [ (stretchyPath bounds leftLeaf_color leftLeaf_strokeColor leftLeaf_strokeWidth dPcts) ])))))\n\n  [ (group bounds (concat [ leftLeaf rightLeaf centerLeaf ])) ]))\n\n(blobs [\n  (withBounds [56 45.523358950223596 512 495] (newGroup4 4 100 431 0.4693710270993644? 0.3959689822652434? 0.35053185358677735 0.47858611976259036 0.44362108479755546 0.5977244375980417 1 1 0 1 1 0.3407539747046014?))\n])\n\n";
   var sns_revisited_UIST = "\n; Try deleting the five helper circles from the main expression.\n\n(def [polygon6_top polygon5_left polygon6_right] [69 92 296])\n(def helper_r 27.5)\n(def polygon7_bot (+ (+ (* 0.5! (+ polygon6_top polygon6_top)) (* 0.5! (- (* 0.5! (+ polygon6_right polygon6_right)) (* 0.5! (+ polygon5_left polygon5_left))))) (* 0.5! (- (* 0.5! (+ polygon6_right polygon6_right)) (* 0.5! (+ polygon5_left polygon5_left))))))\n(def k3105 (/ (- (+ (- polygon6_right helper_r) (* 0.5! (+ (+ (- polygon6_right helper_r) (* 2! helper_r)) (- helper_r polygon6_right)))) (+ (+ (- polygon5_left helper_r) (* 0.5! (+ (+ (- polygon5_left helper_r) (* 2! helper_r)) (- helper_r polygon5_left)))) (* 0.5! (+ (+ (- polygon5_left helper_r) (* 2! helper_r)) (- helper_r polygon5_left))))) (- polygon6_right (+ (+ (- polygon5_left helper_r) (* 0.5! (+ (+ (- polygon5_left helper_r) (* 2! helper_r)) (- helper_r polygon5_left)))) (* 0.5! (+ (+ (- polygon5_left helper_r) (* 2! helper_r)) (- helper_r polygon5_left)))))))\n(def polygon7_top (- (* 0.5! (+ (- polygon7_bot helper_r) (- polygon6_top (+ (- 0! (+ helper_r helper_r)) (* 0.5! (+ (+ (- 0! (+ helper_r helper_r)) (* 2! helper_r)) (+ helper_r helper_r))))))) (+ (- 0! (+ helper_r helper_r)) (* 0.5! (+ (+ (- 0! (+ helper_r helper_r)) (* 2! helper_r)) (+ helper_r helper_r))))))\n(def [polygon5_right k3038] [(- (* 0.5! (+ (+ (+ (- polygon5_left helper_r) (* 0.5! (+ (+ (- polygon5_left helper_r) (* 2! helper_r)) (- helper_r polygon5_left)))) helper_r) (- polygon6_right helper_r))) helper_r) (- (+ (- polygon5_left helper_r) (* 0.5! (+ (+ (- polygon5_left helper_r) (* 2! helper_r)) (- helper_r polygon5_left)))) helper_r)])\n(def k3061 (/ (- (+ polygon5_right helper_r) (+ (+ k3038 helper_r) helper_r)) (- (- polygon6_right helper_r) (+ (+ k3038 helper_r) helper_r))))\n(def polygon6_bot (- (+ (- polygon7_bot helper_r) (* 0.5! (+ (+ (- polygon7_bot helper_r) (* 2! helper_r)) (- helper_r polygon7_bot)))) helper_r))\n(def k3063 (/ (- (+ polygon6_bot helper_r) polygon7_top) (- polygon7_bot polygon7_top)))\n(def k3034 (- polygon6_right helper_r))\n(def polygon5_top (- polygon6_top (+ (- 0! (+ helper_r helper_r)) (* 0.5! (+ (+ (- 0! (+ helper_r helper_r)) (* 2! helper_r)) (+ helper_r helper_r))))))\n(def k3103 (/ (- (+ (- polygon5_top (+ helper_r helper_r)) (* 0.5! (+ (+ (- polygon5_top (+ helper_r helper_r)) (* 2! helper_r)) (- (+ helper_r helper_r) polygon5_top)))) polygon6_top) (- polygon6_bot polygon6_top)))\n(def [k3041 polygon5_bot] [(- polygon7_top (+ helper_r helper_r)) (- polygon7_bot helper_r)])\n(def k3134 (/ (- (+ k3041 helper_r) polygon5_top) (- polygon5_bot polygon5_top)))\n(def k3045 (- polygon5_top (+ helper_r helper_r)))\n(def k3046 (- polygon5_left helper_r))\n(def k3141 (/ (- (+ k3038 helper_r) polygon5_left) (- polygon5_right polygon5_left)))\n\n(def helper (\\(left top)\n  (let [left top] [left top]\n  (let bounds [left top (+ left (* 2! helper_r)) (+ top (* 2! helper_r))]\n  (let [color strokeColor strokeWidth] [394 \'black\' 0]\n    [ (oval color strokeColor strokeWidth bounds) ])))))\n\n(def polygon5\n  (let bounds [polygon5_left polygon5_top polygon5_right polygon5_bot]\n  (let [color strokeColor strokeWidth] [261 \'black\' 2]\n  (let pcts [[k3141 1] [0 0] [1 k3134]]\n    [ (stretchyPolygon bounds color strokeColor strokeWidth pcts) ]))))\n\n(def polygon6\n  (let left (+ (+ (- polygon5_left helper_r) (* 0.5! (+ (+ (- polygon5_left helper_r) (* 2! helper_r)) (- helper_r polygon5_left)))) (* 0.5! (+ (+ (- polygon5_left helper_r) (* 2! helper_r)) (- helper_r polygon5_left))))\n  (let bounds [left polygon6_top polygon6_right polygon6_bot]\n  (let [color strokeColor strokeWidth] [132 \'black\' 2]\n  (let pcts [[0 k3103] [k3105 0] [1 1]]\n    [ (stretchyPolygon bounds color strokeColor strokeWidth pcts) ])))))\n\n(def polygon7\n  (let [left right] [(+ (+ k3038 helper_r) helper_r) (- polygon6_right helper_r)]\n  (let bounds [left polygon7_top right polygon7_bot]\n  (let [color strokeColor strokeWidth] [334 \'black\' 2]\n  (let pcts [[0 1] [1 k3063] [k3061 0]]\n    [ (stretchyPolygon bounds color strokeColor strokeWidth pcts) ])))))\n\n(def circle8\n  (let [left top r] [(* 0.5! (+ polygon5_left polygon5_left)) (* 0.5! (+ polygon6_top polygon6_top)) (* 0.5! (- (* 0.5! (+ polygon6_right polygon6_right)) (* 0.5! (+ polygon5_left polygon5_left))))]\n  (let bounds [left top (+ left (* 2! r)) (+ top (* 2! r))]\n  (let [color strokeColor strokeWidth] [405 \'black\' 0]\n    [ (oval color strokeColor strokeWidth bounds) ]))))\n\n(blobs [\n  (helper k3046 k3045)\n  (helper polygon5_right k3041)\n  (helper k3038 polygon5_bot)\n  (helper k3034 polygon6_bot)\n  polygon5\n  polygon6\n  polygon7\n  circle8\n])\n\n";
   var sns_UIST = "\n(def newGroup4 (\\(line2_width line2_color color [left top right bot])\n  (def bounds [left top right bot])\n\n  (def rect1\n    (let bounds [left top right bot]\n      [ (rectangle color \'black\' \'0\' 0 bounds) ]))\n\n  (def line2\n      [ (line line2_color line2_width left top right bot) ])\n\n  (def line3\n    (let [ x2 y2] [ (* 0.5! (+ left right)) (* 0.5! (+ top bot))]\n      [ (line line2_color line2_width left bot x2 y2) ]))\n\n  [ (group bounds (concat [ rect1 line2 line3 ])) ]))\n\n(blobs [\n  (withBounds [31 100 216 269] (newGroup4 5 202 60))\n])\n\n";
   var snsLogoWheel = "\n(def logo (\\(rectColor\n             lineColor lineWidth\n             width height\n             rot\n             topLeft@[left top])\n\n  (def botRight@[right bot] [(+ left width) (+ top height)])\n\n  (def rect1\n    (rawRect rectColor 360 0 left top width height rot))\n\n  (def line2\n    (line lineColor lineWidth left top right bot))\n\n  (def line3\n    (lineBetween lineColor lineWidth\n      [left bot]\n      (halfwayBetween topLeft botRight)))\n\n  [ rect1 line2 line3 ]))\n\n(def wheel (\\(n\n              spokeLen spokeColor spokeWidth\n              logoSize logoColor1 logoColor2 logoLineWidth\n              hubRadius\n              rot center@[cx cy])\n\n  (def cars\n    (let car_i (\\[x y]\n      (let cx (- x (/ logoSize 2!))\n      (let cy (- y (/ logoSize 2!))\n        (logo logoColor1 logoColor2 logoLineWidth logoSize logoSize 0 [cx cy]))))\n    (radialArray n spokeLen rot car_i center)))\n\n  (def spokes\n    (let spoke_i (\\endpoint\n      [(lineBetween spokeColor spokeWidth center endpoint)])\n    (radialArray n spokeLen rot spoke_i center)))\n\n  (def hub\n    [(ring spokeColor spokeWidth cx cy hubRadius)])\n\n  (concat [ spokes cars hub ])\n))\n\n(blobs [\n  (wheel\n    (let n 16{1-30} n)\n    100 420 2\n    30 100 200 3\n    20\n    0\n    ([150 150] : Point)\n  )\n])\n\n";
   var cyclingAssociation0 = "\n; http://www.awwwards.com/gallery/4433/99-creative-logo-designs-for-inspiration/\n\n(def equiTriAt (\\(cx cy color sideLen rot)\n  (let len1 (* sideLen (/ 2! 3!))\n  (let len2 (* sideLen (/ 1! 3!))\n  (let point (circle color cx cy 15!)\n  (let tri (nStar \'none\' color 10! 3! len1 len2 rot cx cy)\n  [tri (ghost point)]\n))))))\n\n\n(def logo (\\(cx0 cy0\n             wheelRadius wheelDistance\n             armPct\n             wheelCapSize\n             [logoColor logoStrokeWidth])\n\n  (def helper\n    (ghosts (equiTriAt cx0 cy0 60 wheelDistance 0!)))\n\n  (def [ snap1 _ snap2 _ snap3 | _ ]\n    (polygonPoints (hd helper)))\n\n  (def onePiece (\\([cx cy] rot)\n\n    (def wheel\n      (rawCircle \'none\' logoColor logoStrokeWidth cx cy wheelRadius))\n\n    (def arm\n      (let armLength (* armPct wheelDistance)\n      (let dx (* armLength (cos (/ (pi) 3!)))\n      (let dy (* armLength (sin (/ (pi) 3!)))\n      (let d [\'M\' cx cy \'L\' (+ cx dx) (- cy dy) \'L\' (+ cx 8) (- cy dy)]\n        (rawPath \'none\' logoColor logoStrokeWidth d 0))))))\n\n    (def cap\n      (rawCircle logoColor 360 0 cx cy wheelCapSize))\n\n    [wheel (rotateAround rot cx cy arm) cap]\n  ))\n\n  ; TODO use a triangle function that doesn\'t draw center\n  (def midTriangle\n    ; slightly less than 0.50 to keep room for width of stroke\n    (equiTriAt cx0 cy0 logoColor (* 0.42! wheelDistance) (pi)))\n\n  (concat [\n    (onePiece snap2 0)\n    (onePiece snap1 120)\n    (onePiece snap3 240)\n    midTriangle\n    helper\n  ])\n))\n\n(blobs [\n  (logo 167 182 49 156.42857142857147 0.7 9 [416 9])\n])\n\n";
   var horrorFilms0 = "\n; http://www.awwwards.com/gallery/4453/99-creative-logo-designs-for-inspiration/\n\n(def equiTriAt (\\(cx cy color sideLen rot)\n  (let len1 (* sideLen (/ 2! 3!))\n  (let len2 (* sideLen (/ 1! 3!))\n  (let point (circle color cx cy 15!)\n  (let tri (nStar \'none\' color 10! 3! len1 len2 rot cx cy)\n  [tri point]\n))))))\n\n(def horror (\\(cx0 cy0 bgColor fgColor rBig rSmall sep)\n\n  (def helper\n    (ghosts (equiTriAt cx0 cy0 60 sep (pi))))\n\n  (def [ snap3 _ snap2 _ snap1 | _ ]\n    (polygonPoints (hd helper)))\n\n  (def backgroundCircle\n    [ (rawCircle bgColor 360 0 cx0 cy0 rBig) ])\n\n  (def foregroundCircle (\\[cx cy]\n    [ (rawCircle fgColor 360 0 cx cy rSmall) ]))\n\n  (concat [\n    backgroundCircle\n    (foregroundCircle snap1)\n    (foregroundCircle snap2)\n    (foregroundCircle snap3)\n    helper\n  ])\n))\n\n(blobs [\n  (horror 220 250 390 499 172 47 139)\n])\n\n";
   var blank = "(blobs [\n])\n\n";
   var spiralSpiralGraph = "; Spiral Spiral-Graph\n; Somewhat like the Spirograph toy, but based on a circle\n; following a spiral rather than a circle in a circle.\n\n(def n 140{1-200})\n(def revs 4{0-20})\n(def innerRevsRatio 2{0-20})\n(def innerR 125{0-500})\n\n(def placeCircle (\\i\n  (let spiralRadius 200\n  (let radius (* spiralRadius (/ i (- n 1)))\n  (let theta (* (* (/ i (- n 1)) (* 2 (pi))) revs)\n  (let innerTheta (* (* (* (/ i (- n 1)) (* 2 (pi))) innerRevsRatio) revs)\n  (let x (+ (+ (+ spiralRadius 150) (* radius (cos theta))) (* innerR (cos innerTheta)))\n  (let y (+ (+ (+ spiralRadius 250) (* radius (sin theta))) (* innerR (sin innerTheta)))\n    (circle i x y 10)\n  ))))))\n))\n\n(def theCircles (map placeCircle (range 1 n)))\n\n(svg theCircles)\n";
   var roundedRect = "\n(def roundedRect (\\(fill x y w h rxSeed rySeed)\n  (let off 20!\n  (let [wHalf hHalf] [(/ w 2!) (/ h 2!)]\n  (let [rx rxSlider] (hSlider true x (+ x wHalf) (- y off) 0! wHalf \'\' rxSeed)\n  (let [ry rySlider] (vSlider true y (+ y hHalf) (- x off) 0! hHalf \'\' rySeed)\n  (concat [\n    [ (consAttr (consAttr (rect fill x y w h) [\'rx\' rx]) [\'ry\' ry]) ]\n    rxSlider\n    rySlider\n  ])))))))\n\n(svg (concat [\n  [(rect \'black\' 0 0 0 0)] ; TODO remove dummy\n  (roundedRect 150 100 100 80 200 10 20)\n]))\n\n";
   var zones = "(def ngon (\\(n cx cy len1 len2)\n  (let dangle (/ (* 3! (pi)) 2!)\n  (let anglei (\\i (+ dangle (/ (* i (* 2! (pi))) n)))\n  (let xi     (\\i (+ cx (* len1 (cos (anglei i)))))\n  (let yi     (\\i (+ cy (* len2 (sin (anglei i)))))\n  (let pti    (\\i [(xi i) (yi i)])\n  (let pts    (map pti (list0N (- n 1!)))\n    (polygon \'goldenrod\' \'none\' 4 pts)))))))))\n\n(svg [\n  (rect \'goldenrod\' 32 170 109 132)\n  (ellipse \'goldenrod\' 203 237 32 68)\n  (ngon 5 464{200-600} 240{100-300} 60 60)\n  (path_ [\'M\' 261 250 \'Q\' 316.5 306 307 231 \'C\' 317 179 341 256 366 188 \'T\' 380 274])\n])\n\n";
   var floralLogo2 = "(def ringParameters [\n  ; petalSize petalRotation ringRadius ringRotation\n  [ 76{0-300} -0.266{-3.2-3.2}  -12{-100-300}   0.128{-3.2-3.2}]\n  [ 52{0-300} -0.317{-3.2-3.2}   60{-100-300}  -0.320{-3.2-3.2}]\n  [ 38{0-300} -0.629{-3.2-3.2}  104{-100-300}  -0.570{-3.2-3.2}]\n])\n\n(def rotatePointAround (\\(relX relY aroundX aroundY theta orientation)\n  (let relY (* orientation relY)\n  (let [rotRelX rotRelY] [(- (* relX (cos theta)) (* relY (sin theta))) (+ (* relX (sin theta)) (* relY (cos theta)))]\n    [(+ rotRelX aroundX) (+ rotRelY aroundY)]\n  ))\n))\n\n;(x + yi)(cosθ + isinθ) = xcosθ + ixsinθ + iycosθ - ysinθ\n;= (xcosθ - ysinθ) + (xsinθ + ycosθ)i\n\n(def petal (\\(x y scale theta orientation)\n  (let [[x1 y1]     [x2 y2]    ] [(rotatePointAround (* 1 scale) 0              x y theta orientation) (rotatePointAround 0              0             x y theta orientation)]\n  (let [[cx1a cy1a] [cx1b cy1b]] [(rotatePointAround (* 0.58 scale) (* 0.305 scale)  x y theta orientation) (rotatePointAround (* 0.43 scale) (* 0.275 scale)  x y theta orientation)]\n  (let [[cx2a cy2a] [cx2b cy2b]] [(rotatePointAround (* 0.4573836036582167 scale) (* -0.24276959866973943 scale) x y theta orientation) (rotatePointAround (* 0.5760783946789573 scale) (* -0.2389275837043081 scale) x y theta orientation)]\n    (path \'orange\' \'none\' 0 [\n      \'M\' x1 y1\n      \'C\' cx1a cy1a cx1b cy1b x2 y2\n      \'C\' cx2a cy2a cx2b cy2b x1 y1\n      \'Z\'\n    ])\n  )))\n))\n\n(def [x y] [300 200])\n(def [theta0 deltaTheta] [0.314{-3.2-3.2} -0.5{-3.2-3.2}])\n(def flower\n  (concat\n    (map\n      (\\[petalSize petalRotation ringRadius ringRotation]\n        (concatMap\n          (\\theta\n            (let armTheta (+ ringRotation theta)\n            (let rightPetalX (+ x (* ringRadius (cos armTheta)))\n            (let leftPetalX  (- x (* ringRadius (cos armTheta)))\n            (let petalY (+ y (* ringRadius (sin armTheta)))\n              [\n                (petal rightPetalX petalY petalSize (+ armTheta petalRotation) 1!)\n                (petal leftPetalX petalY petalSize (- (pi) (+ armTheta petalRotation)) -1!)\n              ]\n            ))))\n          )\n          [theta0 (+ theta0 deltaTheta) (+ theta0 (* 2! deltaTheta))]\n        )\n      )\n      ringParameters\n    )\n  )\n)\n\n(svg flower)\n";
   var floralLogo = "(def spiralArmCount 5)\n(def ringParameters [\n  ; petalSize petalRotation ringRadius ringRotation\n  [ 118{0-300}  0.63{-3.2-3.2} -16{-100-300}      0{-3.2-3.2}]\n  [ 76{0-300} -0.957{-3.2-3.2}  48{-100-300} -0.384{-3.2-3.2}]\n  [ 59{0-300} -1.269{-3.2-3.2}  76{-100-300} -0.89{-3.2-3.2}]\n  [ 36{0-300} -1.136{-3.2-3.2} 88{-100-300} -1.394{-3.2-3.2}]\n])\n\n(def rotatePointAround (\\(relX relY aroundX aroundY theta)\n  (let [rotRelX rotRelY] [(- (* relX (cos theta)) (* relY (sin theta))) (+ (* relX (sin theta)) (* relY (cos theta)))]\n    [(+ rotRelX aroundX) (+ rotRelY aroundY)]\n  )\n))\n\n;(x + yi)(cosθ + isinθ) = xcosθ + ixsinθ + iycosθ - ysinθ\n;= (xcosθ - ysinθ) + (xsinθ + ycosθ)i\n\n(def petal (\\(x y scale theta)\n  (let [[x1 y1]     [x2 y2]    ] [(rotatePointAround (* 1.0 scale) 0              x y theta) (rotatePointAround 0              0             x y theta)]\n  (let [[cx1a cy1a] [cx1b cy1b]] [(rotatePointAround (* 0.7 scale) (* 0.3 scale)  x y theta) (rotatePointAround (* 0.3 scale) (* 0.3 scale)  x y theta)]\n  (let [[cx2a cy2a] [cx2b cy2b]] [(rotatePointAround (* 0.4573836036582167 scale) (* -0.24276959866973943 scale) x y theta) (rotatePointAround (* 0.4710783946789573 scale) (* 0.40107241629569196 scale) x y theta)]\n    (path \'orange\' \'none\' 0 [\n      \'M\' x1 y1\n      \'C\' cx1a cy1a cx1b cy1b x2 y2\n      \'C\' cx2a cy2a cx2b cy2b x1 y1\n      \'Z\'\n    ])\n  )))\n))\n\n(def [x y] [300 140])\n(def flower\n  (concat\n    (map\n      (\\[petalSize petalRotation ringRadius ringRotation]\n        (map\n          (\\i\n            (let armTheta (+ ringRotation (* i (/ twoPi spiralArmCount)))\n            (let petalX (+ x (* ringRadius (cos armTheta)))\n            (let petalY (+ y (* ringRadius (sin armTheta)))\n              (petal petalX petalY petalSize (+ armTheta petalRotation))\n            )))\n          )\n          (range 0! (- spiralArmCount 1!))\n        )\n      )\n      ringParameters\n    )\n  )\n)\n\n(svg flower)\n\n";
   var tessellation2 = "; I believe this is set up for group p6mm\n; https://en.wikipedia.org/wiki/Wallpaper_group#Group_p6mm_.28.2A632.29\n\n; SVG transforms to flip, rotate, and position.\n(def transformGroup (\\(transformCenterX transformCenterY flipVertical rotationAngle translateX translateY shapes)\n  [\n    \'g\'\n    [\n      [\'transform\' [[\'translate\' (+ translateX transformCenterX) (+ translateY transformCenterY)] [\'rotate\' rotationAngle 0 0] [\'scale\' (if flipVertical -1 1) 1] [\'translate\' (- 0 transformCenterX) (- 0 transformCenterY)]]]\n    ]\n    shapes\n  ]\n))\n\n\n(def sin30 0.5!)\n(def cos30 (* 0.5! (sqrt 3!)))\n\n(def [x y radius] [350 200 200])\n(def innerRadius (* radius cos30))\n(def [bottomY cornerX] [(+ y innerRadius) (- x (/ radius 2!))])\n\n(def smallInnerRadius 36.14359353944901)\n(def smallInnerRadius2 62.143593539449)\n(def largeInnerRadius 74.2487113059643)\n\n(def primitive [\n  (path \'lightblue\' \'none\' 0 [\n    \'M\' x y\n    \'L\' x bottomY\n    \'L\' cornerX bottomY\n    \'Z\'\n  ])\n  (path \'blue\' \'none\' 0 [\n    \'M\' x y\n    \'L\' x (+ y (/ (* largeInnerRadius 2!) (sqrt 3!)))\n    \'L\' (- x (* smallInnerRadius sin30)) (+ y (* smallInnerRadius cos30))\n    \'Z\'\n  ])\n  (path \'darkblue\' \'none\' 0 [\n    \'M\' cornerX bottomY\n    \'L\' (+ cornerX smallInnerRadius2) bottomY\n    \'L\' (+ cornerX largeInnerRadius) (- bottomY (/ largeInnerRadius (sqrt 3!)))\n    \'L\' (+ cornerX (* smallInnerRadius2 sin30)) (- bottomY (* smallInnerRadius2 cos30))\n    \'Z\'\n  ])\n  (path \'white\' \'none\' 0 [\n    \'M\' x (+ y (/ (* largeInnerRadius 2!) (sqrt 3!)))\n    \'L\' (+ cornerX largeInnerRadius) (- bottomY (/ largeInnerRadius (sqrt 3!)))\n    \'L\' x (- bottomY (/ largeInnerRadius (sqrt 3!)))\n    \'Z\'\n  ])\n])\n\n(def primitiveHexagon [\n  (transformGroup x y false 0 0 0 primitive)\n  (transformGroup x y true  0 0 0 primitive)\n  (transformGroup x y false 60 0 0 primitive)\n  (transformGroup x y true  60 0 0 primitive)\n  (transformGroup x y false 120 0 0 primitive)\n  (transformGroup x y true  120 0 0 primitive)\n  (transformGroup x y false 180 0 0 primitive)\n  (transformGroup x y true  180 0 0 primitive)\n  (transformGroup x y false 240 0 0 primitive)\n  (transformGroup x y true  240 0 0 primitive)\n  (transformGroup x y false 300 0 0 primitive)\n  (transformGroup x y true  300 0 0 primitive)\n])\n\n(def primitiveHexagonColumn [\n  (transformGroup x y false 0 0 (* -2 innerRadius) primitiveHexagon)\n  (transformGroup x y false 0 0 0 primitiveHexagon)\n  (transformGroup x y false 0 0 (* 2 innerRadius) primitiveHexagon)\n  (transformGroup x y false 0 0 (* 4 innerRadius) primitiveHexagon)\n])\n\n(def primitiveHexagonColumns [\n  (transformGroup x y false 0 (* -1 (* radius (+ 1 sin30))) innerRadius primitiveHexagonColumn)\n  (transformGroup x y false 0 0 0 primitiveHexagonColumn)\n  (transformGroup x y false 0 (* 1 (* radius (+ 1 sin30))) innerRadius primitiveHexagonColumn)\n  (transformGroup x y false 0 (* 3 radius) 0 primitiveHexagonColumn)\n])\n\n(svg primitiveHexagonColumns)\n";
   var tessellationTarget = "; I believe this is set up for group p6mm\n; https://en.wikipedia.org/wiki/Wallpaper_group#Group_p6mm_.28.2A632.29\n\n; SVG transforms to flip, rotate, and position.\n(def transformGroup (\\(transformCenterX transformCenterY flipVertical rotationAngle translateX translateY shapes)\n  [\n    \'g\'\n    [\n      [\'transform\' [[\'translate\' (+ translateX transformCenterX) (+ translateY transformCenterY)] [\'rotate\' rotationAngle 0 0] [\'scale\' (if flipVertical -1 1) 1] [\'translate\' (- 0 transformCenterX) (- 0 transformCenterY)]]]\n    ]\n    shapes\n  ]\n))\n\n\n(def sin30 0.5!)\n(def cos30 (* 0.5! (sqrt 3!)))\n\n(def [x y radius] [350 200 200])\n(def innerRadius (* radius cos30))\n(def [bottomY cornerX] [(+ y innerRadius) (- x (/ radius 2!))])\n(def primativeBottomWidth (/ radius 2!))\n\n(def smallInnerRadius 56)\n(def largeInnerRadius 69)\n(def bottomRectWidth (- primativeBottomWidth smallInnerRadius))\n(def bottomRectHeight (/ smallInnerRadius (sqrt 3!)))\n\n(def primitive [\n  (path \'lightblue\' \'none\' 0 [\n    \'M\' x y\n    \'L\' x bottomY\n    \'L\' cornerX bottomY\n    \'Z\'\n  ])\n  (path \'green\' \'none\' 0 [\n    \'M\' x y\n    \'L\' x (+ y (/ (* largeInnerRadius 2!) (sqrt 3!)))\n    \'L\' (- x (* smallInnerRadius sin30)) (+ y (* smallInnerRadius cos30))\n    \'Z\'\n  ])\n  (path \'green\' \'none\' 0 [\n    \'M\' cornerX bottomY\n    \'L\' (+ cornerX smallInnerRadius) bottomY\n    \'L\' (+ cornerX largeInnerRadius) (- bottomY (/ largeInnerRadius (sqrt 3!)))\n    \'L\' (+ cornerX (* smallInnerRadius sin30)) (- bottomY (* smallInnerRadius cos30))\n    \'Z\'\n  ])\n  (path \'red\' \'none\' 0 [\n    \'M\' x (+ y (/ (* largeInnerRadius 2!) (sqrt 3!)))\n    \'L\' (+ cornerX largeInnerRadius) (- bottomY (/ largeInnerRadius (sqrt 3!)))\n    \'L\' x (- bottomY (/ largeInnerRadius (sqrt 3!)))\n    \'Z\'\n  ])\n])\n\n(def primitiveHexagon [\n  (transformGroup x y false 0 0 0 primitive)\n  (transformGroup x y true  0 0 0 primitive)\n  (transformGroup x y false 60 0 0 primitive)\n  (transformGroup x y true  60 0 0 primitive)\n  (transformGroup x y false 120 0 0 primitive)\n  (transformGroup x y true  120 0 0 primitive)\n  (transformGroup x y false 180 0 0 primitive)\n  (transformGroup x y true  180 0 0 primitive)\n  (transformGroup x y false 240 0 0 primitive)\n  (transformGroup x y true  240 0 0 primitive)\n  (transformGroup x y false 300 0 0 primitive)\n  (transformGroup x y true  300 0 0 primitive)\n])\n\n(def primitiveHexagonColumn [\n  (transformGroup x y false 0 0 (* -2 innerRadius) primitiveHexagon)\n  (transformGroup x y false 0 0 0 primitiveHexagon)\n  (transformGroup x y false 0 0 (* 2 innerRadius) primitiveHexagon)\n  (transformGroup x y false 0 0 (* 4 innerRadius) primitiveHexagon)\n])\n\n(def primitiveHexagonColumns [\n  (transformGroup x y false 0 (* -1 (* radius (+ 1 sin30))) innerRadius primitiveHexagonColumn)\n  (transformGroup x y false 0 0 0 primitiveHexagonColumn)\n  (transformGroup x y false 0 (* 1 (* radius (+ 1 sin30))) innerRadius primitiveHexagonColumn)\n  (transformGroup x y false 0 (* 3 radius) 0 primitiveHexagonColumn)\n])\n\n(svg primitiveHexagonColumns)\n";
   var tessellation = "; I believe this is set up for group p6mm\n; https://en.wikipedia.org/wiki/Wallpaper_group#Group_p6mm_.28.2A632.29\n\n; SVG transforms to flip, rotate, and position.\n(def transformGroup (\\(transformCenterX transformCenterY flipVertical rotationAngle translateX translateY shapes)\n  [\n    \'g\'\n    [\n      [\'transform\' [[\'translate\' (+ translateX transformCenterX) (+ translateY transformCenterY)] [\'rotate\' rotationAngle 0 0] [\'scale\' (if flipVertical -1 1) 1] [\'translate\' (- 0 transformCenterX) (- 0 transformCenterY)]]]\n    ]\n    shapes\n  ]\n))\n\n\n(def sin30 0.5!)\n(def cos30 (* 0.5! (sqrt 3!)))\n\n(def [x y radius] [350 200 200])\n(def innerRadius (* radius cos30))\n(def [bottomY cornerX] [(+ y innerRadius) (- x (/ radius 2!))])\n(def primativeBottomWidth (/ radius 2!))\n\n(def smallInnerRadius 50)\n(def bottomRectWidth (- primativeBottomWidth smallInnerRadius))\n(def bottomRectHeight (/ smallInnerRadius (sqrt 3!)))\n\n(def primitive [\n  (path \'lightblue\' \'none\' 0 [\n    \'M\' x y\n    \'L\' x bottomY\n    \'L\' cornerX bottomY\n    \'Z\'\n  ])\n  (path \'green\' \'none\' 0 [\n    \'M\' x y\n    \'L\' x (+ y (/ (* smallInnerRadius 2!) (sqrt 3!)))\n    \'L\' (- x (* smallInnerRadius sin30)) (+ y (* smallInnerRadius cos30))\n    \'Z\'\n  ])\n  (path \'green\' \'none\' 0 [\n    \'M\' cornerX bottomY\n    \'L\' (+ cornerX smallInnerRadius) bottomY\n    \'L\' (+ cornerX smallInnerRadius) (- bottomY (/ smallInnerRadius (sqrt 3!)))\n    \'L\' (+ cornerX (* smallInnerRadius sin30)) (- bottomY (* smallInnerRadius cos30))\n    \'Z\'\n  ])\n  (rect \'pink\' (- x bottomRectWidth) (- bottomY bottomRectHeight) bottomRectWidth bottomRectHeight)\n  (path \'pink\' \'none\' 0 [\n    \'M\' x (+ y (/ (* smallInnerRadius 2!) (sqrt 3!)))\n    \'L\' (+ cornerX smallInnerRadius) (- bottomY (/ smallInnerRadius (sqrt 3!)))\n    \'L\' (+ cornerX (* smallInnerRadius sin30)) (- bottomY (* smallInnerRadius cos30))\n    \'L\' (- x (* smallInnerRadius sin30)) (+ y (* smallInnerRadius cos30))\n    \'Z\'\n  ])\n  (path \'red\' \'none\' 0 [\n    \'M\' x (- bottomY bottomRectHeight)\n    \'L\' x (- (- bottomY bottomRectHeight) (* bottomRectWidth cos30))\n    \'L\' (- x (/ bottomRectWidth 2)) (- (- bottomY bottomRectHeight) (* bottomRectWidth cos30))\n    \'Z\'\n  ])\n])\n\n(def primitiveHexagon [\n  (transformGroup x y false 0 0 0 primitive)\n  (transformGroup x y true  0 0 0 primitive)\n  (transformGroup x y false 60 0 0 primitive)\n  (transformGroup x y true  60 0 0 primitive)\n  (transformGroup x y false 120 0 0 primitive)\n  (transformGroup x y true  120 0 0 primitive)\n  (transformGroup x y false 180 0 0 primitive)\n  (transformGroup x y true  180 0 0 primitive)\n  (transformGroup x y false 240 0 0 primitive)\n  (transformGroup x y true  240 0 0 primitive)\n  (transformGroup x y false 300 0 0 primitive)\n  (transformGroup x y true  300 0 0 primitive)\n])\n\n(def primitiveHexagonColumn [\n  (transformGroup x y false 0 0 (* -2 innerRadius) primitiveHexagon)\n  (transformGroup x y false 0 0 0 primitiveHexagon)\n  (transformGroup x y false 0 0 (* 2 innerRadius) primitiveHexagon)\n  (transformGroup x y false 0 0 (* 4 innerRadius) primitiveHexagon)\n])\n\n(def primitiveHexagonColumns [\n  (transformGroup x y false 0 (* -1 (* radius (+ 1 sin30))) innerRadius primitiveHexagonColumn)\n  (transformGroup x y false 0 0 0 primitiveHexagonColumn)\n  (transformGroup x y false 0 (* 1 (* radius (+ 1 sin30))) innerRadius primitiveHexagonColumn)\n  (transformGroup x y false 0 (* 3 radius) 0 primitiveHexagonColumn)\n])\n\n(svg primitiveHexagonColumns)\n";
   var keyboard2target = "(def scale 40)\n(def keyBaseHeight scale)\n(def keyBaseWidth keyBaseHeight)\n(def relativeSpacing 0.3333333333333)\n\n(def [boardLeft boardTop] [54 50])\n\n(def key (\\(relativeLeft relativeTop relativeWidth relativeHeight)\n  (rect\n    \'lightgray\'\n    (+ boardLeft (* relativeLeft keyBaseWidth))\n    (+ boardTop (* relativeTop keyBaseWidth))\n    (* relativeWidth keyBaseWidth)\n    (* relativeHeight keyBaseHeight)\n  )\n))\n\n; Generate a row of keys with the given relativeKeyWidths, separated by relativeKeySpacing\n; Returns [keyRects relativeTotalWidth]\n(def row (\\(relativeLeft relativeTop relativeHeight relativeKeySpacing relativeKeyWidths)\n  (let [keys relativeWidthPlusSpacing]\n    (foldl\n      (\\(relativeKeyWidth [keys nextKeyRelativeLeft])\n        (let newKey (key nextKeyRelativeLeft relativeTop relativeKeyWidth relativeHeight)\n          [[newKey|keys] (+ nextKeyRelativeLeft (+ relativeKeySpacing relativeKeyWidth))]\n        )\n      )\n      [[] relativeLeft]\n      relativeKeyWidths\n    )\n  [keys (- (- relativeWidthPlusSpacing relativeKeySpacing) relativeLeft)]\n  )\n))\n\n(def row2EndKeysWidth 1.95)\n(def row3EndKeysWidth 2.625)\n(def row4CommandKeysWidth 1.5)\n\n(def row1RelativeKeyWidths [1.575 1 1 1 1 1 1 1 1 1])\n(def row2RelativeKeyWidths [row2EndKeysWidth 1 1 1 1 1 1 1 row2EndKeysWidth])\n(def row3RelativeKeyWidths [row3EndKeysWidth 1 1 1 1 1 1 row3EndKeysWidth])\n(def row4RelativeKeyWidths [1 row4CommandKeysWidth 7.2667 row4CommandKeysWidth 1])\n\n(def [row1 keysRelativeWidth] (row relativeSpacing relativeSpacing 1 relativeSpacing row1RelativeKeyWidths))\n(def [row2        _] (row relativeSpacing (+ 1 (* 2 relativeSpacing)) 1 relativeSpacing row2RelativeKeyWidths))\n(def [row3        _] (row relativeSpacing (+ 2 (* 3 relativeSpacing)) 1 relativeSpacing row3RelativeKeyWidths))\n(def [row4        _] (row relativeSpacing (+ 3 (* 4 relativeSpacing)) 1 relativeSpacing row4RelativeKeyWidths))\n\n(def boardRelativeWidth  (+ keysRelativeWidth (* 2 relativeSpacing)))\n(def boardRelativeHeight (+ 4 (* 5 relativeSpacing)))\n\n(def backBoard\n  (rect \'green\' boardLeft boardTop (* boardRelativeWidth scale) (* boardRelativeHeight scale))\n)\n\n(svg (concat [\n  [backBoard]\n  row1\n  row2\n  row3\n  row4\n]))\n";
   var keyboard2 = "(def scale 40)\n(def keyBaseHeight scale)\n(def keyBaseWidth keyBaseHeight)\n(def relativeSpacing 0.3333333333333)\n\n(def [boardLeft boardTop] [50 50])\n\n(def key (\\(relativeLeft relativeTop relativeWidth relativeHeight)\n  (rect\n    \'lightgray\'\n    (+ boardLeft (* relativeLeft keyBaseWidth))\n    (+ boardTop (* relativeTop keyBaseWidth))\n    (* relativeWidth keyBaseWidth)\n    (* relativeHeight keyBaseHeight)\n  )\n))\n\n; Generate a row of keys with the given relativeKeyWidths, separated by relativeKeySpacing\n; Returns [keyRects relativeTotalWidth]\n(def row (\\(relativeLeft relativeTop relativeHeight relativeKeySpacing relativeKeyWidths)\n  (let [keys relativeWidthPlusSpacing]\n    (foldl\n      (\\(relativeKeyWidth [keys nextKeyRelativeLeft])\n        (let newKey (key nextKeyRelativeLeft relativeTop relativeKeyWidth relativeHeight)\n          [[newKey|keys] (+ nextKeyRelativeLeft (+ relativeKeySpacing relativeKeyWidth))]\n        )\n      )\n      [[] relativeLeft]\n      relativeKeyWidths\n    )\n  [keys (- (- relativeWidthPlusSpacing relativeKeySpacing) relativeLeft)]\n  )\n))\n\n(def row1RelativeKeyWidths [1 1 1 1 1 1 1 1])\n(def row2RelativeKeyWidths [1 1 1 1 1 1 1 1])\n(def row3RelativeKeyWidths [1 1 1 1 1 1 1 1])\n(def row4RelativeKeyWidths [1 7.6667      1])\n\n(def [row1 keysRelativeWidth] (row relativeSpacing relativeSpacing 1 relativeSpacing row1RelativeKeyWidths))\n(def [row2 _] (row relativeSpacing (+ 1 (* 2 relativeSpacing)) 1 relativeSpacing row2RelativeKeyWidths))\n(def [row3 _] (row relativeSpacing (+ 2 (* 3 relativeSpacing)) 1 relativeSpacing row3RelativeKeyWidths))\n(def [row4 _] (row relativeSpacing (+ 3 (* 4 relativeSpacing)) 1 relativeSpacing row4RelativeKeyWidths))\n\n(def boardRelativeWidth  (+ keysRelativeWidth (* 2 relativeSpacing)))\n(def boardRelativeHeight (+ 4 (* 5 relativeSpacing)))\n\n(def backBoard\n  (rect \'green\' boardLeft boardTop (* boardRelativeWidth scale) (* boardRelativeHeight scale))\n)\n\n(svg (concat [\n  [backBoard]\n  row1\n  row2\n  row3\n  row4\n]))\n";
   var keyboard = "(def scale 25)\n(def keyBaseHeight scale)\n(def keyBaseWidth keyBaseHeight)\n(def relativeSpacing 0.3333333333333)\n\n(def [boardLeft boardTop] [50 50])\n\n(def key (\\(relativeLeft relativeTop relativeWidth relativeHeight)\n  (rect\n    \'orange\'\n    (+ boardLeft (* relativeLeft keyBaseWidth))\n    (+ boardTop (* relativeTop keyBaseWidth))\n    (* relativeWidth keyBaseWidth)\n    (* relativeHeight keyBaseHeight)\n  )\n))\n\n; Generate a row of keys with the given relativeKeyWidths, separated by relativeKeySpacing\n; Returns [keyRects relativeTotalWidth]\n(def row (\\(relativeLeft relativeTop relativeHeight relativeKeySpacing relativeKeyWidths)\n  (let [keys relativeWidthPlusSpacing]\n    (foldl\n      (\\(relativeKeyWidth [keys nextKeyRelativeLeft])\n        (let newKey (key nextKeyRelativeLeft relativeTop relativeKeyWidth relativeHeight)\n          [[newKey|keys] (+ nextKeyRelativeLeft (+ relativeKeySpacing relativeKeyWidth))]\n        )\n      )\n      [[] relativeLeft]\n      relativeKeyWidths\n    )\n  [keys (- (- relativeWidthPlusSpacing relativeKeySpacing) relativeLeft)]\n  )\n))\n\n(def row1SquareKeyCount 10)\n(def row2SquareKeyCount 8)\n(def row3SquareKeyCount 7)\n\n(def row2SquareKeysRelativeWidth (+ row2SquareKeyCount (* relativeSpacing (- row2SquareKeyCount 1))))\n(def row3SquareKeysRelativeWidth (+ row3SquareKeyCount (* relativeSpacing (- row3SquareKeyCount 1))))\n\n(def [row1 keysRelativeWidth] (row relativeSpacing relativeSpacing 1 relativeSpacing [1.5|(repeat row1SquareKeyCount 1)]))\n\n; Make the first and last keys of the row the appropriate width so the other keys are center.\n(def row2EdgeKeyRelativeWidth (- (* 0.5 (- keysRelativeWidth row2SquareKeysRelativeWidth)) relativeSpacing))\n(def row3EdgeKeyRelativeWidth (- (* 0.5 (- keysRelativeWidth row3SquareKeysRelativeWidth)) relativeSpacing))\n\n(def [row2 _] (row relativeSpacing (+ 1 (* 2 relativeSpacing)) 1 relativeSpacing (concat [[row2EdgeKeyRelativeWidth] (repeat row2SquareKeyCount 1) [row2EdgeKeyRelativeWidth]])))\n(def [row3 _] (row relativeSpacing (+ 2 (* 3 relativeSpacing)) 1 relativeSpacing (concat [[row3EdgeKeyRelativeWidth] (repeat row3SquareKeyCount 1) [row3EdgeKeyRelativeWidth]])))\n\n(def boardRelativeWidth  (+ keysRelativeWidth (* 2 relativeSpacing)))\n(def boardRelativeHeight (+ 4 (* 5 relativeSpacing)))\n\n(def arrowVerticalSpacing 0.1)\n(def arrowHeight (* 0.5 (- 1 arrowVerticalSpacing)))\n(def arrowsRelativeWidth (+ 3 (* 2 relativeSpacing)))\n(def [bottomArrows _] (row (- (- boardRelativeWidth arrowsRelativeWidth) relativeSpacing) (+ arrowVerticalSpacing (+ arrowHeight (+ 3 (* 4 relativeSpacing)))) arrowHeight relativeSpacing (repeat 3 1)))\n\n(def topArrow\n  (key\n    (- (- boardRelativeWidth (+ 2 relativeSpacing)) relativeSpacing)\n    (+ 3 (* 4 relativeSpacing))\n    1\n    arrowHeight\n  )\n)\n\n(def row4SquareKeyCount 2)\n(def row4NextToSpaceBarKeyRelativeWidth 1.25)\n(def row4NotArrowsRelativeWidth (- (- keysRelativeWidth arrowsRelativeWidth) relativeSpacing))\n(def row4SquareKeysRelativeWidth (+ row4SquareKeyCount (* relativeSpacing (- row4SquareKeyCount 1))))\n(def spaceBarRelativeWidth (- row4NotArrowsRelativeWidth (+ row4SquareKeysRelativeWidth (+ (* 2 row4NextToSpaceBarKeyRelativeWidth) (* 3 relativeSpacing)))))\n(def row4KeyRelativeWidths (concat [(repeat row4SquareKeyCount 1) [row4NextToSpaceBarKeyRelativeWidth spaceBarRelativeWidth row4NextToSpaceBarKeyRelativeWidth]]))\n(def [row4 _] (row relativeSpacing (+ 3 (* 4 relativeSpacing)) 1 relativeSpacing row4KeyRelativeWidths))\n\n(def backBoard\n  (rect \'lightblue\' boardLeft boardTop (* boardRelativeWidth scale) (* boardRelativeHeight scale))\n)\n\n(svg (concat [\n  [backBoard]\n  row1\n  row2\n  row3\n  bottomArrows\n  [topArrow]\n  row4\n]))\n";
   var lilliconP2 = "\n(def [x0 x1 x2 x3 x4] [20 80 150 240 380])\n(def [y0 y1 y2 y3]    [20 125 296 424])\n\n(def yRightmostPt (+ y0 (/ (- y2 y0) 2!)))\n(def arcR 1!) ; any non-zero, not-too-large number works\n\n(def theP\n  (path \'black\' \'none\' 0\n    [\'M\' x0 y3\n     \'C\' x1 376 x1 216 x1 y1\n     \'C\' 80 60 134 y0 x3 y0\n     \'A\' arcR arcR 0 0 1 x3 y2\n     \'L\' x2 y2\n     \'L\' x2 y3\n     \'L\' x0 y3\n    ]))\n\n(def highlights\n  (let r 10!\n  [ (circle \'goldenrod\' x3 y2 r)\n    (circle \'magenta\'   x2 y2 r) ]))\n\n(svg (cons theP (if true highlights [])))\n\n";
   var lilliconP = "\n(def [x0 x1 x2 x3 x4] [20 80 150 240 380])\n(def [y0 y1 y2 y3]    [20 125 296 424])\n\n(def yRightmostPt (+ y0 (/ (- y2 y0) 2!)))\n(def delta 50!) ; TODO\n\n(def theP\n  (path \'black\' \'none\' 0\n    [\'M\' x0 y3\n     \'C\' x1 376 x1 216 x1 y1\n     \'C\' 80 60 134 y0 x3 y0\n     \'C\' (- x4 delta) y0 x4 (+ y0 delta) x4 yRightmostPt\n     \'C\' x4 (- y2 delta) (- x4 delta) y2 x3 y2\n     \'L\' x2 y2\n     \'L\' x2 y3\n     \'L\' x0 y3\n    ]))\n\n(def highlights\n  (let r 10!\n  (cons\n    (circle \'goldenrod\' x3 y2 r)\n    (map (\\[x y] (circle \'magenta\' x y r))\n         [[(- x4 delta) y0]\n          [x4 (+ y0 delta)]\n          [x4 yRightmostPt]\n          [x4 (- y2 delta)]\n          [(- x4 delta) y2]\n          [x2 y2]\n         ]))))\n\n(svg (cons theP (if true highlights [])))\n\n";
   var gridTile = "\n(def grid (\\(x0 y0 w h n m)\n  (let [xw yh] [(+ x0 w) (+ y0 h)]\n  (let [rowH colW] [(/ h n) (/ w m)]\n  (let box (rect 460 x0 y0 w h)\n  (let rows\n    (map (\\i (let yi (+ y0 (mult i rowH))\n             (line \'black\' 2 x0 yi xw yi)))\n         (range 0! n))\n  (let cols\n    (map (\\i (let xi (+ x0 (mult i colW))\n             (line \'black\' 2 xi y0 xi yh)))\n         (range 0! n))\n  (concat [[box] rows cols]))))))))\n\n(def [x0 y0 w h n m] [100 100 325 285 10! 10!])\n\n(def blob\n  (ellipse 196 (+ x0 (/ w 2!))\n               (+ y0 (/ h 2!))\n               (- (/ w 2!) (/ w m))\n               (- (/ h 2!) (/ h n))))\n\n(svg (append\n  (grid x0 y0 w h n m)\n  [blob]\n))\n\n";
   var equiTri = "\n; Equilateral Triangles\n; (derived in terms of nStar, rather than nGon)\n\n(def tri (\\(c x y sideLen rot)\n  (let len1 (* sideLen (/ 2! 3!))\n  (let len2 (* sideLen (/ 1! 3!))\n  (nStar c \'none\' 0 3! len1 len2 rot x y)))))\n\n(svg [\n  (tri \'darkblue\'\n    150 150\n    100\n    0)\n  (tri \'lightblue\'\n    200 300\n    50\n    10)\n])\n\n";
   var surveyResultsTriHist2 = "\n; Interactive charts that show results from user study:\n; http://ravichugh.github.io/sketch-n-sketch/blog/03-user-study-videos.html\n\n; counts: [ A/B C/A C/B CI-Intervals ]\n\n(def ferrisCounts [\n  [ 3 14  2  5  1 ]\n  [ 0  3  1 11 10 ]\n  [ 1  3  4  9  8 ]\n  [ [-0.92 0.01] [0.59 1.47] [0.25 1.23] ]\n])\n\n(def keyboardCounts [\n  [ 0  5  3 10  7 ]\n  [ 0  1  5 14  5 ]\n  [ 0  2  2  9 12 ]\n  [ [0.26 1.18] [0.59 1.21] [0.73 1.57] ]\n])\n\n(def tesselationCounts [\n  [ 0  7  9  6  3 ]\n  [ 1  0  8 11  5 ]\n  [ 1  0  4 13  7 ]\n  [ [-0.20 0.64] [0.34 1.10] [0.53 1.32] ]\n])\n\n(def maxDataPoint 14!)\n\n(def sum (\\ns\n  (foldr\n    (\\([weight n] acc) (+ (* n weight) acc))\n    0 (zip [0 1 2 3 4] ns))))\n\n(def [iRot jRot kRot]                   [0! -120! 120!])\n(def [iRevCounts jRevCounts kRevCounts] [id id reverse])\n(def [iRevAvg jRevAvg kRevAvg]          [id id (\\n (+ (neg (- n 2!)) 2!))])\n(def [iRevBound jRevBound kRevBound]    [(\\n (+ 2! n)) (\\n (+ 2! n)) (\\n (+ 2! (neg n)))])\n\n(def numUsers 25!)\n(def numBins 5!)\n(def slices (- numBins 0!))\n(def shift  (\\idx (+ idx 0.5!)))\n\n(def sideLen 90{20-200})\n(def sidePad 13!{0-50})\n(def tickLen 5!{1-10})\n(def edgeWidth 1!{0-4})\n(def levelWidth 1.0!{0.0-2.1})\n(def dotSize 5!{3-10})\n(def barSize 16!{1-20})\n(def intWidth 8!{1-30})\n(def intTicks 0!{-3-15})\n(def fontSize 20!{10-40})\n(def showAvgs (let showAvgs_ 0.7{0.1-1.0} (< showAvgs_ 0.5!)))\n(def showTicks (let showTicks_ 0.7{0.1-1.0} (< showTicks_ 0.5!)))\n\n(def [aUp   aLeft]  [-5!{-20-50}  25!{0-50}])\n(def [bUp   bRight] [aUp          98!{0-150}])\n(def [cDown cLeft]  [115!{50-200} 10!{0-30}])\n\n(def halfLen (/ sideLen 2!))\n\n(def tri (\\(cx cy [iCounts jCounts kCounts ciIntervals])\n  (let [iSum jSum kSum] (map sum [iCounts jCounts kCounts])\n  (let [iAvg jAvg kAvg] [(/ iSum numUsers) (/ jSum numUsers) (/ kSum numUsers)]\n  (let [iBounds jBounds kBounds] ciIntervals\n  (let x0    (- cx halfLen)\n  (let x1    (+ cx halfLen)\n  (let y     (- cy (* (+ sideLen (* 2! sidePad)) (/ (sqrt 3!) 6!)))\n  (let dx    (/ (- x1 x0) slices)\n  (let xi    (\\i (+ x0 (* (shift i) dx)))\n  (let yn    (\\n (- y (* n tickLen)))\n  (let edge  (line \'gray\' edgeWidth)\n  (let tick  (\\x (circle \'gray\' x y 3!))\n  (let bar   (line \'lightblue\' barSize)\n  (let dot   (\\x (circle \'goldenrod\' x y dotSize))\n  (let level (\\i (let yLevel (- y (* i tickLen))\n                 (line \'white\' levelWidth x0 yLevel x1 yLevel)))\n  (let label (\\(x y s)\n    (addAttr (text x y s) [\'font-size\' (+ (toString fontSize) \'pt\')]))\n  (let edges\n    [ (rotate (edge x0 y x1 y) iRot cx cy)\n      (rotate (edge x0 y x1 y) jRot cx cy)\n      (rotate (edge x0 y x1 y) kRot cx cy)\n    ]\n  (let tickmarks\n    (let foo (\\rot\n      (map (\\i (rotate (tick (+ (+ x0 (/ dx 2!)) (* i dx))) rot cx cy))\n           (zeroTo slices)))\n    (concatMap foo [iRot jRot kRot]))\n  (let levels\n    (let foo (\\rot\n      (map (\\i (rotate (level i) rot cx cy))\n           (range 1! maxDataPoint)))\n    (concatMap foo [iRot jRot kRot]))\n  (let averages\n    [ (rotate (dot (xi (iRevAvg iAvg))) iRot cx cy)\n      (rotate (dot (xi (jRevAvg jAvg))) jRot cx cy)\n      (rotate (dot (xi (kRevAvg kAvg))) kRot cx cy)\n    ]\n  (let intervals\n    (let draw (\\(revBound [ciMin ciMax] rot)\n      [ (rotate (line \'red\' intWidth\n           (xi (revBound ciMin)) (- y (* intTicks tickLen))\n           (xi (revBound ciMax)) (- y (* intTicks tickLen))) rot cx cy) ])\n    (concat [\n      (draw iRevBound iBounds iRot)\n      (draw jRevBound jBounds jRot)\n      (draw kRevBound kBounds kRot)\n    ]))\n  (let labels\n    [ (label (- x0 aLeft) (- y aUp) \'A\')\n      (label (+ x0 bRight) (- y bUp) \'B\')\n      (label (- (+ x0 (/ (- x1 x0) 2!)) cLeft) (+ y cDown) \'C\')\n    ]\n  (concat [\n    (flip mapi (iRevCounts iCounts) (\\[i n]\n      (rotate (bar (xi i) y (xi i) (yn n)) iRot cx cy)))\n    (flip mapi (jRevCounts jCounts) (\\[i n]\n      (rotate (bar (xi i) y (xi i) (yn n)) jRot cx cy)))\n    (flip mapi (kRevCounts kCounts) (\\[i n]\n      (rotate (bar (xi i) y (xi i) (yn n)) kRot cx cy)))\n    levels\n    edges\n    intervals\n    (if showTicks tickmarks [])\n    (if showAvgs averages [])\n    labels\n  ]\n))))))))))))))))))))))))\n\n(def [cx0 cy0] [180!{0-200} 130!{0-200}])\n(def sep 216!{100-300})\n\n(svg (concat\n  (mapi\n    (\\[i countsi] (tri cx0 (+ cy0 (* i sep)) countsi))\n    [ferrisCounts keyboardCounts tesselationCounts])))\n\n";
   var bezier = "; Animated Bezier Curves\n; Recreating https://www.jasondavies.com/animated-bezier/\n;\n; Bezier functions\n;\n(def linbez (\\(t p1 p2)\n  (+ p1 (* t (- p2 p1))) ) )\n(def quadbez (\\(t p1 p2 p3)\n  (+ (* (- 1 t) (linbez t p1 p2)) (* t (linbez t p2 p3))) ) )\n(def cubez (\\(t p1 p2 p3 p4)\n  (+ (* (- 1 t) (quadbez t p1 p2 p3)) (* t (quadbez t p2 p3 p4))) ) )\n(def quarbez (\\(t p1 p2 p3 p4 p5)\n  (+ (* (- 1 t) (cubez t p1 p2 p3 p4)) (* t (cubez t p2 p3 p4 p5))) ) )\n;\n; Point definitions\n;\n(def [t tslider] (hSlider false 50! 450! 300! 0! 1! \'t: \' 0.25))\n(def [linx1 liny1 linx2 liny2] [50 200 100 50])\n(def [quadx1 quady1 quadx2 quady2 quadx3 quady3] \n     [(+ linx1 150!) liny1 (+ linx2 150!) liny2 300 200])\n(def [cux1 cuy1 cux2 cuy2 cux3 cuy3 cux4 cuy4] \n     [(+ quadx1 150!) liny1 (+ quadx2 150!) liny2 (+ quadx3 150!) quady3 500 50])\n(def [qux1 quy1 qux2 quy2 qux3 quy3 qux4 quy4 qux5 quy5]\n     [(+ cux1 150!) liny1 (+ cux2 150!) liny2 (+ cux3 150!) quady3 (+ cux4 150!) cuy4 700 200])\n;\n; Style Definitions\n;\n(def [linwd col1 col2 col3 col4] [3 \'gray\' \'lightblue\' \'green\' \'lightgreen\'])\n(def ptcirc (\\(cx cy) (circle \'red\' cx cy 5!)))\n;\n; Curve Definitions\n;\n(def linCurve\n  (let [midx midy] [(linbez t linx1 linx2) (linbez t liny1 liny2)]\n  [ (path \'none\' col1 linwd\n      [ \'M\' linx1 liny1\n        \'L\' linx2 liny2 ] )\n    (path \'none\' \'red\' linwd\n      [ \'M\' linx1 liny1\n        \'L\' midx midy ] )\n    (ptcirc midx midy)  ] ) )\n(def quadCurve\n  (let [midx1 midy1 midx2 midy2] [(linbez t quadx1 quadx2) (linbez t quady1 quady2)\n                                  (linbez t quadx2 quadx3) (linbez t quady2 quady3)]\n  (let [px py] [(quadbez t quadx1 quadx2 quadx3) (quadbez t quady1 quady2 quady3)]\n  [ (path \'none\' col1 linwd\n      [ \'M\' quadx1 quady1\n        \'L\' quadx2 quady2 ] )\n    (path \'none\' col1 linwd\n      [ \'M\' quadx2 quady2\n        \'L\' quadx3 quady3 ] )\n    (path \'none\' col2 linwd\n      [ \'M\' midx1 midy1\n        \'L\' midx2 midy2 ] )\n    (path \'none\' \'red\' linwd\n      [ \'M\' quadx1 quady1\n        \'Q\' quadx2 quady2\n            quadx3 quady3 ] )\n    (ptcirc px py)    ] ) ) )\n(def cuCurve\n  (let [midx1 midy1 midx2 midy2 midx3 midy3]\n       [(linbez t cux1 cux2) (linbez t cuy1 cuy2)\n        (linbez t cux2 cux3) (linbez t cuy2 cuy3)\n        (linbez t cux3 cux4) (linbez t cuy3 cuy4)]\n  (let [dubmidx1 dubmidy1 dubmidx2 dubmidy2]\n       [(linbez t midx1 midx2) (linbez t midy1 midy2)\n        (linbez t midx2 midx3) (linbez t midy2 midy3)]\n  (let [px py] [(cubez t cux1 cux2 cux3 cux4) (cubez t cuy1 cuy2 cuy3 cuy4)]\n  [ (path \'none\' col1 linwd\n      [ \'M\' cux1 cuy1\n        \'L\' cux2 cuy2 ] )\n    (path \'none\' col1 linwd\n      [ \'M\' cux2 cuy2\n        \'L\' cux3 cuy3 ] )\n    (path \'none\' col1 linwd\n      [ \'M\' cux3 cuy3\n        \'L\' cux4 cuy4 ] )\n    (path \'none\' col2 linwd\n      [ \'M\' midx1 midy1\n        \'L\' midx2 midy2 ] )\n    (path \'none\' col2 linwd\n      [ \'M\' midx2 midy2\n        \'L\' midx3 midy3 ] )\n    (path \'none\' col3 linwd\n      [ \'M\' dubmidx1 dubmidy1\n        \'L\' dubmidx2 dubmidy2 ] )\n    (path \'none\' \'red\' linwd\n      [ \'M\' cux1 cuy1\n        \'C\' cux2 cuy2\n            cux3 cuy3\n            cux4 cuy4 ] )\n    (ptcirc px py)            ] ) ) ) )\n\n(def quCurve\n  (let [midx1 midy1 midx2 midy2 midx3 midy3 midx4 midy4]\n       [(linbez t qux1 qux2) (linbez t quy1 quy2)\n        (linbez t qux2 qux3) (linbez t quy2 quy3)\n        (linbez t qux3 qux4) (linbez t quy3 quy4)\n        (linbez t qux4 qux5) (linbez t quy4 quy5)]\n  (let [dubmidx1 dubmidy1 dubmidx2 dubmidy2 dubmidx3 dubmidy3]\n       [(linbez t midx1 midx2) (linbez t midy1 midy2)\n        (linbez t midx2 midx3) (linbez t midy2 midy3)\n        (linbez t midx3 midx4) (linbez t midy3 midy4)]\n  (let [trimidx1 trimidy1 trimidx2 trimidy2]\n       [(linbez t dubmidx1 dubmidx2) (linbez dubmidy1 dubmidy2)\n        (linbez t dubmidx2 dubmidx3) (linbez dubmidy2 dubmidy3)]\n  (let [px py] [(quarbez t qux1 qux2 qux3 qux4 qux5) (quarbez t quy1 quy2 quy3 quy4 quy5)]\n  [ (path \'none\' col1 linwd\n      [ \'M\' qux1 quy1\n        \'L\' qux2 quy2 ] )\n    (path \'none\' col1 linwd\n      [ \'M\' qux2 quy2\n        \'L\' qux3 quy3 ] )\n    (path \'none\' col1 linwd\n      [ \'M\' qux3 quy3\n        \'L\' qux4 quy4 ] )\n    (path \'none\' col1 linwd\n      [ \'M\' qux4 quy4\n        \'L\' qux5 quy5 ] )\n    (path \'none\' col2 linwd\n      [ \'M\' midx1 midy1\n        \'L\' midx2 midy2 ] )\n    (path \'none\' col2 linwd\n      [ \'M\' midx2 midy2\n        \'L\' midx3 midy3 ] )\n    (path \'none\' col2 linwd\n      [ \'M\' midx3 midy3\n        \'L\' midx4 midy4 ] )\n    (path \'none\' col3 linwd\n      [ \'M\' dubmidx1 dubmidy1\n        \'L\' dubmidx2 dubmidy2 ] )\n    (path \'none\' col3 linwd\n      [ \'M\' dubmidx2 dubmidy2\n        \'L\' dubmidx3 dubmidy3 ] )\n    (path \'none\' col4 linwd\n      [ \'M\' trimidx1 trimidy1\n        \'L\' trimidx2 trimidy2 ] )\n    (ptcirc px py)            ] ) ) ) ) )\n;\n; Putting it all together\n;\n(svg (concat [linCurve quadCurve cuCurve tslider]))\n";
   var poppl = "; Logo for POP-PL\n; see https://github.com/florence/pop-pl\n\n(def M \'M\')\n(def L \'L\')\n(def C \'C\')\n(def Z \'Z\')\n\n(def ltopWidth 29!)\n(def ltopHeight 63!)\n(def xstart 131!)\n(def ystart 63!)\n(def stethx 31!)\n(def stethy 7!)\n(def cr2Control -0.1769993052254364)\n(def cr2x (* cr2Control ltopWidth))\n(def cr2y (* cr2Control ltopHeight))\n(def lpath\n  [M (- xstart stethx) (- ystart stethy)\n   C (+ xstart -12) (+ ystart -19)\n     (+ cr2x xstart) (+ cr2y ystart)\n     xstart ystart\n   L (+ xstart ltopWidth) (+ ystart ltopHeight)\n   ])\n\n(def axstart  (+ xstart ltopWidth))\n(def aystart (+ ystart ltopHeight))\n(def ascale 1.9534135150166867!)\n(def ax (* ascale ltopWidth))\n(def ay (* ascale ltopHeight))\n(def bx 18!)\n(def armpath\n  [M axstart aystart\n   C (+ xstart 71) (+ ystart 94)\n     (+ xstart 90) (+ ystart 142)\n     (+ axstart ax) (+ aystart ay)\n   C (+ xstart 63) (+ ystart 190)\n     (+ xstart 74) (+ ystart 188)\n     (- (+ axstart ax) bx) (+ aystart ay)])\n\n(def lwidth 5)\n\n\n(def nub\n  (circle \'black\' (- (+ axstart ax) bx) (+ aystart ay) (* lwidth 2!)))\n\n(def small (* lwidth 2.1))\n(def scope1\n  (circle \'black\' (- xstart stethx) (- ystart stethy) (+ small lwidth)))\n(def scope2\n  (circle \'white\' (- xstart stethx) (- ystart stethy) small))\n\n[\'svg\'\n [[\'viewBox\' \'0 0 300 300\']]\n [(square \'white\' 0! 0! 300!)\n      (path \'none\' \'black\' lwidth lpath)\n      (path \'none\' \'black\' lwidth armpath)\n      nub\n      (addAttr (path \'white\' \'black\' lwidth armpath)\n               [\'transform\' (+ (+ \'matrix(-1 0 0 1 \' (toString (* 2 axstart)))\n                               \' 0)\')])\n      (addAttr nub\n               [\'transform\' (+ (+ \'matrix(-1 0 0 1 \' (toString (* 2 axstart)))\n                               \' 0)\')])\n      scope1\n      scope2\n]]\n\n";
   var cover = "; Logo for Cover\n; see https://github.com/florence/cover\n\n(def size 300!)\n(def line 10!)\n(def h (/ size 2.6548672566371683))\n(def w (- (* 2! h) (* 2! line)))\n\n(def m (/ size 2!))\n\n(def x (- m (/ w 2!)))\n(def y (- m (+ (/ line 2!) (/ w 2!))))\n\n(def x2 (- x (+ w line)))\n(def y2 (- x (+ w (* 2.5! line))))\n\n(def x3 (+ x (+ w line)))\n(def y3 (+ x (+ w (* 1.5! line))))\n\n(def top (\\(x y)\n (rect \'red\' x y w (- h line))))\n\n(def sw (- h (* 1.5! line)))\n\n(def bottom (\\(x y)\n  (rect \'blue\' x (+ y h) sw (- h line))))\n\n(def bottoma (\\(x y) (bottom x y)))\n(def bottomb (\\(x y) (bottom (+ sw (+ x line)) y)))\n\n(def rot 45)\n\n[\'svg\'\n [[\'viewBox\' (+ (+ (+ \'0 0 \' (toString size)) \' \') (toString size))]]\n [\n  (square \'white\' 0! 0! size)\n\n  (rotate (top x y)   rot m m)\n  (rotate (bottoma x y) rot m m)\n  (rotate (bottomb x y) rot m m)\n\n  (rotate (top x2 y)   rot m m)\n  (rotate (bottoma x2 y) rot m m)\n  (rotate (bottomb x2 y) rot m m)\n\n  (rotate (top x y2)   rot m m)\n  (rotate (bottoma x y2) rot m m)\n  (rotate (bottomb x y2) rot m m)\n\n  (rotate (top x3 y)   rot m m)\n  (rotate (bottoma x3 y) rot m m)\n  (rotate (bottomb x3 y) rot m m)\n\n  (rotate (top x y3)   rot m m)\n  (rotate (bottoma x y3) rot m m)\n  (rotate (bottomb x y3) rot m m)\n]]\n\n";
   var dictionaries = "(def d (empty))\n(def d1 (insert \'a\' 3 d))\n(def d2 (insert \'b\' 4 d1))\n(def d3 (remove \'a\' d2))\n\n(def getWithDefault (\\(key default dict)\n  (let value (get key dict)\n  (typecase value\n    (Null default)\n    (_ value)))\n))\n\n(blobs [\n    [(text 50 30  (toString d2))]\n    [(text 50 50  (toString d3))]\n    [(text 50 70  (toString (get \'b\' d3)))]\n    [(text 50 90  (toString (get \'a\' d3)))]\n    [(text 50 110 (toString (getWithDefault \'a\' \'default\' d3)))]\n])\n\n";
   var thawFreeze = "\n# unannotated-numbers: n!\n\n; Set [unannotated-numbers] to [n?] or [n!] to declare that\n; unannotated literals be thawed or frozen, respectively.\n;\n; By default, this option is set to [n?].\n\n(svg [(rect \'maroon\' 100? 15 200! 50)])\n\n";
   var barGraph = "; A Bar Graph\n;\n; Try:\n;   - Manipulating the height of the bars\n;   - Manipulating the spacing between the bars\n;   - Changing the X Offset with the bottom slider\n;   - Adding and removing data points\n;   - Changing the captions\n;\n; When you\'re done editing, change the doneEditing variable to true to\n; get an SVG that\'s ready to be embedded in a web page!\n(def doneEditing false)\n\n; Each data point specifies a single bar as [XValue YValue]\n(def data [[1! 5!] [2! 1!] [3! 3!] [4! 2!] [5! 4!] [7! 3!]])\n\n; Relevant variables\n(def [title xcaption ycaption] [\'Bar Graph\' \'X Axis\' \'Y Axis\'])\n(def [totht totwd barspacing numy] [250! 450! 60 5])\n(def [barwd axiswd] [50 4])\n(def [barcol axiscol] [\'lightblue\' \'gray\'])\n\n(def [xbegin windowslider] (hSlider true 100! 500! 500! 0! 10! \'X Offset: \' 0))\n\n; If you would like to specify the X Offset without the slider, uncomment\n; the below line and set it appropriately.\n;(def xbegin 0)\n\n(def [lowerx upperx] [xbegin (+ xbegin (/ totwd barspacing))])\n(def [x0 y0] [100! 100!])\n\n(def [textht textwd] [18! 4!])\n\n(def bar (\\[val freq] (if (< val upperx) (if (< lowerx val)\n                [(rect barcol (+ x0 (- (* barspacing (- val xbegin)) (* 0.5! barwd)))\n                                    (+ y0 (- totht (* freq (/ totht numy))))\n                                    barwd\n                                    (* freq (/ totht numy)) )] []) []) ) )\n\n(def xaxis (line axiscol axiswd (- x0 (* 0.5! axiswd))\n                                (+ y0 totht)\n                                (+ x0 totwd)\n                                (+ y0 totht) ) )\n\n(def yaxis (line axiscol axiswd x0 (- y0 (* 0.5! (/ totht numy)))\n                                x0 (+ y0 totht) ) )\n\n(def labelx (\\val (text (+ x0 (- (* barspacing (- val xbegin)) textwd))\n                        (+ y0 (+ (* 1.5! textht) totht))\n                        (toString val) ) ) )\n\n(def labely (\\freq (text (- x0 20!)\n                         (+ y0 (+ (* 0.5! textht) (- totht (* freq (/ totht numy)))))\n                         (toString freq) ) ) )\n\n(def titlelabel (text (+ x0 (/ totwd 2!))\n                      (- y0 (/ totht numy))\n                      title) )\n\n(def xlabel (text (+ x0 (/ totwd 2!))\n                  (+ y0 (+ (* 3! textht) totht))\n                  xcaption) )\n(def ylabel (text (- x0 80!) (+ y0 (/ totht 2!)) ycaption) )\n\n(def xs (range lowerx (- upperx 1!)))\n(def ys (range 0! numy))\n\n(def bars (concat (map bar data)))\n(def axes [xaxis yaxis])\n(def xlabels (map labelx xs))\n(def ylabels (map labely ys))\n(def names [titlelabel xlabel ylabel])\n\n(if doneEditing (svgViewBox (+ (* 2! x0) totwd) (+ y0 (+ (* 3! textht) totht)) (concat [bars axes xlabels ylabels names]))\n                (svg (concat [bars axes xlabels ylabels names windowslider])) )\n";
   var interfaceButtons = "(def [w h depth shadow r] [120 22.5 4 0.5 2])\n(def shadowcol [180 180 180 1])\n\n(def draw (\\(topcolor botcolor offset)\n\n  (let tbbox  (rect topcolor r offset (- w (* 2! r)) h)\n  (let lrbox  (rect topcolor 0! (+ r offset) w (- h (* 2! r)))\n  (let tlcirc (circle topcolor r (+ r offset) r)\n  (let trcirc (circle topcolor (- w r) (+ r offset) r)\n  (let blcirc (circle topcolor r (+ (- h r) offset) r)\n  (let brcirc (circle topcolor (- w r) (+ (- h r) offset) r)\n\n  (let btbbox  (rect botcolor r (- h r) (- w (* 2! r)) depth)\n  (let blrbox  (rect botcolor 0! (- h r) w (- depth r))\n  (let belcirc (circle botcolor r (- (+ h depth) (* 2! r)) r)\n  (let bercirc (circle botcolor (- w r) (- (+ h depth) (* 2! r)) r)\n\n  (let stbbox  (rect shadowcol r (+ shadow (- h r)) (- w (* 2! r)) depth)\n  (let slrbox  (rect shadowcol 0! (+ shadow (- h r)) w (- depth r))\n  (let selcirc (circle shadowcol r (+ shadow (- (+ h depth) (* 2! r))) r)\n  (let sercirc (circle shadowcol (- w r) (+ shadow (- (+ h depth) (* 2! r))) r)\n\n  (let btop    [tbbox lrbox tlcirc trcirc blcirc brcirc]\n  (let bbot    [btbbox blrbox belcirc bercirc]\n  (let bshadow (if (= offset 0) [stbbox slrbox selcirc sercirc] [])\n\n    ; NOTE: not calling (addAttr ... [\'preserveAspectRatio\' \'none\'])\n    (svgViewBox 120\n      (+ depth (+ shadow (- h r)))\n      (concat [bshadow bbot btop]))\n\n)))))))))))))))))))\n\n(def hilitedBot [198 77 64 1])\n\n(def raisedButton      (draw [231 76 60 1] [192 57 43 1] 0))\n(def highlightedButton (draw [233 94 80 1] hilitedBot 0))\n(def depressedButton   (draw [233 94 80 1] hilitedBot 1.1))\n(def disabledButton    (draw [236 112 99 1] [205 97 85 1] 0))\n\n(def raisedButton2      raisedButton)\n(def highlightedButton2 highlightedButton)\n(def depressedButton2   depressedButton)\n(def disabledButton2    disabledButton)\n\n(def raisedButton3      (draw \'gray\' hilitedBot 0))\n(def highlightedButton3 (draw \'lightgray\' hilitedBot 0))\n(def depressedButton3   (draw \'lightgray\' hilitedBot 1.1))\n(def disabledButton3    (draw 470 360 0))\n\n(def kind 1{1-3})\n(def state 1{1-4})\n\n(if (= kind 1)\n  (if (= state 1) raisedButton\n  (if (= state 2) highlightedButton\n  (if (= state 3) depressedButton\n    disabledButton)))\n(if (= kind 2)\n  (if (= state 1) raisedButton2\n  (if (= state 2) highlightedButton2\n  (if (= state 3) depressedButton2\n    disabledButton2)))\n; else\n  (if (= state 1) raisedButton3\n  (if (= state 2) highlightedButton3\n  (if (= state 3) depressedButton3\n    disabledButton3)))\n))\n\n";
   var rotTest = "\n(def [x y w h] [257 54 152 261])\n(def rot 38.166250526006905)\n(def colorNum 100)\n\n(def [x_ y_] [(+ x (/ w 2)) (+ y (/ h 2))])\n\n; thin wrapper v1\n(def transform\n  (spaces\n     [\'translate\' (parens (spaces [(toString x_) (toString y_)]))\n      \'rotate\'    (parens (toString rot))\n      \'translate\' (parens (spaces [(toString (neg x_)) (toString (neg y_))]))\n   ]))\n\n; thin wrapper v2\n(def transform2\n  (+ \'rotate\' (parens (spaces [(toString rot) (toString x_) (toString y_)]))))\n\n; specific transform encoding\n(def transform3 [[\'rotate\' rot x_ y_]])\n\n(def r (rotate (rect colorNum x y w h) rot x_ y_))\n\n(def e (rotate (ellipse 240 x_ y_ 10 20) -10 x_ y_))\n\n(svg [r e])\n\n";
   var matrices = "; Definitions for 2D matrices and transform application\n;\n; Similar to the SVG transform operation\n; See https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform\n;\n(def [theta tx ty m s] [(/ 3.14159! 4) 75 75 1.25 2])\n(defrec rmult_ (\\(r v) (case [r v]\n  ([ [] x ] 0)\n  ([ x [] ] 0)\n  ([ [a | aa] [b | bb] ] (+ (* a b) (rmult_ aa bb))))))\n(defrec mmult (\\(m v) (case m\n  ([] [])\n  ([r|rest] (if (= (len r) (len v)) (cons (rmult_ r v) (mmult rest v)) [])))))\n(defrec toPts (\\l (case l\n  ([] [])\n  ([ [x y k] | rest ] (cons [x y] (toPts rest))))))\n(defrec toPath_ (\\l (case l\n  ([] [])\n  ([ [x y] | rest ] (append [ \'L\' x y ] (toPath_ rest))))))\n(def toPath (\\l (case l\n  ([] [])\n  ([ [x1 y1] | rest ] (path \'lightblue\' \'gray\' 1 (append [ \'M\' x1 y1 | (toPath_ rest)] [\'Z\']))))))\n(def id [ [1! 0! 0!] [0! 1! 0!] [0! 0! 1!] ])\n(def translatert (map (mmult [ [1! 0! tx] [0! 1! 0!] [0! 0! 1!]])))\n(def translatedn (map (mmult [ [1! 0! 0!] [0! 1! ty] [0! 0! 1!]])))\n(def rotate (map (mmult [ [(cos theta) (* -1! (sin theta)) 0!] [(sin theta) (cos theta) 0!] [0! 0! 1!]])))\n(def shear (map (mmult [ [1! m 0!] [0! 1! 0!] [0! 0! 1!]])))\n(def scale (map (mmult [ [s 0! 0!] [0! s 0!] [0! 0! 1!] ])))\n(def ps [ [-25! -25! 1!] [-25! 25! 1!] [25! 25! 1!] [25! -25! 1!] ])\n(def square1 (toPath (toPts (translatedn (translatert ps)))))\n(def square2 (toPath (toPts (translatedn (translatert (translatert ps))))))\n(def rotsquare (toPath (toPts (translatert (translatert (translatert (translatedn (rotate ps))))))))\n(def shearsquare (toPath (toPts (translatert (translatert (translatert (translatert (translatedn (shear ps)))))))))\n(def scalesquare (toPath (toPts (translatert (translatert (translatert (translatert (translatert (translatert (translatedn (scale ps)))))))))))\n(svg [square1 square2 rotsquare shearsquare scalesquare])\n";
   var haskell = "; Haskell.org Logo\n; SVG version of https://www.haskell.org/static/img/logo.png?etag=rJR84DMh\n;\n; Try making a slider for the bend amount to adjust that parameter indirectly.\n;\n(def [wedgeWidth lambdaWidth equalsWidth] [120 120 90])\n(def [wedgePos lambdaPos equalsPos] [0! 170 440])\n(def [totalHeight totalWidth] [512! 752!])\n(def bend (/ 3.14159! 5.3))\n(def equalsSep 40)\n(def [wedgeColor lambdaColor equalsColor] \n        [[69 58 98 100]\n         [97 82 138 100]\n         [143 78 139 100]])\n(def tan (\\theta (/ (sin theta) (cos theta))))\n(def leftWedge (path wedgeColor \'black\' 0\n    [ \'M\' wedgePos 0!\n      \'L\' (+ wedgePos (* (/ totalHeight 2!) (tan bend))) (/ totalHeight 2!)\n      \'L\' wedgePos totalHeight\n      \'L\' (+ wedgePos wedgeWidth) totalHeight\n      \'L\' (+ wedgePos (+ wedgeWidth (* (/ totalHeight 2!) (tan bend))))\n          (/ totalHeight 2!)\n      \'L\' (+ wedgeWidth wedgePos) 0!\n      \'Z\']))\n(def lambda (path lambdaColor \'black\' 0\n    [ \'M\' lambdaPos \n          0!\n      \'L\' (+ lambdaPos (* (/ totalHeight 2!) (tan bend))) \n          (/ totalHeight 2!)\n      \'L\' lambdaPos \n          totalHeight\n      \'L\' (+ lambdaPos lambdaWidth) \n          totalHeight\n      \'L\' (+ (+ lambdaPos (* (/ totalHeight 2!) (tan bend))) (/ lambdaWidth 2!)) \n          (+ (/ totalHeight 2!) (/ lambdaWidth (* 2! (tan bend))))\n      \'L\' (+ lambdaPos (* totalHeight (tan bend)))\n          totalHeight\n      \'L\' (+ lambdaPos (+ lambdaWidth (* totalHeight (tan bend))))\n          totalHeight\n      \'L\' (+ lambdaPos lambdaWidth)\n          0!\n      \'Z\']))\n(def equals \n  [ (path equalsColor \'black\' 0\n      [ \'M\' equalsPos\n            (- (- (/ totalHeight 2!) (* equalsSep 0.25!)) (* equalsWidth (cos bend)))\n        \'L\' totalWidth\n            (- (- (/ totalHeight 2!) (* equalsSep 0.25!)) (* equalsWidth (cos bend)))\n        \'L\' totalWidth\n            (- (/ totalHeight 2!) (* equalsSep 0.25!))\n        \'L\' (+ equalsPos (* equalsWidth (sin bend)))\n            (- (/ totalHeight 2!) (* equalsSep 0.25!))\n        \'Z\'])\n    (path equalsColor \'black\' 0\n      [ \'M\' (+ equalsPos (+ (* equalsWidth (sin bend)) (* equalsSep (tan bend))))\n            (+ (/ totalHeight 2!) (* equalsSep 0.75!))\n        \'L\' totalWidth\n            (+ (/ totalHeight 2!) (* equalsSep 0.75!))\n        \'L\' totalWidth\n            (+ (+ (/ totalHeight 2!) (* equalsSep 0.75!)) (* equalsWidth (cos bend)))\n        \'L\' (+ equalsPos (+ (* 2! (* equalsWidth (sin bend))) (* equalsSep (tan bend))))\n            (+ (+ (/ totalHeight 2!) (* equalsSep 0.75!)) (* equalsWidth (cos bend)))\n        \'Z\'])])\n(svg (append [leftWedge lambda] equals))\n";
   var wikimedia = "; Wikimedia Logo\n; Recreation of https://upload.wikimedia.org/wikipedia/commons/8/81/Wikimedia-logo.svg\n \n; The white objects are an example of using masks as opposed to paths to create\n; more complicated forms, such as the green \'wings\' and broken ring of this logo.\n \n(def [greenr innerBluer outerBluer] [110! 134! 180!])\n(def [wedgeTheta barWidth barHeight] [(/ 3.14159! 4!) 32 150])\n(def [dotRed wingGreen ringBlue] [\'#900\' \'#396\' \'#069\'])\n(def [centerx centery] [256! 256!])\n(def greenCirc (circle wingGreen centerx centery greenr))\n(def whiteRing (circle \'white\' centerx centery innerBluer))\n(def blueCirc (circle ringBlue centerx centery outerBluer))\n(def rightPtx (+ centerx (* outerBluer (sin wedgeTheta))))\n(def leftPtx (- centery (* outerBluer (sin wedgeTheta))))\n(def pty (- (- centery 16) (* outerBluer (cos wedgeTheta))))\n(def whiteWedge \n    (path \'white\' \'black\' 0 \n        [ \'M\' centerx (- centery 16)\n          \'L\' rightPtx pty\n          \'A\' outerBluer outerBluer 0 0 0 leftPtx pty\n          \'Z\']))\n(def whiteBar (rect \'white\' (- centerx (/ barWidth 2!)) (- centery 32!) barWidth barHeight))\n(def redDot (circle \'#900\' centerx 128! 64!))\n\n(svg [blueCirc whiteRing greenCirc whiteWedge whiteBar redDot])\n\n";
   var eyeIcon = "; An eye icon\n; Recreation of https://commons.wikimedia.org/wiki/Category:SVG_eye_icons#/media/File:Eye_open_font_awesome.svg\n;\n; Try unfreezing:\n;   glintr, and manipulating the glint control points\n;   cornear, and manipulating the cornea radius\n;   glintWidth, and manipulating the glint control points\n;   Any of the outer/inner parameters, and seeing what happens!\n;\n(def [outerStartx outerStarty innerStartx innerStarty] [16! 240! 50 256!])\n(def [outerWidth innerWidth outerHeight innerHeight sharpness] [480 412 -60 0 16])\n(def [corneax corneay cornear glintr glintWidth] [256! 216! 120! 50! 24])\n(def midline 256!)\n(def outerBorder\n  (path\n    \'black\'\n    \'black\'\n    0\n    [\'M\' outerStartx outerStarty\n     \'Q\' midline outerHeight (+ outerStartx outerWidth) outerStarty\n     \'Q\' (+ (+ outerStartx outerWidth) sharpness) 256! (+ outerStartx outerWidth) (+ outerStarty 32!)\n     \'Q\' midline (- 512! outerHeight) outerStartx (+ outerStarty 32!)\n     \'Q\' (- outerStartx sharpness) 256! outerStartx outerStarty\n     \'Z\']))\n(def innerBorder\n  (path\n    \'white\'\n    \'black\'\n    0\n    [\'M\' innerStartx innerStarty\n     \'Q\' midline innerHeight (+ innerStartx innerWidth) innerStarty\n     \'Q\' midline (- 512! innerHeight) innerStartx innerStarty\n     \'Z\']))\n(def cornea (circle \'black\' corneax corneay cornear))\n(def glint\n  (path\n    \'white\'\n    \'black\'\n    0\n    [\'M\' corneax (- corneay (+ glintr glintWidth))\n     \'A\' (/ glintWidth 2!) (/ glintWidth 2!) 0 0 1 corneax (- corneay glintr)\n     \'A\' glintr glintr 0 0 0 (- corneax glintr) corneay\n     \'A\' (/ glintWidth 2!) (/ glintWidth 2!) 0 0 1 (- corneax (+ glintr glintWidth)) corneay\n     \'A\' (+ glintr glintWidth) (+ glintr glintWidth) 0 0 1 corneax (- corneay (+ glintr glintWidth))\n     \'Z\']))\n(svg  [outerBorder innerBorder cornea glint])\n\n";
   var sailBoat = "; A sail boat on the ocean\n;\n; Try mainupulating:\n;   - The position of the boat by dragging the sail\n;   - The height of the waves by moving the path control points with zones on\n;   - The frequency of the waves\n;   - The sea level\n\n(def [sealevel amplitude period boatpos] [300 40 200 400])\n(def [oceancolor backgroundcolor] [[28 107 160 50] [135 206 250 100]])\n\n(def wave (\\([sx sy] [ex ey] amplitude)\n            [ (path oceancolor \'black\' 0 \n                [ \'M\' sx sy \n                  \'Q\' (+ sx (/ period 4!)) (- sy amplitude) \n                  (+ sx (/ period 2!)) sy\n                  \'Z\'])\n              (path backgroundcolor \'black\' 0\n                  [ \'M\' (+ sx (/ period 2!)) sy\n                    \'Q\' (+ sx (* period 0.75!)) (+ sy amplitude)\n                    ex ey \n                    \'Z\' ])]))\n\n(def nodes\n  (map2 (\\(a b) [(* a period) b])\n        (range 0! (round (/ 3000 period)))\n        (repeat (round (/ 4000 period)) sealevel)))\n\n(defrec mkwaves \n  (\\l (case l \n    ([] [])\n    ([x] [])\n    ([a b | rest] (append (wave a b amplitude) (mkwaves [ b | rest ]))))))\n\n(def backdrop (rect backgroundcolor -400! -400! 2400! 2400!))\n(def sun (circle \'yellow\' 50 0 70))\n(def deepwater (rect oceancolor -400! sealevel 2400! 4000!))\n(def quadraticbezier (\\(s c e t) (+ (+ \n    (* (* (- 1 t) (- 1 t)) s) \n    (* (* (* 2 (- 1 t)) t) c)) \n    (* (* t t) e))))\n\n(defrec mod (\\(x m) (if (< x m) x (mod (- x m) m))))\n(def tphase (/ (mod boatpos (/ period 2)) (/ period 2)))\n(def pickdir (\\(sl amp) (if \n    (< (mod boatpos period) (/ period 2))\n      (- sl amp) \n      (+ sl amp))))\n\n(def boat\n  (let boaty (quadraticbezier sealevel (pickdir sealevel amplitude) sealevel tphase)\n  (let hull (path \'saddlebrown\' \'black\' 0\n    [ \'M\' (- boatpos 30) (- boaty 10)\n      \'C\' (- boatpos 30) (+ boaty 15)\n      (+ boatpos 30) (+ boaty 15)\n      (+ boatpos 30) (- boaty 10)\n      \'Z\'])\n  (let mast (rect \'saddlebrown\' (+ boatpos 10) (- boaty 60) 5 50)\n  (let sail (rect \'beige\' (- boatpos 15!) (- boaty 50!) 50 30)\n  [mast hull sail])))))\n\n(svg \n  (concat [\n    [ backdrop sun deepwater ]\n    (mkwaves nodes)\n    boat]))\n\n";
   var paths5 = "; Adapted from:\n; https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n;\n(svg [\n  (path \'green\' \'black\' 2\n    [\'M\' 80 80 \'A\' 45 45 0 0 0 125 125 \'L\' 125 80 \'Z\'])\n  (path \'red\' \'black\' 2\n    [\'M\' 230 80 \'A\' 45 45 0 1 0 275 125 \'L\' 275 80 \'Z\'])\n  (path \'purple\' \'black\' 2\n    [\'M\' 80 230 \'A\' 45 45 0 0 1 125 275 \'L\' 125 230 \'Z\'])\n  (path \'blue\' \'black\' 2\n    [\'M\' 230 230 \'A\' 45 45 0 1 1 275 275 \'L\' 275 230 \'Z\'])\n])\n\n";
   var paths4 = "; Adapted from:\n; https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n;\n(svg [\n  (addAttr\n    (path \'green\' \'black\' 2\n      [\'M\' 10 315\n       \'L\' 110 215\n       \'A\' 30 50 0 0 1 162.55 162.45\n       \'L\' 172.55 152.45\n       \'A\' 30 50 -45 0 1 215.1 109.9\n       \'L\' 315 10])\n    [\'opacity\' 0.5])\n])\n\n";
   var paths3 = "(svg [\n  (path_ [\'M\' 10 80 \'C\' 40 10 65 10 95 80 \'S\' 150 150 180 80])\n  (path_ [\'M\' 10 80 \'Q\' 95 10 180 80])\n  (path_ [\'M\' 10 80 \'Q\' 52.5 10 95 80 \'T\' 180 80])\n])\n\n";
   var paths2 = "; Adapted from:\n; https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n;\n; Turn on the zones to see the Bezier control points.\n; Try replacing \"svg\" with \"svgViewBox 200 200\".\n;\n(svg [\n  (path_ [\'M\' 10 10   \'C\' 20 20 40 20 50 10])\n  (path_ [\'M\' 70 10   \'C\' 70 20 120 20 120 10])\n  (path_ [\'M\' 130 10  \'C\' 120 20 180 20 170 10])\n  (path_ [\'M\' 10 60   \'C\' 20 80 40 80 50 60])\n  (path_ [\'M\' 70 60   \'C\' 70 80 110 80 110 60])\n  (path_ [\'M\' 130 60  \'C\' 120 80 180 80 170 60])\n  (path_ [\'M\' 10 110  \'C\' 20 140 40 140 50 110])\n  (path_ [\'M\' 70 110  \'C\' 70 140 110 140 110 110])\n  (path_ [\'M\' 130 110 \'C\' 120 140 180 140 170 110])\n])\n\n";
   var paths1 = "(svg [\n  (path_ [\'M\' 10 10 \'H\' 90 \'V\' 90 \'H\' 10 \'L\' 10 10 \'Z\'])\n  (path_ [\'M\' 20 20 \'L\' 60 20 \'L\' 60 80 \'Z\'])\n  (path_ [\'M\' 150 0 \'L\' 75 200 \'L\' 225 200 \'Z\'])\n])\n\n";
   var miscShapes = "(let [x y] [200 150] (svg [\n  (rect \'#999999\'  50 10 80 130)\n  (circle \'lightblue\' 300 100 50)\n  (ellipse \'orange\' 40 280 30 50)\n  (polygon \'lightgreen\' \'black\' 5 [[110 110] [300 110] [x y]])\n  (polygon \'lightgreen\' \'black\' 5 [[110 210] [300 210] [x y]])\n  (line \'blue\' 4 10 20 300 40)\n]))\n\n";
   var clique = ";\n; A six node clique\n;\n(let node (\\[x y] (circle \'lightblue\' x y 20))\n(let edge (\\[[x y] [i j]] (line \'lightgreen\' 5 x y i j))\n(letrec genpairs\n   (\\xs\n     (case xs\n       ([x y | xx] [[x y] | (append (genpairs (cons x xx)) (genpairs (cons y xx)))])\n       ([x] [])\n       ([] [])))\n(let pts [[200 50] [400 50] [100 223] [200 389] [400 391] [500 223]]\n(let nodes (map node pts)\n(let pairs (genpairs  pts)\n(let edges (map edge pairs)\n  (svg (append edges nodes)))))))))\n\n";
   var cultOfLambda = ";\n; Cult of Lambda\n;\n; Some fun \n;\n(let [x0 y0 w h] [0 0 500 500]\n(let wstripe (/ w 6!)\n(let xoff (+ x0 wstripe)\n(let yoff (+ y0 (/ h 4!))\n(let minrad\n  (if (< (/ wstripe 7.5!) (/ h 30!))\n    (/ wstripe 7.5!)\n    (/ h 15!))\n(let min\n  (if (< w h)\n    (* 0.4! w)\n    (* 0.4! h))\n(let rotate (\\a (/ (* (+ 1! a) (pi)) 4!))\n(let figure \n  (\\(x y) \n    (let [x1 x2 x3] (map (\\n (+ x (* wstripe n))) [1.2! 1.5! 1.8!])\n    (let [y1 y2 y3 y4] (map (\\n (+ y (/ (/ h 2!) n))) [4.3! 2.8! 1.9! 1.4!])\n    (let figline (\\[[a b] [c d]] (line \'orange\' (/ minrad 2!) a b c d))\n      (snoc\n        (ellipse \'orange\' x2 y1 (/ wstripe 7.5!) (/ h 30!))\n        (map\n          figline\n            [[[x1 y1] [x1 y2]]\n            [[x1 y2] [x3 y2]]\n            [[x3 y1] [x3 y2]]\n            [[x1 y4] [x1 y3]]\n            [[x1 y3] [x3 y3]]\n            [[x3 y3] [x3 y4]]\n            [[x2 y1] [x2 y3]]]))))))\n(let logo\n  (\\(x y)\n    (let [xl yl wl hl delta] [x y w h 27.5]\n    (let [xw yh w2 h2] [(+ xl wl) (+ yl hl) (div wl 2) (div hl 2)]\n    (let poly (\\pts (polygon \'black\' \'none\' 0 pts))\n      [\n      (rect \'white\' xl yl wl hl)\n      (poly\n        [[(+ xl delta) yl]\n         [xw yl]\n         [xw (- yh delta)]])\n      (poly\n        [[xl (+ yl delta)]\n         [xl (- yh delta)]\n         [(- (+ xl w2) delta) (+ yl h2)]])\n      (poly\n        [[(+ xl delta) yh]\n         [(- xw delta) yh]\n         [(+ xl w2) (+ (+ yl h2) delta)]])\n    ]))))\n;\n  (svg\n    (append\n      (logo (+ x0 80!) (+ y0 36!))\n      (concatMap \n        (\\i \n          (figure \n            (+ (* 0.41! w) (+ x0 (* min (cos (rotate i)))))\n            (+ (* 0.38! h) (+ y0 (* min (sin (rotate i)))))))\n        (range 0! 7!)))))))))))))\n\n";
   var stickFigures = ";\n; A diagram of a sketch-n-sketch demo w/ audience\n;\n(let [x0 y0 w h] [60 -22 417! 915!]\n(let wstripe (/ w 6!)\n(let xoff (+ x0 wstripe)\n(let yoff (+ y0 (/ h 4!))\n(let minrad (if (< (/ wstripe 7.5!) (/ h 30!)) (/ wstripe 7.5!) (/ h 15!))\n(let min (if (< w h) (* 0.6! w) (* 0.6! h))\n(let figure\n  (\\(x y)\n    (let [x1 x2 x3] (map (\\n (+ x (* wstripe n))) [1.2! 1.5! 1.8!])\n    (let [y1 yh y2 y3 y4] (map (\\n (+ y (/ (/ h 2!) n))) [4.3! 2.2! 2.8! 1.9! 1.4!])\n    (let figline (\\[[a b] [c d]] (line \'black\' (/ minrad 2!) a b c d))\n      (snoc\n        (circle \'black\' x2 y1 (/ wstripe 3.75!))\n        (map\n          figline\n          [[[x1 yh] [x1 y2]]\n           [[x1 y2] [x3 y2]]\n           [[x3 yh] [x3 y2]]\n           [[x1 y4] [x1 y3]]\n           [[x1 y3] [x3 y3]]\n           [[x3 y3] [x3 y4]]\n           [[x2 y1] [x2 y3]]]))))))\n(let logo\n  (\\(x y)\n    (let [xl yl wl hl delta] [x y 90 90 6.5]\n    (let [xw yh w2 h2] [(+ xl wl) (+ yl hl) (div wl 2) (div hl 2)]\n    (let poly (\\pts (polygon \'black\' \'none\' 0 pts))\n      [(rect \'white\' xl yl wl hl)\n       (poly  [[(+ xl delta) yl] [xw yl] [xw (- yh delta)]])\n       (poly  [[xl (+ yl delta)] [xl (- yh delta)] [(- (+ xl w2) delta) (+ yl h2)]])\n       (poly  [[(+ xl delta) yh] [(- xw delta) yh] [(+ xl w2) (+ (+ yl h2) delta)]])]))))\n  ;\n  (let textBoxes\n    [ (addAttr (text 160 160 \'Laptop on Table\') [\'font-size\' 40])\n      (addAttr (text 30 600 \'Demonstrators\') [\'font-size\' 40])\n      (addAttr (text 550 660 \'Audience\') [\'font-size\' 40])\n    ]\n  ;\n  (svg (append textBoxes\n    (append\n      [(polygon\n        \'#CD7F32\'\n        \'none\'\n        0\n        [[508 511]\n         [497 347]\n         [200 354]\n         [188 512]\n         [171 334]\n         [133 287]\n         [133 435]\n         [110 257]\n         [443 250]\n         [520 324]])\n       (polygon \'none\' \'black\' 4 [[106 256] [445 251] [524 325] [183 334]])\n       (rect \'gray\' 230! 184! 103 102)\n       (polygon \'gray\' \'black\' 2 [[250 295] [357 294] [393 312] [282 312]])]\n      (append\n        (logo 238 190)\n        (concatMap\n          (\\[x y] (figure (+ x0 x) (+ y0 y)))\n          [[-24 245] [-96 140] [325 321] [405 184] [474 298]]))))))))))))))\n\n";
   var hilbertCurveAnimation = "; How to draw a Hilbert curve.\n;\n; https://thoughtstreams.io/jtauber/on-drawing-owls-and-teaching-non-beginners/\n; 1. Draw a U.\n; 2. Draw the rest of the curve.\n;\n\n; What fraction of the final curve should we draw?\n; Time 0 to 0.5: none. Draw curve from time 0.5 to 1.\n(def curveFractionToDraw (\\time\n  (if (gt time 0.5)\n    (- (* time 2.0) 1.0)\n    0\n  )\n))\n\n; For when all the Hilbert levels but the most detailed fade out together.\n(def earlierLevelOpacity (\\time\n  (pow (- 1.0 (curveFractionToDraw time)) 2)\n))\n\n; The basic U.\n;\n; We can\'t center this around 0,0 because of some weird clipping with the view box.\n(def hilbertPart_ [\n  (path \'none\' \'green\' 0.4 [ \'M\' 10 10 \'L\' 10 20 \'L\' 20 20 \'L\' 20 10 ])\n  (circle \'red\' 10 10 1)\n])\n\n; We use SVG transforms to position, rotate, and size the U.\n(def hilbertPart (\\(centerX centerY width rotation orientation opacity)\n  [\n    \'g\'\n    [\n      [\'transform\' [[\'translate\' centerX centerY] [\'rotate\' rotation 0 0] [\'scale\' (/ width 20) (/ width 20)] [\'scale\' orientation 1] [\'translate\' -15 -15]]]\n      [\'opacity\' opacity]\n    ]\n    hilbertPart_\n  ]\n))\n\n; Add 90 degrees.\n(def rotateAngleRight (\\a\n  (if (= a 0)\n    90\n    (if (= a 90)\n      180\n      (if (= a 180)\n        -90\n        (if (= a -90)\n          0\n          \'error\'\n        )\n      )\n    )\n  )\n))\n\n; Angle 0 is straight up, so basically -angle.\n(def flipAngleVertical (\\a\n  (if (or (= a 0) (= a 180))\n    a\n    (- 0 a)\n  )\n))\n\n; Rotates by 90 degrees around 0,0\n(def rotatePointRight (\\[x y]\n  (if (and (lt 0 x) (lt 0 y))\n    [(- 0 x) y]\n    (if (and (gt 0 x) (lt 0 y))\n      [x (- 0 y)]\n      (if (and (gt 0 x) (gt 0 y))\n        [(- 0 x) y]\n        (if (and (lt 0 x) (gt 0 y))\n          [x (- 0 y)]\n          \'error\'\n        )\n      )\n    )\n  )\n))\n\n; Want to always rotate the short way around the circle.\n(defrec circularDisplacement (\\(a b)\n  (let diff (- b a)\n    (if (gt diff 180)\n      (circularDisplacement a (- b 360))\n      (if (le diff -180)\n        (circularDisplacement a (+ b 360))\n        diff\n      )\n    )\n  )\n))\n\n; Clamp angle to (-180, 180]\n(def normalizeRotation (\\angle\n  (circularDisplacement 0 angle)\n))\n\n(def rotateChildrenRight (\\[\n    [ x1 y1 rot1 or1 ]\n    [ x2 y2 rot2 or2 ]\n    [ x3 y3 rot3 or3 ]\n    [ x4 y4 rot4 or4 ]\n  ]\n  [\n    (append (rotatePointRight [x1 y1]) [(rotateAngleRight rot1) or1])\n    (append (rotatePointRight [x2 y2]) [(rotateAngleRight rot2) or2])\n    (append (rotatePointRight [x3 y3]) [(rotateAngleRight rot3) or3])\n    (append (rotatePointRight [x4 y4]) [(rotateAngleRight rot4) or4])\n  ]\n))\n\n(def flipChildrenVertical (\\[\n    [ x1 y1 rot1 or1 ]\n    [ x2 y2 rot2 or2 ]\n    [ x3 y3 rot3 or3 ]\n    [ x4 y4 rot4 or4 ]\n  ]\n  [\n    [ (- 0 x1) y1 (flipAngleVertical rot1) (- 0 or1) ]\n    [ (- 0 x2) y2 (flipAngleVertical rot2) (- 0 or2) ]\n    [ (- 0 x3) y3 (flipAngleVertical rot3) (- 0 or3) ]\n    [ (- 0 x4) y4 (flipAngleVertical rot4) (- 0 or4) ]\n  ]\n))\n\n; Returns [ [relX relY rotation orientation] ... ]\n(def hilbertChildParams (\\(rotation orientation)\n  (let initial [\n      [-1 -1  -90 -1]\n      [-1  1    0  1]\n      [1   1    0  1]\n      [1  -1   90 -1]\n    ]\n  (let oriented (if (= orientation 1) initial (flipChildrenVertical initial))\n    (if (= rotation 0)\n      oriented\n      (if (= rotation 90)\n        (rotateChildrenRight oriented)\n        (if (= rotation 180)\n          (rotateChildrenRight (rotateChildrenRight oriented))\n          (rotateChildrenRight (rotateChildrenRight (rotateChildrenRight oriented)))\n        )\n      )\n    )\n  ))\n))\n\n; Recursively draw the U\'s with the proper animation and opacity.\n(defrec hilbertParts (\\(time depth levelPartCount partNumber opacity centerX centerY width rotation orientation)\n  (let thisLevel (hilbertPart centerX centerY width rotation orientation (* (pow 0.5 depth) opacity))\n    (if (le depth 0)\n      (if (gt opacity 0.005)\n        [thisLevel]\n        []\n      )\n      (append\n        (concat (map2\n          (\\(i [relX relY rot or])\n            (let [targetX targetY targetWidth targetRot targetOr]\n              [\n                (+ centerX (* relX (/ width 4)))\n                (+ centerY (* relY (/ width 4)))\n                (/ width 2)\n                (+ rotation (circularDisplacement rotation rot))\n                or\n              ]\n            (let thisLevelPartCount (* levelPartCount 4)\n            (let thisPartNumber (+ (* partNumber 4) i)\n            (let animationFraction\n              (if (le depth 1)\n                (let partAndFraction (* (* time 2) thisLevelPartCount)\n                  (if (le partAndFraction thisPartNumber)\n                    0\n                    (if (ge partAndFraction (+ thisPartNumber 1))\n                      1\n                      (- partAndFraction thisPartNumber)\n                    )\n                  )\n                )\n                1\n              )\n            (let [movementFraction orientationFraction]\n              (if (= orientation targetOr)\n                [animationFraction 1]\n                (if (lt animationFraction 0.5)\n                  [(* animationFraction 2) 0]\n                  [1 (- (* animationFraction 2) 1)]\n                )\n              )\n            (let [aniX aniY aniWidth aniRot aniOr] [\n                (+ (* centerX     (- 1 movementFraction   )) (* targetX     movementFraction))\n                (+ (* centerY     (- 1 movementFraction   )) (* targetY     movementFraction))\n                (+ (* width       (- 1 movementFraction   )) (* targetWidth movementFraction))\n                (+ (* rotation    (- 1 movementFraction   )) (* targetRot   movementFraction))\n                (+ (* orientation (- 1 orientationFraction)) (* targetOr    orientationFraction))\n              ]\n            (let opacity\n              (if (gt (curveFractionToDraw time) 0.0)\n                (if (le depth 1)\n                  (let partAndFraction (* (curveFractionToDraw time) thisLevelPartCount)\n                    (if (le partAndFraction thisPartNumber)\n                      1\n                      (if (ge partAndFraction (+ thisPartNumber 1))\n                        0\n                        (- 1 (- partAndFraction thisPartNumber))\n                      )\n                    )\n                  )\n                  (earlierLevelOpacity time)\n                )\n                1\n              )\n              (if (gt animationFraction 0)\n                (hilbertParts time (- depth 1) thisLevelPartCount thisPartNumber opacity aniX aniY aniWidth aniRot aniOr)\n                []\n              )\n            )))))))\n          )\n          (range 0 3)\n          (hilbertChildParams (normalizeRotation rotation) orientation)\n        ))\n        [thisLevel]\n      )\n    )\n  )\n))\n\n; Four points in a block.\n(def hilbertPoints_ (\\(centerX centerY width rotation orientation)\n  (let quarterWidth (/ width 4)\n    (map\n      (\\[relX relY _ _]\n        [(+ centerX (* relX quarterWidth)) (+ centerY (* relY quarterWidth))]\n      )\n      (hilbertChildParams rotation orientation)\n    )\n  )\n))\n\n; List of points on the curve in order. [ [100 100] [150 100] ... ]\n(defrec hilbertPoints (\\(depth centerX centerY width rotation orientation)\n  (let thisLevel (hilbertPoints_ centerX centerY width rotation orientation)\n    (if (le depth 0)\n      thisLevel\n      (concatMap\n        (\\[relX relY childRot childOr]\n          (let [childX childY childWidth]\n            [\n              (+ centerX (* relX (/ width 4)))\n              (+ centerY (* relY (/ width 4)))\n              (/ width 2)\n            ]\n            (hilbertPoints (- depth 1) childX childY childWidth childRot childOr)\n          )\n        )\n        (hilbertChildParams (normalizeRotation rotation) orientation)\n      )\n    )\n  )\n))\n\n; Returns the first n elements of the list\n(def take (\\(n list)\n  (map2\n    always\n    list\n    (range 1 n)\n  )\n))\n\n; Returns element i (starting from 0) from a list\n(def fetch (\\(i list)\n  (fst (foldl\n    (\\(x [ret thisI])\n      (if (= 0 thisI)\n        [x (- thisI 1)]\n        [ret (- thisI 1)]\n      )\n    )\n    [nil i]\n    list\n  ))\n))\n\n; When drawing the final curve, which points should we draw?\n;\n; All the complexity here is for adding a point part-way between\n; the last point and the next point based on the time.\n(def hilbertPointsAnimated (\\(time depth centerX centerY width rotation orientation)\n  (if (gt (curveFractionToDraw time) 0)\n    (let allPoints (hilbertPoints depth centerX centerY width rotation orientation)\n    (let count (len allPoints)\n    (let countToDraw (floor (* (curveFractionToDraw time) count))\n    (let partialLineFraction (- (* (curveFractionToDraw time) count) countToDraw)\n    (let pointsToDraw (take countToDraw allPoints)\n      (if (and (gt partialLineFraction 0) (gt countToDraw 0))\n        (let [lastPointX lastPointY] (fetch (- countToDraw 1) allPoints)\n        (let [nextPointX nextPointY] (fetch countToDraw allPoints)\n        (let lastPointToDraw\n          [\n            (+ (* lastPointX (- 1 partialLineFraction)) (* nextPointX partialLineFraction))\n            (+ (* lastPointY (- 1 partialLineFraction)) (* nextPointY partialLineFraction))\n          ]\n          (snoc lastPointToDraw pointsToDraw)\n        )))\n        (if (gt countToDraw 1)\n          pointsToDraw\n          [[0 0]]\n        )\n      )\n    )))))\n    [[0 0]]\n  )\n))\n\n; Draw the curve as one long path at the end of the animation.\n(def hilbertCurve (\\(time depth centerX centerY width rotation orientation)\n  (let [[firstX firstY]|otherPoints] (hilbertPointsAnimated time depth centerX centerY width rotation orientation)\n    [(path \'none\' \'blue\' 5\n      [ \'M\' firstX firstY | (concatMap (\\[x y] [\'L\' x y]) otherPoints) ]\n    )]\n  )\n))\n\n(def crossfade (\\(a b t)\n  (+\n    (* a (- 1.0 t))\n    (* b t)\n  )\n))\n\n(def maxLevels 3)\n\n[\n  maxLevels\n  (\\slideNumber\n    (let level slideNumber\n    (let levelPartCount (pow 4 level)\n    (let drawingParts (lt level maxLevels)\n\n      [\n        (if drawingParts (+ 1 levelPartCount) 1)\n        (\\slideMovieNumber\n          (if (and drawingParts (= 1 slideMovieNumber))\n            [\n              \'Dynamic\'\n              0.5\n              (\\(slideNumber movieNumber t)\n                (let relT (* t 2.0)\n                  [\'svg\' [[\'opacity\' (crossfade 1.0 0.5 relT)]] (hilbertParts 0.5 (- level 1) 1 0 1.0 300 300 400 0 1)]\n                )\n              )\n              (not (= slideNumber 1))\n            ]\n            (if drawingParts\n              (let animationDuration (* 3 (pow 0.5 level))\n                [\n                  \'Dynamic\'\n                  animationDuration\n                  (\\(slideNumber movieNumber t)\n                    (let localT (/ (+ (/ (/ t animationDuration) levelPartCount) (* (/ 1.0 levelPartCount) (- movieNumber 2))) 2)\n                      (svg (hilbertParts localT level 1 0 1.0 300 300 400 0 1))\n                    )\n                  )\n                  (and (gt slideMovieNumber 5) (le slideMovieNumber levelPartCount))\n                ]\n              )\n              (let animationDuration 9\n                [\n                  \'Dynamic\'\n                  animationDuration\n                  (\\(slideNumber movieNumber t)\n                    (let localT (+ 0.5 (/ (/ t animationDuration) 2))\n                      (let elements [\n                        (hilbertParts localT (- maxLevels 1) 1 0 (earlierLevelOpacity localT) 300 300 400 0 1)\n                        (hilbertCurve localT (- maxLevels 1) 300 300 400 0 1)\n                      ]\n                      (svg (concat elements))\n                    ))\n                  )\n                  false\n                ]\n              )\n            )\n          )\n        )\n      ]\n    )))\n  )\n]\n";
   var fractalTree = "; A fractal tree\n;\n(defrec mod (\\(x m) (if (< x m) x (mod (- x m) m))))\n(def nsin (\\n (if (< n (/ 3.14159 2)) (sin n) (cos (mod n (/ 3.14159 2))))))\n(def ncos (\\n (if (< n (/ 3.14159 2)) (cos n) (sin (mod n (/ 3.14159 2))))))\n(def [initwd initlen] [10! 150!])\n(def [steps stepslider] (hSlider true 20! 420! 550! 3! 8! \'Steps \' 4))\n(def [bendn bendnslider] (hSlider false 20! 420! 580! 1! 8! \'Bend \' 1))\n(def initangle (/ 3.14159! 2!))\n(def bend (/ 3.14159! bendn))\n(defrec exp (\\(base pow)\n  (if (< pow 1) 1 (* base (exp base (- pow 1))))))\n(def mkleftx (\\(stepnum theta px) \n  (- px (* (/ initlen stepnum) (ncos (+ theta (* (exp 0.5 stepnum) bend)))))))\n(def mkrightx (\\(stepnum theta px)\n  (+ px (* (/ initlen stepnum) (ncos (- theta (* (exp 0.5 stepnum) bend)))))))\n(def mklefty (\\(stepnum theta py)\n  (- py (* (/ initlen stepnum) (nsin (+ theta (* (exp 0.5 stepnum) bend)))))))\n(def mkrighty (\\(stepnum theta py)\n  (- py (* (/ initlen stepnum) (nsin (- theta (* (exp 0.5 stepnum) bend)))))))\n(defrec genchildren (\\(stepnum maxstep theta px2 py2) \n  (if (< maxstep stepnum) \n    [] \n    (append \n      [ (line \'black\' (/ initwd stepnum) px2 py2 \n          (mkleftx stepnum theta px2)\n          (mklefty stepnum theta py2))\n        (line \'black\' (/ initwd stepnum) px2 py2\n          (mkrightx stepnum theta px2)\n          (mkrighty stepnum theta py2))]\n      (append\n        (genchildren (+ stepnum 1) maxstep (+ theta (* (exp 0.5 stepnum) bend))\n          (mkleftx stepnum theta px2)\n          (mklefty stepnum theta py2))\n        (genchildren (+ stepnum 1) maxstep (- theta (* (exp 0.5 stepnum) bend))\n          (mkrightx stepnum theta px2)\n          (mkrighty stepnum theta py2)))))))\n(def trunk (line \'black\' initwd 210 400 210 250))\n(def branches (genchildren 2 steps initangle 210 250))\n(svg (concat [ [ trunk | branches ] bendnslider stepslider]))\n\n";
   var solarSystem = "; Visualization of the solar system \n;\n; The slider on top controls the \"animation.\"\n; Try changing the size of a planet in one frame,\n;   and see what happens in the others.\n \n(def aupx 12)\n(def [ox oy] [200 400])\n\n; Relative radii of the planet orbits, in au\n(def [ merorb venorb earorb marorb juporb satorb uraorb neporb ] \n     [ 0.387! 0.723! 1! 1.524! 5.203! 9.539! 19.18! 30.06! ]\n)\n\n; Relative orbital period to the Earth\n(def [ meryr venyr earyr maryr jupyr satyr urayr nepyr ]\n     [ 0.2409! 0.616! 1! 1.9! 12! 29.5! 84! 165! ]\n)\n\n; Function to place a body\n(def planet (\\(color orb yr radius)\n  (\\t (circle color  (+ ox (* aupx (* orb (cos (* t (/ 6.28318 yr))))))\n                       (+ oy (* aupx (* orb (sin (* t (/ -6.28318 yr))))))\n                       radius))))\n\n; Visual for each body\n; Each takes a time to be displayed at\n(def sun (circle \'yellow\' ox oy 10))\n(def mercury (planet \'lightred\'   merorb meryr 4))\n(def venus   (planet \'orange\'     venorb venyr 5))\n(def earth   (planet \'green\'      earorb earyr 5))\n(def mars    (planet \'red\'        marorb maryr 4))\n(def jupiter (planet \'brown\'      juporb jupyr 6))\n(def saturn  (planet \'sandybrown\' satorb satyr 6))\n(def uranus  (planet \'blue\'       uraorb urayr 6))\n(def neptune (planet \'darkblue\'   neporb nepyr 6))\n\n; Visual for the rings\n(def rings\n  (reverse\n    (map (\\orb (ring \'lightgrey\' 2! ox oy (* aupx orb)))\n         [ merorb venorb earorb marorb juporb satorb uraorb neporb ])))\n\n(def [time timeslider] (hSlider true 20! 600! 20! 1! 1000! \'Day \' 1))\n(def rev (\\(x f) (f x)))\n(def planets\n  (map (rev (/ time 365))\n       [mercury venus earth mars jupiter saturn uranus neptune]))\n\n(svg (concat [ rings [sun | planets] timeslider ]))\n\n";
   var pieChart1 = "; A Pie Chart\n;\n; Move the sliders to change the size of a particular slice\n;\n(let [count1_ count2_ count3_ count4_ count5_] [35 31 16 10 8]\n(let [color1 color2 color3 color4 color5] [\'#8DEEEE\' \'#66CCCC\' \'#49E9BD\' \'#5EDA9E\' \'#00FA9A\']\n(let [h1 h2 h3 h4 h5] [20! 50! 80! 110! 140!]\n(let [count1 s1] (hSlider true 20! 420! h1 0! 100! \'\' count1_)\n(let [count2 s2] (hSlider true 20! 420! h2 0! 100! \'\' count2_)\n(let [count3 s3] (hSlider true 20! 420! h3 0! 100! \'\' count3_)\n(let [count4 s4] (hSlider true 20! 420! h4 0! 100! \'\' count4_)\n(let [count5 s5] (hSlider true 20! 420! h5 0! 100! \'\' count5_)\n(let total (+ count1 (+ count2 (+ count3 (+ count4 count5))))\n(let p2 (+ count1 count2)\n(let p3 (+ p2 count3)\n(let p4 (+ p3 count4)\n(let p5 (+ p4 count5)\n;\n(let sliders (concat [s1 s2 s3 s4 s5])\n(let swatches (map (\\[h c] (square c 460! (- h 10!) 20!)) [[h1 color1] [h2 color2] [h3 color3] [h4 color4] [h5 color5]])\n(let [cx cy r t border] [280! 440! 180 4 \'grey\']\n;\n(let pie\n  (let pToDegrees (\\p (* 360! (/ p total)))\n  (let [d1 d2 d3 d4 d5] (map pToDegrees [count1 p2 p3 p4 p5])\n  (let flag (\\d (if (< 180 d) 1 0))\n  (let flagged (map (\\[d fr] [d (flag fr)]) [[d1 d1] [d2 (- d2 d1)] [d3 (- d3 d2)] [d4 (- d4 d3)] [d5 (- d5 d4)]])\n  (let toRadian (\\[d f] [(* (/ (pi) 180!) d) f])\n  (let polarcoords (map toRadian flagged)\n  (let slice (\\[ang flg] [flg (* r (cos ang)) (* r (sin ang))])\n  (let [[f1 x1 y1] [f2 x2 y2] [f3 x3 y3] [f4 x4 y4] [f5 x5 y5]] (map slice polarcoords)\n  (let wedge (\\[color f [sx sy] [ex ey]] (path color border t [\'M\' cx cy \'L\' sx sy \'A\' 180 180 0 f 1 ex ey \'Z\']))\n  (let wedges \n    (map\n      wedge\n        [[color1 f1 [(+ cx 180!) cy] [(+ cx x1) (+ cy y1)]]\n        [color2 f2 [(+ cx x1) (+ cy y1)] [(+ cx x2) (+ cy y2)]]\n        [color3 f3 [(+ cx x2) (+ cy y2)] [(+ cx x3) (+ cy y3)]]\n        [color4 f4 [(+ cx x3) (+ cy y3)] [(+ cx x4) (+ cy y4)]]\n        [color5 f5 [(+ cx x4) (+ cy y4)] [(+ cx x5) (+ cy y5)]]])\n  wedges))))))))))\n;\n(svg (cons (circle \'lightgray\' cx cy (* 1.1 r)) (append (append sliders swatches) pie))))))))))))))))))))\n";
   var ferrisWheelSlideshow = "(def [slideN slideSlider] (hSlider true 20! 400! 20! 1! 13! \'Slide \' 1))\n(def [timeInSlide timeInSlideSlider] (hSlider false 20! 400! 40! 0.0! 1.0! \'Time in Slide \' 0.0))\n\n(def rimColor [0 0 0 1])\n(def beamWidth 1)\n(def [centerX centerY] [300 300])\n(def [smallRadius largeRadius] [50 150])\n(def spokeEndSize 3)\n(def hubRadius 12)\n(def [carHighlightColor carColor] [[251 191 141 1] [191 191 191 1]])\n(def [carWidth carHeight] [20 20])\n(def spokeDuplicationOffset 12)\n(def carDuplicationOffset (+ carWidth 12))\n(def carDiagonalDuplicationOffset 14)\n(def rotationAngle (* twoPi 0.03))\n\n(def spoke (\\(centerX centerY rimX rimY)\n  [\n    (line \'black\' 1 centerX centerY rimX rimY)\n    (circle \'black\' rimX rimY spokeEndSize)\n  ]\n))\n\n(def diameterSpoke (\\(x1 y1 x2 y2)\n  [\n    (line \'black\' 1 x1 y1 x2 y2)\n    (circle \'black\' x1 y1 spokeEndSize)\n    (circle \'black\' x2 y2 spokeEndSize)\n  ]\n))\n\n(def car_ (\\(fill x y w h)\n  ; Manual, so we can add stroke.\n  [\n    \'rect\'\n    [ [\'x\' (- x (/ w 2))] [\'y\' (- y (/ h 2))] [\'width\' w] [\'height\' h] [\'fill\' fill] [\'stroke\' \'black\'] ]\n    []\n  ]\n))\n\n(def hub_ (\\(fill x y r)\n  ; Manual, so we can add stroke.\n  [\n    \'circle\'\n    [ [\'cx\' x] [\'cy\' y] [\'r\' r] [\'fill\' fill] [\'stroke\' \'black\'] ]\n    []\n  ]\n))\n\n(def rimAttachmentPoints (\\(spokeCount radius angle centerX centerY)\n  (let angles (map (\\i (- (+ (* (/ i spokeCount) twoPi) angle) halfPi)) (range 0 (- spokeCount 1)))\n    (map (\\angle [(+ centerX (* (cos angle) radius)) (+ centerY (* (sin angle) radius))]) angles)\n  )\n))\n\n(def carsAndHub (\\(spokeCount radius angle carWidth carHeight hubRadius centerX centerY)\n  (let hub [(hub_ carColor centerX centerY hubRadius)]\n  (let [[highlightedCarX highlightedCarY]|otherRimAttachmentPoints] (rimAttachmentPoints spokeCount radius angle centerX centerY)\n  (let highlightedCar [(car_ carHighlightColor highlightedCarX highlightedCarY carWidth carHeight)]\n  (let otherCars (map (\\[x y] (car_ carColor x y carWidth carHeight)) otherRimAttachmentPoints)\n    [hub highlightedCar otherCars]\n  ))))\n))\n\n(def rimAndSpokes (\\(spokeCount radius angle centerX centerY)\n  (let rim [(ring rimColor beamWidth centerX centerY radius)]\n  (let spokes (map (\\[x y] (spoke centerX centerY x y)) (rimAttachmentPoints spokeCount radius angle centerX centerY))\n    [rim (concat spokes)]\n  ))\n))\n\n(def ferrisWheel (\\(spokeCount radius angle carWidth carHeight hubRadius centerX centerY)\n  (concat [\n    (carsAndHub spokeCount radius angle carWidth carHeight hubRadius centerX centerY)\n    (rimAndSpokes spokeCount radius angle centerX centerY)\n  ])\n))\n\n(def hub [(hub_ carColor centerX centerY hubRadius)])\n(def smallRim [(ring rimColor beamWidth centerX centerY smallRadius)])\n(def spoke1 (diameterSpoke centerX (+ centerY smallRadius) centerX (- centerY smallRadius)))\n(def spoke1Duplicate1 (diameterSpoke (+ centerX spokeDuplicationOffset) (+ (+ centerY smallRadius) spokeDuplicationOffset) (+ centerX spokeDuplicationOffset) (+ (- centerY smallRadius) spokeDuplicationOffset)))\n(def spoke1Duplicate2 (diameterSpoke (+ centerX (mult 2 spokeDuplicationOffset)) (+ (+ centerY smallRadius) (mult 2 spokeDuplicationOffset)) (+ centerX (mult 2 spokeDuplicationOffset)) (+ (- centerY smallRadius) (mult 2 spokeDuplicationOffset))))\n(def spoke1Duplicate1HalfMoved (diameterSpoke (+ centerX spokeDuplicationOffset) (+ (+ centerY smallRadius) spokeDuplicationOffset) (- centerX smallRadius) centerY))\n(def spoke2 (diameterSpoke (+ centerX smallRadius) centerY (- centerX smallRadius) centerY))\n\n(def car (\\(x y)\n  [(car_ carColor x y carWidth carHeight)]\n))\n\n(def highlightedCar (\\(x y)\n  [(car_ carHighlightColor x y carWidth carHeight)]\n))\n\n(def car1 (highlightedCar centerX (- centerY smallRadius)))\n(def car1Duplicates (map (\\n (car (+ centerX (* n carDuplicationOffset)) (- centerY smallRadius))) (range 1 3)))\n\n(def ferrisSmall4\n  (ferrisWheel\n    4 ; number of spokes\n    smallRadius\n    0 ; angle\n    carWidth\n    carHeight\n    hubRadius\n    centerX\n    centerY\n  )\n)\n(def car2Duplicates (map (\\n (car (+ smallRadius (+ centerX (* n carDiagonalDuplicationOffset))) (+ centerY (* n carDiagonalDuplicationOffset)))) (range 1 3)))\n(def ferrisSmall4CarsAndHub\n  (carsAndHub\n    4 ; number of spokes\n    smallRadius\n    0 ; angle\n    carWidth\n    carHeight\n    hubRadius\n    centerX\n    centerY\n  )\n)\n(def ferrisSmall8CarsAndHub\n  (carsAndHub\n    8 ; number of spokes\n    smallRadius\n    0 ; angle\n    carWidth\n    carHeight\n    hubRadius\n    centerX\n    centerY\n  )\n)\n(def ferrisSmall8RimAndSpokes\n  (rimAndSpokes\n    8 ; number of spokes\n    smallRadius\n    0 ; angle\n    centerX\n    centerY\n  )\n)\n(def ferrisSmall8\n  (concat [ferrisSmall8CarsAndHub ferrisSmall8RimAndSpokes])\n)\n(def ferrisLarge8RimAndSpokesOffset\n  (rimAndSpokes\n    8 ; number of spokes\n    largeRadius\n    0 ; angle\n    (+ centerX (- largeRadius smallRadius))\n    (- centerY (- largeRadius smallRadius))\n  )\n)\n(def ferrisLarge8RimAndSpokes\n  (rimAndSpokes\n    8 ; number of spokes\n    largeRadius\n    0 ; angle\n    centerX\n    centerY\n  )\n)\n(def ferrisLarge8\n  (ferrisWheel\n    8 ; number of spokes\n    largeRadius\n    0 ; angle\n    carWidth\n    carHeight\n    hubRadius\n    centerX\n    centerY\n  )\n)\n(def ferrisLarge8BadlyRotated\n  [(rotate\n    [\'g\' [] (concat ferrisLarge8)]\n    (/ (* rotationAngle 360) twoPi)\n    centerX\n    centerY\n  )]\n)\n\n(def [car7X car7Y] (hd (reverse (rimAttachmentPoints 8 largeRadius rotationAngle centerX centerY))))\n(def car7 (car car7X car7Y))\n(def car7Duplicates (map (\\n (car (+ car7X (* n carDiagonalDuplicationOffset)) (+ car7Y (* n carDiagonalDuplicationOffset)))) (range 1 7)))\n\n(def ferrisLarge8RimAndSpokesRotated\n  (rimAndSpokes\n    8 ; number of spokes\n    largeRadius\n    rotationAngle\n    centerX\n    centerY\n  )\n)\n(def ferrisLarge8Rotated\n  (ferrisWheel\n    8 ; number of spokes\n    largeRadius\n    (+ rotationAngle (* twoPi timeInSlide))\n    carWidth\n    carHeight\n    hubRadius\n    centerX\n    centerY\n  )\n)\n\n(def appearInOrder (\\shapeGroups\n  (let appearanceTimeAndShapeGroups (map2 (\\(i shapeGroup) [(/ i (len shapeGroups)) shapeGroup]) (range 0 (- (len shapeGroups) 1)) shapeGroups)\n    (foldr\n      (\\([t shapeGroup] visible)\n        (if (ge timeInSlide t)\n          (let opacity (/ (- timeInSlide t) (/ 1 (len shapeGroups)))\n          (let faded [[\'g\' [[\'opacity\' opacity]] shapeGroup]]\n            [faded | visible]\n          ))\n          visible\n        )\n      )\n      []\n      appearanceTimeAndShapeGroups\n    )\n  )\n))\n\n(def elements\n  (if (= slideN 1)\n    (appearInOrder [smallRim spoke1 spoke1Duplicate1])\n    (if (= slideN 2)\n      [smallRim spoke1 spoke1Duplicate1HalfMoved]\n      (if (= slideN 3)\n        (concat [ [hub car1] (appearInOrder car1Duplicates) [smallRim spoke1 spoke2] ])\n        (if (= slideN 4)\n          ferrisSmall4\n          (if (= slideN 5)\n            (concat [ ferrisSmall4 (appearInOrder (concat [[spoke1Duplicate1 spoke1Duplicate2] car2Duplicates])) ])\n            (if (= slideN 6)\n              (concat [ ferrisSmall4CarsAndHub ferrisSmall8RimAndSpokes (appearInOrder car2Duplicates) ])\n              (if (= slideN 7)\n                ferrisSmall8\n                (if (= slideN 8)\n                  (concat [ ferrisSmall8CarsAndHub ferrisLarge8RimAndSpokesOffset ])\n                  (if (= slideN 9)\n                    (concat [ ferrisSmall8CarsAndHub ferrisLarge8RimAndSpokes ])\n                    (if (= slideN 10)\n                      ferrisLarge8\n                      (if (= slideN 11)\n                        [ferrisLarge8BadlyRotated]\n                        (if (= slideN 12)\n                          (concat [ [hub car7] ferrisLarge8RimAndSpokesRotated (appearInOrder car7Duplicates) ])\n                          (if (= slideN 13)\n                            ferrisLarge8Rotated\n                            []\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n)\n\n(svg (append (concat elements) (concat [slideSlider timeInSlideSlider])))\n";
   var ferris2target = "(def n 8)\n(def len 142)\n(def rot -0.13796015197333036)\n\n(def wheel\n  (let [cx cy] [280 200]\n  (let rim [(ring \'darkgray\' 3 cx cy len)]\n  (let center [(circle \'black\' cx cy 15)]\n  (let frame [(nStar \'goldenrod\' \'darkgray\' 3 n len 0 rot cx cy)]\n  (let spokePts (nPointsOnCircle n rot cx cy len)\n  (let caps (map (\\[x y] (circle \'black\' x y 6)) spokePts)\n  (let cars\n    (let wCar 27\n    (let wHalfCar (/ wCar 2!)\n    (mapi (\\[i [x y]] (squareByCenter (if (= 0 i) \'pink\' \'lightgray\') x y wCar)) spokePts)))\n  (concat [rim cars center frame caps])))))))))\n\n(svg wheel)\n\n";
   var ferris2 = "(def n 5)\n(def len 80)\n(def rot 0)\n\n(def wheel\n  (let [cx cy] [280 200]\n  (let rim [(ring \'darkgray\' 8 cx cy len)]\n  (let center [(circle \'black\' cx cy 20)]\n  (let frame [(nStar \'goldenrod\' \'darkgray\' 3 n len 0 rot cx cy)]\n  (let spokePts (nPointsOnCircle n rot cx cy len)\n  (let caps (map (\\[x y] (circle \'black\' x y 7)) spokePts)\n  (let cars\n    (let wCar 30\n    (let wHalfCar (/ wCar 2!)\n    (map (\\[x y] (squareByCenter \'lightgray\' x y wCar)) spokePts)))\n  (concat [rim cars center frame caps])))))))))\n\n(svg wheel)\n\n";
   var ferris = "\n; Take this ferris wheel for a spin!\n; Try:\n;  - Stretching the passenger cars\n;  - Stretching the central hub\n;  - Dragging the central hub\n;  - Setting showSliders to false\n\n(def wheel (\\(cx cy rCenter wCar rCap numSpokes spokeLen rotAngle)\n  (let rim      [(ring \'darkgray\' 6 cx cy spokeLen)]\n  (let center   [(circle \'black\' cx cy rCenter)]\n  (let frame    [(nStar \'goldenrod\' \'darkgray\' 3 numSpokes spokeLen 0 rotAngle cx cy)]\n  (let spokePts (nPointsOnCircle numSpokes rotAngle cx cy spokeLen)\n  (let cars     (mapi (\\[i [x y]] (squareByCenter (if (= i 0) \'pink\' \'lightgray\') x y wCar)) spokePts)\n  (let hubcaps  (map (\\[x y] (circle \'black\' x y rCap)) spokePts)\n    (concat [rim cars center frame hubcaps])\n))))))))\n\n(def [cx cy spokeLen rCenter wCar rCap] [220 300 80 20 30 7])\n(def [numSpokes rotAngle] [5!{3-15} 0!{-3.14-3.14}])\n\n(svg (wheel cx cy rCenter wCar rCap numSpokes spokeLen rotAngle))\n\n";
   var flw2 = ";\n; A Frank Lloyd Wright design based on:\n; http://www.glass-by-design.com/images3/skylight3.jpg\n;\n; This is a tiled version of that design\n;\n; Possible ways to manipulate:\n; - Grab edges of red polygons, yellow circles, or\n;     blue ellipses and pull in various directions\n; - Grab ends of lines and move in various directions\n;\n(let [x0 y0 w h max] [69 55 200 320 10!]\n(let wbox (/ w 10!)\n(let hbox (/ h 10!)\n(let xoff (\\(n x) (+ x0 (+ (* x w) (* wbox n))))\n(let yoff (\\(n y) (+ y0 (+ (* y h) (* hbox n))))\n(let blkline (\\[[a b] [c d]] (line \'black\' 3 a b c d))\n(let redpoly\n  (\\[a b x y]\n    (polygon\n      \'red\'\n      \'black\'\n      3\n      [[(xoff a x) (yoff a y)]\n       [(xoff a x) (yoff b y)]\n       [(xoff b x) (yoff b y)]\n       [(xoff b x) (yoff a y)]]))\n(let dimension [0! 4 5 6 7 10!]\n(let [p0 p1 p2 p3 p4] [0 1 2 2.9 5]\n(let singletile\n  (\\[x y] \n    (let verticals\n      (zip\n        (map (\\n [(xoff n x) (+ y0 (* y h))]) dimension)\n        (map (\\n [(xoff n x) (+ y0 (* (+ y 1) h))]) dimension))\n    (let horizontals\n      (zip\n        (map (\\n [(+ x0 (* x w)) (yoff n y)]) dimension)\n        (map (\\n [(+ x0 (* (+ 1 x) w)) (yoff n y)]) dimension))\n      (append\n        (append\n          (map blkline (append verticals horizontals))\n          (map (\\[xc yc r] (circle \'yellow\' xc yc r))\n            [[(xoff 6 x) (yoff 1.75 y) (+ wbox hbox)]\n             [(xoff 6 x) (yoff 7 y) (/ (+ wbox hbox) 4)]\n             [(xoff 6 x) (yoff 5 y) (/ (+ wbox hbox) 2)]]))\n        (cons\n          (ellipse \'blue\' (xoff 5 x) (yoff 9 y) (* wbox 4) hbox)\n          (map redpoly [[p0 p1 x y] [p1 p2 x y] [p2 p3 x y] [p3 p4 x y]])\n          )))))\n(let grid (cartProd [0! 1! 2!] [0! 1!])\n;\n  (svg \n    (cons (rect \'white\' (- x0 10!) (- y0 10!) (+ (* 3 w) 20!) (+ (* 2 h) 20!))\n      (concatMap singletile grid))))))))))))))\n\n";
   var flw1 = ";\n; A Frank Lloyd Wright design inspired by:\n; http://www.glass-by-design.com/images3/skylight3.jpg\n;\n(let [x0 y0 w h max] [69 55 532 744 10!]\n(let wbox (/ w 10!)\n(let hbox (/ h 10!)\n(let xoff (\\n (+ x0 (* wbox n)))\n(let yoff (\\n (+ y0 (* hbox n)))\n(let blkline (\\[[a b] [c d]] (line \'black\' 3 a b c d))\n(let redpoly\n  (\\[a b]\n    (polygon\n      \'red\'\n      \'black\'\n      3\n      [[(xoff  a) (yoff  a)]\n       [(xoff  a) (yoff  b)]\n       [(xoff  b) (yoff  b)]\n       [(xoff  b) (yoff  a)]]))\n(let dimension\n  [0! 1 2 2.9 2.4 1.5 9.1 7.9 8.2 8.7 10!]\n(let verticals\n  (zip\n    (map (\\n [(xoff  n) y0]) dimension)\n    (map (\\n [(xoff  n) (+ y0 (* hbox max))]) dimension))\n(let horizontals\n  (zip\n    (map (\\n [x0 (yoff  n)]) dimension)\n    (map (\\n [(+ x0 (* wbox max)) (yoff  n)]) dimension))\n  (svg\n    (cons (rect \'white\' (- x0 10!) (- y0 10!) (+ w 20!) (+ h 20!)) \n    (append\n      (map blkline (append verticals horizontals))\n      (append\n        (append\n          (let [p0 p1 p2 p3 p4] [0 1 2 2.9 5]\n            (map redpoly [[p0 p1] [p1 p2] [p2 p3] [p3 p4]]))\n          (map (\\[x y] (ellipse \'blue\' x y (* wbox 4) hbox)) [[(xoff  5) (yoff  9)]]))\n        (map\n          (\\[x y r] (circle \'yellow\' x y r))\n          [[(xoff  6) (yoff  1.75) (+ wbox hbox)]\n           [(xoff  6) (yoff  7) (/ (+ wbox hbox) 4)]\n           [(xoff  6) (yoff  5) (/ (+ wbox hbox) 2)]])))))))))))))))\n\n";
   var frenchSudan = ";\n; The Flag of French Sudan, based on:\n;\n; A few ways to manipulate:\n; - Grab any part of the stick figure and move it\n;     in various directions\n;\n(let [x0 y0 w h] [50 30 450 300]\n(let wstripe (/ w 3!)\n(let xoff (+ x0 wstripe)\n(let yoff (+ y0 (/ h 4!))\n(let stripe (\\[color x] (rect color x y0 wstripe h))\n(let minrad\n  (if (< (/ wstripe 7.5!) (/ h 15!))\n    (/ wstripe 7.5!)\n    (/ h 15!))\n(let figline (\\[[a b] [c d]] (line \'black\' (/ minrad 2!) a b c d))\n(let [x1 x2 x3] (map (\\n (+ x0 (* wstripe n))) [1.2! 1.5! 1.8!])\n(let [y1 y2 y3 y4] (map (\\n (+ y0 (/ h n))) [4.3! 2.8! 1.9! 1.4!])\n;\n  (svg\n    (cons (rect \'white\' (- x0 10!) (- y0 10!) (+ w 20!) (+ h 20!)) \n    (append\n      (map stripe [[\'blue\' x0] [\'white\' (+ x0 wstripe)] [\'red\' (+ x0 (* 2! wstripe))]])\n      (snoc\n        (ellipse \'black\' x2 y1 (/ wstripe 7.5!) (/ h 15!))\n        (map\n          figline\n          [[[x1 y1] [x1 y2]]\n           [[x1 y2] [x3 y2]]\n           [[x3 y1] [x3 y2]]\n           [[x1 y4] [x1 y3]]\n           [[x1 y3] [x3 y3]]\n           [[x3 y3] [x3 y4]]\n           [[x2 y1] [x2 y3]]]))))))))))))))\n\n";
   var chicago = " \n; The flag of Chicago\n;\n; Possible ways to manipulate\n; - Pull stripes or stars in various directions\n; - Group box in background\n \n(def [x0 y0 ni nj pts w h] [40 40 0.5! 3.5! 6! 454 300])\n(def [outerLen innerLen] [30 12])\n\n(def background\n  (let [d1 d2] [10! 20!]\n  [ (rect \'white\' (- x0 d1) (- y0 d1) (+ w d2) (+ h d2)) ]))\n\n(def stripes\n  (map (\\i\n    (rect \'lightblue\' x0 (+ y0 (* i h)) w (/ h 6!)))\n  [(/ 1! 6!) (/ 2! 3!)]))\n\n(def stars\n  (map (\\i\n    (let off (* i (/ w 4!))\n    (nStar \'red\' \'none\' 0 pts outerLen innerLen 0\n      (+ x0 off) (+ y0 (/ h 2!)))))\n  (range ni nj)))\n\n(svg (concat [background stripes stars]))\n\n";
   var usFlag50 = ";\n; Current Flag of the United States\n; (using circles for now, since 50 stars is slow)\n;\n; A few ways to manipulate:\n; - Grab various parts of the red stripes or\n;     blue block and pull in various directions\n; - Grab the edges of the circles and and\n;     increase or decrease the radius\n;\n(let [x0 y0 ni nj pts w h rad] [20 20 0! 12! 5! 510 272 6]\n(let hstripe (/ h 13!)\n(let block (rect \'#09096d\' x0 y0 (* w (/ 2! 5!)) (* 7! hstripe))\n(let stripes\n  (map\n    (\\i (rect \'red\' x0 (+ y0 (* i hstripe)) w hstripe))\n    [0! 2! 4! 6! 8! 10! 12!])\n(let base (append stripes [block])\n;\n  (svg\n    (cons (rect \'white\' (- x0 10!) (- y0 10!) (+ w 20!) (+ h 20!)) \n    (append base\n      (map (\\[i j]\n        (let xsep (/ w 15!)\n        (let ysep (* hstripe 1.3!)\n          (circle \'white\' (+ x0 (* i xsep)) (+ y0 (* j ysep)) rad))))\n        (append (cartProd (range 0.5! 5.5!) (range 0.75! 4.75!))\n                (cartProd (range 1! 5!) (range 1.2! 4.2!))))))))))))\n\n";
   var usFlag13 = ";\n; Original flag of the United States\n;\n; A few ways to mainpulate this example:\n; - Grab bottom right corner to increase overall size\n; - Grab the edge of a red stripe to increase width\n; - Grab the points of one of the stars to change \n;     the size of its points\n;\n(let rotate (\\a (/ (* a (pi)) 6.5!))\n(let [x0 y0 ni nj pts w h] [20 20 0! 12! 5! 500 260]\n(let hstripe (/ h 13!)\n(let [blockw blockh] [(/ w 3!) (* 7! hstripe)]\n(let min\n  (if (< blockw blockh)\n    (* 0.4! blockw)\n    (* 0.4! blockh))\n(let [outerLen innerLen] [10 4]\n(let block (rect \'#09096d\' x0 y0 blockw blockh)\n(let stripes\n  (map\n    (\\i (rect \'red\' x0 (+ y0 (* i hstripe)) w hstripe))\n    [0! 2! 4! 6! 8! 10! 12!])\n(let base (append stripes [block])\n;\n  (svg\n    (cons (rect \'white\' (- x0 10!) (- y0 10!) (+ w 20!) (+ h 20!))\n    (append base\n      (map (\\i\n         (nStar \'white\' \'none\' 0 pts innerLen outerLen\n           (rotate  i)\n           (+ (+ x0 (/ w 6!)) (* min (cos (rotate i))))\n           (+ (+ y0 (* hstripe 3.5!)) (* min (sin (rotate i))))))\n        (range ni nj))))))))))))))\n\n";
   var boxGridTokenFilter = "\n; Drag some \"filter tokens\" from the right over the grid.\n; Toggle between positive/negative filtering.\n\n(def [x0 y0 w h boxSize] [30! 100! 300! 300! 50!])\n(def allColors [0 100 200 300 450])\n(def seedRows 1.5)\n(def seedCols 2.5)\n(def seedNumColors 1.5)\n(def seedShapeKind 0.5)\n(def seedFilterKind 0.75)\n\n; derived values\n(def [xw yh] [(+ x0 w) (+ y0 h)])\n(def sep (+ boxSize 10!))\n(def halfBoxSize (/ boxSize 2!))\n\n(def [ [ cols rows ] boxSlider ] \n  (let pad 10!\n  (xySlider\n    (- x0 pad) (+ xw pad)\n    (- y0 pad) (+ yh pad)\n    0! (/ w sep)\n    0! (/ h sep)\n    \'\' \'\'\n    seedCols seedRows)))\n\n(def [numColors numColorsSlider]\n  (hSlider true 20! 100! 30! 1! 5! \'#Colors = \' seedNumColors))\n\n(def [shapeKind shapeKindSlider]\n  (enumSlider 220! 300! 30! [\'Box\' \'Dot\' \'Star\'] \'\' seedShapeKind))\n\n(def [posFilter filterKindSlider]\n  (button 360! 30! \'PosNeg = \' seedFilterKind))\n\n(def tokens \n  (let [x0 y0] [400! 50!]\n  (let shift (\\(dx dy) [(+ x0 dx) (+ y0 dy)])\n  (map (\\[x y] (ghost (circle (if posFilter \'blue\' \'red\') x y 10!)))\n       [(shift 0  30)\n        (shift 0  60)\n        (shift 0  90)\n        (shift 0 120)\n        (shift 0 150)\n        (shift 0 180)\n        (shift 0 210)\n        (shift 0 240)\n        (shift 0 270)\n        (shift 0 300)\n       ]))))\n\n(def isCovered (\\(cx cy)\n  (let checkX (between (- cx halfBoxSize) (+ cx halfBoxSize))\n  (let checkY (between (- cy halfBoxSize) (+ cy halfBoxSize))\n  (let centers (map (\\tok [(lookupAttr tok \'cx\') (lookupAttr tok \'cy\')]) tokens)\n  (some (\\[x y] (and (checkX x) (checkY y))) centers)\n )))))\n\n(def shapes\n  (let indices (cartProd (range 0! (- cols 1!)) (range 0! (- rows 1!)))\n  (let drawShape (\\[i j]\n    (let shape\n      (let c (nth allColors (mod (- i j) numColors))\n      (let x (+ x0 (mult i sep))\n      (let y (+ y0 (mult j sep))\n      (let [cx cy] [(+ x halfBoxSize) (+ y halfBoxSize)]\n      ; TODO boolean patterns?\n      (let covered (isCovered cx cy)\n      (if (or (and posFilter (not covered))\n              (and (not posFilter) covered)) (circle \'none\' 0! 0! 0!)\n      (case shapeKind\n        (\'Box\'  (square c x y boxSize))\n        (\'Dot\'  (circle c cx cy halfBoxSize))\n        (\'Star\' (nStar c \'none\' 0! 4! halfBoxSize 10! 0! cx cy))\n        ( else  (circle \'none\' 0! 0! 0!)))))))))\n    (if (and (= i (- cols 1!)) (< j numColors))\n        shape\n        (addAttr shape [\'ZONES\' \'none\']))))\n  (map drawShape indices))))\n\n(svg (concat [ \n  shapes\n  boxSlider\n  numColorsSlider\n  shapeKindSlider\n  filterKindSlider\n  tokens\n]))\n\n";
   var rgba = ";\n; A Color Picker\n; \n; Move the sliders to change the rgba\n; value of the circle!\n;\n(let [r_ g_ b_ a_] [22 74 237 0.5]\n;\n(let [r s1] (hSlider true 20! 420! 20! 0! 255! \'\' r_)\n(let [g s2] (hSlider true 20! 420! 50! 0! 255! \'\' g_)\n(let [b s3] (hSlider true 20! 420! 80! 0! 255! \'\' b_)\n(let [a s4] (hSlider false 20! 420! 110! 0.0! 1.0! \'\' a_)\n;\n(let ball (circle [r g b a] 220! 300! 100!)\n(let sliders (concat [s1 s2 s3 s4])\n;\n  (svg (cons ball sliders)))))))))\n\n";
   var xySlider = "; A two dimensional slider in a similar style to the other sliders\n(def xySlider_\n  (\\(dropBall roundInt xStart xEnd yStart yEnd minx maxx miny maxy xcaption ycaption curx cury)\n    (let [rCorner wEdge rBall] [4! 3! 10!]\n    (let [xDiff yDiff xValDiff yValDiff] [(- xEnd xStart) (- yEnd yStart) (- maxx minx) (- maxy miny)]\n    (let ballx (+ xStart (* xDiff (/ (- curx minx) xValDiff)))\n    (let bally (+ yStart (* yDiff (/ (- cury miny) yValDiff)))\n    (let ballx_ (clamp xStart xEnd ballx)\n    (let bally_ (clamp yStart yEnd bally)\n    (let rball_ (if dropBall (if (< maxx curx) 0 rBall) rBall)\n    (let rball__ (if dropBall (if (< maxy cury) 0 rball_) rBall)\n    (let xval\n      (let xval_ (clamp minx maxx curx)\n      (if roundInt (round xval_) xval_))\n    (let yval\n      (let yval_ (clamp miny maxy cury)\n      (if roundInt (round yval_) yval_))\n    (let shapes\n      [ (line \'black\' wEdge xStart yStart xEnd yStart)\n        (line \'black\' wEdge xStart yStart xStart yEnd)\n        (line \'black\' wEdge xStart yEnd xEnd yEnd)\n        (line \'black\' wEdge xEnd yStart xEnd yEnd)\n        (circle \'black\' xStart yStart rCorner)\n        (circle \'black\' xStart yEnd rCorner)\n        (circle \'black\' xEnd yStart rCorner)\n        (circle \'black\' xEnd yEnd rCorner)\n        (circle \'black\' ballx_ bally_ rball__)\n        (text (- (+ xStart (/ xDiff 2)) 40) (+ yEnd 20) (+ xcaption (toString xval)))\n        (text (+ xEnd 10) (+ yStart (/ yDiff 2)) (+ ycaption (toString yval))) ]\n  [ [ xval yval ] shapes ])))))))))))))\n\n(def xySlider (xySlider_ false))\n\n(def [ [ a b ] slider ]\n  (xySlider false 20! 420! 20! 420! 0! 100! 0! 100! \'X Axis: \' \'Y Axis: \' 20 20))\n\n(svg slider)\n\n";
   var widgets = "; library widgets\n;\n(let [n  s1] (hSlider false 20! 90!  20! 0! 5! \'n = \' 3.1415)\n(let [i  s2] (hSlider true  20! 90!  50! 0! 5! \'i = \' 3.1415)\n(let [b1 s3] (button        20!      80!       \'b1 = \' 0.25)\n(let [b2 s4] (button        20!     110!       \'b2 = \' 0.75)\n  (svg (concat [s1 s2 s3 s4]))))))\n\n";
   var buttons = ";\n(let button_ (\\(dropBall xStart y caption xCur)\n  (let [rPoint wLine rBall wSlider] [4! 3! 10! 70!]\n  (let xEnd (+ xStart wSlider)\n  (let xBall (+ xStart (* xCur wSlider))\n  (let xBall_ (clamp xStart xEnd xBall)\n  (let rBall_ (if dropBall (if (= xBall_ xBall) rBall 0) rBall)\n  (let val (< xCur 0.5)\n  (let shapes\n    [ (circle \'black\' xStart y rPoint)\n      (circle \'black\' xEnd y rPoint)\n      (line \'black\' wLine xStart y xEnd y)\n      (circle (if val \'darkgreen\' \'darkred\') xBall y rBall_)\n      (text (+ xEnd 10) (+ y 5) (+ caption (toString val))) ]\n  [val shapes]))))))))\n;\n(let [b b1] (button_ true 20! 20! \'b = \' 0.25)\n  (svg b1)))\n\n";
   var sliders = ";\n; The ni constants get adjusted by the sliders,\n; and then clamped to fit within the [min, max] range.\n; Also try changing the min and max constants below.\n;\n(let [min max] [0! 10!]\n(let [n1 n2 n3 n4] [5 5 5 5]\n(let [m1 m2 m3 m4] (map (clamp min max) [n1 n2 n3 n4])\n;\n; Both the horizontal and vertical slider abstractions\n; below take a dropBall parameter:\n;  - if true, the ball can slide off the rail;\n;  - if false, the ball disappears when off the rail.\n;\n(let horizSlider (\\(dropBall xStart xEnd y minVal maxVal curVal)\n  (let [rPoint wLine rBall] [4! 3! 10!]\n  (let [xDiff valDiff] [(- xEnd xStart) (- maxVal minVal)]\n  (let xBall (+ xStart (* xDiff (/ (- curVal minVal) valDiff)))\n  (let xBall_ (clamp xStart xEnd xBall)\n  (let rBall_ (if dropBall (if (= xBall_ xBall) rBall 0) rBall)\n    [ (circle \'black\' xStart y rPoint)\n      (circle \'black\' xEnd y rPoint)\n      (line \'black\' wLine xStart y xEnd y)\n      (circle \'black\' xBall y rBall_)\n    ]))))))\n;\n(let vertSlider (\\(dropBall yStart yEnd x minVal maxVal curVal)\n  (let [rPoint wLine rBall] [4! 3! 10!]\n  (let [yDiff valDiff] [(- yEnd yStart) (- maxVal minVal)]\n  (let yBall (+ yStart (* yDiff (/ (- curVal minVal) valDiff)))\n  (let yBall_ (clamp yStart yEnd yBall)\n  (let rBall_ (if dropBall (if (= yBall_ yBall) rBall 0) rBall)\n    [ (circle \'black\' x yStart rPoint)\n      (circle \'black\' x yEnd rPoint)\n      (line \'black\' wLine x yStart x yEnd)\n      (circle \'black\' x yBall rBall_)\n    ]))))))\n;\n(let sliders\n  (let s1 (horizSlider false 30! 230! 30! min max n1)\n  (let s2 (horizSlider true 30! 230! 70! min max n2)\n  (let s3 (vertSlider false 110! 300! 110! min max n3)\n  (let s4 (vertSlider true 110! 300! 150! min max n4)\n    (foldl append nil [s1 s2 s3 s4])))))\n;\n(let displays\n  (let t1 (text 300 100 (+ \'m1 = \' (toString m1)))\n  (let t2 (text 300 120 (+ \'m2 = \' (toString m2)))\n  (let t3 (text 300 140 (+ \'m3 = \' (toString m3)))\n  (let t4 (text 300 160 (+ \'m4 = \' (toString m4)))\n    [t1 t2 t3 t4]))))\n;\n  (svg (append sliders displays)))))))))\n\n";
   var stars = " \n(let nStar (\\(fill stroke w n len1 len2 rot cx cy)\n  (let pti (\\[i len]\n    (let anglei (+ (- (/ (* i (pi)) n) rot) halfPi)\n    (let xi (+ cx (* len (cos anglei)))\n    (let yi (+ cy (neg (* len (sin anglei))))\n      [xi yi]))))\n  (let lengths\n    (map (\\b (if b len1 len2))\n         (concat (repeat n [true false])))\n  (let indices (list0N (- (* 2! n) 1!))\n    (polygon fill stroke w (map pti (zip indices lengths)))))))\n \n(let [x0 y0 sep ni nj] [100 100 100 3! 7!]\n(let [outerLen innerLen] [50 20]\n(let iStar (\\i\n   (let off (mult (- i ni) sep)\n   (let [xi yi] [(+ x0 off) (+ y0 off)]\n   (nStar \'goldenrod\' \'black\' 3 i outerLen innerLen 0! xi yi))))\n \n(svg (map iStar (range ni nj)))))))\n\n";
   var polygons = "(let ngon (\\(n cx cy len1 len2)\n  (let dangle (/ (* 3! (pi)) 2!)\n  (let anglei (\\i (+ dangle (/ (* i (* 2! (pi))) n)))\n  (let xi     (\\i (+ cx (* len1 (cos (anglei i)))))\n  (let yi     (\\i (+ cy (* len2 (sin (anglei i)))))\n  (let pti    (\\i [(xi i) (yi i)])\n  (let pts    (map pti (list0N (- n 1!)))\n    (polygon \'yellow\' \'maroon\' 4 pts))))))))\n(svg [\n  (ngon 3 100 200 40 40)\n  (ngon 4 200 200 30 30)\n  (ngon 5 300 300 50 50)\n  (ngon 7 300 100 40 40)\n  (ngon 15 100 400 40 40)\n]))\n\n";
   var rings = "\n(let [x0 y0 w r dx dy] [30 30 7 20 32 20]\n(let dxHalf (div dx 2)\n \n(let row1\n  (map (\\[i c] (ring c w (+ x0 (mult i dx)) y0 r))\n       (zip [0 1 2] [\'blue\' \'black\' \'red\']))\n \n(let row2\n  (map (\\[i c]\n         (let x (+ (+ x0 dxHalf) (mult i dx))\n         (let y (+ y0 dy)\n           (ring c w x y r))))\n       (zip [0 1] [\'yellow\' \'green\']))\n \n(svg (append row1 row2))))))\n\n";
   var botanic = "\n; Logo: Chicago Botanic Garden\n\n; Click \'[Zones]\' to see the control points for\n; the various Bezier curves.\n\n(def [w h] [434! 622])\n(def midline (/ w 2!))\n\n(def [x0  y0  xc1 yc1 x1  y1  xc2 yc2]\n     [185 261 59  232 0   382 28  183])\n\n(def leaf (\\polarity\n  (let [mx0 mxc1 mx1 mxc2]\n       [(+ midline (* polarity x0))\n        (+ midline (* polarity xc1))\n        (+ midline (* polarity x1))\n        (+ midline (* polarity xc2))]\n    (path \'white\' \'none\' 0\n      [\'M\' mx0 y0\n       \'Q\' mxc1 yc1 mx1 y1\n       \'M\' mx1 y1\n       \'Q\' mxc2 yc2 mx0 y0]))))\n\n(def [budTipY budCornerX budCornerY]\n     [322     34         262       ])\n\n(def bud\n  (let [rx1 rx2]\n       [(- midline budCornerX)\n        (+ midline budCornerX)]\n    (path \'white\' \'none\' 0\n      [\'M\' midline budTipY\n       \'L\' rx1 budCornerY\n       \'A\' 31 31 0 0 1 rx2 budCornerY\n       \'L\' rx2 budCornerY \'Z\'])))\n\n(def background (zones \'none\' [(rect \'#83F52C\' 0! 0! w h)]))\n\n(svg (concat [background [(leaf 1!) (leaf -1!) bud]]))\n";
   var activeTrans2 = "\n; Logo based on Active Transportation Alliance\n; (http://activetrans.org/)\n \n(def base 0)\n(def grayPts\n  [[  97 546           ] [  33 414           ]\n   [  33 (+ base 153!) ] [  53 (+ base 128!) ]\n   [  82 (+ base 135!) ] [  83 (+ base 160!) ]\n   [ 114 (+ base 149!) ] [ 113 (+ base  98!) ]\n   [ 143 (+ base  82!) ] [ 158 (+ base 101!) ]\n   [ 160 (+ base  46!) ] [ 192 (+ base  27!) ]\n   [ 221 (+ base  56!) ] [ 227 (+ base 222!) ]\n   [ 245 (+ base 224!) ] [ 246 (+ base 181!) ]\n   [ 288 (+ base 156!) ] [ 286 (+ base 113!) ]\n   [ 312 (+ base  88!) ] [ 374 (+ base 106!) ]\n   [ 375 (+ base 155!) ] [ 397 (+ base 136!) ]\n   [ 424 (+ base 145!) ] [ 425 207           ]\n  ])\n\n(def greenPts\n  [[247 663] [461 419] [466 230] [439 230] [178 614]])\n\n(def [grayctrl greenctrl]\n  [[47 489] [451 542]])\n\n(def [cGreen cGray] [\'#66CC66\' \'#505050\'])\n(def [b buttonShapes] (button 20! 20! \'\' 0.25))\n(def groupBox (rect (if b \'transparent\' cGreen) 0! 0! 500! 700!))\n\n(def makePath (\\(color pts [xc yc])\n  (let [[x0 y0] [x1 y1] | rest] pts\n  (let commands\n    (append\n      (append [\'M\' x0 y0] [\'Q\' xc yc x1 y1])\n      (foldr (\\([xi yi] acc) (append [\'L\' xi yi] acc))\n             [\'Z\'] rest))\n  (path color \'black\' 0 commands)))))\n \n(def grayPath (makePath (if b cGray \'white\') grayPts grayctrl))\n(def greenPath (makePath (if b cGreen \'white\') greenPts greenctrl))\n\n(svg (append [groupBox grayPath greenPath] buttonShapes))\n\n";
   var elmLogo = "; Elm logo, based on:\n; https://github.com/evancz/elm-svg/blob/1.0.2/examples/Logo.elm\n;\n; Notice how the \'viewBox\' attribute puts the canvas in\n; \"full screen\" mode. Also, although we don\'t currently handle\n; rotations (i.e. \'transform\'s) specially, the resulting zone\n; is still useful; toggle the Zones option to see.\n;\n(let foo (\\(color pts) (polygon color \'black\' 0 pts))\n(svgViewBox 323.141 322.95 [\n  (foo \'#F0AD00\' [[161 152] [231 82] [91 82]])\n  (foo \'#7FD13B\' [[8 0] [79 70] [232 70] [161 0]])\n  (addAttr\n     (rect \'#7FD13B\' 192 107 107 108)\n     [\'transform\' \'matrix(0.7071 0.7071 -0.7071 0.7071 186.4727 -127.2386)\'])\n  (foo \'#60B5CC\' [[323 143] [323 0] [179 0]])\n  (foo \'#5A6378\' [[152 161] [0 8] [0 314]])\n  (foo \'#F0AD00\' [[255 246] [323 314] [323 178]])\n  (foo \'#60B5CC\' [[161 170] [8 323] [314 323]])\n]))\n\n";
   var logoSizes = "\n(def logo (\\(x0 y0 w h delta1 delta2 fg bg)\n  (let [xw yh w2 h2] [(+ x0 w) (+ y0 h) (div w 2) (div h 2)]\n  (let poly (\\(c pts) (polygon c \'none\' 0 pts))\n  (let basic (\\shape (addAttr shape [\'ZONES\' \'basic\']))\n  [\n  \n    ; positive background\n    ; starting with (xw,yh) to place color slider\n    (poly fg [[xw yh] [xw y0] [x0 y0] [x0 yh]])\n  \n    ; negative X, part 1\n    (poly bg\n      [[x0 y0] [(+ x0 delta1) y0] [xw (- yh delta2)]\n       [xw yh] [(- xw delta1) yh] [x0 (+ y0 delta2)]])\n  \n    ; negative X, part 2\n    (basic (poly bg\n      [[xw y0] [xw (+ y0 delta2)] [(+ x0 delta1) yh]\n       [x0 yh] [x0 (- yh delta2)] [(- xw delta1) y0]]))\n  \n    ; positive, hiding top-right quarter of X\n    (basic (poly fg\n      [[(+ x0 delta1) y0] [xw y0] [xw (- yh delta2)]]))\n  \n  ])))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(def [w h]      [300 300])\n(def [fg bg]    [360 499])\n(def [p0 p1 p2] [1.0! 0.3! 0.1!])\n(def offset     20!)\n\n(def x0 offset)\n(def y0 offset)\n(def x1 (+ x0 (+ offset (* p0 w))))\n(def x2 (+ x1 (+ offset (* p1 w))))\n\n(def [large medium small] [\n  (logo x0 y0 (* p0 w) (* p0 h) 10 10 fg bg)\n  (logo x1 y0 (* p1 w) (* p1 h)  3  3 fg bg)\n  (logo x2 y0 (* p2 w) (* p2 h)  1  1 fg bg)\n])\n\n(svg (concat [\n  large\n  (zones \'basic\' medium)\n  (zones \'basic\' small)\n]))\n\n";
   var logo2 = "; sketch-n-sketch logo, v2\n; better lines for non-square scaling\n\n(def logo (\\(x0 y0 w h delta1 delta2 fg bg)\n  (let [xw yh w2 h2] [(+ x0 w) (+ y0 h) (div w 2) (div h 2)]\n  (let poly (\\(c pts) (polygon c \'none\' 0 pts))\n  (let basic (\\shape (addAttr shape [\'ZONES\' \'basic\']))\n  (svg [\n\n    ; positive background\n    ; starting with (xw,yh) to place color slider\n    (poly fg [[xw yh] [xw y0] [x0 y0] [x0 yh]])\n\n    ; negative X, part 1\n    (poly bg\n      [[x0 y0] [(+ x0 delta1) y0] [xw (- yh delta2)]\n       [xw yh] [(- xw delta1) yh] [x0 (+ y0 delta2)]])\n\n    ; negative X, part 2\n    (basic (poly bg\n      [[xw y0] [xw (+ y0 delta2)] [(+ x0 delta1) yh]\n       [x0 yh] [x0 (- yh delta2)] [(- xw delta1) y0]]))\n\n    ; positive, hiding top-right quarter of X\n    (basic (poly fg\n      [[(+ x0 delta1) y0] [xw y0] [xw (- yh delta2)]]))\n\n  ]))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def [x0 y0 w h delta1 delta2] [50! 50! 200 200 10 10])\n(def [fg bg] [360 499])\n\n(logo x0 y0 w h delta1 delta2 fg bg)\n\n";
   var logo = "; sketch-n-sketch logo\n;\n(let [x0 y0 w h delta] [50 50 200 200 10]\n(let [xw yh w2 h2] [(+ x0 w) (+ y0 h) (div w 2) (div h 2)]\n(let poly (\\pts (polygon \'black\' \'none\' 0 pts))\n(svg [\n  (rect \'white\' x0 y0 w h)\n  (poly\n    [[(+ x0 delta) y0]\n     [xw y0]\n     [xw (- yh delta)]])\n  (poly\n    [[x0 (+ y0 delta)]\n     [x0 (- yh delta)]\n     [(- (+ x0 w2) delta) (+ y0 h2)]])\n  (poly\n    [[(+ x0 delta) yh]\n     [(- xw delta) yh]\n     [(+ x0 w2) (+ (+ y0 h2) delta)]])\n]))))\n\n";
   var basicSlides = "(def slideCount 5)\n(def slideMovieCount 5)\n\n[\n  slideCount\n  (\\slideNumber\n    [\n      slideMovieCount\n      (\\slideMovieNumber\n        [\n          \'Dynamic\'\n          1\n          (\\(slideNumber movieNumber t)\n            (svg [\n              (rect\n                \'lightblue\'\n                (+ 100 (* 50 movieNumber))\n                (+ 100 (* 50 slideNumber))\n                (* t 50)\n                (* t 50)\n              )\n            ])\n          )\n          true\n        ]\n      )\n    ]\n  )\n]\n";
   var groupOfBoxes = "\n; Try:\n;  - replacing (basicZonesTail nBoxes) with nBoxes\n\n(def [x0 y0 w h sep] [50 200 60 130 110])\n(def colorNum 100)\n(def rotBox 0)\n(def rotGroup 0)\n\n(def [n slider] (hSlider true 50! 300! 30! 1! 10! \'n = \'\n                 3))\n\n(def xi (\\i (+ x0 (mult i sep))))\n\n(def nBoxes\n  (let boxi (\\i\n    (rotate\n      (rect colorNum (xi i) y0 w h)\n      rotBox (+ (xi i) (/ w 2)) (+ y0 (/ h 2))))\n  (map boxi (list0N (- n 1)))))\n\n(def groupBox\n  (let [dw dh] [50 50]\n  (let xg (- x0 (/ dw 2))\n  (let yg (- y0 (/ dh 2))\n  (let wg (+ (+ (- (xi (- n 1)) x0) w) dw)\n  (let hg (+ h dh)\n    (rotate\n      (rect \'lightyellow\' xg yg wg hg)\n      rotGroup (+ xg (/ wg 2)) (+ yg (/ hg 2)))))))))\n\n(svg (concat\n  [ slider [groupBox] (basicZonesTail nBoxes) ]))\n\n";
   var nBoxes = "\n(def nBoxes\n  (let [n x0 y0 w h sep] [3{1-10} 40 28 60 130 110{50-200}]\n  (let boxi (\\i\n    (let xi (+ x0 (mult i sep))\n    (rect \'lightblue\' xi y0 w h)))\n  (svg (map boxi (range 0! (- n 1!)))))))\n \nnBoxes\n\n";
   var sineWaveGrid = "; WORKAROUND: Switch to [Heuristics] None before using sliders.\n; (Better yet, toggle Heuristics before selecting this example.)\n; Both heuristics modes use a naive algorithm to compute triggers,\n; which runs very slowly with the number of shapes in this canvas.\n\n  ; fix case bug:\n  ; > import Eval exposing (parseAndRun)\n  ; > parseAndRun \"(case [2 false] ([2 true] \'A\') (_ \'B\'))\"\n  ; \"\'A\'\" : String\n\n  ; (let color (case [i shadow]\n  ;   ([2 false] \'crimson\')   ([2 true] \'gray\')\n  ;   ([_ false] \'lightblue\') ([_ true] \'transparent\'))\n\n(def sineWave (\\(x0 y0 w h sep amp n shadow)\n  (let boxi (\\i\n    (let xi (+ x0 (* i sep))\n    (let yi (- y0 (* amp (sin (* i (/ twoPi n)))))\n    (let colori\n      (if (= i 2) (if shadow \'lightgray\' \'crimson\')\n                  (if shadow \'transparent\' \'lightblue\'))\n    (rect colori xi yi w h)))))\n  (map boxi (zeroTo n)))))\n\n; Would be even cooler if wGrid and hGrid were computed\n; automatically from the sine waves in each grid box.\n; Leaving this step as an exercise for another day...\n\n(def [outerPad innerPad] [100{0-300} 20{0-50}])\n(def [wGrid hGrid]       [740{0-1500} 430{0-1000}])\n\n; Helper function (could be added to Prelude)\n\n(def outlined (\\(stroke strokeWidth shape)\n  (consAttr (consAttr shape\n    [\'stroke\' \'black\'])\n    [\'stroke-width\' strokeWidth])))\n\n; Call sineWave in grid box at row i, column j.\n\n(def place (\\(i j x0 y0 w h sep amp n shadow)\n  (let [iPad jPad] [(+ outerPad (* innerPad i)) (+ outerPad (* innerPad j))]\n  (let gridBox\n    (outlined \'black\' (let border 3{0-10} border)\n      (rect \'none\' (+ jPad (* j wGrid)) (+ iPad (* i hGrid)) wGrid hGrid))\n  (let waveBoxes\n    (let [x y] [(+ x0 (* j wGrid)) (+ y0 (* i hGrid))]\n    (sineWave (+ x jPad) (+ y iPad) w h sep amp n shadow))\n  (cons gridBox waveBoxes))))))\n\n; Parameters from the original sineWaveOfBoxes.little.\n; If want to add sliders, then symbolically compute\n; the possible solutions below. Could even add a slider\n; for the index of the box being dragged... another exercise.\n\n(def [x0 y0 w h sep0 amp0 n] [50 120 20 90 30 60 12])\n\n; Simulate dragging of third box by (dx,dy) pixels.\n; Two possible solutions for each mouse direction.\n\n(def [dx dy] [50!{0-300} 110!{0-300}])\n\n(def x1   (+ x0 dx))\n(def sep1 (+ sep0 (/ dx 2!)))\n\n(def y1   (+ y0 dy))\n(def amp1 (/ (- y0 (+ dy 68!)) 0.867!))\n\n; Now draw original and versions with different solutions.\n\n(def totalPad (+ (* 2 outerPad) (* 2 innerPad)))\n(def totalWidth (+ (* 3 wGrid) totalPad))\n(def totalHeight (+ (* 3 hGrid) totalPad))\n\n(svgViewBox totalWidth totalHeight\n  (concat [\n    (place 0 0 x0 y0 w h sep0 amp0 n false)\n    (place 0 0 x1 y1 w h sep0 amp0 n true)  ; shadow box\n\n    (place 1 1 x1 y1 w h sep0 amp0 n false) ; update  x0/y0\n    (place 1 2 x1 y0 w h sep0 amp1 n false) ; update  x0/amp\n    (place 2 1 x0 y1 w h sep1 amp0 n false) ; update sep/y0\n    (place 2 2 x0 y0 w h sep1 amp1 n false) ; update sep/amp\n\n    ; workaround parser design bug that the comment above\n    ; needs to be followed by an expression\n    []\n]))\n\n";
   var sineWaveOfBoxes = "(def [x0 y0 w h sep amp] [50 120 20 90 30 60])\n(def n 12!{3-30})\n(def boxi (\\i\n   (let xi (+ x0 (* i sep))\n   (let yi (- y0 (* amp (sin (* i (/ twoPi n)))))\n     (rect \'lightblue\' xi yi w h)))))\n\n(svg (map boxi (zeroTo n)))\n\n";
   var nBoxesH2 = "\n(def [a b c] [0 0 0])\n(def something (+ a (+ a (+ b (+ b (+ c c))))))\n\n(def nBoxes\n  (let [n x0 y0 w h sep] [3 40 28 60 130 110]\n  (let boxi (\\i\n    (let xi (+ (+ x0 something) (mult i sep))\n    (rect \'lightblue\' xi y0 w h)))\n  (svg (map boxi (zeroTo n))))))\n \nnBoxes\n\n";
   var threeBoxes = "\n(def threeBoxesInt\n  (let [x0 y0 w h sep] [40 28 60 130 110]\n  (let boxi (\\i\n    (let xi (+ x0 (mult i sep))\n    (rect \'lightblue\' xi y0 w h)))\n  (svg (map boxi [0 1 2])))))\n \nthreeBoxesInt\n\n";
   var scratch = " \n; Write a little program below.\n; Or choose an example from the list.\n;\n; Changes to this *Scratch* example will be saved and\n; restored when navigating to and from other examples.\n; For the remaining named examples, changes will be\n; discarded when choosing a different example.\n \n(svg [(rect \'maroon\' 100 15 200 50)])\n\n";
   var scratchName = "*Scratch*";
   var makeExample = F2(function (name,s) {
      var thunk = function (_p0) {
         var _p1 = _p0;
         var e = A2($Utils.fromOkay,
         A2($Basics._op["++"],"Error parsing example ",name),
         $LangParser2.parseE(s));
         var ati = $Types.dummyAceTypeInfo;
         var _p2 = A2($Utils.fromOk,
         A2($Basics._op["++"],"Error executing example ",name),
         $Eval.run(e));
         var v = _p2._0;
         var ws = _p2._1;
         return {e: e,v: v,ws: ws,ati: ati};
      };
      return {ctor: "_Tuple3",_0: name,_1: s,_2: thunk};
   });
   var examples = _U.list([A2(makeExample,"BLANK",blank)
                          ,A2(makeExample,scratchName,scratch)
                          ,A2(makeExample,"*Prelude*",$PreludeGenerated.src)
                          ,A2(makeExample,"SnS Logo (UIST)",sns_UIST)
                          ,A2(makeExample,"SnS Logo Revisited (UIST)",sns_revisited_UIST)
                          ,A2(makeExample,"Botanic Garden Logo (UIST)",botanic_UIST)
                          ,A2(makeExample,"Coffee Mugs (UIST)",coffee_UIST)
                          ,A2(makeExample,"Wave Boxes",sineWaveOfBoxes)
                          ,A2(makeExample,"Wave Boxes Grid",sineWaveGrid)
                          ,A2(makeExample,"Basic Slides",basicSlides)
                          ,A2(makeExample,"Logo",logo)
                          ,A2(makeExample,"Botanic Garden Logo",botanic)
                          ,A2(makeExample,"Active Trans Logo",activeTrans2)
                          ,A2(makeExample,"Sailboat",sailBoat)
                          ,A2(makeExample,"Chicago Flag",chicago)
                          ,A2(makeExample,"Sliders",sliders)
                          ,A2(makeExample,"Buttons",buttons)
                          ,A2(makeExample,"Widgets",widgets)
                          ,A2(makeExample,"xySlider",xySlider)
                          ,A2(makeExample,"Tile Pattern",boxGridTokenFilter)
                          ,A2(makeExample,"Color Picker",rgba)
                          ,A2(makeExample,"Ferris Wheel",ferris)
                          ,A2(makeExample,"Ferris Task Before",ferris2)
                          ,A2(makeExample,"Ferris Task After",ferris2target)
                          ,A2(makeExample,"Ferris Wheel Slideshow",ferrisWheelSlideshow)
                          ,A2(makeExample,"SnS Logo Wheel",snsLogoWheel)
                          ,A2(makeExample,"Survey Results",surveyResultsTriHist2)
                          ,A2(makeExample,"Hilbert Curve Animation",hilbertCurveAnimation)
                          ,A2(makeExample,"Bar Graph",barGraph)
                          ,A2(makeExample,"Pie Chart",pieChart1)
                          ,A2(makeExample,"Solar System",solarSystem)
                          ,A2(makeExample,"Clique",clique)
                          ,A2(makeExample,"Eye Icon",eyeIcon)
                          ,A2(makeExample,"Wikimedia Logo",wikimedia)
                          ,A2(makeExample,"Haskell.org Logo",haskell)
                          ,A2(makeExample,"Cover Logo",cover)
                          ,A2(makeExample,"POP-PL Logo",poppl)
                          ,A2(makeExample,"Horror Films",horrorFilms0)
                          ,A2(makeExample,"Cycling Association",cyclingAssociation0)
                          ,A2(makeExample,"Lillicon P",lilliconP)
                          ,A2(makeExample,"Lillicon P, v2",lilliconP2)
                          ,A2(makeExample,"Keyboard",keyboard)
                          ,A2(makeExample,"Keyboard Task Before",keyboard2)
                          ,A2(makeExample,"Keyboard Task After",keyboard2target)
                          ,A2(makeExample,"Tessellation Task Before",tessellation)
                          ,A2(makeExample,"Tessellation Task After",tessellationTarget)
                          ,A2(makeExample,"Tessellation 2",tessellation2)
                          ,A2(makeExample,"Floral Logo 1",floralLogo)
                          ,A2(makeExample,"Floral Logo 2",floralLogo2)
                          ,A2(makeExample,"Spiral Spiral-Graph",spiralSpiralGraph)
                          ,A2(makeExample,"Rounded Rect",roundedRect)
                          ,A2(makeExample,"Thaw/Freeze",thawFreeze)
                          ,A2(makeExample,"Dictionaries",dictionaries)
                          ,A2(makeExample,"3 Boxes",threeBoxes)
                          ,A2(makeExample,"N Boxes Sli",nBoxes)
                          ,A2(makeExample,"N Boxes",groupOfBoxes)
                          ,A2(makeExample,"Elm Logo",elmLogo)
                          ,A2(makeExample,"Logo 2",logo2)
                          ,A2(makeExample,"Logo Sizes",logoSizes)
                          ,A2(makeExample,"Rings",rings)
                          ,A2(makeExample,"Polygons",polygons)
                          ,A2(makeExample,"Stars",stars)
                          ,A2(makeExample,"Triangles",equiTri)
                          ,A2(makeExample,"US-13 Flag",usFlag13)
                          ,A2(makeExample,"US-50 Flag",usFlag50)
                          ,A2(makeExample,"French Sudan Flag",frenchSudan)
                          ,A2(makeExample,"Frank Lloyd Wright",flw1)
                          ,A2(makeExample,"Frank Lloyd Wright B",flw2)
                          ,A2(makeExample,"Bezier Curves",bezier)
                          ,A2(makeExample,"Fractal Tree",fractalTree)
                          ,A2(makeExample,"Stick Figures",stickFigures)
                          ,A2(makeExample,"Cult of Lambda",cultOfLambda)
                          ,A2(makeExample,"Matrix Transformations",matrices)
                          ,A2(makeExample,"Misc Shapes",miscShapes)
                          ,A2(makeExample,"Interface Buttons",interfaceButtons)
                          ,A2(makeExample,"Paths 1",paths1)
                          ,A2(makeExample,"Paths 2",paths2)
                          ,A2(makeExample,"Paths 3",paths3)
                          ,A2(makeExample,"Paths 4",paths4)
                          ,A2(makeExample,"Paths 5",paths5)
                          ,A2(makeExample,"Sample Rotations",rotTest)
                          ,A2(makeExample,"Grid Tile",gridTile)
                          ,A2(makeExample,"Zones",zones)]);
   var list = examples;
   return _elm.ExamplesGenerated.values = {_op: _op
                                          ,list: list
                                          ,scratchName: scratchName
                                          ,scratch: scratch};
};
Elm.InterfaceModel = Elm.InterfaceModel || {};
Elm.InterfaceModel.make = function (_elm) {
   "use strict";
   _elm.InterfaceModel = _elm.InterfaceModel || {};
   if (_elm.InterfaceModel.values)
   return _elm.InterfaceModel.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Ace = Elm.Ace.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Char = Elm.Char.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Eval = Elm.Eval.make(_elm),
   $ExamplesGenerated = Elm.ExamplesGenerated.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $ShapeWidgets = Elm.ShapeWidgets.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Sync = Elm.Sync.make(_elm),
   $Types = Elm.Types.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var codeToShow = function (model) {
      var _p0 = model.previewCode;
      if (_p0.ctor === "Just") {
            return _p0._0;
         } else {
            return model.code;
         }
   };
   var liveInfoToHighlights = F2(function (zoneKey,model) {
      var _p1 = model.mode;
      if (_p1.ctor === "Live") {
            return A2($Sync.yellowAndGrayHighlights,zoneKey,_p1._0);
         } else {
            return _U.list([]);
         }
   });
   var WaitCodeBox = {ctor: "WaitCodeBox"};
   var WaitClean = {ctor: "WaitClean"};
   var WaitSave = function (a) {
      return {ctor: "WaitSave",_0: a};
   };
   var WaitRun = {ctor: "WaitRun"};
   var MultiEvent = function (a) {
      return {ctor: "MultiEvent",_0: a};
   };
   var UpdateModel = function (a) {
      return {ctor: "UpdateModel",_0: a};
   };
   var CleanCode = {ctor: "CleanCode"};
   var UpdateFieldContents = function (a) {
      return {ctor: "UpdateFieldContents",_0: a};
   };
   var Noop = {ctor: "Noop"};
   var events = $Signal.mailbox(Noop);
   var WindowDimensions = function (a) {
      return {ctor: "WindowDimensions",_0: a};
   };
   var KeysDown = function (a) {
      return {ctor: "KeysDown",_0: a};
   };
   var Redo = {ctor: "Redo"};
   var Undo = {ctor: "Undo"};
   var StartResizingMid = {ctor: "StartResizingMid"};
   var ToggleBasicCodeBox = {ctor: "ToggleBasicCodeBox"};
   var RemoveDialog = F2(function (a,b) {
      return {ctor: "RemoveDialog",_0: a,_1: b};
   });
   var InstallSaveState = {ctor: "InstallSaveState"};
   var SwitchOrient = {ctor: "SwitchOrient"};
   var PreviousMovie = {ctor: "PreviousMovie"};
   var NextMovie = {ctor: "NextMovie"};
   var PreviousSlide = {ctor: "PreviousSlide"};
   var NextSlide = {ctor: "NextSlide"};
   var ToggleOutput = {ctor: "ToggleOutput"};
   var Redraw = {ctor: "Redraw"};
   var StartAnimation = {ctor: "StartAnimation"};
   var TryParseRun = function (a) {
      return {ctor: "TryParseRun",_0: a};
   };
   var Run = {ctor: "Run"};
   var SelectExample = F2(function (a,b) {
      return {ctor: "SelectExample",_0: a,_1: b};
   });
   var SwitchMode = function (a) {
      return {ctor: "SwitchMode",_0: a};
   };
   var ReplicateBlob = function (a) {
      return {ctor: "ReplicateBlob",_0: a};
   };
   var MergeBlobs = {ctor: "MergeBlobs"};
   var DuplicateBlobs = {ctor: "DuplicateBlobs"};
   var AbstractBlobs = {ctor: "AbstractBlobs"};
   var GroupBlobs = {ctor: "GroupBlobs"};
   var MakeEquidistant = {ctor: "MakeEquidistant"};
   var MakeEqual = {ctor: "MakeEqual"};
   var DigHole = {ctor: "DigHole"};
   var CancelSync = {ctor: "CancelSync"};
   var SelectOption = function (a) {
      return {ctor: "SelectOption",_0: a};
   };
   var PreviewCode = function (a) {
      return {ctor: "PreviewCode",_0: a};
   };
   var TickDelta = function (a) {
      return {ctor: "TickDelta",_0: a};
   };
   var MousePosition = function (a) {
      return {ctor: "MousePosition",_0: a};
   };
   var MouseIsDown = function (a) {
      return {ctor: "MouseIsDown",_0: a};
   };
   var MouseClickCanvas = {ctor: "MouseClickCanvas"};
   var ClickZone = function (a) {
      return {ctor: "ClickZone",_0: a};
   };
   var RadialRepeat = {ctor: "RadialRepeat"};
   var LinearRepeat = {ctor: "LinearRepeat"};
   var HorizontalRepeat = {ctor: "HorizontalRepeat"};
   var LangError = function (a) {
      return {ctor: "LangError",_0: a};
   };
   var Hovering = function (a) {
      return {ctor: "Hovering",_0: a};
   };
   var LambdaAnchor = function (a) {
      return {ctor: "LambdaAnchor",_0: a};
   };
   var LambdaBounds = function (a) {
      return {ctor: "LambdaBounds",_0: a};
   };
   var Sticky = {ctor: "Sticky"};
   var Stretchy = {ctor: "Stretchy"};
   var Raw = {ctor: "Raw"};
   var Lambda = {ctor: "Lambda"};
   var HelperLine = {ctor: "HelperLine"};
   var HelperDot = {ctor: "HelperDot"};
   var Text = {ctor: "Text"};
   var Path = function (a) {    return {ctor: "Path",_0: a};};
   var Poly = function (a) {    return {ctor: "Poly",_0: a};};
   var Oval = function (a) {    return {ctor: "Oval",_0: a};};
   var Rect = function (a) {    return {ctor: "Rect",_0: a};};
   var Line = function (a) {    return {ctor: "Line",_0: a};};
   var Cursor = {ctor: "Cursor"};
   var Horizontal = {ctor: "Horizontal"};
   var Vertical = {ctor: "Vertical"};
   var MouseDrawNew = function (a) {
      return {ctor: "MouseDrawNew",_0: a};
   };
   var MouseDragZone = F2(function (a,b) {
      return {ctor: "MouseDragZone",_0: a,_1: b};
   });
   var MouseResizeMid = function (a) {
      return {ctor: "MouseResizeMid",_0: a};
   };
   var MouseNothing = {ctor: "MouseNothing"};
   var CodeBoxInfo = F5(function (a,b,c,d,e) {
      return {cursorPos: a
             ,selections: b
             ,highlights: c
             ,annotations: d
             ,tooltips: e};
   });
   var DialogInfo = F2(function (a,b) {
      return {value: a,hint: b};
   });
   var SaveDialog = function (a) {
      return {ctor: "SaveDialog",_0: a};
   };
   var Print = function (a) {    return {ctor: "Print",_0: a};};
   var Live = function (a) {    return {ctor: "Live",_0: a};};
   var mkLive = F6(function (opts,
   slideNumber,
   movieNumber,
   movieTime,
   e,
   _p2) {
      var _p3 = _p2;
      return A2($Result.andThen,
      $LangSvg.valToIndexedTree(_p3._0),
      function (slate) {
         return A2($Result.map,
         Live,
         A6($Sync.prepareLiveUpdates,
         opts,
         slideNumber,
         movieNumber,
         movieTime,
         e,
         {ctor: "_Tuple2",_0: slate,_1: _p3._1}));
      });
   });
   var mkLive_ = F5(function (opts,
   slideNumber,
   movieNumber,
   movieTime,
   e) {
      return A2($Result.andThen,
      $Eval.run(e),
      A5(mkLive,opts,slideNumber,movieNumber,movieTime,e));
   });
   var sampleModel = function () {
      var _p4 = $Utils.head_($ExamplesGenerated.list);
      var name = _p4._0;
      var f = _p4._2;
      var _p5 = f({ctor: "_Tuple0"});
      var e = _p5.e;
      var v = _p5.v;
      var ws = _p5.ws;
      var _p6 = A2($Utils.fromOk,
      "generating sample model",
      A4($LangSvg.fetchEverything,1,1,0.0,v));
      var slideCount = _p6._0;
      var movieCount = _p6._1;
      var movieDuration = _p6._2;
      var movieContinue = _p6._3;
      var slate = _p6._4;
      var code = $LangUnparser.unparse(e);
      return {scratchCode: $ExamplesGenerated.scratch
             ,exName: name
             ,code: code
             ,previewCode: $Maybe.Nothing
             ,history: {ctor: "_Tuple2",_0: _U.list([code]),_1: _U.list([])}
             ,inputExp: e
             ,inputVal: v
             ,slideNumber: 1
             ,slideCount: slideCount
             ,movieNumber: 1
             ,movieCount: movieCount
             ,movieTime: 0.0
             ,movieDuration: movieDuration
             ,movieContinue: movieContinue
             ,runAnimation: true
             ,syncSelectTime: 0.0
             ,slate: slate
             ,widgets: ws
             ,mode: A2($Utils.fromOk,
             "mkLive sample model",
             A6(mkLive,
             $Sync.defaultOptions,
             1,
             1,
             0.0,
             e,
             {ctor: "_Tuple2",_0: v,_1: ws}))
             ,mouseMode: MouseNothing
             ,orient: Vertical
             ,hideCode: false
             ,hideCanvas: false
             ,dimensions: {ctor: "_Tuple2",_0: 1000,_1: 800}
             ,midOffsetX: 0
             ,midOffsetY: -100
             ,mouseState: {ctor: "_Tuple2"
                          ,_0: $Maybe.Nothing
                          ,_1: {ctor: "_Tuple2",_0: 0,_1: 0}}
             ,syncOptions: $Sync.defaultOptions
             ,caption: $Maybe.Nothing
             ,showGhosts: true
             ,localSaves: _U.list([])
             ,fieldContents: {value: "",hint: "Input File Name"}
             ,startup: true
             ,codeBoxInfo: {cursorPos: {row: $Basics.round(0)
                                       ,column: $Basics.round(0)}
                           ,selections: _U.list([])
                           ,highlights: _U.list([])
                           ,annotations: _U.list([])
                           ,tooltips: _U.list([])}
             ,basicCodeBox: false
             ,errorBox: $Maybe.Nothing
             ,genSymCount: 1
             ,tool: Line(Raw)
             ,hoveredShapes: $Set.empty
             ,hoveredCrosshairs: $Set.empty
             ,selectedShapes: $Set.empty
             ,selectedFeatures: $Set.empty
             ,selectedBlobs: $Dict.empty
             ,keysDown: _U.list([])
             ,randomColor: 100
             ,lambdaTools: {ctor: "_Tuple2"
                           ,_0: 1
                           ,_1: _U.list([LambdaBounds($Lang.eVar("star"))])}};
   }();
   var SyncSelect = function (a) {
      return {ctor: "SyncSelect",_0: a};
   };
   var AdHoc = {ctor: "AdHoc"};
   var Model = function (a) {
      return function (b) {
         return function (c) {
            return function (d) {
               return function (e) {
                  return function (f) {
                     return function (g) {
                        return function (h) {
                           return function (i) {
                              return function (j) {
                                 return function (k) {
                                    return function (l) {
                                       return function (m) {
                                          return function (n) {
                                             return function (o) {
                                                return function (p) {
                                                   return function (q) {
                                                      return function (r) {
                                                         return function (s) {
                                                            return function (t) {
                                                               return function (u) {
                                                                  return function (v) {
                                                                     return function (w) {
                                                                        return function (x) {
                                                                           return function (y) {
                                                                              return function (z) {
                                                                                 return function (_1) {
                                                                                    return function (_2) {
                                                                                       return function (_3) {
                                                                                          return function (_4) {
                                                                                             return function (_5) {
                                                                                                return function (_6) {
                                                                                                   return function (_7) {
                                                                                                      return function (_8) {
                                                                                                         return function (_9) {
                                                                                                            return function (_10) {
                                                                                                               return function (_11) {
                                                                                                                  return function (_12) {
                                                                                                                     return function (_13) {
                                                                                                                        return function (_14) {
                                                                                                                           return function (_15) {
                                                                                                                              return function (_16) {
                                                                                                                                 return function (_17) {
                                                                                                                                    return function (_18) {
                                                                                                                                       return function (_19) {
                                                                                                                                          return function (_20) {
                                                                                                                                             return {scratchCode: a
                                                                                                                                                    ,exName: b
                                                                                                                                                    ,code: c
                                                                                                                                                    ,previewCode: d
                                                                                                                                                    ,history: e
                                                                                                                                                    ,inputExp: f
                                                                                                                                                    ,inputVal: g
                                                                                                                                                    ,slideNumber: h
                                                                                                                                                    ,slideCount: i
                                                                                                                                                    ,movieNumber: j
                                                                                                                                                    ,movieCount: k
                                                                                                                                                    ,movieTime: l
                                                                                                                                                    ,movieDuration: m
                                                                                                                                                    ,movieContinue: n
                                                                                                                                                    ,runAnimation: o
                                                                                                                                                    ,syncSelectTime: p
                                                                                                                                                    ,slate: q
                                                                                                                                                    ,widgets: r
                                                                                                                                                    ,mode: s
                                                                                                                                                    ,mouseMode: t
                                                                                                                                                    ,orient: u
                                                                                                                                                    ,hideCode: v
                                                                                                                                                    ,hideCanvas: w
                                                                                                                                                    ,dimensions: x
                                                                                                                                                    ,midOffsetX: y
                                                                                                                                                    ,midOffsetY: z
                                                                                                                                                    ,mouseState: _1
                                                                                                                                                    ,syncOptions: _2
                                                                                                                                                    ,caption: _3
                                                                                                                                                    ,showGhosts: _4
                                                                                                                                                    ,localSaves: _5
                                                                                                                                                    ,fieldContents: _6
                                                                                                                                                    ,startup: _7
                                                                                                                                                    ,codeBoxInfo: _8
                                                                                                                                                    ,basicCodeBox: _9
                                                                                                                                                    ,errorBox: _10
                                                                                                                                                    ,genSymCount: _11
                                                                                                                                                    ,tool: _12
                                                                                                                                                    ,hoveredShapes: _13
                                                                                                                                                    ,hoveredCrosshairs: _14
                                                                                                                                                    ,selectedShapes: _15
                                                                                                                                                    ,selectedFeatures: _16
                                                                                                                                                    ,selectedBlobs: _17
                                                                                                                                                    ,keysDown: _18
                                                                                                                                                    ,randomColor: _19
                                                                                                                                                    ,lambdaTools: _20};
                                                                                                                                          };
                                                                                                                                       };
                                                                                                                                    };
                                                                                                                                 };
                                                                                                                              };
                                                                                                                           };
                                                                                                                        };
                                                                                                                     };
                                                                                                                  };
                                                                                                               };
                                                                                                            };
                                                                                                         };
                                                                                                      };
                                                                                                   };
                                                                                                };
                                                                                             };
                                                                                          };
                                                                                       };
                                                                                    };
                                                                                 };
                                                                              };
                                                                           };
                                                                        };
                                                                     };
                                                                  };
                                                               };
                                                            };
                                                         };
                                                      };
                                                   };
                                                };
                                             };
                                          };
                                       };
                                    };
                                 };
                              };
                           };
                        };
                     };
                  };
               };
            };
         };
      };
   };
   return _elm.InterfaceModel.values = {_op: _op
                                       ,Model: Model
                                       ,AdHoc: AdHoc
                                       ,SyncSelect: SyncSelect
                                       ,Live: Live
                                       ,Print: Print
                                       ,SaveDialog: SaveDialog
                                       ,DialogInfo: DialogInfo
                                       ,CodeBoxInfo: CodeBoxInfo
                                       ,MouseNothing: MouseNothing
                                       ,MouseResizeMid: MouseResizeMid
                                       ,MouseDragZone: MouseDragZone
                                       ,MouseDrawNew: MouseDrawNew
                                       ,Vertical: Vertical
                                       ,Horizontal: Horizontal
                                       ,Cursor: Cursor
                                       ,Line: Line
                                       ,Rect: Rect
                                       ,Oval: Oval
                                       ,Poly: Poly
                                       ,Path: Path
                                       ,Text: Text
                                       ,HelperDot: HelperDot
                                       ,HelperLine: HelperLine
                                       ,Lambda: Lambda
                                       ,Raw: Raw
                                       ,Stretchy: Stretchy
                                       ,Sticky: Sticky
                                       ,LambdaBounds: LambdaBounds
                                       ,LambdaAnchor: LambdaAnchor
                                       ,Hovering: Hovering
                                       ,LangError: LangError
                                       ,HorizontalRepeat: HorizontalRepeat
                                       ,LinearRepeat: LinearRepeat
                                       ,RadialRepeat: RadialRepeat
                                       ,ClickZone: ClickZone
                                       ,MouseClickCanvas: MouseClickCanvas
                                       ,MouseIsDown: MouseIsDown
                                       ,MousePosition: MousePosition
                                       ,TickDelta: TickDelta
                                       ,PreviewCode: PreviewCode
                                       ,SelectOption: SelectOption
                                       ,CancelSync: CancelSync
                                       ,DigHole: DigHole
                                       ,MakeEqual: MakeEqual
                                       ,MakeEquidistant: MakeEquidistant
                                       ,GroupBlobs: GroupBlobs
                                       ,AbstractBlobs: AbstractBlobs
                                       ,DuplicateBlobs: DuplicateBlobs
                                       ,MergeBlobs: MergeBlobs
                                       ,ReplicateBlob: ReplicateBlob
                                       ,SwitchMode: SwitchMode
                                       ,SelectExample: SelectExample
                                       ,Run: Run
                                       ,TryParseRun: TryParseRun
                                       ,StartAnimation: StartAnimation
                                       ,Redraw: Redraw
                                       ,ToggleOutput: ToggleOutput
                                       ,NextSlide: NextSlide
                                       ,PreviousSlide: PreviousSlide
                                       ,NextMovie: NextMovie
                                       ,PreviousMovie: PreviousMovie
                                       ,SwitchOrient: SwitchOrient
                                       ,InstallSaveState: InstallSaveState
                                       ,RemoveDialog: RemoveDialog
                                       ,ToggleBasicCodeBox: ToggleBasicCodeBox
                                       ,StartResizingMid: StartResizingMid
                                       ,Undo: Undo
                                       ,Redo: Redo
                                       ,KeysDown: KeysDown
                                       ,WindowDimensions: WindowDimensions
                                       ,Noop: Noop
                                       ,UpdateFieldContents: UpdateFieldContents
                                       ,CleanCode: CleanCode
                                       ,UpdateModel: UpdateModel
                                       ,MultiEvent: MultiEvent
                                       ,WaitRun: WaitRun
                                       ,WaitSave: WaitSave
                                       ,WaitClean: WaitClean
                                       ,WaitCodeBox: WaitCodeBox
                                       ,events: events
                                       ,mkLive: mkLive
                                       ,mkLive_: mkLive_
                                       ,liveInfoToHighlights: liveInfoToHighlights
                                       ,codeToShow: codeToShow
                                       ,sampleModel: sampleModel};
};
/*!
    localForage -- Offline Storage, Improved
    Version 1.2.2
    https://mozilla.github.io/localForage
    (c) 2013-2015 Mozilla, Apache License 2.0
*/
(function() {
var define, requireModule, require, requirejs;

(function() {
  var registry = {}, seen = {};

  define = function(name, deps, callback) {
    registry[name] = { deps: deps, callback: callback };
  };

  requirejs = require = requireModule = function(name) {
  requirejs._eak_seen = registry;

    if (seen[name]) { return seen[name]; }
    seen[name] = {};

    if (!registry[name]) {
      throw new Error("Could not find module " + name);
    }

    var mod = registry[name],
        deps = mod.deps,
        callback = mod.callback,
        reified = [],
        exports;

    for (var i=0, l=deps.length; i<l; i++) {
      if (deps[i] === 'exports') {
        reified.push(exports = {});
      } else {
        reified.push(requireModule(resolve(deps[i])));
      }
    }

    var value = callback.apply(this, reified);
    return seen[name] = exports || value;

    function resolve(child) {
      if (child.charAt(0) !== '.') { return child; }
      var parts = child.split("/");
      var parentBase = name.split("/").slice(0, -1);

      for (var i=0, l=parts.length; i<l; i++) {
        var part = parts[i];

        if (part === '..') { parentBase.pop(); }
        else if (part === '.') { continue; }
        else { parentBase.push(part); }
      }

      return parentBase.join("/");
    }
  };
})();

define("promise/all",
  ["./utils","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /* global toString */

    var isArray = __dependency1__.isArray;
    var isFunction = __dependency1__.isFunction;

    /**
      Returns a promise that is fulfilled when all the given promises have been
      fulfilled, or rejected if any of them become rejected. The return promise
      is fulfilled with an array that gives all the values in the order they were
      passed in the `promises` array argument.

      Example:

      ```javascript
      var promise1 = RSVP.resolve(1);
      var promise2 = RSVP.resolve(2);
      var promise3 = RSVP.resolve(3);
      var promises = [ promise1, promise2, promise3 ];

      RSVP.all(promises).then(function(array){
        // The array here would be [ 1, 2, 3 ];
      });
      ```

      If any of the `promises` given to `RSVP.all` are rejected, the first promise
      that is rejected will be given as an argument to the returned promises's
      rejection handler. For example:

      Example:

      ```javascript
      var promise1 = RSVP.resolve(1);
      var promise2 = RSVP.reject(new Error("2"));
      var promise3 = RSVP.reject(new Error("3"));
      var promises = [ promise1, promise2, promise3 ];

      RSVP.all(promises).then(function(array){
        // Code here never runs because there are rejected promises!
      }, function(error) {
        // error.message === "2"
      });
      ```

      @method all
      @for RSVP
      @param {Array} promises
      @param {String} label
      @return {Promise} promise that is fulfilled when all `promises` have been
      fulfilled, or rejected if any of them become rejected.
    */
    function all(promises) {
      /*jshint validthis:true */
      var Promise = this;

      if (!isArray(promises)) {
        throw new TypeError('You must pass an array to all.');
      }

      return new Promise(function(resolve, reject) {
        var results = [], remaining = promises.length,
        promise;

        if (remaining === 0) {
          resolve([]);
        }

        function resolver(index) {
          return function(value) {
            resolveAll(index, value);
          };
        }

        function resolveAll(index, value) {
          results[index] = value;
          if (--remaining === 0) {
            resolve(results);
          }
        }

        for (var i = 0; i < promises.length; i++) {
          promise = promises[i];

          if (promise && isFunction(promise.then)) {
            promise.then(resolver(i), reject);
          } else {
            resolveAll(i, promise);
          }
        }
      });
    }

    __exports__.all = all;
  });
define("promise/asap",
  ["exports"],
  function(__exports__) {
    "use strict";
    var browserGlobal = (typeof window !== 'undefined') ? window : {};
    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
    var local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);

    // node
    function useNextTick() {
      return function() {
        process.nextTick(flush);
      };
    }

    function useMutationObserver() {
      var iterations = 0;
      var observer = new BrowserMutationObserver(flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    function useSetTimeout() {
      return function() {
        local.setTimeout(flush, 1);
      };
    }

    var queue = [];
    function flush() {
      for (var i = 0; i < queue.length; i++) {
        var tuple = queue[i];
        var callback = tuple[0], arg = tuple[1];
        callback(arg);
      }
      queue = [];
    }

    var scheduleFlush;

    // Decide what async method to use to triggering processing of queued callbacks:
    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      scheduleFlush = useNextTick();
    } else if (BrowserMutationObserver) {
      scheduleFlush = useMutationObserver();
    } else {
      scheduleFlush = useSetTimeout();
    }

    function asap(callback, arg) {
      var length = queue.push([callback, arg]);
      if (length === 1) {
        // If length is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        scheduleFlush();
      }
    }

    __exports__.asap = asap;
  });
define("promise/config",
  ["exports"],
  function(__exports__) {
    "use strict";
    var config = {
      instrument: false
    };

    function configure(name, value) {
      if (arguments.length === 2) {
        config[name] = value;
      } else {
        return config[name];
      }
    }

    __exports__.config = config;
    __exports__.configure = configure;
  });
define("promise/polyfill",
  ["./promise","./utils","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    /*global self*/
    var RSVPPromise = __dependency1__.Promise;
    var isFunction = __dependency2__.isFunction;

    function polyfill() {
      var local;

      if (typeof global !== 'undefined') {
        local = global;
      } else if (typeof window !== 'undefined' && window.document) {
        local = window;
      } else {
        local = self;
      }

      var es6PromiseSupport =
        "Promise" in local &&
        // Some of these methods are missing from
        // Firefox/Chrome experimental implementations
        "resolve" in local.Promise &&
        "reject" in local.Promise &&
        "all" in local.Promise &&
        "race" in local.Promise &&
        // Older version of the spec had a resolver object
        // as the arg rather than a function
        (function() {
          var resolve;
          new local.Promise(function(r) { resolve = r; });
          return isFunction(resolve);
        }());

      if (!es6PromiseSupport) {
        local.Promise = RSVPPromise;
      }
    }

    __exports__.polyfill = polyfill;
  });
define("promise/promise",
  ["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
    "use strict";
    var config = __dependency1__.config;
    var configure = __dependency1__.configure;
    var objectOrFunction = __dependency2__.objectOrFunction;
    var isFunction = __dependency2__.isFunction;
    var now = __dependency2__.now;
    var all = __dependency3__.all;
    var race = __dependency4__.race;
    var staticResolve = __dependency5__.resolve;
    var staticReject = __dependency6__.reject;
    var asap = __dependency7__.asap;

    var counter = 0;

    config.async = asap; // default async is asap;

    function Promise(resolver) {
      if (!isFunction(resolver)) {
        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
      }

      if (!(this instanceof Promise)) {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }

      this._subscribers = [];

      invokeResolver(resolver, this);
    }

    function invokeResolver(resolver, promise) {
      function resolvePromise(value) {
        resolve(promise, value);
      }

      function rejectPromise(reason) {
        reject(promise, reason);
      }

      try {
        resolver(resolvePromise, rejectPromise);
      } catch(e) {
        rejectPromise(e);
      }
    }

    function invokeCallback(settled, promise, callback, detail) {
      var hasCallback = isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        try {
          value = callback(detail);
          succeeded = true;
        } catch(e) {
          failed = true;
          error = e;
        }
      } else {
        value = detail;
        succeeded = true;
      }

      if (handleThenable(promise, value)) {
        return;
      } else if (hasCallback && succeeded) {
        resolve(promise, value);
      } else if (failed) {
        reject(promise, error);
      } else if (settled === FULFILLED) {
        resolve(promise, value);
      } else if (settled === REJECTED) {
        reject(promise, value);
      }
    }

    var PENDING   = void 0;
    var SEALED    = 0;
    var FULFILLED = 1;
    var REJECTED  = 2;

    function subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      subscribers[length] = child;
      subscribers[length + FULFILLED] = onFulfillment;
      subscribers[length + REJECTED]  = onRejection;
    }

    function publish(promise, settled) {
      var child, callback, subscribers = promise._subscribers, detail = promise._detail;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        invokeCallback(settled, child, callback, detail);
      }

      promise._subscribers = null;
    }

    Promise.prototype = {
      constructor: Promise,

      _state: undefined,
      _detail: undefined,
      _subscribers: undefined,

      then: function(onFulfillment, onRejection) {
        var promise = this;

        var thenPromise = new this.constructor(function() {});

        if (this._state) {
          var callbacks = arguments;
          config.async(function invokePromiseCallback() {
            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
          });
        } else {
          subscribe(this, thenPromise, onFulfillment, onRejection);
        }

        return thenPromise;
      },

      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };

    Promise.all = all;
    Promise.race = race;
    Promise.resolve = staticResolve;
    Promise.reject = staticReject;

    function handleThenable(promise, value) {
      var then = null,
      resolved;

      try {
        if (promise === value) {
          throw new TypeError("A promises callback cannot return that same promise.");
        }

        if (objectOrFunction(value)) {
          then = value.then;

          if (isFunction(then)) {
            then.call(value, function(val) {
              if (resolved) { return true; }
              resolved = true;

              if (value !== val) {
                resolve(promise, val);
              } else {
                fulfill(promise, val);
              }
            }, function(val) {
              if (resolved) { return true; }
              resolved = true;

              reject(promise, val);
            });

            return true;
          }
        }
      } catch (error) {
        if (resolved) { return true; }
        reject(promise, error);
        return true;
      }

      return false;
    }

    function resolve(promise, value) {
      if (promise === value) {
        fulfill(promise, value);
      } else if (!handleThenable(promise, value)) {
        fulfill(promise, value);
      }
    }

    function fulfill(promise, value) {
      if (promise._state !== PENDING) { return; }
      promise._state = SEALED;
      promise._detail = value;

      config.async(publishFulfillment, promise);
    }

    function reject(promise, reason) {
      if (promise._state !== PENDING) { return; }
      promise._state = SEALED;
      promise._detail = reason;

      config.async(publishRejection, promise);
    }

    function publishFulfillment(promise) {
      publish(promise, promise._state = FULFILLED);
    }

    function publishRejection(promise) {
      publish(promise, promise._state = REJECTED);
    }

    __exports__.Promise = Promise;
  });
define("promise/race",
  ["./utils","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /* global toString */
    var isArray = __dependency1__.isArray;

    /**
      `RSVP.race` allows you to watch a series of promises and act as soon as the
      first promise given to the `promises` argument fulfills or rejects.

      Example:

      ```javascript
      var promise1 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 1");
        }, 200);
      });

      var promise2 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 2");
        }, 100);
      });

      RSVP.race([promise1, promise2]).then(function(result){
        // result === "promise 2" because it was resolved before promise1
        // was resolved.
      });
      ```

      `RSVP.race` is deterministic in that only the state of the first completed
      promise matters. For example, even if other promises given to the `promises`
      array argument are resolved, but the first completed promise has become
      rejected before the other promises became fulfilled, the returned promise
      will become rejected:

      ```javascript
      var promise1 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 1");
        }, 200);
      });

      var promise2 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          reject(new Error("promise 2"));
        }, 100);
      });

      RSVP.race([promise1, promise2]).then(function(result){
        // Code here never runs because there are rejected promises!
      }, function(reason){
        // reason.message === "promise2" because promise 2 became rejected before
        // promise 1 became fulfilled
      });
      ```

      @method race
      @for RSVP
      @param {Array} promises array of promises to observe
      @param {String} label optional string for describing the promise returned.
      Useful for tooling.
      @return {Promise} a promise that becomes fulfilled with the value the first
      completed promises is resolved with if the first completed promise was
      fulfilled, or rejected with the reason that the first completed promise
      was rejected with.
    */
    function race(promises) {
      /*jshint validthis:true */
      var Promise = this;

      if (!isArray(promises)) {
        throw new TypeError('You must pass an array to race.');
      }
      return new Promise(function(resolve, reject) {
        var results = [], promise;

        for (var i = 0; i < promises.length; i++) {
          promise = promises[i];

          if (promise && typeof promise.then === 'function') {
            promise.then(resolve, reject);
          } else {
            resolve(promise);
          }
        }
      });
    }

    __exports__.race = race;
  });
define("promise/reject",
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      `RSVP.reject` returns a promise that will become rejected with the passed
      `reason`. `RSVP.reject` is essentially shorthand for the following:

      ```javascript
      var promise = new RSVP.Promise(function(resolve, reject){
        reject(new Error('WHOOPS'));
      });

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      Instead of writing the above, your code now simply becomes the following:

      ```javascript
      var promise = RSVP.reject(new Error('WHOOPS'));

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      @method reject
      @for RSVP
      @param {Any} reason value that the returned promise will be rejected with.
      @param {String} label optional string for identifying the returned promise.
      Useful for tooling.
      @return {Promise} a promise that will become rejected with the given
      `reason`.
    */
    function reject(reason) {
      /*jshint validthis:true */
      var Promise = this;

      return new Promise(function (resolve, reject) {
        reject(reason);
      });
    }

    __exports__.reject = reject;
  });
define("promise/resolve",
  ["exports"],
  function(__exports__) {
    "use strict";
    function resolve(value) {
      /*jshint validthis:true */
      if (value && typeof value === 'object' && value.constructor === this) {
        return value;
      }

      var Promise = this;

      return new Promise(function(resolve) {
        resolve(value);
      });
    }

    __exports__.resolve = resolve;
  });
define("promise/utils",
  ["exports"],
  function(__exports__) {
    "use strict";
    function objectOrFunction(x) {
      return isFunction(x) || (typeof x === "object" && x !== null);
    }

    function isFunction(x) {
      return typeof x === "function";
    }

    function isArray(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    }

    // Date.now is not available in browsers < IE9
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
    var now = Date.now || function() { return new Date().getTime(); };


    __exports__.objectOrFunction = objectOrFunction;
    __exports__.isFunction = isFunction;
    __exports__.isArray = isArray;
    __exports__.now = now;
  });
requireModule('promise/polyfill').polyfill();
}());(function() {
    'use strict';

    // Sadly, the best way to save binary data in WebSQL/localStorage is serializing
    // it to Base64, so this is how we store it to prevent very strange errors with less
    // verbose ways of binary <-> string data storage.
    var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    var SERIALIZED_MARKER = '__lfsc__:';
    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

    // OMG the serializations!
    var TYPE_ARRAYBUFFER = 'arbf';
    var TYPE_BLOB = 'blob';
    var TYPE_INT8ARRAY = 'si08';
    var TYPE_UINT8ARRAY = 'ui08';
    var TYPE_UINT8CLAMPEDARRAY = 'uic8';
    var TYPE_INT16ARRAY = 'si16';
    var TYPE_INT32ARRAY = 'si32';
    var TYPE_UINT16ARRAY = 'ur16';
    var TYPE_UINT32ARRAY = 'ui32';
    var TYPE_FLOAT32ARRAY = 'fl32';
    var TYPE_FLOAT64ARRAY = 'fl64';
    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH +
                                        TYPE_ARRAYBUFFER.length;

    // Serialize a value, afterwards executing a callback (which usually
    // instructs the `setItem()` callback/promise to be executed). This is how
    // we store binary data with localStorage.
    function serialize(value, callback) {
        var valueString = '';
        if (value) {
            valueString = value.toString();
        }

        // Cannot use `value instanceof ArrayBuffer` or such here, as these
        // checks fail when running the tests using casper.js...
        //
        // TODO: See why those tests fail and use a better solution.
        if (value && (value.toString() === '[object ArrayBuffer]' ||
                      value.buffer &&
                      value.buffer.toString() === '[object ArrayBuffer]')) {
            // Convert binary arrays to a string and prefix the string with
            // a special marker.
            var buffer;
            var marker = SERIALIZED_MARKER;

            if (value instanceof ArrayBuffer) {
                buffer = value;
                marker += TYPE_ARRAYBUFFER;
            } else {
                buffer = value.buffer;

                if (valueString === '[object Int8Array]') {
                    marker += TYPE_INT8ARRAY;
                } else if (valueString === '[object Uint8Array]') {
                    marker += TYPE_UINT8ARRAY;
                } else if (valueString === '[object Uint8ClampedArray]') {
                    marker += TYPE_UINT8CLAMPEDARRAY;
                } else if (valueString === '[object Int16Array]') {
                    marker += TYPE_INT16ARRAY;
                } else if (valueString === '[object Uint16Array]') {
                    marker += TYPE_UINT16ARRAY;
                } else if (valueString === '[object Int32Array]') {
                    marker += TYPE_INT32ARRAY;
                } else if (valueString === '[object Uint32Array]') {
                    marker += TYPE_UINT32ARRAY;
                } else if (valueString === '[object Float32Array]') {
                    marker += TYPE_FLOAT32ARRAY;
                } else if (valueString === '[object Float64Array]') {
                    marker += TYPE_FLOAT64ARRAY;
                } else {
                    callback(new Error('Failed to get type for BinaryArray'));
                }
            }

            callback(marker + bufferToString(buffer));
        } else if (valueString === '[object Blob]') {
            // Conver the blob to a binaryArray and then to a string.
            var fileReader = new FileReader();

            fileReader.onload = function() {
                var str = bufferToString(this.result);

                callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };

            fileReader.readAsArrayBuffer(value);
        } else {
            try {
                callback(JSON.stringify(value));
            } catch (e) {
                window.console.error("Couldn't convert value into a JSON " +
                                     'string: ', value);

                callback(null, e);
            }
        }
    }

    // Deserialize data we've inserted into a value column/field. We place
    // special markers into our strings to mark them as encoded; this isn't
    // as nice as a meta field, but it's the only sane thing we can do whilst
    // keeping localStorage support intact.
    //
    // Oftentimes this will just deserialize JSON content, but if we have a
    // special marker (SERIALIZED_MARKER, defined above), we will extract
    // some kind of arraybuffer/binary data/typed array out of the string.
    function deserialize(value) {
        // If we haven't marked this string as being specially serialized (i.e.
        // something other than serialized JSON), we can just return it and be
        // done with it.
        if (value.substring(0,
            SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
        }

        // The following code deals with deserializing some kind of Blob or
        // TypedArray. First we separate out the type of data we're dealing
        // with from the data itself.
        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type = value.substring(SERIALIZED_MARKER_LENGTH,
                                   TYPE_SERIALIZED_MARKER_LENGTH);

        var buffer = stringToBuffer(serializedString);

        // Return the right type based on the code/type set during
        // serialization.
        switch (type) {
            case TYPE_ARRAYBUFFER:
                return buffer;
            case TYPE_BLOB:
                return new Blob([buffer]);
            case TYPE_INT8ARRAY:
                return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
                return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
                return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
                return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
                return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
                return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
                return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
                return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
                return new Float64Array(buffer);
            default:
                throw new Error('Unkown type: ' + type);
        }
    }

    function stringToBuffer(serializedString) {
        // Fill the string into a ArrayBuffer.
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i;
        var p = 0;
        var encoded1, encoded2, encoded3, encoded4;

        if (serializedString[serializedString.length - 1] === '=') {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === '=') {
                bufferLength--;
            }
        }

        var buffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer);

        for (i = 0; i < len; i+=4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i+1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i+2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i+3]);

            /*jslint bitwise: true */
            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }
        return buffer;
    }

    // Converts a buffer to a string to store, serialized, in the backend
    // storage library.
    function bufferToString(buffer) {
        // base64-arraybuffer
        var bytes = new Uint8Array(buffer);
        var base64String = '';
        var i;

        for (i = 0; i < bytes.length; i += 3) {
            /*jslint bitwise: true */
            base64String += BASE_CHARS[bytes[i] >> 2];
            base64String += BASE_CHARS[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
            base64String += BASE_CHARS[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
            base64String += BASE_CHARS[bytes[i + 2] & 63];
        }

        if ((bytes.length % 3) === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + '=';
        } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + '==';
        }

        return base64String;
    }

    var localforageSerializer = {
        serialize: serialize,
        deserialize: deserialize,
        stringToBuffer: stringToBuffer,
        bufferToString: bufferToString
    };

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = localforageSerializer;
    } else if (typeof define === 'function' && define.amd) {
        define('localforageSerializer', function() {
            return localforageSerializer;
        });
    } else {
        this.localforageSerializer = localforageSerializer;
    }
}).call(window);
// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).
(function() {
    'use strict';

    // Originally found in https://github.com/mozilla-b2g/gaia/blob/e8f624e4cc9ea945727278039b3bc9bcb9f8667a/shared/js/async_storage.js

    // Promises!
    var Promise = (typeof module !== 'undefined' && module.exports) ?
                  require('promise') : this.Promise;

    // Initialize IndexedDB; fall back to vendor-prefixed versions if needed.
    var indexedDB = indexedDB || this.indexedDB || this.webkitIndexedDB ||
                    this.mozIndexedDB || this.OIndexedDB ||
                    this.msIndexedDB;

    // If IndexedDB isn't available, we get outta here!
    if (!indexedDB) {
        return;
    }

    // Open the IndexedDB database (automatically creates one if one didn't
    // previously exist), using any options set in the config.
    function _initStorage(options) {
        var self = this;
        var dbInfo = {
            db: null
        };

        if (options) {
            for (var i in options) {
                dbInfo[i] = options[i];
            }
        }

        return new Promise(function(resolve, reject) {
            var openreq = indexedDB.open(dbInfo.name, dbInfo.version);
            openreq.onerror = function() {
                reject(openreq.error);
            };
            openreq.onupgradeneeded = function() {
                // First time setup: create an empty object store
                openreq.result.createObjectStore(dbInfo.storeName);
            };
            openreq.onsuccess = function() {
                dbInfo.db = openreq.result;
                self._dbInfo = dbInfo;
                resolve();
            };
        });
    }

    function getItem(key, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')
                    .objectStore(dbInfo.storeName);
                var req = store.get(key);

                req.onsuccess = function() {
                    var value = req.result;
                    if (value === undefined) {
                        value = null;
                    }

                    resolve(value);
                };

                req.onerror = function() {
                    reject(req.error);
                };
            })["catch"](reject);
        });

        executeDeferedCallback(promise, callback);
        return promise;
    }

    // Iterate over all items stored in database.
    function iterate(iterator, callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')
                                     .objectStore(dbInfo.storeName);

                var req = store.openCursor();
                var iterationNumber = 1;

                req.onsuccess = function() {
                    var cursor = req.result;

                    if (cursor) {
                        var result = iterator(cursor.value, cursor.key, iterationNumber++);

                        if (result !== void(0)) {
                            resolve(result);
                        } else {
                            cursor["continue"]();
                        }
                    } else {
                        resolve();
                    }
                };

                req.onerror = function() {
                    reject(req.error);
                };
            })["catch"](reject);
        });

        executeDeferedCallback(promise, callback);

        return promise;
    }

    function setItem(key, value, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
                var store = transaction.objectStore(dbInfo.storeName);

                // The reason we don't _save_ null is because IE 10 does
                // not support saving the `null` type in IndexedDB. How
                // ironic, given the bug below!
                // See: https://github.com/mozilla/localForage/issues/161
                if (value === null) {
                    value = undefined;
                }

                var req = store.put(value, key);
                transaction.oncomplete = function() {
                    // Cast to undefined so the value passed to
                    // callback/promise is the same as what one would get out
                    // of `getItem()` later. This leads to some weirdness
                    // (setItem('foo', undefined) will return `null`), but
                    // it's not my fault localStorage is our baseline and that
                    // it's weird.
                    if (value === undefined) {
                        value = null;
                    }

                    resolve(value);
                };
                transaction.onabort = transaction.onerror = function() {
                    reject(req.error);
                };
            })["catch"](reject);
        });

        executeDeferedCallback(promise, callback);
        return promise;
    }

    function removeItem(key, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
                var store = transaction.objectStore(dbInfo.storeName);

                // We use a Grunt task to make this safe for IE and some
                // versions of Android (including those used by Cordova).
                // Normally IE won't like `.delete()` and will insist on
                // using `['delete']()`, but we have a build step that
                // fixes this for us now.
                var req = store["delete"](key);
                transaction.oncomplete = function() {
                    resolve();
                };

                transaction.onerror = function() {
                    reject(req.error);
                };

                // The request will be aborted if we've exceeded our storage
                // space. In this case, we will reject with a specific
                // "QuotaExceededError".
                transaction.onabort = function(event) {
                    var error = event.target.error;
                    if (error === 'QuotaExceededError') {
                        reject(error);
                    }
                };
            })["catch"](reject);
        });

        executeDeferedCallback(promise, callback);
        return promise;
    }

    function clear(callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
                var store = transaction.objectStore(dbInfo.storeName);
                var req = store.clear();

                transaction.oncomplete = function() {
                    resolve();
                };

                transaction.onabort = transaction.onerror = function() {
                    reject(req.error);
                };
            })["catch"](reject);
        });

        executeDeferedCallback(promise, callback);
        return promise;
    }

    function length(callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')
                              .objectStore(dbInfo.storeName);
                var req = store.count();

                req.onsuccess = function() {
                    resolve(req.result);
                };

                req.onerror = function() {
                    reject(req.error);
                };
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    function key(n, callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            if (n < 0) {
                resolve(null);

                return;
            }

            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')
                              .objectStore(dbInfo.storeName);

                var advanced = false;
                var req = store.openCursor();
                req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                        // this means there weren't enough keys
                        resolve(null);

                        return;
                    }

                    if (n === 0) {
                        // We have the first key, return it if that's what they
                        // wanted.
                        resolve(cursor.key);
                    } else {
                        if (!advanced) {
                            // Otherwise, ask the cursor to skip ahead n
                            // records.
                            advanced = true;
                            cursor.advance(n);
                        } else {
                            // When we get here, we've got the nth key.
                            resolve(cursor.key);
                        }
                    }
                };

                req.onerror = function() {
                    reject(req.error);
                };
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    function keys(callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')
                              .objectStore(dbInfo.storeName);

                var req = store.openCursor();
                var keys = [];

                req.onsuccess = function() {
                    var cursor = req.result;

                    if (!cursor) {
                        resolve(keys);
                        return;
                    }

                    keys.push(cursor.key);
                    cursor["continue"]();
                };

                req.onerror = function() {
                    reject(req.error);
                };
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    function executeCallback(promise, callback) {
        if (callback) {
            promise.then(function(result) {
                callback(null, result);
            }, function(error) {
                callback(error);
            });
        }
    }

    function executeDeferedCallback(promise, callback) {
        if (callback) {
            promise.then(function(result) {
                deferCallback(callback, result);
            }, function(error) {
                callback(error);
            });
        }
    }

    // Under Chrome the callback is called before the changes (save, clear)
    // are actually made. So we use a defer function which wait that the
    // call stack to be empty.
    // For more info : https://github.com/mozilla/localForage/issues/175
    // Pull request : https://github.com/mozilla/localForage/pull/178
    function deferCallback(callback, result) {
        if (callback) {
            return setTimeout(function() {
                return callback(null, result);
            }, 0);
        }
    }

    var asyncStorage = {
        _driver: 'asyncStorage',
        _initStorage: _initStorage,
        iterate: iterate,
        getItem: getItem,
        setItem: setItem,
        removeItem: removeItem,
        clear: clear,
        length: length,
        key: key,
        keys: keys
    };

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = asyncStorage;
    } else if (typeof define === 'function' && define.amd) {
        define('asyncStorage', function() {
            return asyncStorage;
        });
    } else {
        this.asyncStorage = asyncStorage;
    }
}).call(window);
// If IndexedDB isn't available, we'll fall back to localStorage.
// Note that this will have considerable performance and storage
// side-effects (all data will be serialized on save and only data that
// can be converted to a string via `JSON.stringify()` will be saved).
(function() {
    'use strict';

    // Promises!
    var Promise = (typeof module !== 'undefined' && module.exports) ?
                  require('promise') : this.Promise;

    var globalObject = this;
    var serializer = null;
    var localStorage = null;

    // If the app is running inside a Google Chrome packaged webapp, or some
    // other context where localStorage isn't available, we don't use
    // localStorage. This feature detection is preferred over the old
    // `if (window.chrome && window.chrome.runtime)` code.
    // See: https://github.com/mozilla/localForage/issues/68
    try {
        // If localStorage isn't available, we get outta here!
        // This should be inside a try catch
        if (!this.localStorage || !('setItem' in this.localStorage)) {
            return;
        }
        // Initialize localStorage and create a variable to use throughout
        // the code.
        localStorage = this.localStorage;
    } catch (e) {
        return;
    }

    var ModuleType = {
        DEFINE: 1,
        EXPORT: 2,
        WINDOW: 3
    };

    // Attaching to window (i.e. no module loader) is the assumed,
    // simple default.
    var moduleType = ModuleType.WINDOW;

    // Find out what kind of module setup we have; if none, we'll just attach
    // localForage to the main window.
    if (typeof module !== 'undefined' && module.exports) {
        moduleType = ModuleType.EXPORT;
    } else if (typeof define === 'function' && define.amd) {
        moduleType = ModuleType.DEFINE;
    }

    // Config the localStorage backend, using options set in the config.
    function _initStorage(options) {
        var self = this;
        var dbInfo = {};
        if (options) {
            for (var i in options) {
                dbInfo[i] = options[i];
            }
        }

        dbInfo.keyPrefix = dbInfo.name + '/';

        self._dbInfo = dbInfo;

        var serializerPromise = new Promise(function(resolve/*, reject*/) {
            // We allow localForage to be declared as a module or as a
            // library available without AMD/require.js.
            if (moduleType === ModuleType.DEFINE) {
                require(['localforageSerializer'], resolve);
            } else if (moduleType === ModuleType.EXPORT) {
                // Making it browserify friendly
                resolve(require('./../utils/serializer'));
            } else {
                resolve(globalObject.localforageSerializer);
            }
        });

        return serializerPromise.then(function(lib) {
            serializer = lib;
            return Promise.resolve();
        });
    }

    // Remove all keys from the datastore, effectively destroying all data in
    // the app's key/value store!
    function clear(callback) {
        var self = this;
        var promise = self.ready().then(function() {
            var keyPrefix = self._dbInfo.keyPrefix;

            for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);

                if (key.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key);
                }
            }
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Retrieve an item from the store. Unlike the original async_storage
    // library in Gaia, we don't modify return values at all. If a key's value
    // is `undefined`, we pass that value to the callback function.
    function getItem(key, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = self.ready().then(function() {
            var dbInfo = self._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key);

            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the key
            // is likely undefined and we'll pass it straight to the
            // callback.
            if (result) {
                result = serializer.deserialize(result);
            }

            return result;
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Iterate over all items in the store.
    function iterate(iterator, callback) {
        var self = this;

        var promise = self.ready().then(function() {
            var keyPrefix = self._dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length = localStorage.length;

            for (var i = 0; i < length; i++) {
                var key = localStorage.key(i);
                var value = localStorage.getItem(key);

                // If a result was found, parse it from the serialized
                // string into a JS object. If result isn't truthy, the
                // key is likely undefined and we'll pass it straight
                // to the iterator.
                if (value) {
                    value = serializer.deserialize(value);
                }

                value = iterator(value, key.substring(keyPrefixLength), i + 1);

                if (value !== void(0)) {
                    return value;
                }
            }
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Same as localStorage's key() method, except takes a callback.
    function key(n, callback) {
        var self = this;
        var promise = self.ready().then(function() {
            var dbInfo = self._dbInfo;
            var result;
            try {
                result = localStorage.key(n);
            } catch (error) {
                result = null;
            }

            // Remove the prefix from the key, if a key is found.
            if (result) {
                result = result.substring(dbInfo.keyPrefix.length);
            }

            return result;
        });

        executeCallback(promise, callback);
        return promise;
    }

    function keys(callback) {
        var self = this;
        var promise = self.ready().then(function() {
            var dbInfo = self._dbInfo;
            var length = localStorage.length;
            var keys = [];

            for (var i = 0; i < length; i++) {
                if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {
                    keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));
                }
            }

            return keys;
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Supply the number of keys in the datastore to the callback function.
    function length(callback) {
        var self = this;
        var promise = self.keys().then(function(keys) {
            return keys.length;
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Remove an item from the store, nice and simple.
    function removeItem(key, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = self.ready().then(function() {
            var dbInfo = self._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key);
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Set a key's value and run an optional callback once the value is set.
    // Unlike Gaia's implementation, the callback function is passed the value,
    // in case you want to operate on that value only after you're sure it
    // saved, or something like that.
    function setItem(key, value, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = self.ready().then(function() {
            // Convert undefined values to null.
            // https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
                value = null;
            }

            // Save the original value to pass to the callback.
            var originalValue = value;

            return new Promise(function(resolve, reject) {
                serializer.serialize(value, function(value, error) {
                    if (error) {
                        reject(error);
                    } else {
                        try {
                            var dbInfo = self._dbInfo;
                            localStorage.setItem(dbInfo.keyPrefix + key, value);
                            resolve(originalValue);
                        } catch (e) {
                            // localStorage capacity exceeded.
                            // TODO: Make this a specific error/event.
                            if (e.name === 'QuotaExceededError' ||
                                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                                reject(e);
                            }
                            reject(e);
                        }
                    }
                });
            });
        });

        executeCallback(promise, callback);
        return promise;
    }

    function executeCallback(promise, callback) {
        if (callback) {
            promise.then(function(result) {
                callback(null, result);
            }, function(error) {
                callback(error);
            });
        }
    }

    var localStorageWrapper = {
        _driver: 'localStorageWrapper',
        _initStorage: _initStorage,
        // Default API, from Gaia/localStorage.
        iterate: iterate,
        getItem: getItem,
        setItem: setItem,
        removeItem: removeItem,
        clear: clear,
        length: length,
        key: key,
        keys: keys
    };

    if (moduleType === ModuleType.EXPORT) {
        module.exports = localStorageWrapper;
    } else if (moduleType === ModuleType.DEFINE) {
        define('localStorageWrapper', function() {
            return localStorageWrapper;
        });
    } else {
        this.localStorageWrapper = localStorageWrapper;
    }
}).call(window);
/*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function() {
    'use strict';

    // Promises!
    var Promise = (typeof module !== 'undefined' && module.exports) ?
                  require('promise') : this.Promise;

    var globalObject = this;
    var serializer = null;
    var openDatabase = this.openDatabase;

    // If WebSQL methods aren't available, we can stop now.
    if (!openDatabase) {
        return;
    }

    var ModuleType = {
        DEFINE: 1,
        EXPORT: 2,
        WINDOW: 3
    };

    // Attaching to window (i.e. no module loader) is the assumed,
    // simple default.
    var moduleType = ModuleType.WINDOW;

    // Find out what kind of module setup we have; if none, we'll just attach
    // localForage to the main window.
    if (typeof module !== 'undefined' && module.exports) {
        moduleType = ModuleType.EXPORT;
    } else if (typeof define === 'function' && define.amd) {
        moduleType = ModuleType.DEFINE;
    }

    // Open the WebSQL database (automatically creates one if one didn't
    // previously exist), using any options set in the config.
    function _initStorage(options) {
        var self = this;
        var dbInfo = {
            db: null
        };

        if (options) {
            for (var i in options) {
                dbInfo[i] = typeof(options[i]) !== 'string' ?
                            options[i].toString() : options[i];
            }
        }

        var serializerPromise = new Promise(function(resolve/*, reject*/) {
            // We allow localForage to be declared as a module or as a
            // library available without AMD/require.js.
            if (moduleType === ModuleType.DEFINE) {
                require(['localforageSerializer'], resolve);
            } else if (moduleType === ModuleType.EXPORT) {
                // Making it browserify friendly
                resolve(require('./../utils/serializer'));
            } else {
                resolve(globalObject.localforageSerializer);
            }
        });

        var dbInfoPromise = new Promise(function(resolve, reject) {
            // Open the database; the openDatabase API will automatically
            // create it for us if it doesn't exist.
            try {
                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version),
                                         dbInfo.description, dbInfo.size);
            } catch (e) {
                return self.setDriver(self.LOCALSTORAGE).then(function() {
    return self._initStorage(options);
}).then(resolve)["catch"](reject);
            }

            // Create our key/value table if it doesn't exist.
            dbInfo.db.transaction(function(t) {
                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName +
                             ' (id INTEGER PRIMARY KEY, key unique, value)', [],
                             function() {
                    self._dbInfo = dbInfo;
                    resolve();
                }, function(t, error) {
                    reject(error);
                });
            });
        });

        return serializerPromise.then(function(lib) {
            serializer = lib;
            return dbInfoPromise;
        });
    }

    function getItem(key, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                    t.executeSql('SELECT * FROM ' + dbInfo.storeName +
                                 ' WHERE key = ? LIMIT 1', [key],
                                 function(t, results) {
                        var result = results.rows.length ?
                                     results.rows.item(0).value : null;

                        // Check to see if this is serialized content we need to
                        // unpack.
                        if (result) {
                            result = serializer.deserialize(result);
                        }

                        resolve(result);
                    }, function(t, error) {

                        reject(error);
                    });
                });
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    function iterate(iterator, callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;

                dbInfo.db.transaction(function(t) {
                    t.executeSql('SELECT * FROM ' + dbInfo.storeName, [],
                        function(t, results) {
                            var rows = results.rows;
                            var length = rows.length;

                            for (var i = 0; i < length; i++) {
                                var item = rows.item(i);
                                var result = item.value;

                                // Check to see if this is serialized content
                                // we need to unpack.
                                if (result) {
                                    result = serializer.deserialize(result);
                                }

                                result = iterator(result, item.key, i + 1);

                                // void(0) prevents problems with redefinition
                                // of `undefined`.
                                if (result !== void(0)) {
                                    resolve(result);
                                    return;
                                }
                            }

                            resolve();
                        }, function(t, error) {
                            reject(error);
                        });
                });
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    function setItem(key, value, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                // The localStorage API doesn't return undefined values in an
                // "expected" way, so undefined is always cast to null in all
                // drivers. See: https://github.com/mozilla/localForage/pull/42
                if (value === undefined) {
                    value = null;
                }

                // Save the original value to pass to the callback.
                var originalValue = value;

                serializer.serialize(value, function(value, error) {
                    if (error) {
                        reject(error);
                    } else {
                        var dbInfo = self._dbInfo;
                        dbInfo.db.transaction(function(t) {
                            t.executeSql('INSERT OR REPLACE INTO ' +
                                         dbInfo.storeName +
                                         ' (key, value) VALUES (?, ?)',
                                         [key, value], function() {
                                resolve(originalValue);
                            }, function(t, error) {
                                reject(error);
                            });
                        }, function(sqlError) { // The transaction failed; check
                                                // to see if it's a quota error.
                            if (sqlError.code === sqlError.QUOTA_ERR) {
                                // We reject the callback outright for now, but
                                // it's worth trying to re-run the transaction.
                                // Even if the user accepts the prompt to use
                                // more storage on Safari, this error will
                                // be called.
                                //
                                // TODO: Try to re-run the transaction.
                                reject(sqlError);
                            }
                        });
                    }
                });
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    function removeItem(key, callback) {
        var self = this;

        // Cast the key to a string, as that's all we can set as a key.
        if (typeof key !== 'string') {
            window.console.warn(key +
                                ' used as a key, but it is not a string.');
            key = String(key);
        }

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                    t.executeSql('DELETE FROM ' + dbInfo.storeName +
                                 ' WHERE key = ?', [key], function() {

                        resolve();
                    }, function(t, error) {

                        reject(error);
                    });
                });
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Deletes every item in the table.
    // TODO: Find out if this resets the AUTO_INCREMENT number.
    function clear(callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                    t.executeSql('DELETE FROM ' + dbInfo.storeName, [],
                                 function() {
                        resolve();
                    }, function(t, error) {
                        reject(error);
                    });
                });
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Does a simple `COUNT(key)` to get the number of items stored in
    // localForage.
    function length(callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                    // Ahhh, SQL makes this one soooooo easy.
                    t.executeSql('SELECT COUNT(key) as c FROM ' +
                                 dbInfo.storeName, [], function(t, results) {
                        var result = results.rows.item(0).c;

                        resolve(result);
                    }, function(t, error) {

                        reject(error);
                    });
                });
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    // Return the key located at key index X; essentially gets the key from a
    // `WHERE id = ?`. This is the most efficient way I can think to implement
    // this rarely-used (in my experience) part of the API, but it can seem
    // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
    // the ID of each key will change every time it's updated. Perhaps a stored
    // procedure for the `setItem()` SQL would solve this problem?
    // TODO: Don't change ID on `setItem()`.
    function key(n, callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                    t.executeSql('SELECT key FROM ' + dbInfo.storeName +
                                 ' WHERE id = ? LIMIT 1', [n + 1],
                                 function(t, results) {
                        var result = results.rows.length ?
                                     results.rows.item(0).key : null;
                        resolve(result);
                    }, function(t, error) {
                        reject(error);
                    });
                });
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    function keys(callback) {
        var self = this;

        var promise = new Promise(function(resolve, reject) {
            self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                    t.executeSql('SELECT key FROM ' + dbInfo.storeName, [],
                                 function(t, results) {
                        var keys = [];

                        for (var i = 0; i < results.rows.length; i++) {
                            keys.push(results.rows.item(i).key);
                        }

                        resolve(keys);
                    }, function(t, error) {

                        reject(error);
                    });
                });
            })["catch"](reject);
        });

        executeCallback(promise, callback);
        return promise;
    }

    function executeCallback(promise, callback) {
        if (callback) {
            promise.then(function(result) {
                callback(null, result);
            }, function(error) {
                callback(error);
            });
        }
    }

    var webSQLStorage = {
        _driver: 'webSQLStorage',
        _initStorage: _initStorage,
        iterate: iterate,
        getItem: getItem,
        setItem: setItem,
        removeItem: removeItem,
        clear: clear,
        length: length,
        key: key,
        keys: keys
    };

    if (moduleType === ModuleType.DEFINE) {
        define('webSQLStorage', function() {
            return webSQLStorage;
        });
    } else if (moduleType === ModuleType.EXPORT) {
        module.exports = webSQLStorage;
    } else {
        this.webSQLStorage = webSQLStorage;
    }
}).call(window);
(function() {
    'use strict';

    // Promises!
    var Promise = (typeof module !== 'undefined' && module.exports) ?
                  require('promise') : this.Promise;

    // Custom drivers are stored here when `defineDriver()` is called.
    // They are shared across all instances of localForage.
    var CustomDrivers = {};

    var DriverType = {
        INDEXEDDB: 'asyncStorage',
        LOCALSTORAGE: 'localStorageWrapper',
        WEBSQL: 'webSQLStorage'
    };

    var DefaultDriverOrder = [
        DriverType.INDEXEDDB,
        DriverType.WEBSQL,
        DriverType.LOCALSTORAGE
    ];

    var LibraryMethods = [
        'clear',
        'getItem',
        'iterate',
        'key',
        'keys',
        'length',
        'removeItem',
        'setItem'
    ];

    var ModuleType = {
        DEFINE: 1,
        EXPORT: 2,
        WINDOW: 3
    };

    var DefaultConfig = {
        description: '',
        driver: DefaultDriverOrder.slice(),
        name: 'localforage',
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: 'keyvaluepairs',
        version: 1.0
    };

    // Attaching to window (i.e. no module loader) is the assumed,
    // simple default.
    var moduleType = ModuleType.WINDOW;

    // Find out what kind of module setup we have; if none, we'll just attach
    // localForage to the main window.
    if (typeof module !== 'undefined' && module.exports) {
        moduleType = ModuleType.EXPORT;
    } else if (typeof define === 'function' && define.amd) {
        moduleType = ModuleType.DEFINE;
    }

    // Check to see if IndexedDB is available and if it is the latest
    // implementation; it's our preferred backend library. We use "_spec_test"
    // as the name of the database because it's not the one we'll operate on,
    // but it's useful to make sure its using the right spec.
    // See: https://github.com/mozilla/localForage/issues/128
    var driverSupport = (function(self) {
        // Initialize IndexedDB; fall back to vendor-prefixed versions
        // if needed.
        var indexedDB = indexedDB || self.indexedDB || self.webkitIndexedDB ||
                        self.mozIndexedDB || self.OIndexedDB ||
                        self.msIndexedDB;

        var result = {};

        result[DriverType.WEBSQL] = !!self.openDatabase;
        result[DriverType.INDEXEDDB] = !!(function() {
            // We mimic PouchDB here; just UA test for Safari (which, as of
            // iOS 8/Yosemite, doesn't properly support IndexedDB).
            // IndexedDB support is broken and different from Blink's.
            // This is faster than the test case (and it's sync), so we just
            // do this. *SIGH*
            // http://bl.ocks.org/nolanlawson/raw/c83e9039edf2278047e9/
            //
            // We test for openDatabase because IE Mobile identifies itself
            // as Safari. Oh the lulz...
            if (typeof self.openDatabase !== 'undefined' && self.navigator &&
                self.navigator.userAgent &&
                /Safari/.test(self.navigator.userAgent) &&
                !/Chrome/.test(self.navigator.userAgent)) {
                return false;
            }
            try {
                return indexedDB &&
                       typeof indexedDB.open === 'function' &&
                       // Some Samsung/HTC Android 4.0-4.3 devices
                       // have older IndexedDB specs; if this isn't available
                       // their IndexedDB is too old for us to use.
                       // (Replaces the onupgradeneeded test.)
                       typeof self.IDBKeyRange !== 'undefined';
            } catch (e) {
                return false;
            }
        })();

        result[DriverType.LOCALSTORAGE] = !!(function() {
            try {
                return (self.localStorage &&
                        ('setItem' in self.localStorage) &&
                        (self.localStorage.setItem));
            } catch (e) {
                return false;
            }
        })();

        return result;
    })(this);

    var isArray = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };

    function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
                return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
        };
    }

    function extend() {
        for (var i = 1; i < arguments.length; i++) {
            var arg = arguments[i];

            if (arg) {
                for (var key in arg) {
                    if (arg.hasOwnProperty(key)) {
                        if (isArray(arg[key])) {
                            arguments[0][key] = arg[key].slice();
                        } else {
                            arguments[0][key] = arg[key];
                        }
                    }
                }
            }
        }

        return arguments[0];
    }

    function isLibraryDriver(driverName) {
        for (var driver in DriverType) {
            if (DriverType.hasOwnProperty(driver) &&
                DriverType[driver] === driverName) {
                return true;
            }
        }

        return false;
    }

    var globalObject = this;

    function LocalForage(options) {
        this._config = extend({}, DefaultConfig, options);
        this._driverSet = null;
        this._ready = false;
        this._dbInfo = null;

        // Add a stub for each driver API method that delays the call to the
        // corresponding driver method until localForage is ready. These stubs
        // will be replaced by the driver methods as soon as the driver is
        // loaded, so there is no performance impact.
        for (var i = 0; i < LibraryMethods.length; i++) {
            callWhenReady(this, LibraryMethods[i]);
        }

        this.setDriver(this._config.driver);
    }

    LocalForage.prototype.INDEXEDDB = DriverType.INDEXEDDB;
    LocalForage.prototype.LOCALSTORAGE = DriverType.LOCALSTORAGE;
    LocalForage.prototype.WEBSQL = DriverType.WEBSQL;

    // Set any config values for localForage; can be called anytime before
    // the first API call (e.g. `getItem`, `setItem`).
    // We loop through options so we don't overwrite existing config
    // values.
    LocalForage.prototype.config = function(options) {
        // If the options argument is an object, we use it to set values.
        // Otherwise, we return either a specified config value or all
        // config values.
        if (typeof(options) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
                return new Error("Can't call config() after localforage " +
                                 'has been used.');
            }

            for (var i in options) {
                if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                }

                this._config[i] = options[i];
            }

            // after all config options are set and
            // the driver option is used, try setting it
            if ('driver' in options && options.driver) {
                this.setDriver(this._config.driver);
            }

            return true;
        } else if (typeof(options) === 'string') {
            return this._config[options];
        } else {
            return this._config;
        }
    };

    // Used to define a custom driver, shared across all instances of
    // localForage.
    LocalForage.prototype.defineDriver = function(driverObject, callback,
                                                  errorCallback) {
        var defineDriver = new Promise(function(resolve, reject) {
            try {
                var driverName = driverObject._driver;
                var complianceError = new Error(
                    'Custom driver not compliant; see ' +
                    'https://mozilla.github.io/localForage/#definedriver'
                );
                var namingError = new Error(
                    'Custom driver name already in use: ' + driverObject._driver
                );

                // A driver name should be defined and not overlap with the
                // library-defined, default drivers.
                if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                }
                if (isLibraryDriver(driverObject._driver)) {
                    reject(namingError);
                    return;
                }

                var customDriverMethods = LibraryMethods.concat('_initStorage');
                for (var i = 0; i < customDriverMethods.length; i++) {
                    var customDriverMethod = customDriverMethods[i];
                    if (!customDriverMethod ||
                        !driverObject[customDriverMethod] ||
                        typeof driverObject[customDriverMethod] !== 'function') {
                        reject(complianceError);
                        return;
                    }
                }

                var supportPromise = Promise.resolve(true);
                if ('_support'  in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                        supportPromise = driverObject._support();
                    } else {
                        supportPromise = Promise.resolve(!!driverObject._support);
                    }
                }

                supportPromise.then(function(supportResult) {
                    driverSupport[driverName] = supportResult;
                    CustomDrivers[driverName] = driverObject;
                    resolve();
                }, reject);
            } catch (e) {
                reject(e);
            }
        });

        defineDriver.then(callback, errorCallback);
        return defineDriver;
    };

    LocalForage.prototype.driver = function() {
        return this._driver || null;
    };

    LocalForage.prototype.ready = function(callback) {
        var self = this;

        var ready = new Promise(function(resolve, reject) {
            self._driverSet.then(function() {
                if (self._ready === null) {
                    self._ready = self._initStorage(self._config);
                }

                self._ready.then(resolve, reject);
            })["catch"](reject);
        });

        ready.then(callback, callback);
        return ready;
    };

    LocalForage.prototype.setDriver = function(drivers, callback,
                                               errorCallback) {
        var self = this;

        if (typeof drivers === 'string') {
            drivers = [drivers];
        }

        this._driverSet = new Promise(function(resolve, reject) {
            var driverName = self._getFirstSupportedDriver(drivers);
            var error = new Error('No available storage method found.');

            if (!driverName) {
                self._driverSet = Promise.reject(error);
                reject(error);
                return;
            }

            self._dbInfo = null;
            self._ready = null;

            if (isLibraryDriver(driverName)) {
                // We allow localForage to be declared as a module or as a
                // library available without AMD/require.js.
                if (moduleType === ModuleType.DEFINE) {
                    require([driverName], function(lib) {
                        self._extend(lib);

                        resolve();
                    });

                    return;
                } else if (moduleType === ModuleType.EXPORT) {
                    // Making it browserify friendly
                    var driver;
                    switch (driverName) {
                        case self.INDEXEDDB:
                            driver = require('./drivers/indexeddb');
                            break;
                        case self.LOCALSTORAGE:
                            driver = require('./drivers/localstorage');
                            break;
                        case self.WEBSQL:
                            driver = require('./drivers/websql');
                    }

                    self._extend(driver);
                } else {
                    self._extend(globalObject[driverName]);
                }
            } else if (CustomDrivers[driverName]) {
                self._extend(CustomDrivers[driverName]);
            } else {
                self._driverSet = Promise.reject(error);
                reject(error);
                return;
            }

            resolve();
        });

        function setDriverToConfig() {
            self._config.driver = self.driver();
        }
        this._driverSet.then(setDriverToConfig, setDriverToConfig);

        this._driverSet.then(callback, errorCallback);
        return this._driverSet;
    };

    LocalForage.prototype.supports = function(driverName) {
        return !!driverSupport[driverName];
    };

    LocalForage.prototype._extend = function(libraryMethodsAndProperties) {
        extend(this, libraryMethodsAndProperties);
    };

    // Used to determine which driver we should use as the backend for this
    // instance of localForage.
    LocalForage.prototype._getFirstSupportedDriver = function(drivers) {
        if (drivers && isArray(drivers)) {
            for (var i = 0; i < drivers.length; i++) {
                var driver = drivers[i];

                if (this.supports(driver)) {
                    return driver;
                }
            }
        }

        return null;
    };

    LocalForage.prototype.createInstance = function(options) {
        return new LocalForage(options);
    };

    // The actual localForage object that we expose as a module or via a
    // global. It's extended by pulling in one of our other libraries.
    var localForage = new LocalForage();

    // We allow localForage to be declared as a module or as a library
    // available without AMD/require.js.
    if (moduleType === ModuleType.DEFINE) {
        define('localforage', function() {
            return localForage;
        });
    } else if (moduleType === ModuleType.EXPORT) {
        module.exports = localForage;
    } else {
        this.localforage = localForage;
    }
}).call(window);




/////////////////////////////////
/// NATIVE MODULE STARTS HERE ///
/////////////////////////////////

Elm.Native = Elm.Native || {};
Elm.Native.Storage = {};
Elm.Native.Storage.make = function(localRuntime){

  localRuntime.Native = localRuntime.Native || {};
  localRuntime.Native.Storage = localRuntime.Native.Storage || {};

  if (localRuntime.Native.Storage.values){
    return localRuntime.Native.Storage.values;
  }

  var Task = Elm.Native.Task.make(localRuntime);
  var Utils = Elm.Native.Utils.make(localRuntime);
  var List = Elm.Native.List.make(localRuntime);

  // getItemAsJson : String -> Task error Value
  var getItemAsJson = function(key){
    return Task.asyncFunction(function(callback){
      localforage.getItem(key).then(function(value){
        console.log("get succeeded");
        callback(Task.succeed(value));
      }).catch(function(err){
        console.log("Storage Call: getItemAsJson has failed with key: " + key);
        callback(Task.fail("Storage Call: getItemAsJson has failed with key: " + key));
      });
    });
  };

  // setItem : String -> Value -> Task error ()
  var setItem = function(key, value){
    return Task.asyncFunction(function(callback){
      localforage.setItem(key, value).then(function(){
        console.log("set succeeded");
        callback(Task.succeed(Utils.Tuple0));
      }).catch(function(){
        console.log("Storage Call: setItem has failed with key: " + key + " and value: " + value);
        callback(Task.fail("Storage Call: setItem has failed with key: " + key + " and value: " + value));
      });
    });
  };

  // removeItem : String -> Task error ()
  var removeItem = function(key){
    return Task.asyncFunction(function(callback){
      localforage.removeItem(key).then(function(){
        callback(Task.succeed(Utils.Tuple0));
      }).catch(function(){
        callback(Task.fail("Storage Call: removeItem has failed with key: " + key));
      });
    });
  };

  // clear : Task error ()
  var clear = Task.asyncFunction(function(callback){
    localforage.clear().then(function(){
      callback(Task.succeed(Utils.Tuple0));
    }).catch(function(){
      callback(Task.fail("Storage Call: clear has failed"));
    });
  });


  // keys : Task error (List String)
  var keys = Task.asyncFunction(function(callback){
    localforage.keys().then(function(keys){
      callback(Task.succeed(List.fromArray(keys)));
    }).catch(function(){
      callback(Task.fail("Storage Call: keys has failed"));
    });
  });

  // length : Task error Int
  var length = Task.asyncFunction(function(callback){
    localforage.length().then(function(numberOfKeys){
      callback(Task.succeed(numberOfKeys));
    }).catch(function(){
      callback(Task.fail("Storage Call: length has failed"));
    });
  });


  return {
    getItemAsJson : getItemAsJson,
    setItem       : F2(setItem),
    removeItem    : removeItem,
    clear         : clear,
    keys          : keys,
    length        : length
  };


};

Elm.Storage = Elm.Storage || {};
Elm.Storage.make = function (_elm) {
   "use strict";
   _elm.Storage = _elm.Storage || {};
   if (_elm.Storage.values) return _elm.Storage.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Json$Decode = Elm.Json.Decode.make(_elm),
   $Json$Encode = Elm.Json.Encode.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Native$Storage = Elm.Native.Storage.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Task = Elm.Task.make(_elm);
   var _op = {};
   var length = $Native$Storage.length;
   var keys = $Native$Storage.keys;
   var clear = $Native$Storage.clear;
   var removeItem = $Native$Storage.removeItem;
   var setItem = $Native$Storage.setItem;
   var getItemAsJson = $Native$Storage.getItemAsJson;
   var getItem = F2(function (key,decoder) {
      var decode = function (value) {
         var _p0 = A2($Json$Decode.decodeValue,decoder,value);
         if (_p0.ctor === "Ok") {
               return $Task.succeed(_p0._0);
            } else {
               return $Task.fail("Failed");
            }
      };
      return A2($Task.andThen,getItemAsJson(key),decode);
   });
   return _elm.Storage.values = {_op: _op
                                ,getItemAsJson: getItemAsJson
                                ,getItem: getItem
                                ,setItem: setItem
                                ,removeItem: removeItem
                                ,clear: clear
                                ,keys: keys
                                ,length: length};
};
Elm.InterfaceStorage = Elm.InterfaceStorage || {};
Elm.InterfaceStorage.make = function (_elm) {
   "use strict";
   _elm.InterfaceStorage = _elm.InterfaceStorage || {};
   if (_elm.InterfaceStorage.values)
   return _elm.InterfaceStorage.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $ExamplesGenerated = Elm.ExamplesGenerated.make(_elm),
   $InterfaceModel = Elm.InterfaceModel.make(_elm),
   $Json$Decode = Elm.Json.Decode.make(_elm),
   $Json$Encode = Elm.Json.Encode.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Storage = Elm.Storage.make(_elm),
   $String = Elm.String.make(_elm),
   $Task = Elm.Task.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var removeLocalSave = F2(function (name,oldmodel) {
      return _U.update(oldmodel,
      {localSaves: A2($List.filter,
      F2(function (x,y) {    return !_U.eq(x,y);})(name),
      oldmodel.localSaves)});
   });
   var deleteLocalSave = function (name) {
      return A2($Task.andThen,
      $Storage.removeItem(name),
      function (_p0) {
         return A2($Signal.send,
         $InterfaceModel.events.address,
         $InterfaceModel.UpdateModel(removeLocalSave(name)));
      });
   };
   var clearLocalSaves = A2($Task.andThen,
   $Storage.clear,
   function (_p1) {
      return A2($Signal.send,
      $InterfaceModel.events.address,
      $InterfaceModel.UpdateModel(function (m) {
         return _U.update(m,
         {exName: $ExamplesGenerated.scratchName
         ,localSaves: _U.list([])});
      }));
   });
   var installLocalSaves = F2(function (saves,oldModel) {
      return _U.update(oldModel,{localSaves: saves});
   });
   var getLocalSaves = A2($Task.andThen,
   $Storage.keys,
   function (saves) {
      return A2($Signal.send,
      $InterfaceModel.events.address,
      $InterfaceModel.UpdateModel(installLocalSaves(saves)));
   });
   var invalidInput = function (oldmodel) {
      var oldcontents = oldmodel.fieldContents;
      return _U.update(oldmodel,
      {fieldContents: {value: "",hint: "Invalid File Name"}});
   };
   var removeDialog = F3(function (makeSave,saveName,oldModel) {
      var _p2 = oldModel.mode;
      if (_p2.ctor === "SaveDialog") {
            var _p4 = _p2._0;
            var _p3 = makeSave;
            if (_p3 === true) {
                  return A2($List.all,
                  F2(function (x,y) {    return !_U.eq(x,y);})(saveName),
                  oldModel.localSaves) ? _U.update(oldModel,
                  {mode: _p4
                  ,exName: saveName
                  ,localSaves: A2($List._op["::"],
                  saveName,
                  oldModel.localSaves)}) : _U.update(oldModel,
                  {mode: _p4,exName: saveName});
               } else {
                  return _U.update(oldModel,{mode: _p4});
               }
         } else {
            return _U.crashCase("InterfaceStorage",
            {start: {line: 142,column: 43},end: {line: 154,column: 72}},
            _p2)("Called removeDialog when not in SaveDialog state");
         }
   });
   var checkAndSave = F2(function (saveName,model) {
      return A2($List.all,
      function (_p6) {
         return A2(F2(function (x,y) {    return !_U.eq(x,y);}),
         saveName,
         $Utils.fst3(_p6));
      },
      $ExamplesGenerated.list) && (!_U.eq(saveName,
      "") && (!_U.eq(saveName,
      "__ErrorSave") && $Basics.not(A2($String.all,
      function (c) {
         return _U.eq(c,_U.chr(" ")) || _U.eq(c,_U.chr("\t"));
      },
      saveName)))) ? A2($Task.andThen,
      A2($Signal.send,
      $InterfaceModel.events.address,
      $InterfaceModel.WaitSave(saveName)),
      function (_p7) {
         return A2($Signal.send,
         $InterfaceModel.events.address,
         A2($InterfaceModel.RemoveDialog,true,saveName));
      }) : A2($Signal.send,
      $InterfaceModel.events.address,
      $InterfaceModel.UpdateModel(invalidInput));
   });
   var installSaveState = function (oldModel) {
      return _U.update(oldModel,
      {mode: $InterfaceModel.SaveDialog(oldModel.mode)});
   };
   var saveStateLocally = F3(function (saveName,saveAs,model) {
      return saveAs ? A2($Signal.send,
      $InterfaceModel.events.address,
      $InterfaceModel.InstallSaveState) : A2($Signal.send,
      $InterfaceModel.events.address,
      $InterfaceModel.WaitSave(saveName));
   });
   var modelToValue = function (model) {
      return $Json$Encode.object(_U.list([{ctor: "_Tuple2"
                                          ,_0: "code"
                                          ,_1: $Json$Encode.string(model.code)}
                                         ,{ctor: "_Tuple2"
                                          ,_0: "orient"
                                          ,_1: $Json$Encode.string(function () {
                                             var _p8 = model.orient;
                                             if (_p8.ctor === "Vertical") {
                                                   return "Vertical";
                                                } else {
                                                   return "Horizontal";
                                                }
                                          }())}
                                         ,{ctor: "_Tuple2"
                                          ,_0: "midOffsetX"
                                          ,_1: $Json$Encode.$int(model.midOffsetX)}
                                         ,{ctor: "_Tuple2"
                                          ,_0: "midOffsetY"
                                          ,_1: $Json$Encode.$int(model.midOffsetY)}]));
   };
   var commitLocalSave = F2(function (saveName,model) {
      return A2($Storage.setItem,saveName,modelToValue(model));
   });
   var PartialObject = F4(function (a,b,c,d) {
      return {code: a,orient: b,midOffsetX: c,midOffsetY: d};
   });
   var strToModel = function (baseModel) {
      var partialObjectDecoder = A5($Json$Decode.object4,
      PartialObject,
      A2($Json$Decode._op[":="],"code",$Json$Decode.string),
      A2($Json$Decode._op[":="],
      "orient",
      A2($Json$Decode.customDecoder,
      $Json$Decode.string,
      function (v) {
         var _p9 = v;
         switch (_p9)
         {case "Vertical": return $Result.Ok($InterfaceModel.Vertical);
            case "Horizontal":
            return $Result.Ok($InterfaceModel.Horizontal);
            default: return $Result.Err("Ill-formatted orientation");}
      })),
      A2($Json$Decode._op[":="],"midOffsetX",$Json$Decode.$int),
      A2($Json$Decode._op[":="],"midOffsetY",$Json$Decode.$int));
      return A2($Json$Decode.customDecoder,
      partialObjectDecoder,
      function (partial) {
         return $Result.Ok(_U.update(baseModel,
         {code: partial.code
         ,orient: partial.orient
         ,midOffsetX: partial.midOffsetX
         ,midOffsetY: partial.midOffsetY
         ,fieldContents: {value: "",hint: "Input File Name"}
         ,startup: false}));
      });
   };
   var taskMailbox = $Signal.mailbox($Task.succeed({ctor: "_Tuple0"}));
   var debugLog = $Config.debugLog($Config.debugStorage);
   var installLocalState = F3(function (saveName,
   loadedModel,
   oldModel) {
      return A2(debugLog,
      "installLocalState",
      _U.update(loadedModel,
      {slate: $LangSvg.emptyTree
      ,exName: saveName
      ,localSaves: oldModel.localSaves
      ,selectedFeatures: $Set.empty
      ,selectedBlobs: $Dict.empty}));
   });
   var loadLocalState = F2(function (baseModel,saveName) {
      var _p11 = A2($List.filter,
      function (_p10) {
         return A2(F2(function (x,y) {    return _U.eq(x,y);}),
         saveName,
         $Utils.fst3(_p10));
      },
      $ExamplesGenerated.list);
      if (_p11.ctor === "::" && _p11._0.ctor === "_Tuple3") {
            return A2($Signal.send,
            $InterfaceModel.events.address,
            A2($InterfaceModel.SelectExample,saveName,_p11._0._2));
         } else {
            return A2($Task.andThen,
            A2($Storage.getItem,saveName,strToModel(baseModel)),
            function (loadedModel) {
               return A2($Signal.send,
               $InterfaceModel.events.address,
               $InterfaceModel.UpdateModel(A2(installLocalState,
               saveName,
               loadedModel)));
            });
         }
   });
   return _elm.InterfaceStorage.values = {_op: _op
                                         ,taskMailbox: taskMailbox
                                         ,saveStateLocally: saveStateLocally
                                         ,loadLocalState: loadLocalState
                                         ,getLocalSaves: getLocalSaves
                                         ,checkAndSave: checkAndSave
                                         ,clearLocalSaves: clearLocalSaves
                                         ,removeDialog: removeDialog
                                         ,deleteLocalSave: deleteLocalSave
                                         ,installSaveState: installSaveState
                                         ,commitLocalSave: commitLocalSave};
};
Elm.CodeBox = Elm.CodeBox || {};
Elm.CodeBox.make = function (_elm) {
   "use strict";
   _elm.CodeBox = _elm.CodeBox || {};
   if (_elm.CodeBox.values) return _elm.CodeBox.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Ace = Elm.Ace.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $InterfaceModel = Elm.InterfaceModel.make(_elm),
   $InterfaceStorage = Elm.InterfaceStorage.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Task = Elm.Task.make(_elm);
   var _op = {};
   var tripRender = F2(function (evt,last) {
      var _p0 = {ctor: "_Tuple2",_0: evt,_1: last};
      _v0_5: do {
         _v0_0: do {
            if (_p0.ctor === "_Tuple2") {
                  switch (_p0._0.ctor)
                  {case "SwitchOrient":
                     if (_p0._1.ctor === "::" && _p0._1._0 === true) {
                             break _v0_0;
                          } else {
                             return true;
                          }
                     case "InstallSaveState":
                     if (_p0._1.ctor === "::" && _p0._1._0 === true) {
                             break _v0_0;
                          } else {
                             return true;
                          }
                     case "RemoveDialog":
                     if (_p0._1.ctor === "::" && _p0._1._0 === true) {
                             break _v0_0;
                          } else {
                             return true;
                          }
                     case "ToggleBasicCodeBox":
                     if (_p0._1.ctor === "::" && _p0._1._0 === true) {
                             break _v0_0;
                          } else {
                             return true;
                          }
                     default: if (_p0._1.ctor === "::" && _p0._1._0 === true) {
                             break _v0_0;
                          } else {
                             break _v0_5;
                          }}
               } else {
                  break _v0_5;
               }
         } while (false);
         return A2($List.all,
         function (a) {
            return a;
         },
         last) ? false : true;
      } while (false);
      return false;
   });
   var rerenderCount = 4;
   var recoverFromError = F2(function (amsg,fresh) {
      return _U.update(fresh,
      {code: amsg.strArg
      ,errorBox: $Maybe.Just(amsg.evt)
      ,exName: amsg.exNameArg
      ,codeBoxInfo: {selections: amsg.selectionArg
                    ,cursorPos: amsg.cursorArg
                    ,highlights: fresh.codeBoxInfo.highlights
                    ,annotations: fresh.codeBoxInfo.annotations
                    ,tooltips: fresh.codeBoxInfo.tooltips}});
   });
   var interpretAceEvents = F2(function (amsg,model) {
      var updateModelEvent = $InterfaceModel.UpdateModel(function (m) {
         return _U.update(m,
         {code: amsg.strArg
         ,codeBoxInfo: {cursorPos: amsg.cursorArg
                       ,selections: amsg.selectionArg
                       ,highlights: m.codeBoxInfo.highlights
                       ,annotations: m.codeBoxInfo.annotations
                       ,tooltips: m.codeBoxInfo.tooltips}});
      });
      var _p1 = amsg.evt;
      switch (_p1)
      {case "runResponse": return A2($Signal.send,
           $InterfaceModel.events.address,
           $InterfaceModel.MultiEvent(_U.list([updateModelEvent
                                              ,$InterfaceModel.Run])));
         case "saveResponse": var newModel = _U.update(model,
           {code: amsg.strArg
           ,codeBoxInfo: {cursorPos: amsg.cursorArg
                         ,selections: amsg.selectionArg
                         ,highlights: model.codeBoxInfo.highlights
                         ,annotations: model.codeBoxInfo.annotations
                         ,tooltips: model.codeBoxInfo.tooltips}});
           return A2($Task.andThen,
           A2($InterfaceStorage.commitLocalSave,model.exName,newModel),
           function (_p2) {
              return A2($Signal.send,
              $InterfaceModel.events.address,
              $InterfaceModel.UpdateModel(function (m) {
                 return newModel;
              }));
           });
         case "tryParseRun": var newModel = _U.update(model,
           {code: amsg.strArg
           ,codeBoxInfo: {cursorPos: amsg.cursorArg
                         ,selections: amsg.selectionArg
                         ,highlights: model.codeBoxInfo.highlights
                         ,annotations: model.codeBoxInfo.annotations
                         ,tooltips: model.codeBoxInfo.tooltips}});
           return A2($Signal.send,
           $InterfaceModel.events.address,
           $InterfaceModel.TryParseRun(newModel));
         case "cleanResponse": return A2($Signal.send,
           $InterfaceModel.events.address,
           $InterfaceModel.MultiEvent(_U.list([updateModelEvent
                                              ,$InterfaceModel.CleanCode])));
         case "codeResponse": return A2($Signal.send,
           $InterfaceModel.events.address,
           $InterfaceModel.MultiEvent(_U.list([updateModelEvent
                                              ,$InterfaceModel.ToggleBasicCodeBox])));
         case "Rerender": return A2($Signal.send,
           $InterfaceModel.events.address,
           $InterfaceModel.Noop);
         case "init": return $Task.succeed({ctor: "_Tuple0"});
         default: return A2($Signal.send,
           $InterfaceModel.events.address,
           $InterfaceModel.UpdateModel(recoverFromError(amsg)));}
   });
   var assertion = F3(function (rerender,rerenders,model) {
      return {ctor: "_Tuple2"
             ,_0: {kind: "assertion"
                  ,code: $InterfaceModel.codeToShow(model)
                  ,cursorPos: model.codeBoxInfo.cursorPos
                  ,selections: model.codeBoxInfo.selections
                  ,highlights: model.codeBoxInfo.highlights
                  ,annotations: model.codeBoxInfo.annotations
                  ,tooltips: model.codeBoxInfo.tooltips
                  ,bounce: rerender
                  ,exName: model.exName}
             ,_1: A2($List._op["::"],
             rerender,
             A2($List.take,rerenderCount - 1,rerenders))};
   });
   var poke = F3(function (rerender,rerenders,model) {
      return {ctor: "_Tuple2"
             ,_0: {kind: "poke"
                  ,code: ""
                  ,cursorPos: model.codeBoxInfo.cursorPos
                  ,selections: _U.list([])
                  ,highlights: _U.list([])
                  ,annotations: model.codeBoxInfo.annotations
                  ,tooltips: model.codeBoxInfo.tooltips
                  ,bounce: rerender
                  ,exName: ""}
             ,_1: A2($List._op["::"],
             rerender,
             A2($List.take,rerenderCount - 1,rerenders))};
   });
   var codeRequestInfo = {ctor: "_Tuple2"
                         ,_0: {kind: "codeRequest"
                              ,code: ""
                              ,cursorPos: $InterfaceModel.sampleModel.codeBoxInfo.cursorPos
                              ,selections: _U.list([])
                              ,highlights: _U.list([])
                              ,annotations: _U.list([])
                              ,tooltips: _U.list([])
                              ,bounce: true
                              ,exName: ""}
                         ,_1: _U.list([])};
   var cleanRequestInfo = {ctor: "_Tuple2"
                          ,_0: {kind: "cleanRequest"
                               ,code: ""
                               ,cursorPos: $InterfaceModel.sampleModel.codeBoxInfo.cursorPos
                               ,selections: _U.list([])
                               ,highlights: _U.list([])
                               ,annotations: _U.list([])
                               ,tooltips: _U.list([])
                               ,bounce: true
                               ,exName: ""}
                          ,_1: _U.list([])};
   var runRequestInfo = {ctor: "_Tuple2"
                        ,_0: {kind: "runRequest"
                             ,code: ""
                             ,cursorPos: $InterfaceModel.sampleModel.codeBoxInfo.cursorPos
                             ,selections: _U.list([])
                             ,highlights: _U.list([])
                             ,annotations: _U.list([])
                             ,tooltips: _U.list([])
                             ,bounce: true
                             ,exName: ""}
                        ,_1: _U.list([])};
   var saveRequestInfo = function (saveName) {
      return {ctor: "_Tuple2"
             ,_0: {kind: "saveRequest"
                  ,code: ""
                  ,cursorPos: $InterfaceModel.sampleModel.codeBoxInfo.cursorPos
                  ,selections: _U.list([])
                  ,highlights: _U.list([])
                  ,annotations: _U.list([])
                  ,tooltips: _U.list([])
                  ,bounce: true
                  ,exName: saveName}
             ,_1: _U.list([])};
   };
   var packageModel = F2(function (_p4,_p3) {
      var _p5 = _p4;
      var _p12 = _p5._0;
      var _p11 = _p5._1;
      var _p6 = _p3;
      var _p10 = _p6._2;
      var rerender = A2(tripRender,_p11,_p10);
      var _p7 = function () {
         var _p8 = _p11;
         _v4_8: do {
            switch (_p8.ctor)
            {case "WaitSave": return saveRequestInfo(_p8._0);
               case "WaitRun": return runRequestInfo;
               case "WaitClean": return cleanRequestInfo;
               case "MultiEvent":
               if (_p8._0.ctor === "::" && _p8._0._1.ctor === "::" && _p8._0._1._0.ctor === "CleanCode" && _p8._0._1._1.ctor === "[]")
                 {
                       return A3(assertion,rerender,_p10,_p12);
                    } else {
                       break _v4_8;
                    }
               case "Run": return A3(assertion,rerender,_p10,_p12);
               case "UpdateModel": return A3(assertion,rerender,_p10,_p12);
               case "SelectExample": return A3(assertion,rerender,_p10,_p12);
               case "WaitCodeBox": var _p9 = _p12.basicCodeBox;
                 if (_p9 === true) {
                       return A3(poke,rerender,_p10,_p12);
                    } else {
                       return codeRequestInfo;
                    }
               default: break _v4_8;}
         } while (false);
         return A3(assertion,rerender,_p10,_p12);
      }();
      var newCodeBoxInfo = _p7._0;
      var newRerenders = _p7._1;
      var notifyAce = !_U.eq({ctor: "_Tuple2"
                             ,_0: newCodeBoxInfo
                             ,_1: newRerenders},
      {ctor: "_Tuple2",_0: _p6._1,_1: _p10});
      return {ctor: "_Tuple3"
             ,_0: notifyAce
             ,_1: newCodeBoxInfo
             ,_2: newRerenders};
   });
   var initAceCodeBoxInfo = {kind: "assertion"
                            ,code: $InterfaceModel.sampleModel.code
                            ,cursorPos: $InterfaceModel.sampleModel.codeBoxInfo.cursorPos
                            ,selections: $InterfaceModel.sampleModel.codeBoxInfo.selections
                            ,highlights: $InterfaceModel.sampleModel.codeBoxInfo.highlights
                            ,annotations: $InterfaceModel.sampleModel.codeBoxInfo.annotations
                            ,tooltips: $InterfaceModel.sampleModel.codeBoxInfo.tooltips
                            ,bounce: true
                            ,exName: ""};
   var initFoldpAceCodeBoxInfo = {ctor: "_Tuple3"
                                 ,_0: false
                                 ,_1: initAceCodeBoxInfo
                                 ,_2: _U.list([])};
   var AceMessage = F5(function (a,b,c,d,e) {
      return {evt: a
             ,strArg: b
             ,cursorArg: c
             ,selectionArg: d
             ,exNameArg: e};
   });
   var AceCodeBoxInfo = F9(function (a,b,c,d,e,f,g,h,i) {
      return {kind: a
             ,code: b
             ,cursorPos: c
             ,selections: d
             ,highlights: e
             ,annotations: f
             ,tooltips: g
             ,bounce: h
             ,exName: i};
   });
   return _elm.CodeBox.values = {_op: _op
                                ,interpretAceEvents: interpretAceEvents
                                ,packageModel: packageModel
                                ,tripRender: tripRender
                                ,initAceCodeBoxInfo: initAceCodeBoxInfo
                                ,initFoldpAceCodeBoxInfo: initFoldpAceCodeBoxInfo
                                ,saveRequestInfo: saveRequestInfo
                                ,runRequestInfo: runRequestInfo
                                ,AceMessage: AceMessage
                                ,AceCodeBoxInfo: AceCodeBoxInfo};
};
Elm.Keys = Elm.Keys || {};
Elm.Keys.make = function (_elm) {
   "use strict";
   _elm.Keys = _elm.Keys || {};
   if (_elm.Keys.values) return _elm.Keys.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Char = Elm.Char.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var _op = {};
   var keyDelete = 46;
   var keyBackspace = 8;
   var keyDown = 40;
   var keyRight = 39;
   var keyUp = 38;
   var keyLeft = 37;
   var keyShift = 16;
   var keyCtrl = 17;
   var keyCommand = 224;
   var keyMeta = 91;
   var keyEsc = 27;
   var keyEnter = 13;
   var commandPlus = function (keys) {
      return $List.sort(A2($List._op["::"],keyCommand,keys));
   };
   var metaPlus = function (keys) {
      return $List.sort(A2($List._op["::"],keyMeta,keys));
   };
   var $delete = $List.sort(_U.list([keyDelete]));
   var backspace = $List.sort(_U.list([keyBackspace]));
   var shiftDown = $List.sort(_U.list([keyShift,keyDown]));
   var shiftUp = $List.sort(_U.list([keyShift,keyUp]));
   var shiftRight = $List.sort(_U.list([keyShift,keyRight]));
   var shiftLeft = $List.sort(_U.list([keyShift,keyLeft]));
   var down = $List.sort(_U.list([keyDown]));
   var up = $List.sort(_U.list([keyUp]));
   var right = $List.sort(_U.list([keyRight]));
   var left = $List.sort(_U.list([keyLeft]));
   var shiftS = $List.sort(_U.list([keyShift
                                   ,$Char.toCode(_U.chr("S"))]));
   var shift = $List.sort(_U.list([keyShift]));
   var s = $List.sort(_U.list([$Char.toCode(_U.chr("S"))]));
   var t = $List.sort(_U.list([$Char.toCode(_U.chr("T"))]));
   var q = $List.sort(_U.list([$Char.toCode(_U.chr("Q"))]));
   var p = $List.sort(_U.list([$Char.toCode(_U.chr("P"))]));
   var o = $List.sort(_U.list([$Char.toCode(_U.chr("O"))]));
   var h = $List.sort(_U.list([$Char.toCode(_U.chr("H"))]));
   var g = $List.sort(_U.list([$Char.toCode(_U.chr("G"))]));
   var y = $List.sort(_U.list([$Char.toCode(_U.chr("Y"))]));
   var x = $List.sort(_U.list([$Char.toCode(_U.chr("X"))]));
   var z = $List.sort(_U.list([$Char.toCode(_U.chr("Z"))]));
   var e = $List.sort(_U.list([$Char.toCode(_U.chr("E"))]));
   var d = $List.sort(_U.list([$Char.toCode(_U.chr("D"))]));
   var c = $List.sort(_U.list([$Char.toCode(_U.chr("C"))]));
   var enter = $List.sort(_U.list([keyEnter]));
   var escape = $List.sort(_U.list([keyEsc]));
   var escShift = $List.sort(_U.list([keyEsc,keyShift]));
   var metaShift = $List.sort(_U.list([keyMeta,keyShift]));
   return _elm.Keys.values = {_op: _op
                             ,metaShift: metaShift
                             ,escShift: escShift
                             ,escape: escape
                             ,enter: enter
                             ,c: c
                             ,d: d
                             ,e: e
                             ,z: z
                             ,x: x
                             ,y: y
                             ,g: g
                             ,h: h
                             ,o: o
                             ,p: p
                             ,q: q
                             ,t: t
                             ,s: s
                             ,shift: shift
                             ,shiftS: shiftS
                             ,left: left
                             ,right: right
                             ,up: up
                             ,down: down
                             ,shiftLeft: shiftLeft
                             ,shiftRight: shiftRight
                             ,shiftUp: shiftUp
                             ,shiftDown: shiftDown
                             ,backspace: backspace
                             ,$delete: $delete
                             ,metaPlus: metaPlus
                             ,commandPlus: commandPlus
                             ,keyEnter: keyEnter
                             ,keyEsc: keyEsc
                             ,keyMeta: keyMeta
                             ,keyCommand: keyCommand
                             ,keyCtrl: keyCtrl
                             ,keyShift: keyShift
                             ,keyLeft: keyLeft
                             ,keyUp: keyUp
                             ,keyRight: keyRight
                             ,keyDown: keyDown
                             ,keyBackspace: keyBackspace
                             ,keyDelete: keyDelete};
};
Elm.Draw = Elm.Draw || {};
Elm.Draw.make = function (_elm) {
   "use strict";
   _elm.Draw = _elm.Draw || {};
   if (_elm.Draw.values) return _elm.Draw.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Blobs = Elm.Blobs.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Either = Elm.Either.make(_elm),
   $Html$Attributes = Elm.Html.Attributes.make(_elm),
   $InterfaceModel = Elm.InterfaceModel.make(_elm),
   $Keys = Elm.Keys.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Svg = Elm.Svg.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var lambdaToolOptionsOf = function (_p0) {
      var _p1 = _p0;
      var _p2 = _p1._1;
      if (_p2.ctor === "Blobs") {
            var lambdaPreFuncs = A2($List.concatMap,
            function (_p3) {
               var _p4 = _p3;
               var _p5 = {ctor: "_Tuple2",_0: _p4._1.val,_1: _p4._2.val.e__};
               if (_p5.ctor === "_Tuple2" && _p5._0.ctor === "PVar" && _p5._1.ctor === "EFun")
               {
                     var _p8 = _p5._0._1;
                     var _p6 = $List.reverse(_p5._1._1);
                     if (_p6.ctor === "::") {
                           var _p7 = $Lang.varsOfPat(_p6._0);
                           _v5_6: do {
                              if (_p7.ctor === "::") {
                                    if (_p7._1.ctor === "[]") {
                                          switch (_p7._0)
                                          {case "bounds": return _U.list([$Either.Left(_p8)]);
                                             case "anchor": return _U.list([$Either.Right(_p8)]);
                                             default: break _v5_6;}
                                       } else {
                                          if (_p7._1._1.ctor === "[]") {
                                                if (_p7._0 === "xAnchor" && _p7._1._0 === "yAnchor") {
                                                      return _U.list([$Either.Right(_p8)]);
                                                   } else {
                                                      break _v5_6;
                                                   }
                                             } else {
                                                if (_p7._1._1._1.ctor === "::") {
                                                      if (_p7._1._1._1._1.ctor === "[]") {
                                                            if (_p7._0 === "left" && _p7._1._0 === "top" && _p7._1._1._0 === "right" && _p7._1._1._1._0 === "bot")
                                                            {
                                                                  return _U.list([$Either.Left(_p8)]);
                                                               } else {
                                                                  break _v5_6;
                                                               }
                                                         } else {
                                                            if (_p7._0 === "bounds" && _p7._1._0 === "left" && _p7._1._1._0 === "top" && _p7._1._1._1._0 === "right" && _p7._1._1._1._1._0 === "bot" && _p7._1._1._1._1._1.ctor === "[]")
                                                            {
                                                                  return _U.list([$Either.Left(_p8)]);
                                                               } else {
                                                                  break _v5_6;
                                                               }
                                                         }
                                                   } else {
                                                      if (_p7._0 === "anchor" && _p7._1._0 === "xAnchor" && _p7._1._1._0 === "yAnchor")
                                                      {
                                                            return _U.list([$Either.Right(_p8)]);
                                                         } else {
                                                            break _v5_6;
                                                         }
                                                   }
                                             }
                                       }
                                 } else {
                                    break _v5_6;
                                 }
                           } while (false);
                           return _U.list([]);
                        } else {
                           return _U.list([]);
                        }
                  } else {
                     return _U.list([]);
                  }
            },
            _p1._0);
            var withBlobs = $List.reverse(A2($List.concatMap,
            function (blob) {
               var _p9 = blob;
               _v6_2: do {
                  if (_p9.ctor === "NiceBlob") {
                        switch (_p9._1.ctor)
                        {case "WithBoundsBlob": if (_p9._1._0.ctor === "_Tuple3") {
                                   return _U.list([$Either.Left({ctor: "_Tuple2"
                                                                ,_0: _p9._1._0._1
                                                                ,_1: _p9._1._0._2})]);
                                } else {
                                   break _v6_2;
                                }
                           case "WithAnchorBlob": if (_p9._1._0.ctor === "_Tuple3") {
                                   return _U.list([$Either.Right({ctor: "_Tuple2"
                                                                 ,_0: _p9._1._0._1
                                                                 ,_1: _p9._1._0._2})]);
                                } else {
                                   break _v6_2;
                                }
                           default: break _v6_2;}
                     } else {
                        break _v6_2;
                     }
               } while (false);
               return _U.list([]);
            },
            _p2._0));
            var lambdaCalls = A2($List.concatMap,
            function (preFunc) {
               var pred = function (withBlob) {
                  var _p10 = {ctor: "_Tuple2",_0: preFunc,_1: withBlob};
                  _v7_2: do {
                     if (_p10.ctor === "_Tuple2") {
                           if (_p10._0.ctor === "Left") {
                                 if (_p10._1.ctor === "Left" && _p10._1._0.ctor === "_Tuple2")
                                 {
                                       return _U.eq(_p10._0._0,_p10._1._0._0);
                                    } else {
                                       break _v7_2;
                                    }
                              } else {
                                 if (_p10._1.ctor === "Right" && _p10._1._0.ctor === "_Tuple2")
                                 {
                                       return _U.eq(_p10._0._0,_p10._1._0._0);
                                    } else {
                                       break _v7_2;
                                    }
                              }
                        } else {
                           break _v7_2;
                        }
                  } while (false);
                  return false;
               };
               var _p11 = A2($Utils.findFirst,pred,withBlobs);
               if (_p11.ctor === "Nothing") {
                     return _U.list([]);
                  } else {
                     if (_p11._0.ctor === "Left") {
                           return _U.list([$InterfaceModel.LambdaBounds($Lang.withDummyPos(A4($Lang.EApp,
                           " ",
                           $Lang.eVar0(_p11._0._0._0),
                           _p11._0._0._1,
                           "")))]);
                        } else {
                           return _U.list([$InterfaceModel.LambdaAnchor($Lang.withDummyPos(A4($Lang.EApp,
                           " ",
                           $Lang.eVar0(_p11._0._0._0),
                           _p11._0._0._1,
                           "")))]);
                        }
                  }
            },
            lambdaPreFuncs);
            return lambdaCalls;
         } else {
            return _U.list([]);
         }
   };
   var maybeGhost = F3(function (b,f,args) {
      return b ? {ctor: "_Tuple2"
                 ,_0: $Lang.eVar0("ghost")
                 ,_1: _U.list([$Lang.withDummyPos(A4($Lang.EApp,
                 " ",
                 f,
                 args,
                 ""))])} : {ctor: "_Tuple2",_0: f,_1: args};
   });
   var ghost = maybeGhost(true);
   var addToMainExp = F2(function (newBlob,mainExp) {
      var _p12 = mainExp;
      switch (_p12.ctor)
      {case "SvgConcat": return A2($Blobs.SvgConcat,
           A2($Basics._op["++"],
           _p12._0,
           _U.list([$Blobs.fromBlobExp(newBlob)])),
           _p12._1);
         case "Blobs": return A2($Blobs.Blobs,
           A2($Basics._op["++"],_p12._0,_U.list([newBlob])),
           _p12._1);
         default: var ws = "\n";
           return $Blobs.OtherExp($Lang.withDummyPos(A4($Lang.EApp,
           ws,
           $Lang.eVar0("addBlob"),
           _U.list([$Blobs.fromBlobExp(newBlob),_p12._0]),
           "")));}
   });
   var makeInts = function (nums) {
      var _p13 = nums;
      if (_p13.ctor === "[]") {
            return _U.crashCase("Draw",
            {start: {line: 712,column: 3},end: {line: 717,column: 19}},
            _p13)("makeInts");
         } else {
            if (_p13._1.ctor === "[]") {
                  return _U.list([A2($Lang.eConst0,
                  $Basics.toFloat(_p13._0),
                  $Lang.dummyLoc)]);
               } else {
                  var e = A2($Lang.eConst0,
                  $Basics.toFloat(_p13._0),
                  $Lang.dummyLoc);
                  var es = A2($List.map,
                  function (n$) {
                     return A2($Lang.eConst,$Basics.toFloat(n$),$Lang.dummyLoc);
                  },
                  _p13._1);
                  return A2($List._op["::"],e,es);
               }
         }
   };
   var makeLet = F2(function (vars,exps) {
      var _p15 = {ctor: "_Tuple2",_0: vars,_1: exps};
      if (_p15.ctor === "_Tuple2" && _p15._0.ctor === "::" && _p15._1.ctor === "::")
      {
            if (_p15._0._1.ctor === "[]" && _p15._1._1.ctor === "[]") {
                  return {ctor: "_Tuple2"
                         ,_0: $Lang.pVar(_p15._0._0)
                         ,_1: _p15._1._0};
               } else {
                  var ps = A2($List.map,$Lang.pVar,_p15._0._1);
                  var p = $Lang.pVar0(_p15._0._0);
                  return {ctor: "_Tuple2"
                         ,_0: $Lang.pList(A2($List._op["::"],p,ps))
                         ,_1: A2($Lang.eList,
                         A2($List._op["::"],_p15._1._0,_p15._1._1),
                         $Maybe.Nothing)};
               }
         } else {
            return _U.crashCase("Draw",
            {start: {line: 698,column: 3},end: {line: 703,column: 43}},
            _p15)("makeLet");
         }
   });
   var makeLetAs = F3(function (x,vars,exps) {
      var _p17 = A2(makeLet,vars,exps);
      var p = _p17._0;
      var e = _p17._1;
      return {ctor: "_Tuple2",_0: A2($Lang.pAs,x,p),_1: e};
   });
   var makeNewShapeDef = F6(function (model,
   newShapeKind,
   name,
   locals,
   func,
   args) {
      var newShapeName = $Lang.withDummyRange(A3($Lang.PVar,
      " ",
      name,
      $Lang.noWidgetDecl));
      var recurse = function (locals) {
         var _p18 = locals;
         if (_p18.ctor === "[]") {
               var multi = function () {
                  var _p19 = model.tool;
                  switch (_p19.ctor)
                  {case "Lambda": return true;
                     case "Text": return true;
                     default: return false;}
               }();
               if (multi) return $Lang.withDummyPos(A4($Lang.EApp,
                  "\n    ",
                  func,
                  args,
                  "")); else {
                     var app = $Lang.withDummyPos(A4($Lang.EApp,
                     " ",
                     func,
                     args,
                     ""));
                     return $Lang.withDummyPos(A5($Lang.EList,
                     "\n    ",
                     _U.list([app]),
                     "",
                     $Maybe.Nothing,
                     " "));
                  }
            } else {
               return $Lang.withDummyPos(A7($Lang.ELet,
               "\n  ",
               $Lang.Let,
               false,
               _p18._0._0,
               _p18._0._1,
               recurse(_p18._1),
               ""));
            }
      };
      return {ctor: "_Tuple4"
             ,_0: "\n\n"
             ,_1: newShapeName
             ,_2: recurse(locals)
             ,_3: ""};
   });
   var add = F5(function (newShapeKind,
   old,
   newShapeLocals,
   newShapeFunc,
   newShapeArgs) {
      var tmp = A2($Basics._op["++"],
      newShapeKind,
      $Basics.toString(old.genSymCount));
      var newDef = A6(makeNewShapeDef,
      old,
      newShapeKind,
      tmp,
      newShapeLocals,
      newShapeFunc,
      newShapeArgs);
      var _p20 = $Blobs.splitExp(old.inputExp);
      var defs = _p20._0;
      var mainExp = _p20._1;
      var defs$ = A2($Basics._op["++"],defs,_U.list([newDef]));
      var eNew = $Lang.withDummyPos(A2($Lang.EVar,"\n  ",tmp));
      var mainExp$ = A2(addToMainExp,
      A2($Blobs.varBlob,eNew,tmp),
      mainExp);
      var code = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                      ,_0: defs$
                                                      ,_1: mainExp$}));
      return _U.update(old,
      {code: code
      ,genSymCount: old.genSymCount + 1
      ,mouseMode: $InterfaceModel.MouseNothing});
   });
   var eAsPoint = function (e) {
      var e$ = A2($LangUnparser.replacePrecedingWhitespace,"",e);
      return $Lang.withDummyPos(A5($Lang.EColonType,
      " ",
      e$,
      " ",
      $Lang.withDummyRange(A2($Lang.TNamed," ","Point")),
      ""));
   };
   var addLambdaAnchor = F4(function (old,_p22,_p21,func) {
      var _p23 = _p21;
      var anchor = eAsPoint(A2($Lang.eList,
      makeInts(_U.list([_p23._1._0,_p23._1._1])),
      $Maybe.Nothing));
      var args = _U.list([]);
      var eNew = $Lang.withDummyPos(A4($Lang.EApp,
      "\n  ",
      $Lang.eVar0("withAnchor"),
      _U.list([anchor,func]),
      ""));
      var newBlob = A2($Blobs.withAnchorBlob,
      eNew,
      {ctor: "_Tuple3",_0: anchor,_1: "XXXXX",_2: args});
      var _p24 = $Blobs.splitExp(old.inputExp);
      var defs = _p24._0;
      var mainExp = _p24._1;
      var mainExp$ = A2(addToMainExp,newBlob,mainExp);
      var code = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                      ,_0: defs
                                                      ,_1: mainExp$}));
      return _U.update(old,
      {code: code,mouseMode: $InterfaceModel.MouseNothing});
   });
   var addStickyPath = F2(function (old,keysAndPoints) {
      return _U.crash("Draw",
      {start: {line: 577,column: 3}
      ,end: {line: 577,column: 14}})("TODO: addStickyPath");
   });
   var strPoint = F3(function (strX,strY,_p25) {
      var _p26 = _p25;
      return $Utils.spaces(_U.list([strX(_p26._0),strY(_p26._1)]));
   });
   var pathCommands = F3(function (strX,strY,keysAndPoints) {
      var strPt = A2(strPoint,strX,strY);
      var keysAndPoints_ = $List.reverse(keysAndPoints);
      var _p27 = $Utils.head_(keysAndPoints_);
      var firstClick = _p27._1;
      var _p28 = $Utils.last_(keysAndPoints_);
      var lastClick = _p28._1;
      var _p29 = function () {
         if (!_U.eq(firstClick,lastClick)) return {ctor: "_Tuple3"
                                                  ,_0: _U.list([])
                                                  ,_1: A2($Basics._op["++"],"\'M\' ",strPt(firstClick))
                                                  ,_2: strPt(firstClick)}; else {
               var extraLets = _U.list([A2(makeLet,
               _U.list(["x0","y0"]),
               _U.list([$Lang.eVar0(strX($Basics.fst(firstClick)))
                       ,$Lang.eVar(strY($Basics.snd(firstClick)))]))]);
               return {ctor: "_Tuple3"
                      ,_0: extraLets
                      ,_1: "\'M\' x0 y0"
                      ,_2: "x0 y0"};
            }
      }();
      var extraLets = _p29._0;
      var firstCmd = _p29._1;
      var lastPoint = _p29._2;
      var remainingCmds = function () {
         var foo = function (list0) {
            var _p30 = list0;
            if (_p30.ctor === "[]") {
                  return _U.list([]);
               } else {
                  var _p48 = _p30._0._0;
                  var _p47 = _p30._1;
                  var _p46 = _p30._0._1;
                  if (_U.eq(_p48,$Keys.q)) {
                        var _p31 = _p47;
                        if (_p31.ctor === "::" && _p31._0.ctor === "_Tuple2") {
                              var _p35 = _p31._1;
                              var _p34 = _p31._0._1;
                              var _p32 = {ctor: "_Tuple2"
                                         ,_0: _U.eq(_p34,firstClick)
                                         ,_1: _p35};
                              if (_p32._0 === false) {
                                    return A2($List._op["::"],
                                    $Utils.spaces(_U.list(["\'Q\'",strPt(_p46),strPt(_p34)])),
                                    foo(_p35));
                                 } else {
                                    if (_p32._1.ctor === "[]") {
                                          return _U.list([$Utils.spaces(_U.list(["\'Q\'"
                                                                                ,strPt(_p46)
                                                                                ,lastPoint]))]);
                                       } else {
                                          return _U.crashCase("Draw",
                                          {start: {line: 523,column: 15},end: {line: 526,column: 55}},
                                          _p32)("addPath Q1");
                                       }
                                 }
                           } else {
                              return _U.crashCase("Draw",
                              {start: {line: 521,column: 11},end: {line: 527,column: 42}},
                              _p31)("addPath Q2");
                           }
                     } else if (_U.eq(_p48,$Keys.c)) {
                           var _p37 = _p47;
                           if (_p37.ctor === "::" && _p37._0.ctor === "_Tuple2" && _p37._1.ctor === "::" && _p37._1._0.ctor === "_Tuple2")
                           {
                                 var _p42 = _p37._1._1;
                                 var _p41 = _p37._1._0._1;
                                 var _p40 = _p37._0._1;
                                 var _p38 = {ctor: "_Tuple2"
                                            ,_0: _U.eq(_p41,firstClick)
                                            ,_1: _p42};
                                 if (_p38._0 === false) {
                                       return A2($List._op["::"],
                                       $Utils.spaces(_U.list(["\'C\'"
                                                             ,strPt(_p46)
                                                             ,strPt(_p40)
                                                             ,strPt(_p41)])),
                                       foo(_p42));
                                    } else {
                                       if (_p38._1.ctor === "[]") {
                                             return _U.list([$Utils.spaces(_U.list(["\'C\'"
                                                                                   ,strPt(_p46)
                                                                                   ,strPt(_p40)
                                                                                   ,lastPoint]))]);
                                          } else {
                                             return _U.crashCase("Draw",
                                             {start: {line: 532,column: 15},end: {line: 535,column: 55}},
                                             _p38)("addPath C1");
                                          }
                                    }
                              } else {
                                 return _U.crashCase("Draw",
                                 {start: {line: 530,column: 11},end: {line: 536,column: 42}},
                                 _p37)("addPath C2");
                              }
                        } else {
                           var _p44 = {ctor: "_Tuple2"
                                      ,_0: _U.eq(_p46,firstClick)
                                      ,_1: _p47};
                           if (_p44._0 === false) {
                                 return A2($List._op["::"],
                                 $Utils.spaces(_U.list(["\'L\'",strPt(_p46)])),
                                 foo(_p47));
                              } else {
                                 if (_p44._1.ctor === "[]") {
                                       return _U.list(["\'Z\'"]);
                                    } else {
                                       return _U.crashCase("Draw",
                                       {start: {line: 539,column: 11},end: {line: 542,column: 51}},
                                       _p44)("addPath ZL");
                                    }
                              }
                        }
               }
         };
         return foo($Utils.tail_(keysAndPoints_));
      }();
      var sD = $Utils.bracks($Utils.spaces(A2($List._op["::"],
      firstCmd,
      remainingCmds)));
      return {ctor: "_Tuple2",_0: extraLets,_1: sD};
   });
   var maybeThaw0 = function (s) {
      return _U.eq(s,"0") ? s : A2($Basics._op["++"],s,"?");
   };
   var maybeThaw = function (n) {
      return _U.eq(n,0) || _U.eq(n,
      1) ? $Basics.toString(n) : A2($Basics._op["++"],
      $Basics.toString(n),
      "?");
   };
   var addHelperDot = F2(function (old,_p49) {
      var _p50 = _p49;
      var r = 6;
      var _p51 = A2(ghost,
      $Lang.eVar0("circle"),
      A2($List._op["::"],
      $Lang.eStr("aqua"),
      A2($List.map,$Lang.eVar,_U.list(["cx","cy","r"]))));
      var f = _p51._0;
      var args = _p51._1;
      return A5(add,
      "helperDot",
      old,
      _U.list([A2(makeLet,
      _U.list(["cx","cy","r"]),
      makeInts(_U.list([_p50._1._0,_p50._1._1,r])))]),
      f,
      args);
   });
   var randomColor1 = function (model) {
      return A2($Lang.eConst,
      $Basics.toFloat(model.randomColor),
      $Lang.dummyLoc);
   };
   var randomColor = function (model) {
      return A2($Lang.eConst0,
      $Basics.toFloat(model.randomColor),
      $Lang.dummyLoc);
   };
   var addRawPolygon = F2(function (old,keysAndPoints) {
      var points = A2($List.map,$Basics.snd,keysAndPoints);
      var sPts = $Utils.bracks($Utils.spaces(A3($Basics.flip,
      $List.map,
      $List.reverse(points),
      function (_p52) {
         var _p53 = _p52;
         var xStr = $Basics.toString(_p53._0);
         var yStr = $Basics.toString(_p53._1);
         return $Utils.bracks($Utils.spaces(_U.list([xStr,yStr])));
      })));
      return A5(add,
      "polygon",
      old,
      _U.list([A2(makeLet,
              _U.list(["pts"]),
              _U.list([$Lang.eRaw(sPts)]))
              ,A2(makeLet,
              _U.list(["color","strokeColor","strokeWidth"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,360,$Lang.dummyLoc)
                      ,A2($Lang.eConst,2,$Lang.dummyLoc)]))]),
      $Lang.eVar0("rawPolygon"),
      _U.list([$Lang.eVar("color")
              ,$Lang.eVar("strokeColor")
              ,$Lang.eVar("strokeWidth")
              ,$Lang.eVar("pts")
              ,A2($Lang.eConst,0,$Lang.dummyLoc)]));
   });
   var addAbsolutePath = F2(function (old,keysAndPoints) {
      var _p54 = A3(pathCommands,
      $Basics.toString,
      $Basics.toString,
      keysAndPoints);
      var extraLets = _p54._0;
      var sD = _p54._1;
      return A5(add,
      "path",
      old,
      A2($Basics._op["++"],
      _U.list([A2(makeLet,
      _U.list(["strokeColor","strokeWidth","color"]),
      _U.list([randomColor(old)
              ,A2($Lang.eConst,5,$Lang.dummyLoc)
              ,randomColor1(old)]))]),
      A2($Basics._op["++"],
      extraLets,
      _U.list([A2(makeLet,
      _U.list(["d"]),
      _U.list([$Lang.eVar(sD)]))]))),
      $Lang.eVar0("rawPath"),
      _U.list([$Lang.eVar("color")
              ,$Lang.eVar("strokeColor")
              ,$Lang.eVar("strokeWidth")
              ,$Lang.eVar("d")
              ,A2($Lang.eConst,0,$Lang.dummyLoc)]));
   });
   var strPt = function (_p55) {
      var _p56 = _p55;
      return $Utils.spaces(_U.list([$Basics.toString(_p56._0)
                                   ,$Basics.toString(_p56._1)]));
   };
   var slicesPerQuadrant = 2;
   var radiansPerSlice = $Basics.pi / (2 * slicesPerQuadrant);
   var snapLine = F3(function (keysDown,_p58,_p57) {
      var _p59 = _p58;
      var _p65 = _p59._1._1;
      var _p64 = _p59._1._0;
      var _p60 = _p57;
      var _p63 = _p60._1._1;
      var _p62 = _p60._1._0;
      if (_U.eq(keysDown,$Keys.shift)) {
            var _p61 = {ctor: "_Tuple2",_0: _p64 - _p62,_1: _p65 - _p63};
            var dx = _p61._0;
            var dy = _p61._1;
            var angle = A2($Basics.atan2,
            $Basics.toFloat(0 - dy),
            $Basics.toFloat(dx));
            var slice = $Basics.round(angle / radiansPerSlice);
            var r = A2($Utils.distanceInt,
            {ctor: "_Tuple2",_0: _p64,_1: _p65},
            {ctor: "_Tuple2",_0: _p62,_1: _p63});
            var xb = $Basics.toFloat(_p62) + r * $Basics.cos($Basics.toFloat(slice) * radiansPerSlice);
            var yb = $Basics.toFloat(_p63) - r * $Basics.sin($Basics.toFloat(slice) * radiansPerSlice);
            return {ctor: "_Tuple2"
                   ,_0: $Basics.round(xb)
                   ,_1: $Basics.round(yb)};
         } else return {ctor: "_Tuple2",_0: _p64,_1: _p65};
   });
   var addLine = F3(function (old,click2,click1) {
      var _p66 = {ctor: "_Tuple2",_0: click2,_1: click1};
      var x2 = _p66._0._1._0;
      var y2 = _p66._0._1._1;
      var x1 = _p66._1._1._0;
      var y1 = _p66._1._1._1;
      var _p67 = A3(snapLine,old.keysDown,click2,click1);
      var xb = _p67._0;
      var yb = _p67._1;
      var color = _U.eq(old.tool,
      $InterfaceModel.HelperLine) ? $Lang.eStr("aqua") : randomColor(old);
      var _p68 = A3(maybeGhost,
      _U.eq(old.tool,$InterfaceModel.HelperLine),
      $Lang.eVar0("line"),
      A2($List.map,
      $Lang.eVar,
      _U.list(["color","width","x1","y1","x2","y2"])));
      var f = _p68._0;
      var args = _p68._1;
      return A5(add,
      "line",
      old,
      _U.list([A2(makeLet,
              _U.list(["x1","y1","x2","y2"]),
              makeInts(_U.list([x1,y1,xb,yb])))
              ,A2(makeLet,
              _U.list(["color","width"]),
              _U.list([color,A2($Lang.eConst,5,$Lang.dummyLoc)]))]),
      f,
      args);
   });
   var squareBoundingBox = F2(function (_p70,_p69) {
      var _p71 = _p70;
      var _p78 = _p71._1;
      var _p77 = _p71._0;
      var _p72 = _p69;
      var _p76 = _p72._1;
      var _p75 = _p72._0;
      var _p73 = {ctor: "_Tuple2"
                 ,_0: $Basics.abs(_p77 - _p75)
                 ,_1: $Basics.abs(_p78 - _p76)};
      var xDiff = _p73._0;
      var yDiff = _p73._1;
      var _p74 = {ctor: "_Tuple3"
                 ,_0: _U.cmp(yDiff,xDiff) > 0
                 ,_1: _U.cmp(_p75,_p77) < 0
                 ,_2: _U.cmp(_p76,_p78) < 0};
      if (_p74._0 === true) {
            if (_p74._1 === true) {
                  return {ctor: "_Tuple4"
                         ,_0: _p75
                         ,_1: _p75 + yDiff
                         ,_2: A2($Basics.min,_p76,_p78)
                         ,_3: A2($Basics.max,_p76,_p78)};
               } else {
                  return {ctor: "_Tuple4"
                         ,_0: _p75 - yDiff
                         ,_1: _p75
                         ,_2: A2($Basics.min,_p76,_p78)
                         ,_3: A2($Basics.max,_p76,_p78)};
               }
         } else {
            if (_p74._2 === true) {
                  return {ctor: "_Tuple4"
                         ,_0: A2($Basics.min,_p75,_p77)
                         ,_1: A2($Basics.max,_p75,_p77)
                         ,_2: _p76
                         ,_3: _p76 + xDiff};
               } else {
                  return {ctor: "_Tuple4"
                         ,_0: A2($Basics.min,_p75,_p77)
                         ,_1: A2($Basics.max,_p75,_p77)
                         ,_2: _p76 - xDiff
                         ,_3: _p76};
               }
         }
   });
   var addRawSquare = F3(function (old,_p80,_p79) {
      var _p81 = _p80;
      var _p82 = _p79;
      var _p83 = A2(squareBoundingBox,_p81._1,_p82._1);
      var xa = _p83._0;
      var xb = _p83._1;
      var ya = _p83._2;
      var yb = _p83._3;
      var _p84 = {ctor: "_Tuple3",_0: xa,_1: ya,_2: xb - xa};
      var x = _p84._0;
      var y = _p84._1;
      var side = _p84._2;
      return A5(add,
      "square",
      old,
      _U.list([A2(makeLet,
              _U.list(["x","y","side"]),
              makeInts(_U.list([x,y,side])))
              ,A2(makeLet,
              _U.list(["color","rot"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,0,$Lang.dummyLoc)]))]),
      $Lang.eVar0("rawRect"),
      _U.list([$Lang.eVar("color")
              ,A2($Lang.eConst,360,$Lang.dummyLoc)
              ,A2($Lang.eConst,0,$Lang.dummyLoc)
              ,$Lang.eVar("x")
              ,$Lang.eVar("y")
              ,$Lang.eVar("side")
              ,$Lang.eVar("side")
              ,$Lang.eVar("rot")]));
   });
   var addStretchySquare = F3(function (old,_p86,_p85) {
      var _p87 = _p86;
      var _p88 = _p85;
      var _p89 = A2(squareBoundingBox,_p87._1,_p88._1);
      var xMin = _p89._0;
      var xMax = _p89._1;
      var yMin = _p89._2;
      var side = xMax - xMin;
      return A5(add,
      "square",
      old,
      _U.list([A2(makeLet,
              _U.list(["left","top","side"]),
              makeInts(_U.list([xMin,yMin,side])))
              ,A2(makeLet,
              _U.list(["bounds"]),
              _U.list([A2($Lang.eList,
              $Lang.listOfRaw(_U.list(["left"
                                      ,"top"
                                      ,"(+ left side)"
                                      ,"(+ top side)"])),
              $Maybe.Nothing)]))
              ,A2(makeLet,
              _U.list(["rot"]),
              _U.list([A2($Lang.eConst,0,$Lang.dummyLoc)]))
              ,A2(makeLet,
              _U.list(["color","strokeColor","strokeWidth"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,360,$Lang.dummyLoc)
                      ,A2($Lang.eConst,0,$Lang.dummyLoc)]))]),
      $Lang.eVar0("rectangle"),
      A2($List.map,
      $Lang.eVar,
      _U.list(["color","strokeColor","strokeWidth","rot","bounds"])));
   });
   var addRawCircle = F3(function (old,_p91,_p90) {
      var _p92 = _p91;
      var _p93 = _p90;
      var _p94 = A2(squareBoundingBox,_p92._1,_p93._1);
      var xa = _p94._0;
      var xb = _p94._1;
      var ya = _p94._2;
      var yb = _p94._3;
      var r = (xb - xa) / 2 | 0;
      var _p95 = {ctor: "_Tuple2",_0: xa + r,_1: ya + r};
      var cx = _p95._0;
      var cy = _p95._1;
      return A5(add,
      "circle",
      old,
      _U.list([A2(makeLet,
              _U.list(["cx","cy","r"]),
              makeInts(_U.list([cx,cy,r])))
              ,A2(makeLet,_U.list(["color"]),_U.list([randomColor1(old)]))]),
      $Lang.eVar0("rawCircle"),
      _U.list([$Lang.eVar("color")
              ,A2($Lang.eConst,360,$Lang.dummyLoc)
              ,A2($Lang.eConst,0,$Lang.dummyLoc)
              ,$Lang.eVar("cx")
              ,$Lang.eVar("cy")
              ,$Lang.eVar("r")]));
   });
   var addStretchyCircle = F3(function (old,_p97,_p96) {
      var _p98 = _p97;
      var _p99 = _p96;
      var _p100 = A2(squareBoundingBox,_p98._1,_p99._1);
      var left = _p100._0;
      var right = _p100._1;
      var top = _p100._2;
      return A5(add,
      "circle",
      old,
      _U.list([A2(makeLet,
              _U.list(["left","top","r"]),
              makeInts(_U.list([left,top,(right - left) / 2 | 0])))
              ,A2(makeLet,
              _U.list(["bounds"]),
              _U.list([A2($Lang.eList,
              _U.list([$Lang.eVar0("left")
                      ,$Lang.eVar("top")
                      ,$Lang.eRaw("(+ left (* 2! r))")
                      ,$Lang.eRaw("(+ top (* 2! r))")]),
              $Maybe.Nothing)]))
              ,A2(makeLet,
              _U.list(["color","strokeColor","strokeWidth"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,360,$Lang.dummyLoc)
                      ,A2($Lang.eConst,0,$Lang.dummyLoc)]))]),
      $Lang.eVar0("oval"),
      A2($List.map,
      $Lang.eVar,
      _U.list(["color","strokeColor","strokeWidth","bounds"])));
   });
   var boundingBox = F2(function (_p102,_p101) {
      var _p103 = _p102;
      var _p108 = _p103._1;
      var _p107 = _p103._0;
      var _p104 = _p101;
      var _p106 = _p104._1;
      var _p105 = _p104._0;
      return {ctor: "_Tuple4"
             ,_0: A2($Basics.min,_p105,_p107)
             ,_1: A2($Basics.max,_p105,_p107)
             ,_2: A2($Basics.min,_p106,_p108)
             ,_3: A2($Basics.max,_p106,_p108)};
   });
   var addRawRect = F3(function (old,_p110,_p109) {
      var _p111 = _p110;
      var _p112 = _p109;
      var _p113 = A2(boundingBox,_p111._1,_p112._1);
      var xa = _p113._0;
      var xb = _p113._1;
      var ya = _p113._2;
      var yb = _p113._3;
      var _p114 = {ctor: "_Tuple4"
                  ,_0: xa
                  ,_1: ya
                  ,_2: xb - xa
                  ,_3: yb - ya};
      var x = _p114._0;
      var y = _p114._1;
      var w = _p114._2;
      var h = _p114._3;
      return A5(add,
      "rect",
      old,
      _U.list([A2(makeLet,
              _U.list(["x","y","w","h"]),
              makeInts(_U.list([x,y,w,h])))
              ,A2(makeLet,
              _U.list(["fill","stroke","strokeWidth"]),
              _U.list([randomColor(old)
                      ,randomColor1(old)
                      ,A2($Lang.eConst,0,$Lang.dummyLoc)]))
              ,A2(makeLet,
              _U.list(["rot"]),
              _U.list([A2($Lang.eConst,0,$Lang.dummyLoc)]))]),
      $Lang.eVar0("rawRect"),
      _U.list([$Lang.eVar("fill")
              ,$Lang.eVar("stroke")
              ,$Lang.eVar("strokeWidth")
              ,$Lang.eVar("x")
              ,$Lang.eVar("y")
              ,$Lang.eVar("w")
              ,$Lang.eVar("h")
              ,$Lang.eVar("rot")]));
   });
   var addStretchyRect = F3(function (old,_p116,_p115) {
      var _p117 = _p116;
      var _p118 = _p115;
      var _p119 = A2(boundingBox,_p117._1,_p118._1);
      var xMin = _p119._0;
      var xMax = _p119._1;
      var yMin = _p119._2;
      var yMax = _p119._3;
      return A5(add,
      "rect",
      old,
      _U.list([A3(makeLetAs,
              "bounds",
              _U.list(["left","top","right","bot"]),
              makeInts(_U.list([xMin,yMin,xMax,yMax])))
              ,A2(makeLet,_U.list(["color"]),_U.list([randomColor1(old)]))]),
      $Lang.eVar0("rectangle"),
      _U.list([$Lang.eVar("color")
              ,A2($Lang.eConst,360,$Lang.dummyLoc)
              ,A2($Lang.eConst,0,$Lang.dummyLoc)
              ,A2($Lang.eConst,0,$Lang.dummyLoc)
              ,$Lang.eVar("bounds")]));
   });
   var addRawOval = F3(function (old,_p121,_p120) {
      var _p122 = _p121;
      var _p123 = _p120;
      var _p124 = A2(boundingBox,_p122._1,_p123._1);
      var xa = _p124._0;
      var xb = _p124._1;
      var ya = _p124._2;
      var yb = _p124._3;
      var _p125 = {ctor: "_Tuple2"
                  ,_0: (xb - xa) / 2 | 0
                  ,_1: (yb - ya) / 2 | 0};
      var rx = _p125._0;
      var ry = _p125._1;
      var _p126 = {ctor: "_Tuple2",_0: xa + rx,_1: ya + ry};
      var cx = _p126._0;
      var cy = _p126._1;
      return A5(add,
      "ellipse",
      old,
      _U.list([A2(makeLet,
              _U.list(["cx","cy","rx","ry"]),
              makeInts(_U.list([cx,cy,rx,ry])))
              ,A2(makeLet,
              _U.list(["color","rot"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,0,$Lang.dummyLoc)]))]),
      $Lang.eVar0("rawEllipse"),
      _U.list([$Lang.eVar("color")
              ,A2($Lang.eConst,360,$Lang.dummyLoc)
              ,A2($Lang.eConst,0,$Lang.dummyLoc)
              ,$Lang.eVar("cx")
              ,$Lang.eVar("cy")
              ,$Lang.eVar("rx")
              ,$Lang.eVar("ry")
              ,$Lang.eVar("rot")]));
   });
   var addStretchyOval = F3(function (old,_p128,_p127) {
      var _p129 = _p128;
      var _p130 = _p127;
      var _p131 = A2(boundingBox,_p129._1,_p130._1);
      var xa = _p131._0;
      var xb = _p131._1;
      var ya = _p131._2;
      var yb = _p131._3;
      return A5(add,
      "ellipse",
      old,
      _U.list([A3(makeLetAs,
              "bounds",
              _U.list(["left","top","right","bot"]),
              makeInts(_U.list([xa,ya,xb,yb])))
              ,A2(makeLet,
              _U.list(["color","strokeColor","strokeWidth"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,360,$Lang.dummyLoc)
                      ,A2($Lang.eConst,0,$Lang.dummyLoc)]))]),
      $Lang.eVar0("oval"),
      A2($List.map,
      $Lang.eVar,
      _U.list(["color","strokeColor","strokeWidth","bounds"])));
   });
   var addLambdaBounds = F4(function (old,_p133,_p132,func) {
      var _p134 = _p133;
      var _p139 = _p134._1;
      var _p135 = _p132;
      var _p138 = _p135._1;
      var _p136 = _U.eq(old.keysDown,
      $Keys.shift) ? A2(squareBoundingBox,
      _p139,
      _p138) : A2(boundingBox,_p139,_p138);
      var xa = _p136._0;
      var xb = _p136._1;
      var ya = _p136._2;
      var yb = _p136._3;
      var bounds = A2($Lang.eList,
      makeInts(_U.list([xa,ya,xb,yb])),
      $Maybe.Nothing);
      var args = _U.list([]);
      var eNew = $Lang.withDummyPos(A4($Lang.EApp,
      "\n  ",
      $Lang.eVar0("withBounds"),
      _U.list([bounds,func]),
      ""));
      var newBlob = A2($Blobs.withBoundsBlob,
      eNew,
      {ctor: "_Tuple3",_0: bounds,_1: "XXXXX",_2: args});
      var _p137 = $Blobs.splitExp(old.inputExp);
      var defs = _p137._0;
      var mainExp = _p137._1;
      var mainExp$ = A2(addToMainExp,newBlob,mainExp);
      var code = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                      ,_0: defs
                                                      ,_1: mainExp$}));
      return _U.update(old,
      {code: code,mouseMode: $InterfaceModel.MouseNothing});
   });
   var addLambda = F3(function (old,pt2,pt1) {
      var _p140 = old.lambdaTools;
      var selectedIdx = _p140._0;
      var exps = _p140._1;
      var _p141 = A2($Utils.geti,selectedIdx,exps);
      if (_p141.ctor === "LambdaBounds") {
            return A4(addLambdaBounds,old,pt2,pt1,_p141._0);
         } else {
            return A4(addLambdaAnchor,old,pt2,pt1,_p141._0);
         }
   });
   var addTextBox = F3(function (old,click2,click1) {
      var _p142 = A2(boundingBox,
      $Basics.snd(click2),
      $Basics.snd(click1));
      var xa = _p142._0;
      var xb = _p142._1;
      var ya = _p142._2;
      var yb = _p142._3;
      var fontSize = A2($Lang.eConst0,
      $Basics.toFloat(yb - ya),
      $Lang.dummyLoc);
      return A5(add,
      "text",
      old,
      _U.list([A2(makeLet,
      _U.list(["fontSize","textVal"]),
      _U.list([fontSize,$Lang.eStr("Text")]))]),
      $Lang.eVar0("simpleText"),
      _U.list([$Lang.eStr("Tahoma, sans-serif")
              ,$Lang.eStr("black")
              ,$Lang.eVar("fontSize")
              ,A2($Lang.eConst,$Basics.toFloat(xa),$Lang.dummyLoc)
              ,A2($Lang.eConst,$Basics.toFloat(xb),$Lang.dummyLoc)
              ,A2($Lang.eConst,$Basics.toFloat(yb),$Lang.dummyLoc)
              ,A2($Lang.eConst,1.5,$Lang.dummyLoc)
              ,$Lang.eVar("textVal")]));
   });
   var guideStroke = A2($LangSvg.attr,"stroke","aqua");
   var dotStrokeWidth = A2($LangSvg.attr,"stroke-width","2");
   var dotStroke = A2($LangSvg.attr,"stroke","black");
   var drawDotSize = 10;
   var dotSize = A2($LangSvg.attr,
   "r",
   $Basics.toString(drawDotSize));
   var dotFillCursor = A2($LangSvg.attr,"fill","none");
   var dotFillControlPt = A2($LangSvg.attr,"fill","green");
   var dotFill2 = A2($LangSvg.attr,"fill","orange");
   var dotFill = A2($LangSvg.attr,"fill","red");
   var defaultFill = A2($LangSvg.attr,"fill","gray");
   var defaultStrokeWidth = A2($LangSvg.attr,"stroke-width","5");
   var defaultStroke = A2($LangSvg.attr,"stroke","gray");
   var defaultOpacity = $Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                                        ,_0: "opacity"
                                                        ,_1: "0.5"}]));
   var boundingBoxOfPoints_ = function (pts) {
      var _p143 = $List.unzip(pts);
      var xs = _p143._0;
      var ys = _p143._1;
      var xMax = $Utils.fromJust($List.maximum(xs));
      var xMin = $Utils.fromJust($List.minimum(xs));
      var yMax = $Utils.fromJust($List.maximum(ys));
      var yMin = $Utils.fromJust($List.minimum(ys));
      return {ctor: "_Tuple4",_0: xMin,_1: xMax,_2: yMin,_3: yMax};
   };
   var boundingBoxOfPoints = function (pts) {
      var pts$ = A2($List.map,
      function (_p144) {
         var _p145 = _p144;
         return {ctor: "_Tuple2"
                ,_0: $Basics.toFloat(_p145._0)
                ,_1: $Basics.toFloat(_p145._1)};
      },
      pts);
      var _p146 = boundingBoxOfPoints_(pts$);
      var a = _p146._0;
      var b = _p146._1;
      var c = _p146._2;
      var d = _p146._3;
      return {ctor: "_Tuple4"
             ,_0: $Basics.round(a)
             ,_1: $Basics.round(b)
             ,_2: $Basics.round(c)
             ,_3: $Basics.round(d)};
   };
   var addStretchablePolygon = F2(function (old,keysAndPoints) {
      var points = A2($List.map,$Basics.snd,keysAndPoints);
      var _p147 = boundingBoxOfPoints(points);
      var xMin = _p147._0;
      var xMax = _p147._1;
      var yMin = _p147._2;
      var yMax = _p147._3;
      var _p148 = {ctor: "_Tuple2",_0: xMax - xMin,_1: yMax - yMin};
      var width = _p148._0;
      var height = _p148._1;
      var sPcts = $Utils.bracks($Utils.spaces(A3($Basics.flip,
      $List.map,
      $List.reverse(points),
      function (_p149) {
         var _p150 = _p149;
         var xPct = ($Basics.toFloat(_p150._0) - $Basics.toFloat(xMin)) / $Basics.toFloat(width);
         var yPct = ($Basics.toFloat(_p150._1) - $Basics.toFloat(yMin)) / $Basics.toFloat(height);
         var xStr = maybeThaw(xPct);
         var yStr = maybeThaw(yPct);
         return $Utils.bracks($Utils.spaces(_U.list([xStr,yStr])));
      })));
      return A5(add,
      "polygon",
      old,
      _U.list([A3(makeLetAs,
              "bounds",
              _U.list(["left","top","right","bot"]),
              makeInts(_U.list([xMin,yMin,xMax,yMax])))
              ,A2(makeLet,
              _U.list(["color","strokeColor","strokeWidth"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,360,$Lang.dummyLoc)
                      ,A2($Lang.eConst,2,$Lang.dummyLoc)]))
              ,A2(makeLet,_U.list(["pcts"]),_U.list([$Lang.eRaw(sPcts)]))]),
      $Lang.eVar0("stretchyPolygon"),
      A2($List.map,
      $Lang.eVar,
      _U.list(["bounds"
              ,"color"
              ,"strokeColor"
              ,"strokeWidth"
              ,"pcts"])));
   });
   var addStickyPolygon = F2(function (old,keysAndPoints) {
      var points = A2($List.map,$Basics.snd,keysAndPoints);
      var _p151 = boundingBoxOfPoints(points);
      var xMin = _p151._0;
      var xMax = _p151._1;
      var yMin = _p151._2;
      var yMax = _p151._3;
      var _p152 = {ctor: "_Tuple2",_0: xMax - xMin,_1: yMax - yMin};
      var width = _p152._0;
      var height = _p152._1;
      var sOffsets = $Utils.bracks($Utils.spaces(A3($Basics.flip,
      $List.map,
      $List.reverse(points),
      function (_p153) {
         var _p154 = _p153;
         var _p158 = _p154._1;
         var _p157 = _p154._0;
         var _p155 = {ctor: "_Tuple2",_0: _p158 - yMin,_1: _p158 - yMax};
         var dyTop = _p155._0;
         var dyBot = _p155._1;
         var yOff = _U.cmp(dyTop,
         $Basics.abs(dyBot)) < 1 ? $Utils.bracks($Utils.spaces(_U.list(["top"
                                                                       ,maybeThaw0($Basics.toString(dyTop))]))) : $Utils.bracks($Utils.spaces(_U.list(["bot"
                                                                                                                                                      ,maybeThaw0($Basics.toString(dyBot))])));
         var _p156 = {ctor: "_Tuple2",_0: _p157 - xMin,_1: _p157 - xMax};
         var dxLeft = _p156._0;
         var dxRight = _p156._1;
         var xOff = _U.cmp(dxLeft,
         $Basics.abs(dxRight)) < 1 ? $Utils.bracks($Utils.spaces(_U.list(["left"
                                                                         ,maybeThaw0($Basics.toString(dxLeft))]))) : $Utils.bracks($Utils.spaces(_U.list(["right"
                                                                                                                                                         ,maybeThaw0($Basics.toString(dxRight))])));
         return $Utils.bracks($Utils.spaces(_U.list([xOff,yOff])));
      })));
      return A5(add,
      "polygon",
      old,
      _U.list([A3(makeLetAs,
              "bounds",
              _U.list(["left","top","right","bot"]),
              makeInts(_U.list([xMin,yMin,xMax,yMax])))
              ,A2(makeLet,
              _U.list(["color","strokeColor","strokeWidth"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,360,$Lang.dummyLoc)
                      ,A2($Lang.eConst,2,$Lang.dummyLoc)]))
              ,A2(makeLet,
              _U.list(["offsets"]),
              _U.list([$Lang.eRaw(sOffsets)]))]),
      $Lang.eVar0("stickyPolygon"),
      A2($List.map,
      $Lang.eVar,
      _U.list(["bounds"
              ,"color"
              ,"strokeColor"
              ,"strokeWidth"
              ,"offsets"])));
   });
   var addPolygon = F3(function (stk,old,points) {
      var _p159 = stk;
      switch (_p159.ctor)
      {case "Raw": return A2(addRawPolygon,old,points);
         case "Stretchy": return A2(addStretchablePolygon,old,points);
         default: return A2(addStickyPolygon,old,points);}
   });
   var addStretchyPath = F2(function (old,keysAndPoints) {
      var points = A2($List.map,$Basics.snd,keysAndPoints);
      var _p160 = boundingBoxOfPoints(points);
      var xMin = _p160._0;
      var xMax = _p160._1;
      var yMin = _p160._2;
      var yMax = _p160._3;
      var _p161 = {ctor: "_Tuple2"
                  ,_0: $Basics.toFloat(xMax - xMin)
                  ,_1: $Basics.toFloat(yMax - yMin)};
      var width = _p161._0;
      var height = _p161._1;
      var strX = function (x) {
         return maybeThaw($Basics.toFloat(x - xMin) / width);
      };
      var strY = function (y) {
         return maybeThaw($Basics.toFloat(y - yMin) / height);
      };
      var _p162 = A3(pathCommands,strX,strY,keysAndPoints);
      var extraLets = _p162._0;
      var sD = _p162._1;
      return A5(add,
      "path",
      old,
      A2($Basics._op["++"],
      _U.list([A3(makeLetAs,
              "bounds",
              _U.list(["left","top","right","bot"]),
              makeInts(_U.list([xMin,yMin,xMax,yMax])))
              ,A2(makeLet,
              _U.list(["strokeColor","strokeWidth","color"]),
              _U.list([randomColor(old)
                      ,A2($Lang.eConst,5,$Lang.dummyLoc)
                      ,randomColor1(old)]))]),
      A2($Basics._op["++"],
      extraLets,
      _U.list([A2(makeLet,
      _U.list(["dPcts"]),
      _U.list([$Lang.eVar(sD)]))]))),
      $Lang.eVar0("stretchyPath"),
      A2($List.map,
      $Lang.eVar,
      _U.list(["bounds"
              ,"color"
              ,"strokeColor"
              ,"strokeWidth"
              ,"dPcts"])));
   });
   var addPath = F3(function (stk,old,keysAndPoints) {
      var _p163 = stk;
      switch (_p163.ctor)
      {case "Raw": return A2(addAbsolutePath,old,keysAndPoints);
         case "Stretchy": return A2(addStretchyPath,old,keysAndPoints);
         default: return A2(addStretchyPath,old,keysAndPoints);}
   });
   var svgPath = A2($Basics.flip,$Svg.path,_U.list([]));
   var svgPolygon = A2($Basics.flip,$Svg.polygon,_U.list([]));
   var svgEllipse = A2($Basics.flip,$Svg.ellipse,_U.list([]));
   var svgCircle = A2($Basics.flip,$Svg.circle,_U.list([]));
   var drawDot = F2(function (fill,_p164) {
      var _p165 = _p164;
      return svgCircle(_U.list([dotSize
                               ,fill
                               ,defaultOpacity
                               ,dotStroke
                               ,dotStrokeWidth
                               ,A2($LangSvg.attr,"cx",$Basics.toString(_p165._0))
                               ,A2($LangSvg.attr,"cy",$Basics.toString(_p165._1))]));
   });
   var drawNewEllipse = F3(function (keysDown,_p167,_p166) {
      var _p168 = _p167;
      var _p173 = _p168._1;
      var _p169 = _p166;
      var _p172 = _p169._1;
      var _p170 = _U.eq(keysDown,$Keys.shift) ? A2(squareBoundingBox,
      _p173,
      _p172) : A2(boundingBox,_p173,_p172);
      var xa = _p170._0;
      var xb = _p170._1;
      var ya = _p170._2;
      var yb = _p170._3;
      var _p171 = {ctor: "_Tuple2"
                  ,_0: (xb - xa) / 2 | 0
                  ,_1: (yb - ya) / 2 | 0};
      var rx = _p171._0;
      var ry = _p171._1;
      var ellipse = svgEllipse(_U.list([defaultFill
                                       ,defaultOpacity
                                       ,A2($LangSvg.attr,"cx",$Basics.toString(xa + rx))
                                       ,A2($LangSvg.attr,"cy",$Basics.toString(ya + ry))
                                       ,A2($LangSvg.attr,"rx",$Basics.toString(rx))
                                       ,A2($LangSvg.attr,"ry",$Basics.toString(ry))]));
      var clearDots = A2($List.map,
      drawDot(dotFillCursor),
      _U.list([{ctor: "_Tuple2",_0: xb,_1: yb}
              ,{ctor: "_Tuple2",_0: xa,_1: ya}
              ,_p173
              ,_p172]));
      return A2($Basics._op["++"],clearDots,_U.list([ellipse]));
   });
   var drawNewPolygon = F2(function (_p174,keysAndPoints) {
      var _p175 = _p174;
      var _p180 = _p175._1;
      var points = A2($List.map,$Basics.snd,keysAndPoints);
      var _p176 = $Utils.last_(A2($List._op["::"],_p180,points));
      var xInit = _p176._0;
      var yInit = _p176._1;
      var redDot = A2(drawDot,
      dotFill,
      {ctor: "_Tuple2",_0: xInit,_1: yInit});
      var clearDots = A2($List.map,
      drawDot(dotFillCursor),
      A2($List._op["::"],_p180,points));
      var maybeShape = function () {
         var _p177 = A2($List._op["::"],_p180,points);
         if (_p177.ctor === "::" && _p177._1.ctor === "[]") {
               return _U.list([]);
            } else {
               var polyPoints = $List.reverse(A2($List._op["::"],
               _p180,
               points));
               var sPoints = $Utils.spaces(A2($List.map,
               function (_p178) {
                  var _p179 = _p178;
                  return A2($String.join,
                  ",",
                  A2($List.map,$Basics.toString,_U.list([_p179._0,_p179._1])));
               },
               polyPoints));
               return _U.list([svgPolygon(_U.list([defaultStroke
                                                  ,defaultStrokeWidth
                                                  ,defaultFill
                                                  ,defaultOpacity
                                                  ,A2($LangSvg.attr,"points",sPoints)]))]);
            }
      }();
      return A2($List._op["::"],
      redDot,
      A2($Basics._op["++"],clearDots,maybeShape));
   });
   var drawNewPath = F2(function (_p181,keysAndPoints) {
      var _p182 = _p181;
      var _p197 = _p182._1;
      var points = A2($List.map,$Basics.snd,keysAndPoints);
      var redDot = _U.list([A2(drawDot,
      dotFill,
      $Utils.last_(A2($List._op["::"],_p197,points)))]);
      var yellowDot = function () {
         var _p183 = points;
         if (_p183.ctor === "[]") {
               return _U.list([]);
            } else {
               return _U.list([A2(drawDot,dotFill2,_p197)]);
            }
      }();
      var pathAndPoints = function () {
         var plus = F2(function (_p185,_p184) {
            var _p186 = _p185;
            var _p187 = _p184;
            return {ctor: "_Tuple2"
                   ,_0: A2($Basics._op["++"],_p186._0,_p187._0)
                   ,_1: A2($Basics._op["++"],_p186._1,_p187._1)};
         });
         var foo = function (list0) {
            var _p188 = list0;
            if (_p188.ctor === "[]") {
                  return {ctor: "_Tuple2",_0: "",_1: _U.list([])};
               } else {
                  var _p194 = _p188._0._0;
                  var _p193 = _p188._1;
                  var _p192 = _p188._0._1;
                  if (_U.eq(_p194,$Keys.q)) {
                        var _p189 = _p193;
                        if (_p189.ctor === "[]") {
                              return {ctor: "_Tuple2",_0: "",_1: _U.list([_p192])};
                           } else {
                              var cmd = $Utils.spaces(_U.list([" Q"
                                                              ,strPt(_p192)
                                                              ,strPt(_p189._0._1)]));
                              return A2(plus,
                              {ctor: "_Tuple2",_0: cmd,_1: _U.list([_p192])},
                              foo(_p189._1));
                           }
                     } else if (_U.eq(_p194,$Keys.c)) {
                           var _p190 = _p193;
                           if (_p190.ctor === "[]") {
                                 return {ctor: "_Tuple2",_0: "",_1: _U.list([_p192])};
                              } else {
                                 if (_p190._1.ctor === "[]") {
                                       return {ctor: "_Tuple2"
                                              ,_0: ""
                                              ,_1: _U.list([_p192,_p190._0._1])};
                                    } else {
                                       var _p191 = _p190._0._1;
                                       var cmd = $Utils.spaces(_U.list([" C"
                                                                       ,strPt(_p192)
                                                                       ,strPt(_p191)
                                                                       ,strPt(_p190._1._0._1)]));
                                       return A2(plus,
                                       {ctor: "_Tuple2",_0: cmd,_1: _U.list([_p192,_p191])},
                                       foo(_p190._1._1));
                                    }
                              }
                        } else return A2(plus,
                        {ctor: "_Tuple2"
                        ,_0: $Utils.spaces(_U.list([" L",strPt(_p192)]))
                        ,_1: _U.list([])},
                        foo(_p193));
               }
         };
         var _p195 = $List.reverse(A2($List._op["::"],
         {ctor: "_Tuple2",_0: _p182._0,_1: _p197},
         keysAndPoints));
         if (_p195.ctor === "[]") {
               return _U.list([]);
            } else {
               if (_p195._1.ctor === "[]") {
                     return _U.list([]);
                  } else {
                     var _p196 = A2(plus,
                     {ctor: "_Tuple2"
                     ,_0: $Utils.spaces(_U.list(["M",strPt(_p195._0._1)]))
                     ,_1: _U.list([])},
                     foo(_p195._1));
                     var sPath = _p196._0;
                     var controlPoints = _p196._1;
                     var path = svgPath(_U.list([defaultStroke
                                                ,defaultStrokeWidth
                                                ,defaultFill
                                                ,defaultOpacity
                                                ,A2($LangSvg.attr,"d",sPath)]));
                     var points = A2($List.map,
                     drawDot(dotFillControlPt),
                     controlPoints);
                     return A2($List._op["::"],path,points);
                  }
            }
      }();
      var clearDots = A2($List.map,
      drawDot(dotFillCursor),
      A2($List._op["::"],_p197,points));
      return A2($Basics._op["++"],
      redDot,
      A2($Basics._op["++"],
      yellowDot,
      A2($Basics._op["++"],clearDots,pathAndPoints)));
   });
   var drawNewHelperDot = function (_p198) {
      var _p199 = _p198;
      var dot = svgCircle(_U.list([defaultFill
                                  ,defaultOpacity
                                  ,A2($LangSvg.attr,"cx",$Basics.toString(200))
                                  ,A2($LangSvg.attr,"cy",$Basics.toString(200))
                                  ,A2($LangSvg.attr,"r",$Basics.toString(drawDotSize))]));
      return _U.list([dot]);
   };
   var svgRect = A2($Basics.flip,$Svg.rect,_U.list([]));
   var drawNewRect = F3(function (keysDown,_p201,_p200) {
      var _p202 = _p201;
      var _p206 = _p202._1;
      var _p203 = _p200;
      var _p205 = _p203._1;
      var _p204 = _U.eq(keysDown,$Keys.shift) ? A2(squareBoundingBox,
      _p206,
      _p205) : A2(boundingBox,_p206,_p205);
      var xa = _p204._0;
      var xb = _p204._1;
      var ya = _p204._2;
      var yb = _p204._3;
      var rect = svgRect(_U.list([defaultFill
                                 ,defaultOpacity
                                 ,A2($LangSvg.attr,"x",$Basics.toString(xa))
                                 ,A2($LangSvg.attr,"width",$Basics.toString(xb - xa))
                                 ,A2($LangSvg.attr,"y",$Basics.toString(ya))
                                 ,A2($LangSvg.attr,"height",$Basics.toString(yb - ya))]));
      var clearDots = A2($List.map,
      drawDot(dotFillCursor),
      _U.list([{ctor: "_Tuple2",_0: xb,_1: yb}
              ,{ctor: "_Tuple2",_0: xa,_1: ya}
              ,_p206
              ,_p205]));
      return A2($Basics._op["++"],clearDots,_U.list([rect]));
   });
   var svgLine = A2($Basics.flip,$Svg.line,_U.list([]));
   var drawNewLine = F3(function (model,click2,click1) {
      var _p207 = {ctor: "_Tuple2",_0: click2,_1: click1};
      var x2 = _p207._0._1._0;
      var y2 = _p207._0._1._1;
      var x1 = _p207._1._1._0;
      var y1 = _p207._1._1._1;
      var stroke = _U.eq(model.tool,
      $InterfaceModel.HelperLine) ? guideStroke : defaultStroke;
      var _p208 = A3(snapLine,model.keysDown,click2,click1);
      var xb = _p208._0;
      var yb = _p208._1;
      var line = svgLine(_U.list([stroke
                                 ,defaultStrokeWidth
                                 ,defaultOpacity
                                 ,A2($LangSvg.attr,"x1",$Basics.toString(x1))
                                 ,A2($LangSvg.attr,"y1",$Basics.toString(y1))
                                 ,A2($LangSvg.attr,"x2",$Basics.toString(xb))
                                 ,A2($LangSvg.attr,"y2",$Basics.toString(yb))]));
      var clearDots = A2($List.map,
      drawDot(dotFillCursor),
      _U.list([{ctor: "_Tuple2",_0: xb,_1: yb}
              ,{ctor: "_Tuple2",_0: x2,_1: y2}
              ,{ctor: "_Tuple2",_0: x1,_1: y1}]));
      return A2($Basics._op["++"],clearDots,_U.list([line]));
   });
   var drawNewShape = function (model) {
      var _p209 = {ctor: "_Tuple2"
                  ,_0: model.tool
                  ,_1: model.mouseMode};
      _v73_9: do {
         if (_p209.ctor === "_Tuple2" && _p209._1.ctor === "MouseDrawNew" && _p209._1._0.ctor === "::")
         {
               switch (_p209._0.ctor)
               {case "Line":
                  if (_p209._1._0._1.ctor === "::" && _p209._1._0._1._1.ctor === "[]")
                    {
                          return A3(drawNewLine,
                          model,
                          _p209._1._0._0,
                          _p209._1._0._1._0);
                       } else {
                          break _v73_9;
                       }
                  case "Rect":
                  if (_p209._1._0._1.ctor === "::" && _p209._1._0._1._1.ctor === "[]")
                    {
                          return A3(drawNewRect,
                          model.keysDown,
                          _p209._1._0._0,
                          _p209._1._0._1._0);
                       } else {
                          break _v73_9;
                       }
                  case "Oval":
                  if (_p209._1._0._1.ctor === "::" && _p209._1._0._1._1.ctor === "[]")
                    {
                          return A3(drawNewEllipse,
                          model.keysDown,
                          _p209._1._0._0,
                          _p209._1._0._1._0);
                       } else {
                          break _v73_9;
                       }
                  case "Poly": return A2(drawNewPolygon,
                    _p209._1._0._0,
                    _p209._1._0._1);
                  case "Path": return A2(drawNewPath,
                    _p209._1._0._0,
                    _p209._1._0._1);
                  case "HelperDot": if (_p209._1._0._1.ctor === "[]") {
                          return drawNewHelperDot(_p209._1._0._0);
                       } else {
                          break _v73_9;
                       }
                  case "HelperLine":
                  if (_p209._1._0._1.ctor === "::" && _p209._1._0._1._1.ctor === "[]")
                    {
                          return A3(drawNewLine,
                          model,
                          _p209._1._0._0,
                          _p209._1._0._1._0);
                       } else {
                          break _v73_9;
                       }
                  case "Lambda":
                  if (_p209._1._0._1.ctor === "::" && _p209._1._0._1._1.ctor === "[]")
                    {
                          return A3(drawNewRect,
                          model.keysDown,
                          _p209._1._0._0,
                          _p209._1._0._1._0);
                       } else {
                          break _v73_9;
                       }
                  case "Text":
                  if (_p209._1._0._1.ctor === "::" && _p209._1._0._1._1.ctor === "[]")
                    {
                          return A3(drawNewRect,
                          model.keysDown,
                          _p209._1._0._0,
                          _p209._1._0._1._0);
                       } else {
                          break _v73_9;
                       }
                  default: break _v73_9;}
            } else {
               break _v73_9;
            }
      } while (false);
      return _U.list([]);
   };
   return _elm.Draw.values = {_op: _op
                             ,drawNewShape: drawNewShape
                             ,drawDotSize: drawDotSize
                             ,boundingBoxOfPoints_: boundingBoxOfPoints_
                             ,addLine: addLine
                             ,addRawSquare: addRawSquare
                             ,addRawRect: addRawRect
                             ,addStretchySquare: addStretchySquare
                             ,addStretchyRect: addStretchyRect
                             ,addRawCircle: addRawCircle
                             ,addRawOval: addRawOval
                             ,addStretchyCircle: addStretchyCircle
                             ,addStretchyOval: addStretchyOval
                             ,addPath: addPath
                             ,addPolygon: addPolygon
                             ,addLambda: addLambda
                             ,addHelperDot: addHelperDot
                             ,addTextBox: addTextBox
                             ,lambdaToolOptionsOf: lambdaToolOptionsOf};
};
Elm.LangTools = Elm.LangTools || {};
Elm.LangTools.make = function (_elm) {
   "use strict";
   _elm.LangTools = _elm.LangTools || {};
   if (_elm.LangTools.values) return _elm.LangTools.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangParser2 = Elm.LangParser2.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var renameIdentifierInPat = F3(function (old,$new,pat) {
      var recurse = A2(renameIdentifierInPat,old,$new);
      var recurseList = $List.map(recurse);
      var pat_$ = function () {
         var _p0 = pat.val;
         switch (_p0.ctor)
         {case "PVar": return _U.eq(_p0._1,old) ? A3($Lang.PVar,
              _p0._0,
              $new,
              _p0._2) : pat.val;
            case "PList": if (_p0._3.ctor === "Nothing") {
                    return A5($Lang.PList,
                    _p0._0,
                    recurseList(_p0._1),
                    _p0._2,
                    $Maybe.Nothing,
                    _p0._4);
                 } else {
                    return A5($Lang.PList,
                    _p0._0,
                    recurseList(_p0._1),
                    _p0._2,
                    $Maybe.Just(recurse(_p0._3._0)),
                    _p0._4);
                 }
            case "PAs": var _p4 = _p0._2;
              var _p3 = _p0._0;
              var _p2 = _p0._3;
              var _p1 = _p0._1;
              return _U.eq(_p1,old) ? A4($Lang.PAs,
              _p3,
              $new,
              _p4,
              recurse(_p2)) : A4($Lang.PAs,_p3,_p1,_p4,recurse(_p2));
            default: return pat.val;}
      }();
      return _U.update(pat,{val: pat_$});
   });
   var renameIdentifierInPats = F3(function (old,$new,pats) {
      return A2($List.map,A2(renameIdentifierInPat,old,$new),pats);
   });
   var renameIdentifier = F3(function (old,$new,exp) {
      var exp__Renamer = function (e__) {
         var _p5 = e__;
         switch (_p5.ctor)
         {case "EVar": return _U.eq(_p5._1,old) ? A2($Lang.EVar,
              _p5._0,
              $new) : e__;
            case "EFun": return A4($Lang.EFun,
              _p5._0,
              A3(renameIdentifierInPats,old,$new,_p5._1),
              _p5._2,
              _p5._3);
            case "ECase": var branches$ = A2($List.map,
              $Lang.mapValField(function (_p6) {
                 var _p7 = _p6;
                 return A4($Lang.Branch_,
                 _p7._0,
                 A3(renameIdentifierInPat,old,$new,_p7._1),
                 _p7._2,
                 _p7._3);
              }),
              _p5._2);
              return A4($Lang.ECase,_p5._0,_p5._1,branches$,_p5._3);
            case "ETypeCase": return A4($Lang.ETypeCase,
              _p5._0,
              A3(renameIdentifierInPat,old,$new,_p5._1),
              _p5._2,
              _p5._3);
            case "ELet": return A7($Lang.ELet,
              _p5._0,
              _p5._1,
              _p5._2,
              A3(renameIdentifierInPat,old,$new,_p5._3),
              _p5._4,
              _p5._5,
              _p5._6);
            default: return e__;}
      };
      return A2($Lang.mapExpViaExp__,exp__Renamer,exp);
   });
   var identifiersListInPat = function (pat) {
      var _p8 = pat.val;
      switch (_p8.ctor)
      {case "PVar": return _U.list([_p8._1]);
         case "PList": if (_p8._3.ctor === "Just") {
                 return A2($List.concatMap,
                 identifiersListInPat,
                 A2($List._op["::"],_p8._3._0,_p8._1));
              } else {
                 return A2($List.concatMap,identifiersListInPat,_p8._1);
              }
         case "PAs": return A2($List._op["::"],
           _p8._1,
           identifiersListInPat(_p8._3));
         default: return _U.list([]);}
   };
   var identifiersList = function (exp) {
      var folder = F2(function (e__,acc) {
         var _p9 = e__;
         switch (_p9.ctor)
         {case "EVar": return A2($List._op["::"],_p9._1,acc);
            case "EFun": return A2($Basics._op["++"],
              A2($List.concatMap,identifiersListInPat,_p9._1),
              acc);
            case "ECase": var pats = $Lang.branchPats(_p9._2);
              return A2($Basics._op["++"],
              A2($List.concatMap,identifiersListInPat,pats),
              acc);
            case "ETypeCase": return A2($Basics._op["++"],
              identifiersListInPat(_p9._1),
              acc);
            case "ELet": return A2($Basics._op["++"],
              identifiersListInPat(_p9._3),
              acc);
            default: return acc;}
      });
      return A3($Lang.foldExpViaE__,folder,_U.list([]),exp);
   };
   var identifierCounts = function (exp) {
      return A3($List.foldl,
      F2(function (ident,counts) {
         return A3($Dict.update,
         ident,
         function (old) {
            var _p10 = old;
            if (_p10.ctor === "Just") {
                  return $Maybe.Just(_p10._0 + 1);
               } else {
                  return $Maybe.Just(1);
               }
         },
         counts);
      }),
      $Dict.empty,
      identifiersList(exp));
   };
   var identifiersSetInPat = function (pat) {
      return $Set.fromList(identifiersListInPat(pat));
   };
   var identifiersSet = function (exp) {
      return $Set.fromList(identifiersList(exp));
   };
   var scopeNamesLocLiftedThrough_ = F3(function (targetLocId,
   scopeNames,
   exp) {
      var _p11 = exp.val.e__;
      _v6_2: do {
         switch (_p11.ctor)
         {case "ELet": var scopeNames$ = function () {
                 var _p12 = _p11._3.val;
                 switch (_p12.ctor)
                 {case "PVar": return A2($Basics._op["++"],
                      scopeNames,
                      _U.list([_p12._1]));
                    case "PAs": return A2($Basics._op["++"],
                      scopeNames,
                      _U.list([_p12._1]));
                    default: return scopeNames;}
              }();
              return A2($Basics._op["++"],
              A3(scopeNamesLocLiftedThrough_,targetLocId,scopeNames$,_p11._4),
              A3(scopeNamesLocLiftedThrough_,targetLocId,scopeNames,_p11._5));
            case "EConst": if (_p11._2.ctor === "_Tuple3") {
                    return _U.eq(_p11._2._0,
                    targetLocId) ? _U.list([scopeNames]) : _U.list([]);
                 } else {
                    break _v6_2;
                 }
            default: break _v6_2;}
      } while (false);
      var recurse = function (exp) {
         return A3(scopeNamesLocLiftedThrough_,
         targetLocId,
         scopeNames,
         exp);
      };
      return A2($List.concatMap,recurse,$Lang.childExps(exp));
   });
   var scopeNamesLocLiftedThrough = F2(function (newLetBody,
   targetLoc) {
      var _p13 = targetLoc;
      var targetLocId = _p13._0;
      var ident = _p13._2;
      var _p14 = A3(scopeNamesLocLiftedThrough_,
      targetLocId,
      _U.list([]),
      newLetBody);
      if (_p14.ctor === "[]") {
            return _U.list([]);
         } else {
            if (_p14._1.ctor === "[]") {
                  var _p16 = _p14._0;
                  var _p15 = $List.head($List.reverse(_p16));
                  if (_p15.ctor === "Nothing") {
                        return _U.list([]);
                     } else {
                        return _U.eq(_p15._0,
                        ident) ? $Utils.removeLastElement(_p16) : _p16;
                     }
               } else {
                  return _U.crashCase("LangTools",
                  {start: {line: 85,column: 3},end: {line: 101,column: 122}},
                  _p14)(A2($Basics._op["++"],
                  "Found locId ",
                  A2($Basics._op["++"],
                  $Basics.toString(targetLocId),
                  A2($Basics._op["++"],
                  " more than once in the expression: ",
                  $Basics.toString(newLetBody)))));
               }
         }
   });
   var isTopLevel = F2(function (exp,program) {
      isTopLevel: while (true) if (_U.eq(exp,program)) return true;
      else {
            var _p18 = program.val.e__;
            _v10_3: do {
               switch (_p18.ctor)
               {case "ELet": if (_p18._1.ctor === "Def") {
                          var _v11 = exp,_v12 = _p18._5;
                          exp = _v11;
                          program = _v12;
                          continue isTopLevel;
                       } else {
                          break _v10_3;
                       }
                  case "EComment": var _v13 = exp,_v14 = _p18._2;
                    exp = _v13;
                    program = _v14;
                    continue isTopLevel;
                  case "EOption": var _v15 = exp,_v16 = _p18._4;
                    exp = _v15;
                    program = _v16;
                    continue isTopLevel;
                  default: break _v10_3;}
            } while (false);
            return false;
         }
   });
   var allLocsAndNumbers = function (exp) {
      return A3($Lang.foldExpViaE__,
      F2(function (e__,acc) {
         var _p19 = e__;
         if (_p19.ctor === "EConst") {
               return A2($List._op["::"],
               {ctor: "_Tuple2",_0: _p19._2,_1: _p19._1},
               acc);
            } else {
               return acc;
            }
      }),
      _U.list([]),
      exp);
   };
   var frozenLocIdsAndNumbers = function (exp) {
      return A2($List.map,
      function (_p20) {
         var _p21 = _p20;
         return {ctor: "_Tuple2",_0: _p21._0._0,_1: _p21._1};
      },
      A2($List.filter,
      function (_p22) {
         var _p23 = _p22;
         return _U.eq(_p23._0._1,
         "!") || $LangParser2.isPreludeLocId(_p23._0._0);
      },
      allLocsAndNumbers(exp)));
   };
   var unfrozenLocIdsAndNumbers = function (exp) {
      return A2($List.map,
      function (_p24) {
         var _p25 = _p24;
         return {ctor: "_Tuple2",_0: _p25._0._0,_1: _p25._1};
      },
      A2($List.filter,
      function (_p26) {
         var _p27 = _p26;
         return !_U.eq(_p27._0._1,
         "!") && $Basics.not($LangParser2.isPreludeLocId(_p27._0._0));
      },
      allLocsAndNumbers(exp)));
   };
   var replaceConstsWithVars = F2(function (locIdToNewName,exp) {
      var replacer = function (exp__) {
         var _p28 = exp__;
         if (_p28.ctor === "EConst" && _p28._2.ctor === "_Tuple3") {
               var _p29 = A2($Dict.get,_p28._2._0,locIdToNewName);
               if (_p29.ctor === "Just") {
                     return A2($Lang.EVar,_p28._0,_p29._0);
                  } else {
                     return exp__;
                  }
            } else {
               return exp__;
            }
      };
      return A2($Lang.mapExpViaExp__,replacer,exp);
   });
   return _elm.LangTools.values = {_op: _op
                                  ,replaceConstsWithVars: replaceConstsWithVars
                                  ,unfrozenLocIdsAndNumbers: unfrozenLocIdsAndNumbers
                                  ,frozenLocIdsAndNumbers: frozenLocIdsAndNumbers
                                  ,allLocsAndNumbers: allLocsAndNumbers
                                  ,isTopLevel: isTopLevel
                                  ,scopeNamesLocLiftedThrough: scopeNamesLocLiftedThrough
                                  ,scopeNamesLocLiftedThrough_: scopeNamesLocLiftedThrough_
                                  ,identifiersSet: identifiersSet
                                  ,identifiersSetInPat: identifiersSetInPat
                                  ,identifiersList: identifiersList
                                  ,identifiersListInPat: identifiersListInPat
                                  ,identifierCounts: identifierCounts
                                  ,renameIdentifierInPat: renameIdentifierInPat
                                  ,renameIdentifierInPats: renameIdentifierInPats
                                  ,renameIdentifier: renameIdentifier};
};
Elm.LangTransform = Elm.LangTransform || {};
Elm.LangTransform.make = function (_elm) {
   "use strict";
   _elm.LangTransform = _elm.LangTransform || {};
   if (_elm.LangTransform.values) return _elm.LangTransform.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangTools = Elm.LangTools.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $OurParser2 = Elm.OurParser2.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var simpleIdentsAndAssigns = F2(function (letPat,letAssign) {
      var _p0 = {ctor: "_Tuple2"
                ,_0: letPat.val
                ,_1: letAssign.val.e__};
      _v0_2: do {
         if (_p0.ctor === "_Tuple2") {
               switch (_p0._0.ctor)
               {case "PVar": return _U.list([{ctor: "_Tuple2"
                                             ,_0: _p0._0._1
                                             ,_1: letAssign}]);
                  case "PList":
                  if (_p0._0._3.ctor === "Nothing" && _p0._1.ctor === "EList" && _p0._1._3.ctor === "Nothing")
                    {
                          var patsAssigns = A2($Utils.zip,_p0._0._1,_p0._1._1);
                          var simplePatsAssigns = A2($List.filterMap,
                          function (_p1) {
                             var _p2 = _p1;
                             var _p3 = _p2._0.val;
                             if (_p3.ctor === "PVar") {
                                   return $Maybe.Just({ctor: "_Tuple2",_0: _p3._1,_1: _p2._1});
                                } else {
                                   return $Maybe.Nothing;
                                }
                          },
                          patsAssigns);
                          return simplePatsAssigns;
                       } else {
                          break _v0_2;
                       }
                  default: break _v0_2;}
            } else {
               break _v0_2;
            }
      } while (false);
      return _U.list([]);
   });
   var inlineTrivialRenamings = function (exp) {
      var inlineReplaceIfTrivialRename = F3(function (targetIdent,
      newExp,
      e__) {
         var _p4 = e__;
         if (_p4.ctor === "ELet") {
               var _p12 = _p4._6;
               var _p11 = _p4._0;
               var _p10 = _p4._2;
               var _p9 = _p4._3;
               var _p8 = _p4._1;
               var _p7 = _p4._5;
               var _p5 = {ctor: "_Tuple2",_0: _p9.val,_1: _p4._4.val.e__};
               _v4_2: do {
                  if (_p5.ctor === "_Tuple2") {
                        switch (_p5._0.ctor)
                        {case "PVar": if (_p5._1.ctor === "EVar") {
                                   if (_U.eq(_p5._1._1,targetIdent)) {
                                         var newExpAdjustedWs = A2($LangUnparser.replacePrecedingWhitespace,
                                         _p5._1._0,
                                         newExp);
                                         return A7($Lang.ELet,
                                         _p11,
                                         _p8,
                                         _p10,
                                         _p9,
                                         newExpAdjustedWs,
                                         _p7,
                                         _p12);
                                      } else return e__;
                                } else {
                                   break _v4_2;
                                }
                           case "PList":
                           if (_p5._0._3.ctor === "Nothing" && _p5._1.ctor === "EList" && _p5._1._3.ctor === "Nothing")
                             {
                                   var newAssigns = A2($List.map,
                                   function (assignExp) {
                                      var _p6 = assignExp.val.e__;
                                      if (_p6.ctor === "EVar") {
                                            if (_U.eq(_p6._1,targetIdent)) {
                                                  var oldPrecedingWs = $LangUnparser.precedingWhitespace(assignExp);
                                                  return A2($LangUnparser.replacePrecedingWhitespace,
                                                  oldPrecedingWs,
                                                  newExp);
                                               } else return assignExp;
                                         } else {
                                            return assignExp;
                                         }
                                   },
                                   _p5._1._1);
                                   var newAssignsListExp = $Lang.withDummyPos(A5($Lang.EList,
                                   _p5._1._0,
                                   newAssigns,
                                   _p5._1._2,
                                   $Maybe.Nothing,
                                   _p5._1._4));
                                   return A7($Lang.ELet,
                                   _p11,
                                   _p8,
                                   _p10,
                                   _p9,
                                   newAssignsListExp,
                                   _p7,
                                   _p12);
                                } else {
                                   break _v4_2;
                                }
                           default: break _v4_2;}
                     } else {
                        break _v4_2;
                     }
               } while (false);
               return e__;
            } else {
               return e__;
            }
      });
      var inliner = function (e__) {
         var _p13 = e__;
         if (_p13.ctor === "ELet") {
               var _p20 = _p13._3;
               var _p19 = _p13._5;
               var _p18 = _p13._4;
               var nameCounts = $LangTools.identifierCounts(_p19);
               var letRemoved = function (newBody) {
                  var oldPrecedingWs = $LangUnparser.precedingWhitespaceExp__(e__);
                  return A2($LangUnparser.replacePrecedingWhitespace,
                  oldPrecedingWs,
                  newBody).val.e__;
               };
               var identsAndAssignsInliningCandidates = A2($List.filter,
               function (_p14) {
                  var _p15 = _p14;
                  return _U.eq(1,A3($Utils.getWithDefault,_p15._0,0,nameCounts));
               },
               A2(simpleIdentsAndAssigns,_p20,_p18));
               var newBody = A3($List.foldl,
               F2(function (_p16,resultExp) {
                  var _p17 = _p16;
                  return A2($Lang.mapExpViaExp__,
                  A2(inlineReplaceIfTrivialRename,_p17._0,_p17._1),
                  resultExp);
               }),
               _p19,
               identsAndAssignsInliningCandidates);
               return A7($Lang.ELet,
               _p13._0,
               _p13._1,
               _p13._2,
               _p20,
               _p18,
               newBody,
               _p13._6);
            } else {
               return e__;
            }
      };
      return A2($Lang.mapExpViaExp__,inliner,exp);
   };
   var changeRenamedVarsToOuter_ = F2(function (renamings,exp) {
      var wrap = function (e__) {
         return A3($OurParser2.WithInfo,
         A2($Lang.Exp_,e__,exp.val.eid),
         exp.start,
         exp.end);
      };
      var recurse = changeRenamedVarsToOuter_(renamings);
      var e__$ = function () {
         var e__ = exp.val.e__;
         var removeIdentsFromRenaming = F2(function (identsToRemove,
         renamings) {
            return A2($Dict.filter,
            F2(function (oldName,newName) {
               return $Basics.not(A2($Set.member,
               oldName,
               identsToRemove)) && $Basics.not(A2($Set.member,
               newName,
               identsToRemove));
            }),
            renamings);
         });
         var _p21 = e__;
         switch (_p21.ctor)
         {case "EConst": return e__;
            case "EBase": return e__;
            case "EVar": var _p22 = A2($Dict.get,_p21._1,renamings);
              if (_p22.ctor === "Just") {
                    return A2($Lang.EVar,_p21._0,_p22._0);
                 } else {
                    return e__;
                 }
            case "ELet": var _p28 = _p21._2;
              var _p27 = _p21._3;
              var _p26 = _p21._4;
              var newlyAssignedIdents = $LangTools.identifiersSetInPat(_p27);
              var renamingsShadowsRemoved = A2(removeIdentsFromRenaming,
              newlyAssignedIdents,
              renamings);
              var assign$ = _p28 ? A2(changeRenamedVarsToOuter_,
              renamingsShadowsRemoved,
              _p26) : recurse(_p26);
              var identsAndAssigns = A2(simpleIdentsAndAssigns,_p27,assign$);
              var simpleRenamings = A2($List.filterMap,
              function (_p23) {
                 var _p24 = _p23;
                 var _p25 = _p24._1.val.e__;
                 if (_p25.ctor === "EVar") {
                       return $Maybe.Just({ctor: "_Tuple2"
                                          ,_0: _p24._0
                                          ,_1: _p25._1});
                    } else {
                       return $Maybe.Nothing;
                    }
              },
              identsAndAssigns);
              var renamings$ = A2($Dict.union,
              $Dict.fromList(simpleRenamings),
              renamingsShadowsRemoved);
              var body$ = A2(changeRenamedVarsToOuter_,renamings$,_p21._5);
              return A7($Lang.ELet,
              _p21._0,
              _p21._1,
              _p28,
              _p27,
              assign$,
              body$,
              _p21._6);
            case "EFun": var _p29 = _p21._1;
              var newlyAssignedIdents = A3($List.foldl,
              $Set.union,
              $Set.empty,
              A2($List.map,$LangTools.identifiersSetInPat,_p29));
              var renamingsShadowsRemoved = A2(removeIdentsFromRenaming,
              newlyAssignedIdents,
              renamings);
              return A4($Lang.EFun,
              _p21._0,
              _p29,
              A2(changeRenamedVarsToOuter_,renamingsShadowsRemoved,_p21._2),
              _p21._3);
            case "EApp": return A4($Lang.EApp,
              _p21._0,
              recurse(_p21._1),
              A2($List.map,recurse,_p21._2),
              _p21._3);
            case "EOp": return A4($Lang.EOp,
              _p21._0,
              _p21._1,
              A2($List.map,recurse,_p21._2),
              _p21._3);
            case "EList": return A5($Lang.EList,
              _p21._0,
              A2($List.map,recurse,_p21._1),
              _p21._2,
              A2($Utils.mapMaybe,recurse,_p21._3),
              _p21._4);
            case "EIf": return A5($Lang.EIf,
              _p21._0,
              recurse(_p21._1),
              recurse(_p21._2),
              recurse(_p21._3),
              _p21._4);
            case "ECase": var newBranches = A2($List.map,
              $Lang.mapValField(function (_p30) {
                 var _p31 = _p30;
                 var _p32 = _p31._1;
                 var newlyAssignedIdents = $LangTools.identifiersSetInPat(_p32);
                 var renamingsShadowsRemoved = A2(removeIdentsFromRenaming,
                 newlyAssignedIdents,
                 renamings);
                 return A4($Lang.Branch_,
                 _p31._0,
                 _p32,
                 A2(changeRenamedVarsToOuter_,renamingsShadowsRemoved,_p31._2),
                 _p31._3);
              }),
              _p21._2);
              return A4($Lang.ECase,
              _p21._0,
              recurse(_p21._1),
              newBranches,
              _p21._3);
            case "ETypeCase": var newBranches = A2($List.map,
              $Lang.mapValField(function (_p33) {
                 var _p34 = _p33;
                 return A4($Lang.TBranch_,
                 _p34._0,
                 _p34._1,
                 recurse(_p34._2),
                 _p34._3);
              }),
              _p21._2);
              return A4($Lang.ETypeCase,_p21._0,_p21._1,newBranches,_p21._3);
            case "EComment": return A3($Lang.EComment,
              _p21._0,
              _p21._1,
              recurse(_p21._2));
            case "EOption": return A5($Lang.EOption,
              _p21._0,
              _p21._1,
              _p21._2,
              _p21._3,
              recurse(_p21._4));
            case "ETyp": return A5($Lang.ETyp,
              _p21._0,
              _p21._1,
              _p21._2,
              recurse(_p21._3),
              _p21._4);
            case "EColonType": return A5($Lang.EColonType,
              _p21._0,
              recurse(_p21._1),
              _p21._2,
              _p21._3,
              _p21._4);
            default: return A5($Lang.ETypeAlias,
              _p21._0,
              _p21._1,
              _p21._2,
              recurse(_p21._3),
              _p21._4);}
      }();
      return wrap(e__$);
   });
   var changeRenamedVarsToOuter = function (exp) {
      return A2(changeRenamedVarsToOuter_,$Dict.empty,exp);
   };
   var removeUnusedVars = function (exp) {
      var remover = function (e__) {
         var _p35 = e__;
         if (_p35.ctor === "ELet") {
               var _p51 = _p35._6;
               var _p50 = _p35._0;
               var _p49 = _p35._2;
               var _p48 = _p35._1;
               var _p47 = _p35._5;
               var _p46 = _p35._4;
               var usedNames = $LangTools.identifiersSet(_p47);
               var letRemoved = _p47.val.e__;
               var _p36 = {ctor: "_Tuple2",_0: _p35._3.val,_1: _p46.val.e__};
               _v16_3: do {
                  if (_p36.ctor === "_Tuple2") {
                        switch (_p36._0.ctor)
                        {case "PVar": return A2($Set.member,
                             _p36._0._1,
                             usedNames) ? e__ : letRemoved;
                           case "PAs": return A2($Set.member,
                             _p36._0._1,
                             usedNames) ? e__ : A7($Lang.ELet,
                             _p50,
                             _p48,
                             _p49,
                             A2($LangUnparser.replacePrecedingWhitespacePat,
                             _p36._0._0,
                             _p36._0._3),
                             _p46,
                             _p47,
                             _p51);
                           case "PList":
                           if (_p36._0._3.ctor === "Nothing" && _p36._1.ctor === "EList" && _p36._1._3.ctor === "Nothing")
                             {
                                   var _p45 = _p36._0._0;
                                   var _p44 = _p36._0._1;
                                   var _p43 = _p36._1._0;
                                   var _p42 = _p36._1._1;
                                   if (!_U.eq($List.length(_p44),$List.length(_p42))) return e__;
                                   else {
                                         var patsAssigns = A2($Utils.zip,_p44,_p42);
                                         var usedPatsAssigns = A2($List.filter,
                                         function (_p37) {
                                            var _p38 = _p37;
                                            var _p39 = _p38._0.val;
                                            if (_p39.ctor === "PVar") {
                                                  return A2($Set.member,_p39._1,usedNames);
                                               } else {
                                                  return true;
                                               }
                                         },
                                         patsAssigns);
                                         var _p40 = $List.length(usedPatsAssigns);
                                         switch (_p40)
                                         {case 0: return letRemoved;
                                            case 1: var _p41 = $Utils.head_(usedPatsAssigns);
                                              var thePat = _p41._0;
                                              var theAssign = _p41._1;
                                              var newPat = A2($LangUnparser.replacePrecedingWhitespacePat,
                                              _p45,
                                              thePat);
                                              var newAssign = A2($LangUnparser.replacePrecedingWhitespace,
                                              _p43,
                                              theAssign);
                                              return A7($Lang.ELet,_p50,_p48,_p49,newPat,newAssign,_p47,_p51);
                                            default: var newPat = $Lang.withDummyRange(A5($Lang.PList,
                                              _p45,
                                              A2($List.map,$Basics.fst,usedPatsAssigns),
                                              _p36._0._2,
                                              $Maybe.Nothing,
                                              _p36._0._4));
                                              var newAssign = $Lang.withDummyPos(A5($Lang.EList,
                                              _p43,
                                              A2($List.map,$Basics.snd,usedPatsAssigns),
                                              _p36._1._2,
                                              $Maybe.Nothing,
                                              _p36._1._4));
                                              return A7($Lang.ELet,
                                              _p50,
                                              _p48,
                                              _p49,
                                              newPat,
                                              newAssign,
                                              _p47,
                                              _p51);}
                                      }
                                } else {
                                   break _v16_3;
                                }
                           default: break _v16_3;}
                     } else {
                        break _v16_3;
                     }
               } while (false);
               return e__;
            } else {
               return e__;
            }
      };
      return A2($Lang.mapExpViaExp__,remover,exp);
   };
   var simplify = function (exp) {
      simplify: while (true) {
         var repeatedlyApplyFirstTwo = function (e) {
            repeatedlyApplyFirstTwo: while (true) {
               var firstTwoSimplified = removeUnusedVars(inlineTrivialRenamings(e));
               if (_U.eq(firstTwoSimplified,e)) return e; else {
                     var _v20 = firstTwoSimplified;
                     e = _v20;
                     continue repeatedlyApplyFirstTwo;
                  }
            }
         };
         var simplified = changeRenamedVarsToOuter(repeatedlyApplyFirstTwo(exp));
         if (_U.eq(simplified,exp)) return exp; else {
               var _v21 = simplified;
               exp = _v21;
               continue simplify;
            }
      }
   };
   var removeExtraPostfixes = F2(function (postfixes,exp) {
      removeExtraPostfixes: while (true) {
         var usedNames = $LangTools.identifiersSet(exp);
         var oldAndNewNames = A2($List.concatMap,
         function (ident) {
            return A2($List.concatMap,
            function (postfix) {
               return A2($String.endsWith,
               postfix,
               ident) ? _U.list([{ctor: "_Tuple2"
                                 ,_0: ident
                                 ,_1: A2($String.dropRight,
                                 $String.length(postfix),
                                 ident)}]) : _U.list([]);
            },
            postfixes);
         },
         $Set.toList(usedNames));
         var renameToPerform = A2($Utils.findFirst,
         function (_p52) {
            var _p53 = _p52;
            return $Basics.not(A2($Set.member,_p53._1,usedNames));
         },
         oldAndNewNames);
         var _p54 = renameToPerform;
         if (_p54.ctor === "Just") {
               var exp$ = A3($LangTools.renameIdentifier,
               _p54._0._0,
               _p54._0._1,
               exp);
               var _v24 = postfixes,_v25 = exp$;
               postfixes = _v24;
               exp = _v25;
               continue removeExtraPostfixes;
            } else {
               return exp;
            }
      }
   });
   return _elm.LangTransform.values = {_op: _op
                                      ,simplify: simplify
                                      ,removeExtraPostfixes: removeExtraPostfixes};
};
Elm.InterfaceView2 = Elm.InterfaceView2 || {};
Elm.InterfaceView2.make = function (_elm) {
   "use strict";
   _elm.InterfaceView2 = _elm.InterfaceView2 || {};
   if (_elm.InterfaceView2.values)
   return _elm.InterfaceView2.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Color = Elm.Color.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Draw = Elm.Draw.make(_elm),
   $Either = Elm.Either.make(_elm),
   $Eval = Elm.Eval.make(_elm),
   $ExamplesGenerated = Elm.ExamplesGenerated.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $Graphics$Input = Elm.Graphics.Input.make(_elm),
   $Html = Elm.Html.make(_elm),
   $Html$Attributes = Elm.Html.Attributes.make(_elm),
   $Html$Events = Elm.Html.Events.make(_elm),
   $Html$Lazy = Elm.Html.Lazy.make(_elm),
   $InterfaceModel = Elm.InterfaceModel.make(_elm),
   $InterfaceStorage = Elm.InterfaceStorage.make(_elm),
   $Json$Decode = Elm.Json.Decode.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $LangTools = Elm.LangTools.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $ShapeWidgets = Elm.ShapeWidgets.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Svg = Elm.Svg.make(_elm),
   $Svg$Attributes = Elm.Svg.Attributes.make(_elm),
   $Svg$Events = Elm.Svg.Events.make(_elm),
   $Sync = Elm.Sync.make(_elm),
   $Task = Elm.Task.make(_elm),
   $Text = Elm.Text.make(_elm),
   $Utils = Elm.Utils.make(_elm),
   $VirtualDom = Elm.VirtualDom.make(_elm);
   var _op = {};
   var turnOffCaptionAndHighlights = $InterfaceModel.UpdateModel(function (m) {
      var codeBoxInfo = m.codeBoxInfo;
      return _U.update(m,
      {caption: $Maybe.Nothing
      ,codeBoxInfo: _U.update(codeBoxInfo,
      {highlights: _U.list([])})});
   });
   var turnOnCaptionAndHighlights = function (zoneKey) {
      return $InterfaceModel.UpdateModel(function (m) {
         var codeBoxInfo = m.codeBoxInfo;
         var hi = A2($InterfaceModel.liveInfoToHighlights,zoneKey,m);
         return _U.update(m,
         {caption: $Maybe.Just($InterfaceModel.Hovering(zoneKey))
         ,codeBoxInfo: _U.update(codeBoxInfo,{highlights: hi})});
      });
   };
   var strLambdaTool = function (lambdaTool) {
      var strExp = function (_p0) {
         return $String.trim($LangUnparser.unparse(_p0));
      };
      var _p1 = lambdaTool;
      if (_p1.ctor === "LambdaBounds") {
            return A2($Basics._op["++"],
            "bounds. ",
            A2($Basics._op["++"],strExp(_p1._0)," bounds"));
         } else {
            return A2($Basics._op["++"],
            "anchor. ",
            A2($Basics._op["++"],strExp(_p1._0)," anchor"));
         }
   };
   var dropdownLambdaTool = F3(function (model,w,h) {
      var options = function () {
         var _p2 = model.lambdaTools;
         var selectedIdx = _p2._0;
         var exps = _p2._1;
         return A2($Utils.mapi,
         function (_p3) {
            var _p4 = _p3;
            var s = strLambdaTool(_p4._1);
            return A2($Html.option,
            _U.list([$Html$Attributes.value(s)
                    ,$Html$Attributes.selected(_U.eq(_p4._0,selectedIdx))]),
            _U.list([$Html.text(s)]));
         },
         exps);
      }();
      var handler = function (selected) {
         return A2($Signal.message,
         $InterfaceModel.events.address,
         $InterfaceModel.UpdateModel(function (model) {
            var _p5 = model.lambdaTools;
            var exps = _p5._1;
            var indexedStrings = A2($Utils.mapi,
            function (_p6) {
               var _p7 = _p6;
               return {ctor: "_Tuple2",_0: _p7._0,_1: strLambdaTool(_p7._1)};
            },
            exps);
            var newSelectedIdx = function () {
               var _p9 = A2($Utils.findFirst,
               function (_p8) {
                  return A2(F2(function (x,y) {    return _U.eq(x,y);}),
                  selected,
                  $Basics.snd(_p8));
               },
               indexedStrings);
               if (_p9.ctor === "Just") {
                     return _p9._0._0;
                  } else {
                     return _U.crashCase("InterfaceView2",
                     {start: {line: 2267,column: 9},end: {line: 2269,column: 59}},
                     _p9)("dropdownLambdaTools");
                  }
            }();
            return _U.update(model,
            {tool: $InterfaceModel.Lambda
            ,lambdaTools: {ctor: "_Tuple2",_0: newSelectedIdx,_1: exps}});
         }));
      };
      var attrs = _U.list([$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                                           ,_0: "pointer-events"
                                                           ,_1: "auto"}
                                                          ,{ctor: "_Tuple2",_0: "border",_1: "0 solid"}
                                                          ,{ctor: "_Tuple2",_0: "display",_1: "block"}
                                                          ,{ctor: "_Tuple2",_0: "width",_1: "80px"}
                                                          ,{ctor: "_Tuple2",_0: "height",_1: "24px"}
                                                          ,{ctor: "_Tuple2"
                                                           ,_0: "font-family"
                                                           ,_1: $Config.params.mainSection.widgets.font}
                                                          ,{ctor: "_Tuple2",_0: "font-size",_1: "1em"}]))
                          ,A3($Html$Events.on,
                          "change",
                          $Html$Events.targetValue,
                          handler)]);
      return A3($Html.toElement,80,24,A2($Html.select,attrs,options));
   });
   var dropdownExamples = F3(function (model,w,h) {
      var findTask = F2(function (name,choices) {
         findTask: while (true) {
            var _p11 = choices;
            if (_p11.ctor === "::") {
                  if (_U.eq(_p11._0._0,name)) return _p11._0._1; else {
                        var _v5 = name,_v6 = _p11._1;
                        name = _v5;
                        choices = _v6;
                        continue findTask;
                     }
               } else {
                  return _U.crashCase("InterfaceView2",
                  {start: {line: 2182,column: 29},end: {line: 2186,column: 75}},
                  _p11)("Dropdown example does not have associated task");
               }
         }
      });
      var choices = function () {
         var _p13 = model.mode;
         if (_p13.ctor === "AdHoc") {
               return _U.list([{ctor: "_Tuple2"
                               ,_0: model.exName
                               ,_1: A2($Signal.send,
                               $InterfaceModel.events.address,
                               $InterfaceModel.Noop)}]);
            } else {
               var blank = {ctor: "_Tuple2"
                           ,_0: ""
                           ,_1: $Task.succeed({ctor: "_Tuple0"})};
               var bar = function (saveName) {
                  return {ctor: "_Tuple2"
                         ,_0: saveName
                         ,_1: A2($InterfaceStorage.loadLocalState,model,saveName)};
               };
               var localsaves = function () {
                  var _p14 = model.localSaves;
                  if (_p14.ctor === "[]") {
                        return _U.list([]);
                     } else {
                        return $List.concat(_U.list([_U.list([{ctor: "_Tuple2"
                                                              ,_0: "Local Saves:"
                                                              ,_1: $Task.succeed({ctor: "_Tuple0"})}
                                                             ,blank])
                                                    ,A2($List.map,bar,_p14)
                                                    ,_U.list([blank])]));
                     }
               }();
               var foo = function (_p15) {
                  var _p16 = _p15;
                  var _p17 = _p16._0;
                  return {ctor: "_Tuple2"
                         ,_0: _p17
                         ,_1: A2($Signal.send,
                         $InterfaceModel.events.address,
                         A2($InterfaceModel.SelectExample,_p17,_p16._2))};
               };
               return $List.concat(_U.list([localsaves
                                           ,_U.list([{ctor: "_Tuple2"
                                                     ,_0: "Builtin Examples:"
                                                     ,_1: $Task.succeed({ctor: "_Tuple0"})}
                                                    ,blank])
                                           ,A2($List.map,foo,$ExamplesGenerated.list)
                                           ,_U.list([blank
                                                    ,{ctor: "_Tuple2"
                                                     ,_0: "*Clear Local Saves*"
                                                     ,_1: $InterfaceStorage.clearLocalSaves}])]));
            }
      }();
      var options = A2($List.map,
      function (_p18) {
         var _p19 = _p18;
         var _p20 = _p19._0;
         return _U.eq(_p20,model.exName) ? A2($Html.option,
         _U.list([$Html$Attributes.value(_p20)
                 ,$Html$Attributes.selected(true)]),
         _U.list([$Html.text(_p20)])) : A2($Html.option,
         _U.list([$Html$Attributes.value(_p20)]),
         _U.list([$Html.text(_p20)]));
      },
      choices);
      return A3($Html.toElement,
      120,
      24,
      A2($Html.select,
      _U.list([$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                               ,_0: "pointer-events"
                                               ,_1: "auto"}
                                              ,{ctor: "_Tuple2",_0: "border",_1: "0 solid"}
                                              ,{ctor: "_Tuple2",_0: "display",_1: "block"}
                                              ,{ctor: "_Tuple2",_0: "width",_1: "120px"}
                                              ,{ctor: "_Tuple2",_0: "height",_1: "24px"}
                                              ,{ctor: "_Tuple2"
                                               ,_0: "font-family"
                                               ,_1: $Config.params.mainSection.widgets.font}
                                              ,{ctor: "_Tuple2",_0: "font-size",_1: "1em"}]))
              ,A3($Html$Events.on,
              "change",
              $Html$Events.targetValue,
              function (selected) {
                 return A2($Signal.message,
                 $InterfaceStorage.taskMailbox.address,
                 A2(findTask,selected,choices));
              })]),
      options));
   });
   var slideNumber = F3(function (model,w,h) {
      var slideNumberElement = function (_p21) {
         return $Graphics$Element.centered(A2($Text.color,
         $Color.white,
         A2($Text.typeface,
         _U.list(["sans-serif"]),
         $Text.fromString(_p21))));
      };
      return A4($Graphics$Element.container,
      w,
      h,
      $Graphics$Element.middle,
      slideNumberElement(A2($Basics._op["++"],
      "Slide ",
      A2($Basics._op["++"],
      $Basics.toString(model.slideNumber),
      A2($Basics._op["++"],
      "/",
      $Basics.toString(model.slideCount))))));
   });
   var displayKey = function (s) {
      return A2($Basics._op["++"]," ",s);
   };
   var fancyCodeBox = F2(function (w,h) {
      return A3($Html.toElement,
      w,
      h,
      A2($Html$Lazy.lazy,
      function (a) {
         return A2($Html.div,
         _U.list([$Html$Attributes.id("editor")
                 ,$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                                  ,_0: "width"
                                                  ,_1: "100%"}
                                                 ,{ctor: "_Tuple2",_0: "height",_1: "100%"}
                                                 ,{ctor: "_Tuple2",_0: "pointer-events",_1: "auto"}
                                                 ,{ctor: "_Tuple2",_0: "z-index",_1: "1"}]))]),
         _U.list([]));
      },
      true));
   });
   var wBtnWide = $Config.params.mainSection.widgets.wBtnWide;
   var hBtn = $Config.params.mainSection.widgets.hBtn;
   var wBtn = $Config.params.mainSection.widgets.wBtn;
   var gapWidget = F2(function (w,h) {
      return A2($Graphics$Element.spacer,w,h);
   });
   var showRawShapeTools = true;
   var flowRight = F3(function (w,h,l) {
      var delta = 6;
      var sep = A2($Graphics$Element.spacer,delta,h);
      var n = $Basics.toFloat($List.length(l));
      var availableWidth = $Basics.toFloat(w) - (n - 1) * delta;
      var elts = A2($List.map,
      function (_p22) {
         var _p23 = _p22;
         return A2(_p23._1,$Basics.round(_p23._0 * availableWidth),h);
      },
      l);
      return A2($Graphics$Element.flow,
      $Graphics$Element.right,
      A2($List.intersperse,sep,elts));
   });
   var twoButtons = F4(function (w,h,b1,b2) {
      return A3(flowRight,
      w,
      h,
      _U.list([{ctor: "_Tuple2",_0: 1 / 2,_1: b1}
              ,{ctor: "_Tuple2",_0: 1 / 2,_1: b2}]));
   });
   var threeButtons = F5(function (w,h,b1,b2,b3) {
      return A3(flowRight,
      w,
      h,
      _U.list([{ctor: "_Tuple2",_0: 1 / 3,_1: b1}
              ,{ctor: "_Tuple2",_0: 1 / 3,_1: b2}
              ,{ctor: "_Tuple2",_0: 1 / 3,_1: b3}]));
   });
   var threeVersions = F5(function (w,h,b1,b2,b3) {
      return A3(flowRight,
      w,
      h,
      _U.list([{ctor: "_Tuple2",_0: 1 / 6,_1: b1}
              ,{ctor: "_Tuple2",_0: 2 / 3,_1: b2}
              ,{ctor: "_Tuple2",_0: 1 / 6,_1: b3}]));
   });
   var errorBox = F3(function (w,h,errormsg) {
      return A3($Html.toElement,
      w,
      h,
      A2($Html.textarea,
      _U.list([$Html$Attributes.spellcheck(false)
              ,$Html$Attributes.readonly(true)
              ,$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                               ,_0: "font-family"
                                               ,_1: $Config.params.mainSection.codebox.font}
                                              ,{ctor: "_Tuple2"
                                               ,_0: "font-size"
                                               ,_1: $Config.params.mainSection.codebox.fontSize}
                                              ,{ctor: "_Tuple2"
                                               ,_0: "border"
                                               ,_1: $Config.params.mainSection.codebox.border}
                                              ,{ctor: "_Tuple2",_0: "whiteSpace",_1: "pre"}
                                              ,{ctor: "_Tuple2",_0: "height",_1: "100%"}
                                              ,{ctor: "_Tuple2",_0: "width",_1: "100%"}
                                              ,{ctor: "_Tuple2",_0: "resize",_1: "none"}
                                              ,{ctor: "_Tuple2",_0: "overflow",_1: "auto"}
                                              ,{ctor: "_Tuple2",_0: "word-wrap",_1: "normal"}
                                              ,{ctor: "_Tuple2",_0: "background-color",_1: "whitesmoke"}
                                              ,{ctor: "_Tuple2",_0: "padding",_1: "4px"}
                                              ,{ctor: "_Tuple2",_0: "box-sizing",_1: "border-box"}]))
              ,$Html$Attributes.value(A2($Basics._op["++"],"💥 ",errormsg))]),
      _U.list([])));
   });
   var basicCodeBox_ = F3(function (w,h,content) {
      var innerPadding = 4;
      return A3($Html.toElement,
      w,
      h,
      A2($Html.textarea,
      _U.list([$Html$Attributes.id("editor")
              ,$Html$Attributes.spellcheck(false)
              ,$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                               ,_0: "font-family"
                                               ,_1: $Config.params.mainSection.codebox.font}
                                              ,{ctor: "_Tuple2"
                                               ,_0: "font-size"
                                               ,_1: $Config.params.mainSection.codebox.fontSize}
                                              ,{ctor: "_Tuple2"
                                               ,_0: "border"
                                               ,_1: $Config.params.mainSection.codebox.border}
                                              ,{ctor: "_Tuple2",_0: "whiteSpace",_1: "pre"}
                                              ,{ctor: "_Tuple2",_0: "height",_1: "100%"}
                                              ,{ctor: "_Tuple2",_0: "width",_1: "100%"}
                                              ,{ctor: "_Tuple2",_0: "resize",_1: "none"}
                                              ,{ctor: "_Tuple2",_0: "overflow",_1: "auto"}
                                              ,{ctor: "_Tuple2",_0: "word-wrap",_1: "normal"}
                                              ,{ctor: "_Tuple2",_0: "background-color",_1: "whitesmoke"}
                                              ,{ctor: "_Tuple2"
                                               ,_0: "padding"
                                               ,_1: A2($Basics._op["++"],$Basics.toString(innerPadding),"px")}
                                              ,{ctor: "_Tuple2",_0: "box-sizing",_1: "border-box"}]))
              ,$Html$Attributes.value(content)]),
      _U.list([])));
   });
   var codeToShow = function (model) {
      var _p24 = model.previewCode;
      if (_p24.ctor === "Just") {
            return _p24._0;
         } else {
            return model.code;
         }
   };
   var basicCodeBox = F3(function (w,h,model) {
      return A3(basicCodeBox_,w,h,codeToShow(model));
   });
   var colorDebug_ = F2(function (c1,c2) {
      return $Config.params.debugLayout ? $Graphics$Element.color(c1) : $Graphics$Element.color(c2);
   });
   var strTitle = A2($Basics._op["++"],
   " sketch-n-sketch ",
   $Config.params.strVersion);
   var firstEqLast = function (xs) {
      return _U.eq($Utils.head_(xs),
      $Utils.head_($List.reverse(xs)));
   };
   var toggleSelectedLambda = F2(function (nodeIdAndFeatures,
   model) {
      var deselect = A2($List.all,
      A2($Basics.flip,$Set.member,model.selectedFeatures),
      nodeIdAndFeatures);
      var updateSet = F2(function (nodeIdAndFeature,acc) {
         return deselect ? A2($Set.remove,
         nodeIdAndFeature,
         acc) : A2($Set.insert,nodeIdAndFeature,acc);
      });
      return _U.update(model,
      {selectedFeatures: A3($List.foldl,
      updateSet,
      model.selectedFeatures,
      nodeIdAndFeatures)});
   });
   var toggleSelected = function (nodeIdAndFeatures) {
      return $InterfaceModel.UpdateModel(toggleSelectedLambda(nodeIdAndFeatures));
   };
   var hairStrokeWidth = "5";
   var colorLineNotSelected = "#FAB4D3";
   var colorLineSelected = "#B4FADB";
   var colorPointNotSelected = "#F5B038";
   var colorPointSelected = "#38F552";
   var maybeStrokeWidthNumAttr = function (l) {
      var _p25 = A2($Utils.maybeFind,"stroke-width",l);
      if (_p25.ctor === "Just") {
            var _p26 = _p25._0.av_;
            if (_p26.ctor === "ANum") {
                  return $Maybe.Just(_p26._0);
               } else {
                  return $Maybe.Nothing;
               }
         } else {
            return $Maybe.Nothing;
         }
   };
   var wStrokeWidthBox = $ShapeWidgets.wStrokeWidthSlider;
   var wOpacityBox = $ShapeWidgets.wOpacitySlider;
   var maybeColorNumAttr = F2(function (k,l) {
      var _p27 = A2($Utils.maybeFind,k,l);
      if (_p27.ctor === "Just") {
            var _p28 = _p27._0.av_;
            if (_p28.ctor === "AColorNum" && _p28._0.ctor === "_Tuple2") {
                  return {ctor: "_Tuple2"
                         ,_0: $Maybe.Just(_p28._0._0)
                         ,_1: _p28._0._1};
               } else {
                  return {ctor: "_Tuple2"
                         ,_0: $Maybe.Nothing
                         ,_1: $Maybe.Nothing};
               }
         } else {
            return {ctor: "_Tuple2"
                   ,_0: $Maybe.Nothing
                   ,_1: $Maybe.Nothing};
         }
   });
   var hZoneColor = 20;
   var wGradient = $ShapeWidgets.wColorSlider;
   var projPt = function (_p29) {
      var _p30 = _p29;
      return {ctor: "_Tuple2"
             ,_0: $Basics.fst(_p30._0)
             ,_1: $Basics.fst(_p30._1)};
   };
   var distance = F2(function (_p32,_p31) {
      var _p33 = _p32;
      var _p34 = _p31;
      return $Basics.sqrt(Math.pow(_p34._0 - _p33._0,
      2) + Math.pow(_p34._1 - _p33._1,2));
   });
   var distance_ = F2(function (pt1,pt2) {
      return A2(distance,projPt(pt1),projPt(pt2));
   });
   var halfwayBetween = F2(function (_p36,_p35) {
      var _p37 = _p36;
      var _p38 = _p35;
      return {ctor: "_Tuple2"
             ,_0: (_p37._0 + _p38._0) / 2
             ,_1: (_p37._1 + _p38._1) / 2};
   });
   var halfwayBetween_ = F2(function (pt1,pt2) {
      return A2(halfwayBetween,projPt(pt1),projPt(pt2));
   });
   var transformAttr = function (cmds) {
      return _U.list([A2($LangSvg.compileAttr,
      "transform",
      $LangSvg.aTransform(cmds))]);
   };
   var maybeTransformCmds = function (l) {
      var _p39 = A2($Utils.maybeFind,"transform",l);
      if (_p39.ctor === "Just") {
            var _p40 = _p39._0.av_;
            if (_p40.ctor === "ATransform") {
                  return $Maybe.Just(_p40._0);
               } else {
                  return $Maybe.Nothing;
               }
         } else {
            return $Maybe.Nothing;
         }
   };
   var maybeTransformAttr = function (l) {
      var _p41 = maybeTransformCmds(l);
      if (_p41.ctor === "Just") {
            return transformAttr(_p41._0);
         } else {
            return _U.list([]);
         }
   };
   var rotZoneDelta = 20;
   var pointZoneStyles = {radius: "6"
                         ,stroke: "black"
                         ,strokeWidth: "2"
                         ,fill: {shown: "white"
                                ,selectedShape: "yellow"
                                ,selectedBlob: "aqua"
                                ,hidden: "rgba(0,0,0,0.0)"}};
   var pointZoneStylesFillSelected = F2(function (model,nodeId) {
      var d = A2($Dict.filter,
      F2(function (_p42,nodeId$) {    return _U.eq(nodeId,nodeId$);}),
      model.selectedBlobs);
      return $Dict.isEmpty(d) ? pointZoneStyles.fill.selectedShape : pointZoneStyles.fill.selectedBlob;
   });
   var minLengthForMiddleZones = 30;
   var objectZoneIsCurrentlyBeingManipulated = F3(function (model,
   nodeId,
   zonePred) {
      var _p43 = model.mouseMode;
      if (_p43.ctor === "MouseDragZone" && _p43._0.ctor === "Left" && _p43._0._0.ctor === "_Tuple3")
      {
            return _U.eq(nodeId,
            _p43._0._0._0) && zonePred(_p43._0._0._2);
         } else {
            return false;
         }
   });
   var objectIsCurrentlyBeingManipulated = F2(function (model,
   nodeId) {
      return A3(objectZoneIsCurrentlyBeingManipulated,
      model,
      nodeId,
      $Basics.always(true));
   });
   var isRotateZone = function (zone) {
      var _p44 = zone;
      if (_p44 === "RotateBall") {
            return true;
         } else {
            return false;
         }
   };
   var isFillStrokeZone = function (zone) {
      var _p45 = zone;
      switch (_p45)
      {case "FillBall": return true;
         case "StrokeBall": return true;
         case "FillOpacityBall": return true;
         case "StrokeOpacityBall": return true;
         case "StrokeWidthBall": return true;
         default: return false;}
   };
   var isPrimaryZone = function (zone) {
      var _p46 = zone;
      switch (_p46)
      {case "FillBall": return false;
         case "StrokeBall": return false;
         case "FillOpacityBall": return false;
         case "StrokeOpacityBall": return false;
         case "StrokeWidthBall": return false;
         case "RotateBall": return false;
         case "SliderBall": return false;
         default: return true;}
   };
   var cursorStyle = function (s) {
      return A2($LangSvg.attr,"cursor",s);
   };
   var cursorOfZone = F2(function (zone,$default) {
      var _p47 = $ShapeWidgets.parseZone(zone);
      switch (_p47.ctor)
      {case "ZInterior": return cursorStyle("move");
         case "ZPoint": switch (_p47._0.ctor)
           {case "LeftEdge": return cursorStyle("ew-resize");
              case "RightEdge": return cursorStyle("ew-resize");
              case "TopLeft": return cursorStyle("nwse-resize");
              case "BotRight": return cursorStyle("nwse-resize");
              case "TopEdge": return cursorStyle("ns-resize");
              case "BotEdge": return cursorStyle("ns-resize");
              case "BotLeft": return cursorStyle("nesw-resize");
              case "TopRight": return cursorStyle("nesw-resize");
              default: return cursorStyle($default);}
         case "ZLineEdge": return cursorStyle("pointer");
         case "ZPolyEdge": return cursorStyle("pointer");
         case "ZOther": return cursorStyle("pointer");
         default: return cursorStyle("pointer");}
   });
   var removeHoveredCrosshair = function (tuple) {
      return $InterfaceModel.UpdateModel(function (m) {
         return _U.update(m,
         {hoveredCrosshairs: A2($Set.remove,tuple,m.hoveredCrosshairs)});
      });
   };
   var addHoveredCrosshair = function (tuple) {
      return $InterfaceModel.UpdateModel(function (m) {
         return _U.update(m,
         {hoveredCrosshairs: A2($Set.insert,tuple,m.hoveredCrosshairs)});
      });
   };
   var addHoveredShape = function (id) {
      return $InterfaceModel.UpdateModel(function (m) {
         return _U.update(m,{hoveredShapes: $Set.singleton(id)});
      });
   };
   var removeHoveredShape = function (id) {
      return $InterfaceModel.UpdateModel(function (m) {
         return _U.update(m,
         {hoveredShapes: A2($Set.remove,id,m.hoveredShapes)});
      });
   };
   var handleEventAndStop = F2(function (eventName,eventHandler) {
      var defaultOptions = $Html$Events.defaultOptions;
      return A4($Html$Events.onWithOptions,
      eventName,
      _U.update(defaultOptions,{stopPropagation: true}),
      $Json$Decode.value,
      function (_p48) {
         return A2($Signal.message,
         $InterfaceModel.events.address,
         eventHandler);
      });
   });
   var onMouseDownAndStop = handleEventAndStop("mousedown");
   var onMouseLeave = $Html$Events.onMouseLeave($InterfaceModel.events.address);
   var onMouseEnter = $Html$Events.onMouseEnter($InterfaceModel.events.address);
   var onMouseOut = function (_p49) {
      return $Svg$Events.onMouseOut(A2($Signal.message,
      $InterfaceModel.events.address,
      _p49));
   };
   var onMouseOver = function (_p50) {
      return $Svg$Events.onMouseOver(A2($Signal.message,
      $InterfaceModel.events.address,
      _p50));
   };
   var onMouseUp = function (_p51) {
      return $Svg$Events.onMouseUp(A2($Signal.message,
      $InterfaceModel.events.address,
      _p51));
   };
   var onMouseDown = function (_p52) {
      return $Svg$Events.onMouseDown(A2($Signal.message,
      $InterfaceModel.events.address,
      _p52));
   };
   var zoneDelete_ = F5(function (id,shape,x,y,transform) {
      var _p53 = {ctor: "_Tuple4"
                 ,_0: 20
                 ,_1: 20
                 ,_2: "silver"
                 ,_3: "2"};
      var w = _p53._0;
      var h = _p53._1;
      var stroke = _p53._2;
      var strokeWidth = _p53._3;
      var evt = function () {
         var foo = function (old) {
            return _U.update(old,
            {slate: A2($Utils.mapSnd,
            A2($Dict.insert,id,$LangSvg.dummySvgNode),
            old.slate)});
         };
         return onMouseDown($InterfaceModel.UpdateModel(foo));
      }();
      var lines = function () {
         var f = F4(function (x1,y1,x2,y2) {
            return A3($Basics.flip,
            $Svg.line,
            _U.list([]),
            A2($Basics._op["++"],
            _U.list([A2($LangSvg.attr,"stroke","darkred")
                    ,A2($LangSvg.attr,"strokeWidth",strokeWidth)
                    ,A2($LangSvg.attr,"x1",$Basics.toString(x1))
                    ,A2($LangSvg.attr,"y1",$Basics.toString(y1))
                    ,A2($LangSvg.attr,"x2",$Basics.toString(x2))
                    ,A2($LangSvg.attr,"y2",$Basics.toString(y2))
                    ,evt]),
            transform));
         });
         return _U.list([A4(f,x,y,x + w,y + h),A4(f,x,y + h,x + w,y)]);
      }();
      var box = A3($Basics.flip,
      $Svg.rect,
      _U.list([]),
      A2($Basics._op["++"],
      _U.list([A2($LangSvg.attr,"fill","white")
              ,A2($LangSvg.attr,"stroke",stroke)
              ,A2($LangSvg.attr,"strokeWidth",strokeWidth)
              ,A2($LangSvg.attr,"x",$Basics.toString(x))
              ,A2($LangSvg.attr,"y",$Basics.toString(y))
              ,A2($LangSvg.attr,"width",$Basics.toString(w))
              ,A2($LangSvg.attr,"height",$Basics.toString(h))
              ,evt]),
      transform));
      return A2($Basics._op["++"],_U.list([box]),lines);
   });
   var zoneDelete = F5(function (id,shape,x,y,transform) {
      var b = false;
      return b ? A5(zoneDelete_,id,shape,x,y,transform) : _U.list([]);
   });
   var mkSvg = F2(function (hilite,svg) {
      return A2($Svg.svg,
      _U.list([onMouseDown($InterfaceModel.MouseClickCanvas)
              ,$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                               ,_0: "width"
                                               ,_1: "100%"}
                                              ,{ctor: "_Tuple2",_0: "height",_1: "100%"}
                                              ,{ctor: "_Tuple2"
                                               ,_0: "border"
                                               ,_1: $Config.params.mainSection.canvas.border}]))]),
      _U.list([svg]));
   });
   var attrNumTr = F2(function (k,nt) {
      return A2($LangSvg.compileAttr,k,$LangSvg.aNum(nt));
   });
   var attrNum = F2(function (k,n) {
      return A2($LangSvg.compileAttr,
      k,
      $LangSvg.aNum({ctor: "_Tuple2",_0: n,_1: $Lang.dummyTrace}));
   });
   var toggleSelectedWidget = function (locId) {
      var feature = {ctor: "_Tuple3"
                    ,_0: $ShapeWidgets.selectedTypeWidget
                    ,_1: -1
                    ,_2: A2($Basics._op["++"],"widget",$Basics.toString(locId))};
      return $InterfaceModel.UpdateModel(function (model) {
         var update = A2($Set.member,
         feature,
         model.selectedFeatures) ? $Set.remove : $Set.insert;
         return _U.update(model,
         {selectedFeatures: A2(update,feature,model.selectedFeatures)});
      });
   };
   var dragZoneEvents = function (zoneKey) {
      return _U.list([onMouseDown($InterfaceModel.ClickZone(zoneKey))
                     ,onMouseOver(turnOnCaptionAndHighlights(zoneKey))
                     ,onMouseOut(turnOffCaptionAndHighlights)]);
   };
   var zoneEvents = F3(function (id,shape,zone) {
      return dragZoneEvents($Either.Left({ctor: "_Tuple3"
                                         ,_0: id
                                         ,_1: shape
                                         ,_2: zone}));
   });
   var draggableZone = F7(function (svgFunc,
   addStroke,
   model,
   id,
   shape,
   zone,
   attrs) {
      var showStroke = false;
      return A3($Basics.flip,
      svgFunc,
      _U.list([]),
      A2($Basics._op["++"],
      attrs,
      A2($Basics._op["++"],
      A3(zoneEvents,id,shape,zone),
      _U.list([A2(cursorOfZone,zone,"default")
              ,A2($LangSvg.attr,"fill","rgba(0,0,0,0.0)")
              ,A2($LangSvg.attr,"stroke-width",addStroke ? "10" : "0")
              ,A2($LangSvg.attr,
              "stroke",
              showStroke ? "rgba(255,0,0,0.5)" : "rgba(0,0,0,0.0)")]))));
   });
   var zoneLine = F7(function (model,
   id,
   shape,
   zone,
   _p55,
   _p54,
   attrs) {
      var _p56 = _p55;
      var _p57 = _p54;
      return A7(draggableZone,
      $Svg.line,
      true,
      model,
      id,
      shape,
      zone,
      A2($Basics._op["++"],
      _U.list([A2(attrNumTr,"x1",_p56._0)
              ,A2(attrNumTr,"y1",_p56._1)
              ,A2(attrNumTr,"x2",_p57._0)
              ,A2(attrNumTr,"y2",_p57._1)
              ,cursorStyle("pointer")]),
      attrs));
   });
   var zoneLine2 = F7(function (model,
   id,
   shape,
   zone,
   _p59,
   _p58,
   attrs) {
      var _p60 = _p59;
      var _p61 = _p58;
      return A7(draggableZone,
      $Svg.line,
      true,
      model,
      id,
      shape,
      zone,
      A2($Basics._op["++"],
      _U.list([A2(attrNum,"x1",_p60._0)
              ,A2(attrNum,"y1",_p60._1)
              ,A2(attrNum,"x2",_p61._0)
              ,A2(attrNum,"y2",_p61._1)
              ,cursorStyle("pointer")]),
      attrs));
   });
   var zoneRotate_ = F7(function (model,id,shape,cx,cy,r,cmds) {
      var _p62 = {ctor: "_Tuple4"
                 ,_0: 20
                 ,_1: "rgba(192,192,192,0.5)"
                 ,_2: "5"
                 ,_3: "7"};
      var a = _p62._0;
      var stroke = _p62._1;
      var strokeWidth = _p62._2;
      var rBall = _p62._3;
      var _p63 = {ctor: "_Tuple2",_0: "silver",_1: "2"};
      var fillBall = _p63._0;
      var swBall = _p63._1;
      var transform = transformAttr(cmds);
      var circle = A3($Basics.flip,
      $Svg.circle,
      _U.list([]),
      _U.list([A2($LangSvg.attr,"fill","none")
              ,A2($LangSvg.attr,"stroke",stroke)
              ,A2($LangSvg.attr,"stroke-width",strokeWidth)
              ,A2($LangSvg.attr,"cx",$Basics.toString(cx))
              ,A2($LangSvg.attr,"cy",$Basics.toString(cy))
              ,A2($LangSvg.attr,"r",$Basics.toString(r))]));
      var ball = A3($Basics.flip,
      $Svg.circle,
      _U.list([]),
      A2($Basics._op["++"],
      _U.list([A2($LangSvg.attr,"stroke","black")
              ,A2($LangSvg.attr,"stroke-width",swBall)
              ,A2($LangSvg.attr,"fill",fillBall)
              ,A2($LangSvg.attr,"cx",$Basics.toString(cx))
              ,A2($LangSvg.attr,"cy",$Basics.toString(cy - r))
              ,A2($LangSvg.attr,"r",rBall)
              ,A2(cursorOfZone,"RotateBall","default")]),
      A2($Basics._op["++"],
      transform,
      A3(zoneEvents,id,shape,"RotateBall"))));
      var line = function () {
         var _p64 = function () {
            var _p65 = {ctor: "_Tuple2",_0: cmds,_1: model.tool};
            if (_p65.ctor === "_Tuple2" && _p65._0.ctor === "::" && _p65._0._0.ctor === "Rot" && _p65._0._0._0.ctor === "_Tuple2" && _p65._0._1.ctor === "[]" && _p65._1.ctor === "Cursor")
            {
                  var typeAndNodeIdAndFeature = {ctor: "_Tuple3"
                                                ,_0: $ShapeWidgets.selectedTypeShapeFeature
                                                ,_1: id
                                                ,_2: $ShapeWidgets.shapeRotation};
                  var handler = _U.list([onMouseDown(toggleSelected(_U.list([typeAndNodeIdAndFeature])))]);
                  return A2($Set.member,
                  typeAndNodeIdAndFeature,
                  model.selectedFeatures) ? {ctor: "_Tuple2"
                                            ,_0: colorPointSelected
                                            ,_1: handler} : {ctor: "_Tuple2"
                                                            ,_0: colorPointNotSelected
                                                            ,_1: handler};
               } else {
                  return {ctor: "_Tuple2",_0: stroke,_1: _U.list([])};
               }
         }();
         var strokeColor = _p64._0;
         var maybeEventHandler = _p64._1;
         return A3($Basics.flip,
         $Svg.line,
         _U.list([]),
         A2($Basics._op["++"],
         _U.list([A2($LangSvg.attr,"stroke",strokeColor)
                 ,A2($LangSvg.attr,"stroke-width",strokeWidth)
                 ,A2($LangSvg.attr,"x1",$Basics.toString(cx))
                 ,A2($LangSvg.attr,"y1",$Basics.toString(cy))
                 ,A2($LangSvg.attr,"x2",$Basics.toString(cx))
                 ,A2($LangSvg.attr,"y2",$Basics.toString(cy - r))]),
         A2($Basics._op["++"],transform,maybeEventHandler)));
      }();
      return _U.list([circle,line,ball]);
   });
   var zoneRotate = F6(function (model,id,shape,_p66,r,maybeCmds) {
      var _p67 = _p66;
      var pred = function (z) {
         return isPrimaryZone(z) || isFillStrokeZone(z);
      };
      var _p68 = {ctor: "_Tuple3"
                 ,_0: A2($Set.member,id,model.selectedShapes)
                 ,_1: A3(objectZoneIsCurrentlyBeingManipulated,model,id,pred)
                 ,_2: maybeCmds};
      if (_p68.ctor === "_Tuple3" && _p68._0 === true && _p68._1 === false && _p68._2.ctor === "Just")
      {
            return A7(zoneRotate_,
            model,
            id,
            shape,
            _p67._0,
            _p67._1,
            r,
            _p68._2._0);
         } else {
            return _U.list([]);
         }
   });
   var zoneRotatePolyOrPath = F5(function (model,
   id,
   kind,
   pts,
   nodeAttrs) {
      var _p69 = $Draw.boundingBoxOfPoints_(A2($List.map,
      function (_p70) {
         var _p71 = _p70;
         return {ctor: "_Tuple2"
                ,_0: $Basics.fst(_p71._0)
                ,_1: $Basics.fst(_p71._1)};
      },
      pts));
      var xMin = _p69._0;
      var xMax = _p69._1;
      var yMin = _p69._2;
      var yMax = _p69._3;
      var _p72 = {ctor: "_Tuple2",_0: xMax - xMin,_1: yMax - yMin};
      var w = _p72._0;
      var h = _p72._1;
      var _p73 = {ctor: "_Tuple2"
                 ,_0: xMin + 0.5 * w
                 ,_1: yMin + 0.5 * h};
      var xMiddle = _p73._0;
      var yMiddle = _p73._1;
      var r = A2($Basics.max,w,h) / 2 + rotZoneDelta;
      return A6(zoneRotate,
      model,
      id,
      kind,
      {ctor: "_Tuple2",_0: xMiddle,_1: yMiddle},
      r,
      maybeTransformCmds(nodeAttrs));
   });
   var zoneColor_ = F8(function (zoneName,
   shapeFeature,
   model,
   id,
   shape,
   x,
   y,
   _p74) {
      var _p75 = _p74;
      var _p76 = {ctor: "_Tuple6"
                 ,_0: wGradient
                 ,_1: hZoneColor
                 ,_2: 20
                 ,_3: "silver"
                 ,_4: "2"
                 ,_5: "7"};
      var w = _p76._0;
      var h = _p76._1;
      var a = _p76._2;
      var stroke = _p76._3;
      var strokeWidth = _p76._4;
      var rBall = _p76._5;
      var yOff = a + rotZoneDelta;
      var typeAndNodeIdAndFeature = {ctor: "_Tuple3"
                                    ,_0: $ShapeWidgets.selectedTypeShapeFeature
                                    ,_1: id
                                    ,_2: shapeFeature};
      var ball = function () {
         var cx = x + _p75._0 / $LangSvg.maxColorNum * wGradient;
         var cy = y - yOff + h / 2;
         return A3($Basics.flip,
         $Svg.circle,
         _U.list([]),
         A2($Basics._op["++"],
         _U.list([A2($LangSvg.attr,"stroke","black")
                 ,A2($LangSvg.attr,"stroke-width",strokeWidth)
                 ,A2($LangSvg.attr,"fill",stroke)
                 ,A2($LangSvg.attr,"cx",$Basics.toString(cx))
                 ,A2($LangSvg.attr,"cy",$Basics.toString(cy))
                 ,A2($LangSvg.attr,"r",rBall)
                 ,A2(cursorOfZone,zoneName,"default")]),
         A3(zoneEvents,id,shape,zoneName)));
      }();
      var box = A3($Basics.flip,
      $Svg.rect,
      _U.list([]),
      _U.list([A2($LangSvg.attr,
              "fill",
              A2($Set.member,
              typeAndNodeIdAndFeature,
              model.selectedFeatures) ? colorPointSelected : "none")
              ,A2($LangSvg.attr,"stroke",stroke)
              ,A2($LangSvg.attr,"stroke-width",strokeWidth)
              ,A2($LangSvg.attr,"x",$Basics.toString(x))
              ,A2($LangSvg.attr,"y",$Basics.toString(y - yOff))
              ,A2($LangSvg.attr,"width",$Basics.toString(w))
              ,A2($LangSvg.attr,"height",$Basics.toString(h))]));
      var gradient = function (_p77) {
         var _p78 = _p77;
         return A2($List.map,
         function (i) {
            var _p79 = A2($Utils.numToColor,
            $ShapeWidgets.wColorSlider,
            i);
            var r = _p79._0;
            var g = _p79._1;
            var b = _p79._2;
            var fill = A2($Basics._op["++"],
            "rgb",
            $Utils.parens(A2($String.join,
            ",",
            A2($List.map,$Basics.toString,_U.list([r,g,b])))));
            return A3($Basics.flip,
            $Svg.rect,
            _U.list([]),
            _U.list([A2($LangSvg.attr,"fill",fill)
                    ,A2($LangSvg.attr,"x",$Basics.toString(x + i))
                    ,A2($LangSvg.attr,"y",$Basics.toString(y - yOff))
                    ,A2($LangSvg.attr,"width","1")
                    ,A2($LangSvg.attr,"height",$Basics.toString(h))]));
         },
         _U.range(0,w));
      };
      return _U.list([A2($Svg.g,
                     _U.list([onMouseDownAndStop(toggleSelected(_U.list([typeAndNodeIdAndFeature])))]),
                     A2($Basics._op["++"],
                     gradient({ctor: "_Tuple0"}),
                     _U.list([box])))
                     ,ball]);
   });
   var zoneColor = F8(function (zoneName,
   shapeFeature,
   model,
   id,
   shape,
   x,
   y,
   maybeColor) {
      var pred = function (z) {
         return isPrimaryZone(z) || isRotateZone(z);
      };
      var shapeSelected = A2($Set.member,id,model.selectedShapes);
      var featureSelected = A2($Set.member,
      {ctor: "_Tuple3"
      ,_0: $ShapeWidgets.selectedTypeShapeFeature
      ,_1: id
      ,_2: shapeFeature},
      model.selectedFeatures);
      var _p80 = {ctor: "_Tuple3"
                 ,_0: shapeSelected || featureSelected
                 ,_1: A3(objectZoneIsCurrentlyBeingManipulated,model,id,pred)
                 ,_2: maybeColor};
      if (_p80.ctor === "_Tuple3" && _p80._0 === true && _p80._1 === false && _p80._2.ctor === "Just")
      {
            return A8(zoneColor_,
            zoneName,
            shapeFeature,
            model,
            id,
            shape,
            x,
            y,
            _p80._2._0);
         } else {
            return _U.list([]);
         }
   });
   var zoneFillColor = A2(zoneColor,
   "FillBall",
   $ShapeWidgets.shapeFill);
   var zoneStrokeColor = A2(zoneColor,
   "StrokeBall",
   $ShapeWidgets.shapeStroke);
   var zoneOpacity_ = F8(function (zoneName,
   shapeFeature,
   model,
   id,
   shape,
   x,
   y,
   _p81) {
      var _p82 = _p81;
      var _p83 = {ctor: "_Tuple6"
                 ,_0: wOpacityBox
                 ,_1: 20
                 ,_2: 20
                 ,_3: "silver"
                 ,_4: "2"
                 ,_5: "7"};
      var w = _p83._0;
      var h = _p83._1;
      var a = _p83._2;
      var stroke = _p83._3;
      var strokeWidth = _p83._4;
      var rBall = _p83._5;
      var yOff = a + rotZoneDelta;
      var typeAndNodeIdAndFeature = {ctor: "_Tuple3"
                                    ,_0: $ShapeWidgets.selectedTypeShapeFeature
                                    ,_1: id
                                    ,_2: shapeFeature};
      var ball = function () {
         var cx = x + _p82._0 * wOpacityBox;
         var cy = y - yOff + h / 2;
         return A3($Basics.flip,
         $Svg.circle,
         _U.list([]),
         A2($Basics._op["++"],
         _U.list([A2($LangSvg.attr,"stroke","black")
                 ,A2($LangSvg.attr,"stroke-width",strokeWidth)
                 ,A2($LangSvg.attr,"fill",stroke)
                 ,A2($LangSvg.attr,"cx",$Basics.toString(cx))
                 ,A2($LangSvg.attr,"cy",$Basics.toString(cy))
                 ,A2($LangSvg.attr,"r",rBall)
                 ,A2(cursorOfZone,zoneName,"default")]),
         A3(zoneEvents,id,shape,zoneName)));
      }();
      var box = A3($Basics.flip,
      $Svg.rect,
      _U.list([]),
      _U.list([A2($LangSvg.attr,
              "fill",
              A2($Set.member,
              typeAndNodeIdAndFeature,
              model.selectedFeatures) ? colorPointSelected : "white")
              ,A2($LangSvg.attr,"stroke",stroke)
              ,A2($LangSvg.attr,"stroke-width",strokeWidth)
              ,A2($LangSvg.attr,"x",$Basics.toString(x))
              ,A2($LangSvg.attr,"y",$Basics.toString(y - yOff))
              ,A2($LangSvg.attr,"width",$Basics.toString(w))
              ,A2($LangSvg.attr,"height",$Basics.toString(h))]));
      return _U.list([A2($Svg.g,
                     _U.list([onMouseDownAndStop(toggleSelected(_U.list([typeAndNodeIdAndFeature])))]),
                     _U.list([box]))
                     ,ball]);
   });
   var zoneOpacity = F8(function (zoneName,
   shapeFeature,
   model,
   id,
   shape,
   x,
   y,
   maybeOpacity) {
      var pred = function (z) {
         return isPrimaryZone(z) || isRotateZone(z);
      };
      var shapeSelected = A2($Set.member,id,model.selectedShapes);
      var featureSelected = A2($Set.member,
      {ctor: "_Tuple3"
      ,_0: $ShapeWidgets.selectedTypeShapeFeature
      ,_1: id
      ,_2: shapeFeature},
      model.selectedFeatures);
      var _p84 = {ctor: "_Tuple3"
                 ,_0: shapeSelected || featureSelected
                 ,_1: A3(objectZoneIsCurrentlyBeingManipulated,model,id,pred)
                 ,_2: maybeOpacity};
      if (_p84.ctor === "_Tuple3" && _p84._0 === true && _p84._1 === false && _p84._2.ctor === "Just")
      {
            return A8(zoneOpacity_,
            zoneName,
            shapeFeature,
            model,
            id,
            shape,
            x,
            y,
            _p84._2._0);
         } else {
            return _U.list([]);
         }
   });
   var zoneFillOpacity = A2(zoneOpacity,
   "FillOpacityBall",
   $ShapeWidgets.shapeFillOpacity);
   var zonesFill = F6(function (model,id,shape,x,y,l) {
      var _p85 = A2(maybeColorNumAttr,"fill",l);
      var maybeColor = _p85._0;
      var maybeOpacity = _p85._1;
      return A2($Basics._op["++"],
      A6(zoneFillOpacity,
      model,
      id,
      shape,
      x - wOpacityBox - 5,
      y,
      maybeOpacity),
      A6(zoneFillColor,model,id,shape,x,y,maybeColor));
   });
   var zoneStrokeOpacity = A2(zoneOpacity,
   "StrokeOpacityBall",
   $ShapeWidgets.shapeStrokeOpacity);
   var sliderZoneEvents = F2(function (i,string) {
      return dragZoneEvents($Either.Right({ctor: "_Tuple2"
                                          ,_0: i
                                          ,_1: string}));
   });
   var Unselected = {ctor: "Unselected"};
   var Selected = {ctor: "Selected"};
   var Regular = {ctor: "Regular"};
   var Disabled = {ctor: "Disabled"};
   var Depressed = {ctor: "Depressed"};
   var Highlighted = {ctor: "Highlighted"};
   var Raised = {ctor: "Raised"};
   var imgPath = function (s) {
      return A2($Basics._op["++"],"img/",s);
   };
   var titleStyle = _U.update($Text.defaultStyle,
   {typeface: _U.list(["Courier","monospace"])
   ,height: $Maybe.Just(18)
   ,bold: false
   ,color: $Color.white});
   var textColor = "white";
   var strButtonTopColor = "rgba(231,76,60,1.0)";
   var strInterfaceColor = "rgba(52,73,94,1.0)";
   var buildSvgWidgets = F3(function (wCanvas,hCanvas,model) {
      var wCaption = $Config.params.mainSection.uiWidgets.wCaption;
      var hSlider = $Config.params.mainSection.uiWidgets.hSlider;
      var wSlider = $Config.params.mainSection.uiWidgets.wSlider;
      var pad = $Config.params.mainSection.uiWidgets.pad;
      var wWidget = wSlider + wCaption + 2 * pad;
      var hWidget = hSlider + 2 * pad;
      var wToolBoxMax = wCanvas - 2 * pad;
      var numCols = $Basics.floor(wToolBoxMax / wWidget);
      var wToolBox = numCols * wWidget;
      var xL = pad;
      var yBL = hCanvas - hWidget - pad;
      var widgets = model.widgets;
      var numWidgets = $List.length(widgets);
      var numRows = $Basics.ceiling($Basics.toFloat(numWidgets) / $Basics.toFloat(numCols));
      var hToolBox = numRows * hWidget;
      var drawNumWidget = F8(function (i_,
      intOrNum,
      widget,
      locId,
      cap_,
      minVal,
      maxVal,
      curVal) {
         var i = i_ - 1;
         var _p86 = {ctor: "_Tuple2"
                    ,_0: A2($Basics._op["%"],i,numRows)
                    ,_1: i / numRows | 0};
         var r = _p86._0;
         var c = _p86._1;
         var xi = xL + c * wWidget;
         var xi$ = xi + pad;
         var yi = yBL - r * hWidget;
         var yi$ = yi + pad;
         var region = A3($Basics.flip,
         $Svg.rect,
         _U.list([]),
         _U.list([A2($LangSvg.attr,"fill","lightgray")
                 ,A2($LangSvg.attr,"stroke",strInterfaceColor)
                 ,A2($LangSvg.attr,"stroke-width","3px")
                 ,A2($LangSvg.attr,"rx","9px")
                 ,A2($LangSvg.attr,"ry","9px")
                 ,A2($LangSvg.attr,"x",$Basics.toString(xL + c * wWidget))
                 ,A2($LangSvg.attr,"y",$Basics.toString(yBL - r * hWidget))
                 ,A2($LangSvg.attr,"width",$Basics.toString(wWidget))
                 ,A2($LangSvg.attr,"height",$Basics.toString(hWidget))]));
         var box = function () {
            var color = function () {
               var feature = {ctor: "_Tuple3"
                             ,_0: $ShapeWidgets.selectedTypeWidget
                             ,_1: -1
                             ,_2: A2($Basics._op["++"],"widget",$Basics.toString(locId))};
               var _p87 = model.tool;
               if (_p87.ctor === "Cursor") {
                     return A2($Set.member,
                     feature,
                     model.selectedFeatures) ? colorPointSelected : strInterfaceColor;
                  } else {
                     return strInterfaceColor;
                  }
            }();
            return A3($Basics.flip,
            $Svg.rect,
            _U.list([]),
            _U.list([A2($LangSvg.attr,"fill",color)
                    ,A2($LangSvg.attr,"stroke","20px")
                    ,A2($LangSvg.attr,"stroke-width","20px")
                    ,A2($LangSvg.attr,"x",$Basics.toString(xL + c * wWidget + pad))
                    ,A2($LangSvg.attr,"y",$Basics.toString(yBL - r * hWidget + pad))
                    ,A2($LangSvg.attr,"width",$Basics.toString(wSlider))
                    ,A2($LangSvg.attr,"height",$Basics.toString(hSlider))
                    ,onMouseDown(toggleSelectedWidget(locId))]));
         }();
         var ball = function () {
            var _p88 = {ctor: "_Tuple2"
                       ,_0: maxVal - minVal
                       ,_1: curVal - minVal};
            var range = _p88._0;
            var diff = _p88._1;
            var pct = diff / range;
            var cx = xi + pad + $Basics.round(pct * wSlider);
            var cy = yi + pad + (hSlider / 2 | 0);
            return A3($Basics.flip,
            $Svg.circle,
            _U.list([]),
            A2($Basics._op["++"],
            _U.list([A2($LangSvg.attr,"stroke","black")
                    ,A2($LangSvg.attr,"stroke-width","2px")
                    ,A2($LangSvg.attr,"fill",strButtonTopColor)
                    ,A2($LangSvg.attr,
                    "r",
                    $Config.params.mainSection.uiWidgets.rBall)
                    ,A2($LangSvg.attr,"cx",$Basics.toString(cx))
                    ,A2($LangSvg.attr,"cy",$Basics.toString(cy))
                    ,A2(cursorOfZone,"SliderBall","default")]),
            A2(sliderZoneEvents,i_,intOrNum)));
         }();
         var text = function () {
            var cap = A2($Basics._op["++"],
            cap_,
            A2($Lang.strNumTrunc,5,curVal));
            return A3($Basics.flip,
            $Svg.text$,
            _U.list([$VirtualDom.text(cap)]),
            _U.list([A2($LangSvg.attr,"fill","black")
                    ,A2($LangSvg.attr,
                    "font-family",
                    $Config.params.mainSection.uiWidgets.font)
                    ,A2($LangSvg.attr,
                    "font-size",
                    $Config.params.mainSection.uiWidgets.fontSize)
                    ,A2($LangSvg.attr,"x",$Basics.toString(xi$ + wSlider + 10))
                    ,A2($LangSvg.attr,"y",$Basics.toString(yi$ + 18))]));
         }();
         return _U.list([region,box,text,ball]);
      });
      var drawPointWidget = F4(function (i_,widget,cx,cy) {
         var ball = A3($Basics.flip,
         $Svg.circle,
         _U.list([]),
         A2($Basics._op["++"],
         _U.list([A2($LangSvg.attr,"stroke","black")
                 ,A2($LangSvg.attr,"stroke-width","2px")
                 ,A2($LangSvg.attr,"fill",strButtonTopColor)
                 ,A2($LangSvg.attr,
                 "r",
                 $Config.params.mainSection.uiWidgets.rBall)
                 ,A2($LangSvg.attr,"cx",$Basics.toString(cx))
                 ,A2($LangSvg.attr,"cy",$Basics.toString(cy))
                 ,A2(cursorOfZone,"SliderBall","default")]),
         A2(sliderZoneEvents,i_,"Point")));
         return _U.list([ball]);
      });
      var draw = function (_p89) {
         var _p90 = _p89;
         var _p94 = _p90._1;
         var _p93 = _p90._0;
         var _p91 = _p94;
         switch (_p91.ctor)
         {case "WNumSlider": return A8(drawNumWidget,
              _p93,
              "Num",
              _p94,
              _p91._4._0,
              _p91._2,
              _p91._0,
              _p91._1,
              _p91._3);
            case "WIntSlider": var _p92 = {ctor: "_Tuple3"
                                          ,_0: $Basics.toFloat(_p91._0)
                                          ,_1: $Basics.toFloat(_p91._1)
                                          ,_2: $Basics.toFloat(_p91._3)};
              var minVal = _p92._0;
              var maxVal = _p92._1;
              var curVal = _p92._2;
              return A8(drawNumWidget,
              _p93,
              "Int",
              _p94,
              _p91._4._0,
              _p91._2,
              minVal,
              maxVal,
              curVal);
            default: return A4(drawPointWidget,
              _p93,
              _p94,
              _p91._0._0,
              _p91._1._0);}
      };
      return A2($Svg.svg,
      _U.list([]),
      $List.concat(A2($Utils.mapi,draw,widgets)));
   });
   var interfaceColor = A4($Color.rgba,52,73,94,1.0);
   var colorDebug = function (c1) {
      return A2(colorDebug_,c1,interfaceColor);
   };
   var caption = F3(function (model,w,h) {
      var eStr = function (_p95) {
         return $Graphics$Element.leftAligned(A2($Text.color,
         $Color.white,
         $Text.monospace($Text.fromString(_p95))));
      };
      var tStr = function (col) {
         return function (_p96) {
            return A2($Text.height,
            16,
            A2($Text.color,col,$Text.monospace($Text.fromString(_p96))));
         };
      };
      var tSpace = function (_p97) {
         return A2($Text.height,
         5,
         A2($Text.color,
         $Color.white,
         $Text.monospace($Text.fromString(_p97))));
      }("\n");
      return A2(colorDebug,
      $Color.orange,
      A4($Graphics$Element.container,
      w,
      h,
      $Graphics$Element.topLeft,
      function () {
         var _p98 = {ctor: "_Tuple3"
                    ,_0: model.caption
                    ,_1: model.mode
                    ,_2: model.mouseMode};
         _v46_2: do {
            if (_p98.ctor === "_Tuple3" && _p98._0.ctor === "Just") {
                  if (_p98._0._0.ctor === "Hovering") {
                        if (_p98._1.ctor === "Live" && _p98._2.ctor === "MouseNothing")
                        {
                              var _p99 = function () {
                                 var _p100 = A2($Sync.hoverInfo,_p98._0._0._0,_p98._1._0);
                                 if (_p100._1.ctor === "Nothing") {
                                       return {ctor: "_Tuple3"
                                              ,_0: _p100._0
                                              ,_1: ""
                                              ,_2: $Text.bold(A2(tStr,$Color.red," (INACTIVE)"))};
                                    } else {
                                       return {ctor: "_Tuple3"
                                              ,_0: _p100._0
                                              ,_1: _p100._1._0
                                              ,_2: $Text.bold(A2(tStr,$Color.green," (ACTIVE)"))};
                                    }
                              }();
                              var line1 = _p99._0;
                              var line2 = _p99._1;
                              var cap = _p99._2;
                              return $Graphics$Element.leftAligned($Text.concat(_U.list([tSpace
                                                                                        ,A2(tStr,$Color.white,A2($Basics._op["++"]," ",line1))
                                                                                        ,cap
                                                                                        ,A2(tStr,$Color.white,A2($Basics._op["++"],"\n ",line2))])));
                           } else {
                              break _v46_2;
                           }
                     } else {
                        return eStr(_p98._0._0._0);
                     }
               } else {
                  break _v46_2;
               }
         } while (false);
         return $Graphics$Element.empty;
      }()));
   });
   var dimToPix = function (d) {
      return A2($String.append,$Basics.toString(d),"px");
   };
   var makeButton = F4(function (_p101,w,h,text) {
      var _p102 = _p101;
      var prefix = function () {
         var _p103 = _p102._0;
         switch (_p103.ctor)
         {case "Regular": return "";
            case "Selected": return "";
            default: return "unselected_";}
      }();
      var depdip = 6.0e-2;
      var topprop = 0.9;
      var fontsize = 16;
      var raisedoffset = $Basics.round(0.5 * topprop * $Basics.toFloat(h) - 0.5 * fontsize);
      var depressedoffset = $Basics.round($Basics.toFloat(raisedoffset) + depdip * $Basics.toFloat(h));
      var _p104 = function () {
         var _p105 = _p102._1;
         switch (_p105.ctor)
         {case "Raised": return {ctor: "_Tuple2"
                                ,_0: imgPath(A2($Basics._op["++"],prefix,"button_raised.svg"))
                                ,_1: raisedoffset};
            case "Highlighted": return {ctor: "_Tuple2"
                                       ,_0: imgPath(A2($Basics._op["++"],
                                       prefix,
                                       "button_highlighted.svg"))
                                       ,_1: raisedoffset};
            case "Depressed": return {ctor: "_Tuple2"
                                     ,_0: imgPath(A2($Basics._op["++"],
                                     prefix,
                                     "button_depressed.svg"))
                                     ,_1: depressedoffset};
            default: return {ctor: "_Tuple2"
                            ,_0: imgPath(A2($Basics._op["++"],prefix,"button_disabled.svg"))
                            ,_1: raisedoffset};}
      }();
      var img = _p104._0;
      var dip = _p104._1;
      return A2($Graphics$Element.flow,
      $Graphics$Element.outward,
      _U.list([A3($Graphics$Element.image,w,h,img)
              ,A3($Html.toElement,
              w,
              h,
              A2($Html.div,
              _U.list([$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                                       ,_0: "color"
                                                       ,_1: textColor}
                                                      ,{ctor: "_Tuple2"
                                                       ,_0: "font-family"
                                                       ,_1: $Config.params.mainSection.widgets.font}
                                                      ,{ctor: "_Tuple2",_0: "font-size",_1: "16px"}
                                                      ,{ctor: "_Tuple2",_0: "text-align",_1: "center"}
                                                      ,{ctor: "_Tuple2",_0: "width",_1: dimToPix(w)}
                                                      ,{ctor: "_Tuple2",_0: "height",_1: dimToPix(h)}
                                                      ,{ctor: "_Tuple2"
                                                       ,_0: "transform"
                                                       ,_1: A2($Basics._op["++"],
                                                       "translate(0px,",
                                                       A2($Basics._op["++"],dimToPix(dip),")"))}]))]),
              _U.list([$Html.text(text)])))]));
   });
   var simpleButton_ = F8(function (addy,
   btnKind,
   defaultMsg,
   disabled,
   msg,
   text,
   w,
   h) {
      return disabled ? A4($Graphics$Input.customButton,
      A2($Signal.message,addy,defaultMsg),
      A4(makeButton,
      {ctor: "_Tuple2",_0: btnKind,_1: Disabled},
      w,
      h,
      text),
      A4(makeButton,
      {ctor: "_Tuple2",_0: btnKind,_1: Disabled},
      w,
      h,
      text),
      A4(makeButton,
      {ctor: "_Tuple2",_0: btnKind,_1: Disabled},
      w,
      h,
      text)) : A4($Graphics$Input.customButton,
      A2($Signal.message,addy,msg),
      A4(makeButton,
      {ctor: "_Tuple2",_0: btnKind,_1: Raised},
      w,
      h,
      text),
      A4(makeButton,
      {ctor: "_Tuple2",_0: btnKind,_1: Highlighted},
      w,
      h,
      text),
      A4(makeButton,
      {ctor: "_Tuple2",_0: btnKind,_1: Depressed},
      w,
      h,
      text));
   });
   var simpleEventButton_ = A3(simpleButton_,
   $InterfaceModel.events.address,
   Regular,
   $InterfaceModel.Noop);
   var simpleButton = simpleEventButton_(false);
   var luckyButton = function (model) {
      var foo = function (old) {
         var so = old.syncOptions;
         var so$ = _U.update(so,
         {feelingLucky: $Sync.toggleHeuristicMode(so.feelingLucky)});
         var _p106 = old.mode;
         if (_p106.ctor === "Live") {
               var _p107 = A5($InterfaceModel.mkLive_,
               so$,
               old.slideNumber,
               old.movieNumber,
               old.movieTime,
               old.inputExp);
               if (_p107.ctor === "Ok") {
                     return _U.update(old,{syncOptions: so$,mode: _p107._0});
                  } else {
                     return _U.update(old,
                     {syncOptions: so$,errorBox: $Maybe.Just(_p107._0)});
                  }
            } else {
               return _U.update(old,{syncOptions: so$});
            }
      };
      var yesno = function () {
         var hm = model.syncOptions.feelingLucky;
         return _U.eq(hm,$Sync.heuristicsNone) ? "None" : _U.eq(hm,
         $Sync.heuristicsFair) ? "Fair" : "Biased";
      }();
      return A2(simpleButton,
      $InterfaceModel.UpdateModel(foo),
      A2($Basics._op["++"],"[Heuristics] ",yesno));
   };
   var orientationButton = F3(function (w,h,model) {
      var text = A2($Basics._op["++"],
      "[Orientation] ",
      $Basics.toString(model.orient));
      return A4(simpleButton,$InterfaceModel.SwitchOrient,text,w,h);
   });
   var basicBoxButton = F3(function (w,h,model) {
      var _p108 = function () {
         var _p109 = model.basicCodeBox;
         if (_p109 === true) {
               return {ctor: "_Tuple2"
                      ,_0: "[Code Box] Basic"
                      ,_1: $InterfaceModel.ToggleBasicCodeBox};
            } else {
               return {ctor: "_Tuple2"
                      ,_0: "[Code Box] Fancy"
                      ,_1: $InterfaceModel.WaitCodeBox};
            }
      }();
      var text = _p108._0;
      var evt = _p108._1;
      return A4(simpleButton,evt,text,w,h);
   });
   var runButton = F3(function (model,w,h) {
      var disabled = _U.eq(model.mode,$InterfaceModel.AdHoc);
      return A5(simpleEventButton_,
      disabled,
      $InterfaceModel.WaitRun,
      "Run Code",
      w,
      h);
   });
   var outputButton = F3(function (model,w,h) {
      var disabled = _U.eq(model.mode,$InterfaceModel.AdHoc);
      var cap = function () {
         var _p110 = model.mode;
         if (_p110.ctor === "Print") {
               return "[Out] SVG";
            } else {
               return "[Out] Canvas";
            }
      }();
      return A5(simpleEventButton_,
      disabled,
      $InterfaceModel.ToggleOutput,
      cap,
      w,
      h);
   });
   var ghostsButton = F3(function (model,w,h) {
      var cap = function () {
         var _p111 = model.showGhosts;
         if (_p111 === true) {
               return "[Ghosts] Shown";
            } else {
               return "[Ghosts] Hidden";
            }
      }();
      var foo = function (old) {
         var showGhosts$ = $Basics.not(old.showGhosts);
         var mode$ = function () {
            var _p112 = old.mode;
            if (_p112.ctor === "Print") {
                  return $InterfaceModel.Print(A2($LangSvg.printSvg,
                  showGhosts$,
                  old.slate));
               } else {
                  return old.mode;
               }
         }();
         return _U.update(old,{showGhosts: showGhosts$,mode: mode$});
      };
      return A5(simpleEventButton_,
      false,
      $InterfaceModel.UpdateModel(foo),
      cap,
      w,
      h);
   });
   var saveButton = F3(function (model,w,h) {
      var cap = "Save";
      var disabled = A2($List.any,
      function (_p113) {
         return A2(F2(function (x,y) {    return _U.eq(x,y);}),
         model.exName,
         $Utils.fst3(_p113));
      },
      $ExamplesGenerated.list);
      return A5(simpleEventButton_,
      disabled,
      $InterfaceModel.WaitSave(model.exName),
      cap,
      w,
      h);
   });
   var undoButton = function (model) {
      var past = $Basics.fst(model.history);
      return A3(simpleEventButton_,
      _U.cmp($List.length(past),1) < 1,
      $InterfaceModel.Undo,
      "Undo");
   };
   var redoButton = function (model) {
      var future = $Basics.snd(model.history);
      return A3(simpleEventButton_,
      _U.eq($List.length(future),0),
      $InterfaceModel.Redo,
      "Redo");
   };
   var previousSlideButton = function (model) {
      return A3(simpleEventButton_,
      _U.eq(model.slideNumber,1) && _U.eq(model.movieNumber,1),
      $InterfaceModel.PreviousSlide,
      "◀◀");
   };
   var nextSlideButton = function (model) {
      return A3(simpleEventButton_,
      _U.eq(model.slideNumber,
      model.slideCount) && _U.eq(model.movieNumber,model.movieCount),
      $InterfaceModel.NextSlide,
      "▶▶");
   };
   var previousMovieButton = function (model) {
      return A3(simpleEventButton_,
      _U.eq(model.slideNumber,1) && _U.eq(model.movieNumber,1),
      $InterfaceModel.PreviousMovie,
      "◀");
   };
   var nextMovieButton = function (model) {
      return A3(simpleEventButton_,
      _U.eq(model.slideNumber,
      model.slideCount) && _U.eq(model.movieNumber,model.movieCount),
      $InterfaceModel.NextMovie,
      "▶");
   };
   var widgetsSlideNavigation = F3(function (w,h,model) {
      return _U.list([A2(gapWidget,w,h)
                     ,A4(twoButtons,
                     w,
                     h,
                     previousSlideButton(model),
                     nextSlideButton(model))
                     ,A4(twoButtons,
                     w,
                     h,
                     previousMovieButton(model),
                     nextMovieButton(model))
                     ,A3(slideNumber,model,w,h)]);
   });
   var cleanButton = function (model) {
      var disabled = function () {
         var _p114 = model.mode;
         if (_p114.ctor === "Live") {
               return false;
            } else {
               return true;
            }
      }();
      return A3(simpleEventButton_,
      disabled,
      $InterfaceModel.WaitClean,
      "Clean Up");
   };
   var widgetsUndoRedo = F3(function (w,h,model) {
      return _U.list([A4(twoButtons,
                     w,
                     h,
                     undoButton(model),
                     redoButton(model))
                     ,A3(cleanButton,model,w,h)]);
   });
   var simpleTaskButton_ = A3(simpleButton_,
   $InterfaceStorage.taskMailbox.address,
   Regular,
   $Task.succeed({ctor: "_Tuple0"}));
   var simpleTaskButton = simpleTaskButton_(false);
   var saveAsButton = F3(function (model,w,h) {
      var cap = "Clone";
      return A4(simpleTaskButton,
      A3($InterfaceStorage.saveStateLocally,model.exName,true,model),
      cap,
      w,
      h);
   });
   var loadButton = F3(function (model,w,h) {
      var cap = "Revert";
      return A4(simpleTaskButton,
      A2($InterfaceStorage.loadLocalState,model,model.exName),
      cap,
      w,
      h);
   });
   var saveElement = F3(function (model,w,h) {
      var _p115 = model.mode;
      if (_p115.ctor === "SaveDialog") {
            var pickBox = A4($Graphics$Element.container,
            w,
            h,
            $Graphics$Element.middle,
            A2($Graphics$Element.color,
            interfaceColor,
            A4($Graphics$Element.container,
            400,
            200,
            $Graphics$Element.middle,
            A2($Graphics$Element.flow,
            $Graphics$Element.down,
            _U.list([A2($Graphics$Element.flow,
                    $Graphics$Element.right,
                    _U.list([A2($Graphics$Element.spacer,42,18)
                            ,$Graphics$Element.centered(A2($Text.style,
                            titleStyle,
                            $Text.fromString("Save Work to Browser")))]))
                    ,A2($Graphics$Element.spacer,160,10)
                    ,A2($Graphics$Element.flow,
                    $Graphics$Element.right,
                    _U.list([A3($Html.toElement,
                            200,
                            40,
                            A2($Html.input,
                            _U.list([$Html$Attributes.type$("text")
                                    ,$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                                                     ,_0: "height"
                                                                     ,_1: "32px"}
                                                                    ,{ctor: "_Tuple2",_0: "width",_1: "192px"}
                                                                    ,{ctor: "_Tuple2",_0: "padding",_1: "4px"}
                                                                    ,{ctor: "_Tuple2",_0: "border-width",_1: "0px"}
                                                                    ,{ctor: "_Tuple2",_0: "pointer-events",_1: "auto"}
                                                                    ,{ctor: "_Tuple2"
                                                                     ,_0: "box-shadow"
                                                                     ,_1: "inset 0 0 10px 3px lightgray"}]))
                                    ,$Html$Attributes.value(model.fieldContents.value)
                                    ,$Html$Attributes.placeholder(model.fieldContents.hint)
                                    ,$Html$Attributes.autofocus(true)
                                    ,A3($Html$Events.on,
                                    "input",
                                    $Html$Events.targetValue,
                                    function (cont) {
                                       return A2($Signal.message,
                                       $InterfaceModel.events.address,
                                       $InterfaceModel.UpdateFieldContents({value: cont
                                                                           ,hint: model.fieldContents.hint}));
                                    })]),
                            _U.list([])))
                            ,A2($Graphics$Element.spacer,10,40)
                            ,A4(simpleTaskButton,
                            A2($InterfaceStorage.checkAndSave,
                            model.fieldContents.value,
                            model),
                            "Create Save",
                            100,
                            40)]))
                    ,A2($Graphics$Element.spacer,160,10)
                    ,A2($Graphics$Element.flow,
                    $Graphics$Element.right,
                    _U.list([A2($Graphics$Element.spacer,47,50)
                            ,$Graphics$Element.centered(A2($Text.height,
                            12,
                            A2($Text.color,
                            $Color.white,
                            $Text.fromString(A2($Basics._op["++"],
                            "Note: This will overwrite saves with\n",
                            A2($Basics._op["++"],
                            "the same name. You must choose a\n",
                            "name different than a built-in example."))))))]))
                    ,A2($Graphics$Element.spacer,160,10)
                    ,A2($Graphics$Element.flow,
                    $Graphics$Element.right,
                    _U.list([A2($Graphics$Element.spacer,112,30)
                            ,A4(simpleButton,
                            A2($InterfaceModel.RemoveDialog,false,""),
                            "Cancel",
                            75,
                            30)]))])))));
            var dimBox = A2($Graphics$Element.color,
            $Color.black,
            A2($Graphics$Element.opacity,
            0.5,
            A2($Graphics$Element.spacer,w,h)));
            return A2($Graphics$Element.flow,
            $Graphics$Element.outward,
            _U.list([dimBox,pickBox]));
         } else {
            return $Graphics$Element.empty;
         }
   });
   var toolButton = F4(function (model,tool,w,h) {
      var capStretchy = function (s) {
         return showRawShapeTools ? "BB" : s;
      };
      var capSticky = $Utils.uniPlusMinus;
      var capRaw = "(Raw)";
      var cap = function () {
         var _p116 = tool;
         _v59_16: do {
            switch (_p116.ctor)
            {case "Cursor": return "Cursor";
               case "Line": if (_p116._0.ctor === "Raw") {
                       return "Line";
                    } else {
                       break _v59_16;
                    }
               case "Rect": switch (_p116._0.ctor)
                 {case "Raw": return "Rect";
                    case "Stretchy": return capStretchy("Box");
                    default: break _v59_16;}
               case "Oval": switch (_p116._0.ctor)
                 {case "Raw": return "Ellipse";
                    case "Stretchy": return capStretchy("Oval");
                    default: break _v59_16;}
               case "Poly": switch (_p116._0.ctor)
                 {case "Raw": return "Polygon";
                    case "Stretchy": return capStretchy("Polygon");
                    default: return capSticky;}
               case "Path": switch (_p116._0.ctor)
                 {case "Raw": return "Path";
                    case "Stretchy": return capStretchy("Path");
                    default: return capSticky;}
               case "Text": return "Text";
               case "HelperLine": return "(Rule)";
               case "HelperDot": return "(Dot)";
               default: return $Utils.uniLambda;}
         } while (false);
         return _U.crashCase("InterfaceView2",
         {start: {line: 2061,column: 13},end: {line: 2078,column: 67}},
         _p116)(A2($Basics._op["++"],
         "toolButton: ",
         $Basics.toString(tool)));
      }();
      var btnKind = _U.eq(model.tool,tool) ? Selected : Unselected;
      var _p118 = function () {
         var _p119 = tool;
         if (_p119.ctor === "Path" && _p119._0.ctor === "Sticky") {
               return {ctor: "_Tuple2",_0: Regular,_1: true};
            } else {
               return {ctor: "_Tuple2",_0: btnKind,_1: false};
            }
      }();
      var btnKind = _p118._0;
      var disabled = _p118._1;
      return A8(simpleButton_,
      $InterfaceModel.events.address,
      btnKind,
      $InterfaceModel.Noop,
      disabled,
      $InterfaceModel.UpdateModel(function (m) {
         return _U.update(m,{tool: tool});
      }),
      cap,
      w,
      h);
   });
   var widgetsTools = F3(function (w,h,model) {
      var noFeatures = $Set.isEmpty(model.selectedFeatures);
      var noBlobs = $Dict.isEmpty(model.selectedBlobs);
      var relateButton = simpleEventButton_(noFeatures);
      var groupButton = simpleEventButton_(noBlobs || $Basics.not(noFeatures));
      var groupButtonSelectedFeaturesOkay = simpleEventButton_(noBlobs);
      return A2($Basics._op["++"],
      _U.list([A4(toolButton,model,$InterfaceModel.Cursor,w,h)]),
      A2($Basics._op["++"],
      false ? _U.list([A3(flowRight,
      w,
      h,
      _U.list([{ctor: "_Tuple2"
               ,_0: 1 / 5
               ,_1: A2(toolButton,
               model,
               $InterfaceModel.Rect($InterfaceModel.Raw))}
              ,{ctor: "_Tuple2"
               ,_0: 1 / 5
               ,_1: A2(toolButton,
               model,
               $InterfaceModel.Oval($InterfaceModel.Raw))}
              ,{ctor: "_Tuple2"
               ,_0: 1 / 5
               ,_1: A2(toolButton,
               model,
               $InterfaceModel.Poly($InterfaceModel.Raw))}
              ,{ctor: "_Tuple2"
               ,_0: 2 / 5
               ,_1: A2(toolButton,
               model,
               $InterfaceModel.Path($InterfaceModel.Raw))}]))]) : showRawShapeTools ? A2($Basics._op["++"],
      _U.list([A4(twoButtons,
      w,
      h,
      A2(toolButton,model,$InterfaceModel.Line($InterfaceModel.Raw)),
      A2(toolButton,model,$InterfaceModel.Text))]),
      A2($Basics._op["++"],
      A2($List.map,
      function (tool) {
         return A3(flowRight,
         w,
         h,
         _U.list([{ctor: "_Tuple2"
                  ,_0: 0.7
                  ,_1: A2(toolButton,model,tool($InterfaceModel.Raw))}
                 ,{ctor: "_Tuple2"
                  ,_0: 0.3
                  ,_1: A2(toolButton,model,tool($InterfaceModel.Stretchy))}]));
      },
      _U.list([$InterfaceModel.Rect
              ,$InterfaceModel.Oval
              ,$InterfaceModel.Poly
              ,$InterfaceModel.Path])),
      _U.list([A3(flowRight,
      w,
      h,
      _U.list([{ctor: "_Tuple2"
               ,_0: 1 / 4
               ,_1: A2(toolButton,model,$InterfaceModel.Lambda)}
              ,{ctor: "_Tuple2"
               ,_0: 3 / 4
               ,_1: dropdownLambdaTool(model)}]))]))) : _U.list([A4(twoButtons,
                                                                w,
                                                                h,
                                                                A2(toolButton,model,$InterfaceModel.Line($InterfaceModel.Raw)),
                                                                A2(toolButton,
                                                                model,
                                                                $InterfaceModel.Rect($InterfaceModel.Stretchy)))
                                                                ,A4(twoButtons,
                                                                w,
                                                                h,
                                                                A2(toolButton,
                                                                model,
                                                                $InterfaceModel.Oval($InterfaceModel.Stretchy)),
                                                                A2(toolButton,
                                                                model,
                                                                $InterfaceModel.Path($InterfaceModel.Stretchy)))
                                                                ,A3(flowRight,
                                                                w,
                                                                h,
                                                                _U.list([{ctor: "_Tuple2"
                                                                         ,_0: 1 / 2
                                                                         ,_1: A2(toolButton,
                                                                         model,
                                                                         $InterfaceModel.Poly($InterfaceModel.Stretchy))}
                                                                        ,{ctor: "_Tuple2"
                                                                         ,_0: 1 / 2
                                                                         ,_1: A2(toolButton,model,$InterfaceModel.Text)}]))
                                                                ,A3(flowRight,
                                                                w,
                                                                h,
                                                                _U.list([{ctor: "_Tuple2"
                                                                         ,_0: 1 / 4
                                                                         ,_1: A2(toolButton,model,$InterfaceModel.Lambda)}
                                                                        ,{ctor: "_Tuple2",_0: 3 / 4,_1: dropdownLambdaTool(model)}]))]),
      _U.list([A2(gapWidget,w,h)
              ,A4(twoButtons,
              w,
              h,
              A2(relateButton,$InterfaceModel.DigHole,"Dig"),
              A2(relateButton,$InterfaceModel.MakeEqual,"A = B"))
              ,A4(twoButtons,
              w,
              h,
              A2(groupButton,$InterfaceModel.DuplicateBlobs,"Dupe"),
              A2(groupButton,$InterfaceModel.MergeBlobs,"Merge"))
              ,A4(twoButtons,
              w,
              h,
              A2(groupButtonSelectedFeaturesOkay,
              $InterfaceModel.GroupBlobs,
              "Group"),
              A2(groupButton,$InterfaceModel.AbstractBlobs,"Abs"))
              ,A4(groupButton,
              $InterfaceModel.ReplicateBlob($InterfaceModel.HorizontalRepeat),
              "Repeat Right",
              w,
              h)
              ,A4(groupButton,
              $InterfaceModel.ReplicateBlob($InterfaceModel.LinearRepeat),
              "Repeat To",
              w,
              h)
              ,A4(groupButton,
              $InterfaceModel.ReplicateBlob($InterfaceModel.RadialRepeat),
              "Repeat Around",
              w,
              h)])));
   });
   var codeButton = F3(function (model,w,h) {
      var _p120 = function () {
         var _p121 = model.hideCode;
         if (_p121 === true) {
               return {ctor: "_Tuple2",_0: "Code",_1: Unselected};
            } else {
               return {ctor: "_Tuple2",_0: "Code",_1: Selected};
            }
      }();
      var cap = _p120._0;
      var btnKind = _p120._1;
      var foo = function (model) {
         return _U.update(model,
         {hideCode: $Basics.not(model.hideCode)});
      };
      return A8(simpleButton_,
      $InterfaceModel.events.address,
      btnKind,
      $InterfaceModel.Noop,
      model.hideCanvas,
      $InterfaceModel.UpdateModel(foo),
      cap,
      w,
      h);
   });
   var canvasButton = F3(function (model,w,h) {
      var _p122 = function () {
         var _p123 = model.hideCanvas;
         if (_p123 === true) {
               return {ctor: "_Tuple2",_0: "Canvas",_1: Unselected};
            } else {
               return {ctor: "_Tuple2",_0: "Canvas",_1: Selected};
            }
      }();
      var cap = _p122._0;
      var btnKind = _p122._1;
      var foo = function (model) {
         return _U.update(model,
         {hideCanvas: $Basics.not(model.hideCanvas)});
      };
      return A8(simpleButton_,
      $InterfaceModel.events.address,
      btnKind,
      $InterfaceModel.Noop,
      model.hideCode,
      $InterfaceModel.UpdateModel(foo),
      cap,
      w,
      h);
   });
   var widgetsExampleNavigation = F3(function (w,h,model) {
      return _U.list([A4(twoButtons,
                     w,
                     h,
                     codeButton(model),
                     canvasButton(model))
                     ,A3(dropdownExamples,model,w,h)
                     ,A3(runButton,model,w,h)
                     ,A3(loadButton,model,w,h)]);
   });
   var middleWidgets = F7(function (row1,
   row2,
   w,
   h,
   wWrap,
   hWrap,
   model) {
      var exampleNavigation = A3(widgetsExampleNavigation,
      w,
      h,
      model);
      var undoRedo = A3(widgetsUndoRedo,w,h,model);
      var tools = A3(widgetsTools,w,h,model);
      var slideNavigation = A3(widgetsSlideNavigation,w,h,model);
      var l1 = row1 ? A2($Basics._op["++"],
      exampleNavigation,
      undoRedo) : _U.list([]);
      var l2_ = row2 ? tools : _U.list([]);
      var l2 = row1 && row2 ? A2($List._op["::"],
      A2(gapWidget,w,h),
      l2_) : l2_;
      return A2($List.map,
      A3($Graphics$Element.container,
      wWrap,
      hWrap,
      $Graphics$Element.middle),
      function () {
         var _p124 = {ctor: "_Tuple2"
                     ,_0: model.mode
                     ,_1: $Lang.unwrapVList(model.inputVal)};
         _v63_3: do {
            if (_p124.ctor === "_Tuple2") {
                  switch (_p124._0.ctor)
                  {case "SyncSelect": return _U.list([]);
                     case "Print": return l1;
                     default:
                     if (_p124._1.ctor === "Just" && _p124._1._0.ctor === "::" && _p124._1._0._0.ctor === "VConst" && _p124._1._0._0._0.ctor === "_Tuple2" && _p124._1._0._1.ctor === "::" && _p124._1._0._1._1.ctor === "[]")
                       {
                             return A2($Basics._op["++"],
                             l1,
                             A2($Basics._op["++"],row1 ? slideNavigation : _U.list([]),l2));
                          } else {
                             break _v63_3;
                          }}
               } else {
                  break _v63_3;
               }
         } while (false);
         return A2($Basics._op["++"],l1,l2);
      }());
   });
   var buttonAttrs = F2(function (w,h) {
      return $Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                             ,_0: "width"
                                             ,_1: dimToPix(w)}
                                            ,{ctor: "_Tuple2",_0: "height",_1: dimToPix(h)}
                                            ,{ctor: "_Tuple2"
                                             ,_0: "font-family"
                                             ,_1: $Config.params.mainSection.widgets.font}
                                            ,{ctor: "_Tuple2"
                                             ,_0: "font-size"
                                             ,_1: $Config.params.mainSection.widgets.fontSize}]));
   });
   var gutterForResizing = F3(function (orient,w,h) {
      var s = _U.eq(orient,
      $InterfaceModel.Vertical) ? "ew-resize" : "ns-resize";
      return A2(colorDebug,
      $Color.darkBlue,
      A3($Html.toElement,
      w,
      h,
      A2($Html.div,
      _U.list([A2($Html$Events.onMouseDown,
              $InterfaceModel.events.address,
              $InterfaceModel.StartResizingMid)
              ,$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                               ,_0: "width"
                                               ,_1: dimToPix(w)}
                                              ,{ctor: "_Tuple2",_0: "height",_1: dimToPix(h)}
                                              ,{ctor: "_Tuple2",_0: "cursor",_1: s}]))]),
      _U.list([]))));
   });
   var svgPath = A2($Basics.flip,$Svg.path,_U.list([]));
   var zoneStrokeWidth_ = F6(function (model,id,shape,x,y,_p125) {
      var _p126 = _p125;
      var _p127 = {ctor: "_Tuple6"
                  ,_0: wStrokeWidthBox
                  ,_1: $LangSvg.maxStrokeWidthNum
                  ,_2: 20
                  ,_3: "silver"
                  ,_4: "2"
                  ,_5: "7"};
      var w = _p127._0;
      var h = _p127._1;
      var a = _p127._2;
      var stroke = _p127._3;
      var strokeWidth = _p127._4;
      var rBall = _p127._5;
      var yOff = a + rotZoneDelta;
      var typeAndNodeIdAndFeature = {ctor: "_Tuple3"
                                    ,_0: $ShapeWidgets.selectedTypeShapeFeature
                                    ,_1: id
                                    ,_2: $ShapeWidgets.shapeStrokeWidth};
      var box = A3($Basics.flip,
      $Svg.rect,
      _U.list([]),
      _U.list([A2($LangSvg.attr,
              "fill",
              A2($Set.member,
              typeAndNodeIdAndFeature,
              model.selectedFeatures) ? colorPointSelected : "white")
              ,A2($LangSvg.attr,"stroke",stroke)
              ,A2($LangSvg.attr,"stroke-width",strokeWidth)
              ,A2($LangSvg.attr,"x",$Basics.toString(x))
              ,A2($LangSvg.attr,"y",$Basics.toString(y - yOff))
              ,A2($LangSvg.attr,"width",$Basics.toString(w))
              ,A2($LangSvg.attr,"height",$Basics.toString(h))]));
      var ball = function () {
         var cx = x + _p126._0 / $LangSvg.maxStrokeWidthNum * wStrokeWidthBox;
         var cy = y - yOff + h / 2;
         return A3($Basics.flip,
         $Svg.circle,
         _U.list([]),
         A2($Basics._op["++"],
         _U.list([A2($LangSvg.attr,"stroke","black")
                 ,A2($LangSvg.attr,"stroke-width",strokeWidth)
                 ,A2($LangSvg.attr,"fill",stroke)
                 ,A2($LangSvg.attr,"cx",$Basics.toString(cx))
                 ,A2($LangSvg.attr,"cy",$Basics.toString(cy))
                 ,A2($LangSvg.attr,"r",rBall)
                 ,A2(cursorOfZone,"StrokeWidthBall","default")]),
         A3(zoneEvents,id,shape,"StrokeWidthBall")));
      }();
      var triangle = function () {
         var _p128 = {ctor: "_Tuple2",_0: x,_1: y - yOff + h / 2};
         var x0 = _p128._0;
         var y0 = _p128._1;
         var _p129 = {ctor: "_Tuple2"
                     ,_0: x + wStrokeWidthBox
                     ,_1: y - yOff};
         var x1 = _p129._0;
         var y1 = _p129._1;
         var _p130 = {ctor: "_Tuple2"
                     ,_0: x + wStrokeWidthBox
                     ,_1: y - yOff + h};
         var x2 = _p130._0;
         var y2 = _p130._1;
         return svgPath(_U.list([A2($LangSvg.attr,"fill","darkgray")
                                ,A2($LangSvg.attr,
                                "d",
                                A2($Basics._op["++"],
                                "M ",
                                A2($Basics._op["++"],
                                $Basics.toString(x0),
                                A2($Basics._op["++"],
                                " ",
                                A2($Basics._op["++"],
                                $Basics.toString(y0),
                                A2($Basics._op["++"],
                                " L ",
                                A2($Basics._op["++"],
                                $Basics.toString(x1),
                                A2($Basics._op["++"],
                                " ",
                                A2($Basics._op["++"],
                                $Basics.toString(y1),
                                A2($Basics._op["++"],
                                " L ",
                                A2($Basics._op["++"],
                                $Basics.toString(x2),
                                A2($Basics._op["++"],
                                " ",
                                A2($Basics._op["++"],$Basics.toString(y2)," Z")))))))))))))]));
      }();
      return _U.list([A2($Svg.g,
                     _U.list([onMouseDownAndStop(toggleSelected(_U.list([typeAndNodeIdAndFeature])))]),
                     _U.list([box,triangle]))
                     ,ball]);
   });
   var zoneStrokeWidth = F6(function (model,
   id,
   shape,
   x,
   y,
   maybeStrokeWidth) {
      var pred = function (z) {
         return isPrimaryZone(z) || isRotateZone(z);
      };
      var shapeSelected = A2($Set.member,id,model.selectedShapes);
      var featureSelected = A2($Set.member,
      {ctor: "_Tuple3"
      ,_0: $ShapeWidgets.selectedTypeShapeFeature
      ,_1: id
      ,_2: $ShapeWidgets.shapeStrokeWidth},
      model.selectedFeatures);
      var _p131 = {ctor: "_Tuple3"
                  ,_0: shapeSelected || featureSelected
                  ,_1: A3(objectZoneIsCurrentlyBeingManipulated,model,id,pred)
                  ,_2: maybeStrokeWidth};
      if (_p131.ctor === "_Tuple3" && _p131._0 === true && _p131._1 === false && _p131._2.ctor === "Just")
      {
            return A6(zoneStrokeWidth_,model,id,shape,x,y,_p131._2._0);
         } else {
            return _U.list([]);
         }
   });
   var zonesStroke = F6(function (model,id,shape,x,y,l) {
      var _p132 = A2(maybeColorNumAttr,"stroke",l);
      var maybeColor = _p132._0;
      var maybeOpacity = _p132._1;
      var maybeStrokeWidth = maybeStrokeWidthNumAttr(l);
      return A2($Basics._op["++"],
      A6(zoneStrokeOpacity,
      model,
      id,
      shape,
      x - wOpacityBox - 5,
      y,
      maybeOpacity),
      A2($Basics._op["++"],
      A6(zoneStrokeColor,model,id,shape,x,y,maybeColor),
      A6(zoneStrokeWidth,
      model,
      id,
      shape,
      x + wGradient + 5,
      y,
      maybeStrokeWidth)));
   });
   var zonesFillAndStroke = F6(function (model,id,shape,x,y,l) {
      return A2($Basics._op["++"],
      A6(zonesFill,model,id,shape,x,y,l),
      A6(zonesStroke,model,id,shape,x,y - hZoneColor - 5,l));
   });
   var svgPolygon = A2($Basics.flip,$Svg.polygon,_U.list([]));
   var svgEllipse = A2($Basics.flip,$Svg.ellipse,_U.list([]));
   var svgCircle = A2($Basics.flip,$Svg.circle,_U.list([]));
   var zonePoint = F6(function (model,
   id,
   shape,
   zone,
   transform,
   attrs) {
      var maybeStyles = function () {
         var maybeStyles_ = function (_p133) {
            var _p134 = _p133;
            return A3(objectZoneIsCurrentlyBeingManipulated,
            model,
            id,
            F2(function (x,y) {
               return _U.eq(x,y);
            })(zone)) ? $Maybe.Just(A2(pointZoneStylesFillSelected,
            model,
            id)) : A2(objectIsCurrentlyBeingManipulated,
            model,
            id) ? $Maybe.Nothing : A2($Set.member,
            id,
            model.selectedShapes) ? $Maybe.Just(A2(pointZoneStylesFillSelected,
            model,
            id)) : A2($Set.member,
            id,
            model.hoveredShapes) ? $Maybe.Just(pointZoneStyles.fill.shown) : $Maybe.Nothing;
         };
         var _p135 = A2($ShapeWidgets.zoneToCrosshair,shape,zone);
         if (_p135.ctor === "Nothing") {
               return maybeStyles_({ctor: "_Tuple0"});
            } else {
               return A2($Set.member,
               {ctor: "_Tuple3",_0: id,_1: _p135._0._0,_2: _p135._0._1},
               model.hoveredCrosshairs) ? $Maybe.Nothing : maybeStyles_({ctor: "_Tuple0"});
            }
      }();
      var _p136 = maybeStyles;
      if (_p136.ctor === "Nothing") {
            return _U.list([]);
         } else {
            return $Utils.singleton(svgCircle(A2($Basics._op["++"],
            _U.list([A2($LangSvg.attr,"r",pointZoneStyles.radius)
                    ,A2($LangSvg.attr,"fill",_p136._0)
                    ,A2($LangSvg.attr,"stroke",pointZoneStyles.stroke)
                    ,A2($LangSvg.attr,"stroke-width",pointZoneStyles.strokeWidth)
                    ,A2(cursorOfZone,zone,"pointer")]),
            A2($Basics._op["++"],
            A3(zoneEvents,id,shape,zone),
            A2($Basics._op["++"],transform,attrs)))));
         }
   });
   var eightCardinalZones = F5(function (model,
   id,
   shape,
   transform,
   _p137) {
      var _p138 = _p137;
      var _p143 = _p138._1;
      var _p142 = _p138._2;
      var _p141 = _p138._0;
      var _p140 = _p138._3;
      var _p139 = {ctor: "_Tuple2"
                  ,_0: _p142 - _p141
                  ,_1: _p140 - _p143};
      var width = _p139._0;
      var height = _p139._1;
      var ifEnoughSpace = F2(function (len,xs) {
         return _U.cmp(len,
         minLengthForMiddleZones) < 0 ? _U.list([]) : xs;
      });
      var mkPoint = F3(function (zone,cx,cy) {
         return A6(zonePoint,
         model,
         id,
         shape,
         zone,
         transform,
         _U.list([A2(attrNum,"cx",cx),A2(attrNum,"cy",cy)]));
      });
      return A2($Basics._op["++"],
      A3(mkPoint,"TopLeft",_p141,_p143),
      A2($Basics._op["++"],
      A3(mkPoint,"TopRight",_p142,_p143),
      A2($Basics._op["++"],
      A3(mkPoint,"BotLeft",_p141,_p140),
      A2($Basics._op["++"],
      A3(mkPoint,"BotRight",_p142,_p140),
      A2($Basics._op["++"],
      A2(ifEnoughSpace,
      height,
      A3(mkPoint,"LeftEdge",_p141,_p143 + height / 2)),
      A2($Basics._op["++"],
      A2(ifEnoughSpace,
      height,
      A3(mkPoint,"RightEdge",_p142,_p143 + height / 2)),
      A2($Basics._op["++"],
      A2(ifEnoughSpace,
      width,
      A3(mkPoint,"TopEdge",_p141 + width / 2,_p143)),
      A2(ifEnoughSpace,
      width,
      A3(mkPoint,"BotEdge",_p141 + width / 2,_p140)))))))));
   });
   var zonePoints = F5(function (model,id,shape,transform,pts) {
      return $List.concat(A3($Basics.flip,
      $Utils.mapi,
      pts,
      function (_p144) {
         var _p145 = _p144;
         return A6(zonePoint,
         model,
         id,
         shape,
         A2($Basics._op["++"],"Point",$Basics.toString(_p145._0)),
         transform,
         _U.list([A2(attrNumTr,"cx",_p145._1._0)
                 ,A2(attrNumTr,"cy",_p145._1._1)]));
      }));
   });
   var zonePoints2 = F5(function (model,id,shape,transform,pts) {
      return $List.concat(A3($Basics.flip,
      $Utils.mapi,
      pts,
      function (_p146) {
         var _p147 = _p146;
         return A6(zonePoint,
         model,
         id,
         shape,
         A2($Basics._op["++"],"Point",$Basics.toString(_p147._0)),
         transform,
         _U.list([A2(attrNum,"cx",_p147._1._0)
                 ,A2(attrNum,"cy",_p147._1._1)]));
      }));
   });
   var svgRect = A2($Basics.flip,$Svg.rect,_U.list([]));
   var boundingBoxZones = F4(function (model,
   id,
   _p148,
   shapeWidgets) {
      var _p149 = _p148;
      var _p151 = _p149._1;
      var _p150 = _p149._0;
      var pad = 10;
      var maybeBackgroundBox = A2(objectIsCurrentlyBeingManipulated,
      model,
      id) ? _U.list([]) : $Basics.not(A2($Set.member,
      id,
      model.hoveredShapes)) ? _U.list([]) : $Utils.singleton(svgRect(_U.list([A2($LangSvg.attr,
                                                                             "x",
                                                                             $Basics.toString(_p150 - pad))
                                                                             ,A2($LangSvg.attr,"y",$Basics.toString(_p151 - pad))
                                                                             ,A2($LangSvg.attr,
                                                                             "width",
                                                                             $Basics.toString(_p149._2 - _p150 + 2 * pad))
                                                                             ,A2($LangSvg.attr,
                                                                             "height",
                                                                             $Basics.toString(_p149._3 - _p151 + 2 * pad))
                                                                             ,A2($LangSvg.attr,"fill","rgba(100,100,100,0.0)")
                                                                             ,A2($LangSvg.attr,"stroke","lightgray")
                                                                             ,A2($LangSvg.attr,"stroke-width","1")])));
      return A2($Svg.g,
      _U.list([onMouseLeave(removeHoveredShape(id))]),
      A2($Basics._op["++"],maybeBackgroundBox,shapeWidgets));
   });
   var svgLine = A2($Basics.flip,$Svg.line,_U.list([]));
   var zoneSelectCrossDot = F4(function (model,_p152,x,y) {
      var _p153 = _p152;
      var _p158 = _p153._2;
      var _p157 = _p153._1;
      var _p156 = _p153._0;
      var xFeatureName = A2($ShapeWidgets.unparseFeatureNum,
      $Maybe.Just(_p157),
      $ShapeWidgets.X(_p158));
      var yFeatureName = A2($ShapeWidgets.unparseFeatureNum,
      $Maybe.Just(_p157),
      $ShapeWidgets.Y(_p158));
      var thisCrosshair = {ctor: "_Tuple3"
                          ,_0: _p156
                          ,_1: xFeatureName
                          ,_2: yFeatureName};
      var len = 20;
      var color = function (typeAndNodeIdAndFeatures) {
         return A2($List.all,
         A2($Basics.flip,$Set.member,model.selectedFeatures),
         typeAndNodeIdAndFeatures) ? colorPointSelected : colorPointNotSelected;
      };
      var yFeature = {ctor: "_Tuple3"
                     ,_0: $ShapeWidgets.selectedTypeShapeFeature
                     ,_1: _p156
                     ,_2: yFeatureName};
      var xFeature = {ctor: "_Tuple3"
                     ,_0: $ShapeWidgets.selectedTypeShapeFeature
                     ,_1: _p156
                     ,_2: xFeatureName};
      var _p154 = {ctor: "_Tuple2"
                  ,_0: color(_U.list([xFeature]))
                  ,_1: color(_U.list([yFeature]))};
      var xColor = _p154._0;
      var yColor = _p154._1;
      var _p155 = function () {
         var r = A2($Set.member,
         thisCrosshair,
         model.hoveredCrosshairs) ? $Basics.toString(len) : "0";
         var backDisc = svgCircle(_U.list([A2($LangSvg.attr,"r",r)
                                          ,A2($LangSvg.attr,"cx",$Basics.toString(x))
                                          ,A2($LangSvg.attr,"cy",$Basics.toString(y))
                                          ,A2($LangSvg.attr,"fill","rgba(255,255,255,1.0)")]));
         var frontDisc = svgCircle(_U.list([A2($LangSvg.attr,"r",r)
                                           ,A2($LangSvg.attr,"cx",$Basics.toString(x))
                                           ,A2($LangSvg.attr,"cy",$Basics.toString(y))
                                           ,A2($LangSvg.attr,"fill","none")
                                           ,A2($LangSvg.attr,"stroke","black")
                                           ,A2($LangSvg.attr,
                                           "stroke-width",
                                           pointZoneStyles.strokeWidth)]));
         return {ctor: "_Tuple2",_0: backDisc,_1: frontDisc};
      }();
      var backDisc = _p155._0;
      var frontDisc = _p155._1;
      var xyDot = svgCircle(_U.list([A2($LangSvg.attr,
                                    "cx",
                                    $Basics.toString(x))
                                    ,A2($LangSvg.attr,"cy",$Basics.toString(y))
                                    ,A2($LangSvg.attr,
                                    "fill",
                                    A2($Set.member,
                                    _p156,
                                    model.selectedShapes) ? A2(pointZoneStylesFillSelected,
                                    model,
                                    _p156) : pointZoneStyles.fill.shown)
                                    ,A2($LangSvg.attr,"stroke",pointZoneStyles.stroke)
                                    ,A2($LangSvg.attr,"stroke-width",pointZoneStyles.strokeWidth)
                                    ,A2($LangSvg.attr,
                                    "r",
                                    $Basics.not(A2(objectIsCurrentlyBeingManipulated,
                                    model,
                                    _p156)) && (A2($Set.member,
                                    _p156,
                                    model.selectedShapes) || (A2($Set.member,
                                    _p156,
                                    model.hoveredShapes) || A2($Set.member,
                                    thisCrosshair,
                                    model.hoveredCrosshairs))) ? pointZoneStyles.radius : "0")
                                    ,onMouseDown($InterfaceModel.UpdateModel(function (model) {
                                       return A2($Set.member,
                                       thisCrosshair,
                                       model.hoveredCrosshairs) ? A2(toggleSelectedLambda,
                                       _U.list([xFeature,yFeature]),
                                       model) : _U.update(model,
                                       {hoveredCrosshairs: A2($Set.insert,
                                       thisCrosshair,
                                       model.hoveredCrosshairs)});
                                    }))]));
      var yLine = svgLine(_U.list([A2($LangSvg.attr,"stroke",yColor)
                                  ,A2($LangSvg.attr,
                                  "stroke-width",
                                  A2($Set.member,
                                  thisCrosshair,
                                  model.hoveredCrosshairs) || A2($Set.member,
                                  yFeature,
                                  model.selectedFeatures) ? hairStrokeWidth : "0")
                                  ,A2($LangSvg.attr,"x1",$Basics.toString(x - len))
                                  ,A2($LangSvg.attr,"y1",$Basics.toString(y))
                                  ,A2($LangSvg.attr,"x2",$Basics.toString(x + len))
                                  ,A2($LangSvg.attr,"y2",$Basics.toString(y))
                                  ,onMouseDown(toggleSelected(_U.list([yFeature])))]));
      var xLine = svgLine(_U.list([A2($LangSvg.attr,"stroke",xColor)
                                  ,A2($LangSvg.attr,
                                  "stroke-width",
                                  A2($Set.member,
                                  thisCrosshair,
                                  model.hoveredCrosshairs) || A2($Set.member,
                                  xFeature,
                                  model.selectedFeatures) ? hairStrokeWidth : "0")
                                  ,A2($LangSvg.attr,"y1",$Basics.toString(y - len))
                                  ,A2($LangSvg.attr,"x1",$Basics.toString(x))
                                  ,A2($LangSvg.attr,"y2",$Basics.toString(y + len))
                                  ,A2($LangSvg.attr,"x2",$Basics.toString(x))
                                  ,onMouseDown(toggleSelected(_U.list([xFeature])))]));
      return $Utils.singleton(A2($Svg.g,
      _U.list([onMouseLeave(removeHoveredCrosshair(thisCrosshair))]),
      _U.list([backDisc,xLine,yLine,frontDisc,xyDot])));
   });
   var maybeZoneSelectCrossDot = F5(function (sideLength,
   model,
   thisCrosshair,
   x,
   y) {
      return _U.cmp(sideLength,
      minLengthForMiddleZones) < 0 ? _U.list([]) : A4(zoneSelectCrossDot,
      model,
      thisCrosshair,
      x,
      y);
   });
   var makeZonesLine = F3(function (model,id,l) {
      var transform = maybeTransformAttr(l);
      var _p159 = A2($ShapeWidgets.evaluateLineFeatures,id,l);
      var x1 = _p159._0;
      var y1 = _p159._1;
      var x2 = _p159._2;
      var y2 = _p159._3;
      var cx = _p159._4;
      var cy = _p159._5;
      var _p160 = {ctor: "_Tuple2"
                  ,_0: {ctor: "_Tuple2",_0: x1,_1: y1}
                  ,_1: {ctor: "_Tuple2",_0: x2,_1: y2}};
      var pt1 = _p160._0;
      var pt2 = _p160._1;
      var bounds = function () {
         var _p161 = A2($Lang.minMax,x1,x2);
         var xMin = _p161._0;
         var xMax = _p161._1;
         var _p162 = A2($Lang.minMax,y1,y2);
         var yMin = _p162._0;
         var yMax = _p162._1;
         return {ctor: "_Tuple4",_0: xMin,_1: yMin,_2: xMax,_3: yMax};
      }();
      var zLine = function () {
         var enter = _U.list([onMouseEnter(addHoveredShape(id))]);
         return A7(zoneLine2,
         model,
         id,
         "line",
         "Edge",
         pt1,
         pt2,
         A2($Basics._op["++"],transform,enter));
      }();
      var zonesSelect = $List.concat(_U.list([A5(maybeZoneSelectCrossDot,
                                             A2(distance,pt1,pt2),
                                             model,
                                             {ctor: "_Tuple3",_0: id,_1: "line",_2: $ShapeWidgets.Center},
                                             cx,
                                             cy)
                                             ,A4(zoneSelectCrossDot,
                                             model,
                                             {ctor: "_Tuple3",_0: id,_1: "line",_2: $ShapeWidgets.Point(1)},
                                             x1,
                                             y1)
                                             ,A4(zoneSelectCrossDot,
                                             model,
                                             {ctor: "_Tuple3",_0: id,_1: "line",_2: $ShapeWidgets.Point(2)},
                                             x2,
                                             y2)]));
      var primaryWidgets = A4(boundingBoxZones,
      model,
      id,
      bounds,
      A2($Basics._op["++"],
      _U.list([zLine]),
      A2($Basics._op["++"],
      zonesSelect,
      A5(zonePoints2,model,id,"line",transform,_U.list([pt1,pt2])))));
      var extraWidgets = function () {
         var c = A2(halfwayBetween,pt1,pt2);
         var r = A2(distance,pt1,pt2) / 2 - rotZoneDelta;
         return A2($Basics._op["++"],
         A6(zoneRotate,
         model,
         id,
         "line",
         {ctor: "_Tuple2",_0: cx,_1: cy},
         r,
         maybeTransformCmds(l)),
         A6(zonesStroke,model,id,"line",x2,y2,l));
      }();
      return A2($List._op["::"],primaryWidgets,extraWidgets);
   });
   var makeZonesPoly = F4(function (model,shape,id,l) {
      var _p163 = A2($Utils.assert,
      "makeZonesPoly",
      _U.eq(shape,"polygon") || _U.eq(shape,"polyline"));
      var transform = maybeTransformAttr(l);
      var pts = $LangSvg.getPolyPoints(l);
      var zPts = A5(zonePoints,model,id,shape,transform,pts);
      var zLines = function () {
         var pairs = A2($Utils.adjacentPairs,
         _U.eq(shape,"polygon"),
         pts);
         var f = function (_p164) {
            var _p165 = _p164;
            return A7(zoneLine,
            model,
            id,
            shape,
            A2($Basics._op["++"],"Edge",$Basics.toString(_p165._0)),
            _p165._1._0,
            _p165._1._1,
            transform);
         };
         return A2($Utils.mapi,f,pairs);
      }();
      var zInterior = A7(draggableZone,
      $Svg.polygon,
      false,
      model,
      id,
      shape,
      "Interior",
      A2($Basics._op["++"],
      _U.list([A2($LangSvg.compileAttr,"points",$LangSvg.aPoints(pts))
              ,onMouseEnter(addHoveredShape(id))]),
      transform));
      var zRot = A5(zoneRotatePolyOrPath,model,id,"polygon",pts,l);
      var zFillAndStroke = function () {
         var _p166 = pts;
         if (_p166.ctor === "::" && _p166._0.ctor === "_Tuple2" && _p166._0._0.ctor === "_Tuple2" && _p166._0._1.ctor === "_Tuple2")
         {
               return A6(zonesFillAndStroke,
               model,
               id,
               shape,
               _p166._0._0._0,
               _p166._0._1._0,
               l);
            } else {
               return _U.crashCase("InterfaceView2",
               {start: {line: 1368,column: 5},end: {line: 1372,column: 36}},
               _p166)("makeZonesPoly");
            }
      }();
      var zSelect = function () {
         var midptCrossDot = function (_p168) {
            var _p169 = _p168;
            var _p173 = _p169._1._0;
            var _p172 = _p169._0._0;
            var _p170 = {ctor: "_Tuple2"
                        ,_0: A2($Basics._op["++"],"x",$Basics.toString(_p172))
                        ,_1: A2($Basics._op["++"],"y",$Basics.toString(_p172))};
            var xAttr1 = _p170._0;
            var yAttr1 = _p170._1;
            var _p171 = {ctor: "_Tuple2"
                        ,_0: A2($Basics._op["++"],"x",$Basics.toString(_p173))
                        ,_1: A2($Basics._op["++"],"y",$Basics.toString(_p173))};
            var xAttr2 = _p171._0;
            var yAttr2 = _p171._1;
            return A4(zoneSelectCrossDot,
            model,
            {ctor: "_Tuple3"
            ,_0: id
            ,_1: shape
            ,_2: $ShapeWidgets.Midpoint(_p172)},
            _p169._0._1._0._0 / 2 + _p169._1._1._0._0 / 2,
            _p169._0._1._1._0 / 2 + _p169._1._1._1._0 / 2);
         };
         var ptCrossDot = function (_p174) {
            var _p175 = _p174;
            var _p177 = _p175._0;
            var _p176 = {ctor: "_Tuple2"
                        ,_0: A2($Basics._op["++"],"x",$Basics.toString(_p177))
                        ,_1: A2($Basics._op["++"],"y",$Basics.toString(_p177))};
            var xAttr = _p176._0;
            var yAttr = _p176._1;
            return A4(zoneSelectCrossDot,
            model,
            {ctor: "_Tuple3"
            ,_0: id
            ,_1: shape
            ,_2: $ShapeWidgets.Point(_p177)},
            _p175._1._0._0,
            _p175._1._1._0);
         };
         var midptCrossDots = function () {
            var ptsI = A2($Utils.mapi,$Basics.identity,pts);
            var ptsIPairs = $Utils.selfZipCircConsecPairs(ptsI);
            return A2($List.concatMap,midptCrossDot,ptsIPairs);
         }();
         var crossDots = $List.concat(A2($Utils.mapi,ptCrossDot,pts));
         return A2($Basics._op["++"],midptCrossDots,crossDots);
      }();
      var primaryWidgets = function () {
         var _p178 = $Draw.boundingBoxOfPoints_(A2($List.map,
         function (_p179) {
            var _p180 = _p179;
            return {ctor: "_Tuple2"
                   ,_0: $Basics.fst(_p180._0)
                   ,_1: $Basics.fst(_p180._1)};
         },
         pts));
         var x1 = _p178._0;
         var x2 = _p178._1;
         var y1 = _p178._2;
         var y2 = _p178._3;
         return A4(boundingBoxZones,
         model,
         id,
         {ctor: "_Tuple4",_0: x1,_1: y1,_2: x2,_3: y2},
         A2($Basics._op["++"],
         _U.list([zInterior]),
         A2($Basics._op["++"],
         zLines,
         A2($Basics._op["++"],zSelect,zPts))));
      }();
      return A2($List._op["::"],
      primaryWidgets,
      A2($Basics._op["++"],zRot,zFillAndStroke));
   });
   var makeZonesPath = F4(function (model,shape,id,nodeAttrs) {
      var _p181 = A2($Utils.assert,
      "makeZonesPoly",
      _U.eq(shape,"path"));
      var transform = maybeTransformAttr(nodeAttrs);
      var cmds = $Basics.fst($LangSvg.toPath(A2($Utils.find_,
      nodeAttrs,
      "d")));
      _op["+++"] = F2(function (_p182,acc) {
         var _p183 = _p182;
         var _p185 = _p183._0;
         var _p184 = _p185;
         if (_p184.ctor === "Nothing") {
               return acc;
            } else {
               return A2($List._op["::"],
               {ctor: "_Tuple2",_0: _p185,_1: _p183._1},
               acc);
            }
      });
      var listOfMaybeIndexWithPt = A3($List.foldr,
      F2(function (c,acc) {
         var _p186 = c;
         switch (_p186.ctor)
         {case "CmdZ": return acc;
            case "CmdMLT": return A2(_op["+++"],_p186._1,acc);
            case "CmdHV": return acc;
            case "CmdC": return A2(_op["+++"],
              _p186._1,
              A2(_op["+++"],_p186._2,A2(_op["+++"],_p186._3,acc)));
            case "CmdSQ": return A2(_op["+++"],
              _p186._1,
              A2(_op["+++"],_p186._2,acc));
            default: return A2(_op["+++"],_p186._6,acc);}
      }),
      _U.list([]),
      cmds);
      var pts = A2($List.map,$Basics.snd,listOfMaybeIndexWithPt);
      var dots = A5(zonePoints,model,id,shape,transform,pts);
      var zRot = A5(zoneRotatePolyOrPath,
      model,
      id,
      "path",
      pts,
      nodeAttrs);
      var zFillAndStroke = function () {
         var _p187 = pts;
         if (_p187.ctor === "::" && _p187._0.ctor === "_Tuple2" && _p187._0._0.ctor === "_Tuple2" && _p187._0._1.ctor === "_Tuple2")
         {
               return A6(zonesFillAndStroke,
               model,
               id,
               shape,
               _p187._0._0._0,
               _p187._0._1._0,
               nodeAttrs);
            } else {
               return _U.crashCase("InterfaceView2",
               {start: {line: 1420,column: 5},end: {line: 1424,column: 36}},
               _p187)("makeZonesPath");
            }
      }();
      var zSelect = function () {
         var ptCrossDot = function (_p189) {
            var _p190 = _p189;
            var i = $Utils.fromJust(_p190._0);
            var _p191 = {ctor: "_Tuple2"
                        ,_0: A2($Basics._op["++"],"x",$Basics.toString(i))
                        ,_1: A2($Basics._op["++"],"y",$Basics.toString(i))};
            var xAttr = _p191._0;
            var yAttr = _p191._1;
            return A4(zoneSelectCrossDot,
            model,
            {ctor: "_Tuple3",_0: id,_1: shape,_2: $ShapeWidgets.Point(i)},
            _p190._1._0._0,
            _p190._1._1._0);
         };
         var crossDots = A2($List.concatMap,
         ptCrossDot,
         listOfMaybeIndexWithPt);
         return crossDots;
      }();
      var zInterior = A7(draggableZone,
      $Svg.path,
      false,
      model,
      id,
      shape,
      "Interior",
      A2($Basics._op["++"],
      _U.list([A2($LangSvg.compileAttr,
              "d",
              A2($Utils.find_,nodeAttrs,"d"))
              ,onMouseEnter(addHoveredShape(id))]),
      transform));
      var primaryWidgets = function () {
         var _p192 = $Draw.boundingBoxOfPoints_(A2($List.map,
         function (_p193) {
            var _p194 = _p193;
            return {ctor: "_Tuple2"
                   ,_0: $Basics.fst(_p194._0)
                   ,_1: $Basics.fst(_p194._1)};
         },
         pts));
         var x1 = _p192._0;
         var x2 = _p192._1;
         var y1 = _p192._2;
         var y2 = _p192._3;
         return A4(boundingBoxZones,
         model,
         id,
         {ctor: "_Tuple4",_0: x1,_1: y1,_2: x2,_3: y2},
         A2($Basics._op["++"],
         _U.list([zInterior]),
         A2($Basics._op["++"],zSelect,dots)));
      }();
      return A2($List._op["::"],
      primaryWidgets,
      A2($Basics._op["++"],zRot,zFillAndStroke));
   });
   var zoneSelectLine_ = F4(function (model,
   typeAndNodeIdAndFeature,
   _p196,
   _p195) {
      var _p197 = _p196;
      var _p198 = _p195;
      var color = A2($Set.member,
      typeAndNodeIdAndFeature,
      model.selectedFeatures) ? colorLineSelected : colorLineNotSelected;
      var line = svgLine(_U.list([A2($LangSvg.attr,"stroke",color)
                                 ,A2($LangSvg.attr,"stroke-width",hairStrokeWidth)
                                 ,A2($LangSvg.attr,"x1",$Basics.toString(_p197._0))
                                 ,A2($LangSvg.attr,"y1",$Basics.toString(_p197._1))
                                 ,A2($LangSvg.attr,"x2",$Basics.toString(_p198._0))
                                 ,A2($LangSvg.attr,"y2",$Basics.toString(_p198._1))
                                 ,onMouseDown(toggleSelected(_U.list([typeAndNodeIdAndFeature])))]));
      return _U.list([line]);
   });
   var zoneSelectLine = F6(function (model,
   nodeId,
   kind,
   featureNum,
   pt1,
   pt2) {
      var typeAndNodeIdAndFeature = {ctor: "_Tuple3"
                                    ,_0: $ShapeWidgets.selectedTypeShapeFeature
                                    ,_1: nodeId
                                    ,_2: A2($ShapeWidgets.unparseFeatureNum,
                                    $Maybe.Just(kind),
                                    featureNum)};
      var _p199 = model.mouseMode;
      if (_p199.ctor === "MouseDragZone" && _p199._0.ctor === "Left")
      {
            return _U.list([]);
         } else {
            return A2($Set.member,
            nodeId,
            model.hoveredShapes) || A2($Set.member,
            typeAndNodeIdAndFeature,
            model.selectedFeatures) ? A4(zoneSelectLine_,
            model,
            typeAndNodeIdAndFeature,
            pt1,
            pt2) : _U.list([]);
         }
   });
   var maybeZoneSelectLine = F7(function (sideLength,
   model,
   nodeId,
   kind,
   featureNum,
   pt1,
   pt2) {
      return _U.cmp(sideLength,
      minLengthForMiddleZones) < 0 ? _U.list([]) : A6(zoneSelectLine,
      model,
      nodeId,
      kind,
      featureNum,
      pt1,
      pt2);
   });
   var boxySelectZones = F4(function (model,id,kind,boxyNums) {
      var drawPoint = F4(function (maybeThreshold,feature,x,y) {
         var _p200 = maybeThreshold;
         if (_p200.ctor === "Just") {
               return A5(maybeZoneSelectCrossDot,
               _p200._0,
               model,
               {ctor: "_Tuple3",_0: id,_1: kind,_2: feature},
               x,
               y);
            } else {
               return A4(zoneSelectCrossDot,
               model,
               {ctor: "_Tuple3",_0: id,_1: kind,_2: feature},
               x,
               y);
            }
      });
      var drawLine = F4(function (threshold,feature,pt1,pt2) {
         return A7(maybeZoneSelectLine,
         threshold,
         model,
         id,
         kind,
         feature,
         pt1,
         pt2);
      });
      var _p201 = boxyNums;
      var left = _p201.left;
      var top = _p201.top;
      var right = _p201.right;
      var bot = _p201.bot;
      var cx = _p201.cx;
      var cy = _p201.cy;
      var width = _p201.width;
      var height = _p201.height;
      var distanceZone = function (f) {
         var _p202 = f;
         if (_p202.ctor === "DistanceFeature") {
               switch (_p202._0.ctor)
               {case "Width": return A4(drawLine,
                    height,
                    $ShapeWidgets.D($ShapeWidgets.Width),
                    {ctor: "_Tuple2",_0: left,_1: cy},
                    {ctor: "_Tuple2",_0: right,_1: cy});
                  case "Height": return A4(drawLine,
                    width,
                    $ShapeWidgets.D($ShapeWidgets.Height),
                    {ctor: "_Tuple2",_0: cx,_1: top},
                    {ctor: "_Tuple2",_0: cx,_1: bot});
                  case "Radius": return A4(drawLine,
                    width,
                    $ShapeWidgets.D($ShapeWidgets.Radius),
                    {ctor: "_Tuple2",_0: cx,_1: cy},
                    {ctor: "_Tuple2",_0: right,_1: cy});
                  case "RadiusX": return A4(drawLine,
                    height,
                    $ShapeWidgets.D($ShapeWidgets.RadiusX),
                    {ctor: "_Tuple2",_0: cx,_1: cy},
                    {ctor: "_Tuple2",_0: right,_1: cy});
                  default: return A4(drawLine,
                    width,
                    $ShapeWidgets.D($ShapeWidgets.RadiusY),
                    {ctor: "_Tuple2",_0: cx,_1: top},
                    {ctor: "_Tuple2",_0: cx,_1: cy});}
            } else {
               return _U.list([]);
            }
      };
      var pointZone = function (f) {
         var _p203 = f;
         _v90_9: do {
            if (_p203.ctor === "PointFeature") {
                  switch (_p203._0.ctor)
                  {case "TopLeft": return A4(drawPoint,
                       $Maybe.Nothing,
                       $ShapeWidgets.TopLeft,
                       left,
                       top);
                     case "TopRight": return A4(drawPoint,
                       $Maybe.Nothing,
                       $ShapeWidgets.TopRight,
                       right,
                       top);
                     case "BotLeft": return A4(drawPoint,
                       $Maybe.Nothing,
                       $ShapeWidgets.BotLeft,
                       left,
                       bot);
                     case "BotRight": return A4(drawPoint,
                       $Maybe.Nothing,
                       $ShapeWidgets.BotRight,
                       right,
                       bot);
                     case "TopEdge": return A4(drawPoint,
                       $Maybe.Just(width),
                       $ShapeWidgets.TopEdge,
                       cx,
                       top);
                     case "BotEdge": return A4(drawPoint,
                       $Maybe.Just(width),
                       $ShapeWidgets.BotEdge,
                       cx,
                       bot);
                     case "LeftEdge": return A4(drawPoint,
                       $Maybe.Just(height),
                       $ShapeWidgets.LeftEdge,
                       left,
                       cy);
                     case "RightEdge": return A4(drawPoint,
                       $Maybe.Just(height),
                       $ShapeWidgets.RightEdge,
                       right,
                       cy);
                     case "Center": return A4(drawPoint,
                       $Maybe.Just(A2($Basics.min,width,height)),
                       $ShapeWidgets.Center,
                       cx,
                       cy);
                     default: break _v90_9;}
               } else {
                  break _v90_9;
               }
         } while (false);
         return _U.list([]);
      };
      var features = A3($Utils.find,
      "boxySelectZones",
      $ShapeWidgets.simpleKindFeatures,
      kind);
      return A2($Basics._op["++"],
      A2($List.concatMap,distanceZone,features),
      A2($List.concatMap,pointZone,features));
   });
   var makeZonesRectOrBox = F4(function (model,id,shape,l) {
      var boxyNums = A3($ShapeWidgets.evaluateBoxyNums,id,shape,l);
      var _p204 = boxyNums;
      var left = _p204.left;
      var top = _p204.top;
      var right = _p204.right;
      var bot = _p204.bot;
      var cx = _p204.cx;
      var cy = _p204.cy;
      var width = _p204.width;
      var height = _p204.height;
      var bounds = {ctor: "_Tuple4"
                   ,_0: left
                   ,_1: top
                   ,_2: right
                   ,_3: bot};
      var transform = maybeTransformAttr(l);
      var zoneInterior = A7(draggableZone,
      $Svg.rect,
      false,
      model,
      id,
      shape,
      "Interior",
      A2($Basics._op["++"],
      _U.list([A2(attrNum,"x",left)
              ,A2(attrNum,"y",top)
              ,A2(attrNum,"width",width)
              ,A2(attrNum,"height",height)
              ,onMouseEnter(addHoveredShape(id))]),
      transform));
      var zonesSelect = A4(boxySelectZones,model,id,shape,boxyNums);
      var primaryWidgets = A4(boundingBoxZones,
      model,
      id,
      bounds,
      A2($Basics._op["++"],
      _U.list([zoneInterior]),
      A2($Basics._op["++"],
      zonesSelect,
      A5(eightCardinalZones,model,id,shape,transform,bounds))));
      var extraWidgets = function () {
         var r = rotZoneDelta + height / 2;
         return A2($Basics._op["++"],
         A6(zoneRotate,
         model,
         id,
         shape,
         {ctor: "_Tuple2",_0: cx,_1: cy},
         r,
         maybeTransformCmds(l)),
         A6(zonesFillAndStroke,model,id,shape,left,top,l));
      }();
      return A2($List._op["::"],primaryWidgets,extraWidgets);
   });
   var makeZonesCircle = F3(function (model,id,l) {
      var boxyNums = A3($ShapeWidgets.evaluateBoxyNums,
      id,
      "circle",
      l);
      var _p205 = boxyNums;
      var left = _p205.left;
      var top = _p205.top;
      var right = _p205.right;
      var bot = _p205.bot;
      var cx = _p205.cx;
      var cy = _p205.cy;
      var r = _p205.r;
      var bounds = {ctor: "_Tuple4"
                   ,_0: left
                   ,_1: top
                   ,_2: right
                   ,_3: bot};
      var transform = maybeTransformAttr(l);
      var zoneInterior = A7(draggableZone,
      $Svg.circle,
      false,
      model,
      id,
      "circle",
      "Interior",
      A2($Basics._op["++"],
      _U.list([A2(attrNum,"cx",cx)
              ,A2(attrNum,"cy",cy)
              ,A2(attrNum,"r",r)
              ,onMouseEnter(addHoveredShape(id))]),
      transform));
      var zonesSelect = A4(boxySelectZones,
      model,
      id,
      "circle",
      boxyNums);
      var primaryWidgets = A4(boundingBoxZones,
      model,
      id,
      bounds,
      A2($Basics._op["++"],
      _U.list([zoneInterior]),
      A2($Basics._op["++"],
      zonesSelect,
      A5(eightCardinalZones,model,id,"circle",transform,bounds))));
      var extraWidgets = A2($Basics._op["++"],
      A6(zoneRotate,
      model,
      id,
      "circle",
      {ctor: "_Tuple2",_0: cx,_1: cy},
      r + rotZoneDelta,
      maybeTransformCmds(l)),
      A6(zonesFillAndStroke,model,id,"circle",cx - r,cy - r,l));
      return A2($List._op["::"],primaryWidgets,extraWidgets);
   });
   var makeZonesEllipseOrOval = F4(function (model,id,shape,l) {
      var boxyNums = A3($ShapeWidgets.evaluateBoxyNums,id,shape,l);
      var _p206 = boxyNums;
      var left = _p206.left;
      var top = _p206.top;
      var right = _p206.right;
      var bot = _p206.bot;
      var width = _p206.width;
      var height = _p206.height;
      var cx = _p206.cx;
      var cy = _p206.cy;
      var rx = _p206.rx;
      var ry = _p206.ry;
      var bounds = {ctor: "_Tuple4"
                   ,_0: left
                   ,_1: top
                   ,_2: right
                   ,_3: bot};
      var transform = maybeTransformAttr(l);
      var zoneInterior = A7(draggableZone,
      $Svg.ellipse,
      false,
      model,
      id,
      shape,
      "Interior",
      A2($Basics._op["++"],
      _U.list([A2(attrNum,"cx",cx)
              ,A2(attrNum,"cy",cy)
              ,A2(attrNum,"rx",rx)
              ,A2(attrNum,"ry",ry)
              ,onMouseEnter(addHoveredShape(id))]),
      transform));
      var zonesSelect = A4(boxySelectZones,model,id,shape,boxyNums);
      var primaryWidgets = A4(boundingBoxZones,
      model,
      id,
      bounds,
      A2($Basics._op["++"],
      _U.list([zoneInterior]),
      A2($Basics._op["++"],
      zonesSelect,
      A5(eightCardinalZones,model,id,shape,transform,bounds))));
      var extraWidgets = A2($Basics._op["++"],
      A6(zoneRotate,
      model,
      id,
      shape,
      {ctor: "_Tuple2",_0: cx,_1: cy},
      ry + rotZoneDelta,
      maybeTransformCmds(l)),
      A6(zonesFillAndStroke,model,id,shape,cx - rx,cy - ry,l));
      return A2($List._op["::"],primaryWidgets,extraWidgets);
   });
   var makeZones = F4(function (model,shape,id,l) {
      var _p207 = shape;
      switch (_p207)
      {case "line": return A3(makeZonesLine,model,id,l);
         case "rect": return A4(makeZonesRectOrBox,model,id,shape,l);
         case "BOX": return A4(makeZonesRectOrBox,model,id,shape,l);
         case "circle": return A3(makeZonesCircle,model,id,l);
         case "ellipse": return A4(makeZonesEllipseOrOval,
           model,
           id,
           shape,
           l);
         case "OVAL": return A4(makeZonesEllipseOrOval,model,id,shape,l);
         case "polygon": return A4(makeZonesPoly,model,shape,id,l);
         case "polyline": return A4(makeZonesPoly,model,shape,id,l);
         case "path": return A4(makeZonesPath,model,shape,id,l);
         default: return _U.list([]);}
   });
   var buildSvg_ = F3(function (stuff,d,i) {
      var _p208 = stuff;
      var model = _p208._0;
      var addZones = _p208._1;
      var _p209 = A3($Utils.justGet_,
      A2($Basics._op["++"],"buildSvg_ ",$Basics.toString(i)),
      i,
      d);
      if (_p209.ctor === "TextNode") {
            return $VirtualDom.text(_p209._0);
         } else {
            var _p216 = _p209._0;
            var _p215 = _p209._1;
            var _p210 = {ctor: "_Tuple2"
                        ,_0: model.showGhosts
                        ,_1: A2($Utils.maybeRemoveFirst,"HIDDEN",_p215)};
            if (_p210.ctor === "_Tuple2" && _p210._0 === false && _p210._1.ctor === "Just")
            {
                  return A2($Svg.svg,_U.list([]),_U.list([]));
               } else {
                  var _p211 = function () {
                     var _p212 = {ctor: "_Tuple2"
                                 ,_0: addZones
                                 ,_1: A2($Utils.maybeRemoveFirst,"ZONES",_p215)};
                     if (_p212._0 === false) {
                           if (_p212._1.ctor === "Nothing") {
                                 return {ctor: "_Tuple2",_0: _U.list([]),_1: _p215};
                              } else {
                                 return {ctor: "_Tuple2",_0: _U.list([]),_1: _p212._1._0._1};
                              }
                        } else {
                           if (_p212._1.ctor === "Nothing") {
                                 return {ctor: "_Tuple2"
                                        ,_0: A4(makeZones,model,_p216,i,_p215)
                                        ,_1: _p215};
                              } else {
                                 var _p213 = _p212._1._0._0.av_;
                                 return {ctor: "_Tuple2"
                                        ,_0: A4(makeZones,model,_p216,i,_p215)
                                        ,_1: _p212._1._0._1};
                              }
                        }
                  }();
                  var zones = _p211._0;
                  var attrs$ = _p211._1;
                  var children = A2($List.map,A2(buildSvg_,stuff,d),_p209._2);
                  var mainshape = function () {
                     var _p214 = A2($LangSvg.desugarShapeAttrs,_p216,attrs$);
                     var rawKind = _p214._0;
                     var rawAttrs = _p214._1;
                     return A3($Svg.node,
                     rawKind,
                     $LangSvg.compileAttrs(rawAttrs),
                     children);
                  }();
                  return _U.eq(zones,_U.list([])) ? mainshape : A2($Svg.svg,
                  _U.list([]),
                  A2($List._op["::"],mainshape,zones));
               }
         }
   });
   var buildSvg = F2(function (options,_p217) {
      var _p218 = _p217;
      return A3(buildSvg_,options,_p218._1,_p218._0);
   });
   var canvas_ = F3(function (w,h,model) {
      var addZones = function () {
         var _p219 = model.mode;
         switch (_p219.ctor)
         {case "AdHoc": return true;
            case "Live": return _U.eq(model.tool,$InterfaceModel.Cursor);
            default: return false;}
      }();
      var mainCanvas_ = A2(buildSvg,
      {ctor: "_Tuple2",_0: model,_1: addZones},
      model.slate);
      var mainCanvas = function () {
         var _p220 = $Draw.drawNewShape(model);
         if (_p220.ctor === "[]") {
               return A2(mkSvg,addZones,mainCanvas_);
            } else {
               return A2(mkSvg,
               addZones,
               A2($Svg.g,_U.list([]),A2($List._op["::"],mainCanvas_,_p220)));
            }
      }();
      var makeWidgetsAndZones = function (_p221) {
         var _p222 = _p221;
         var widgets = A3(buildSvgWidgets,w,h,model);
         var svg = A2(mkSvg,
         addZones,
         A2($Svg.g,_U.list([]),_U.list([mainCanvas,widgets])));
         return A3($Html.toElement,w,h,svg);
      };
      var _p223 = {ctor: "_Tuple2"
                  ,_0: model.mode
                  ,_1: model.showGhosts};
      _v100_2: do {
         if (_p223.ctor === "_Tuple2") {
               switch (_p223._0.ctor)
               {case "Live": if (_p223._1 === true) {
                          return makeWidgetsAndZones({ctor: "_Tuple0"});
                       } else {
                          break _v100_2;
                       }
                  case "SyncSelect":
                  var possibleChangeStyle = _U.list([{ctor: "_Tuple2"
                                                     ,_0: "width"
                                                     ,_1: $Basics.toString((w / 3 | 0) - 32)}
                                                    ,{ctor: "_Tuple2"
                                                     ,_0: "height"
                                                     ,_1: $Basics.toString((h / 3 | 0) - 32)}
                                                    ,{ctor: "_Tuple2",_0: "margin",_1: "10px"}
                                                    ,{ctor: "_Tuple2",_0: "background",_1: "white"}
                                                    ,{ctor: "_Tuple2",_0: "border",_1: "solid 2px black"}
                                                    ,{ctor: "_Tuple2",_0: "cursor",_1: "pointer"}
                                                    ,{ctor: "_Tuple2",_0: "text-align",_1: "center"}]);
                    var animatePossibleChange = function (_p224) {
                       var _p225 = _p224;
                       var _p233 = _p225._1;
                       var _p232 = _p225._2;
                       var _p231 = _p225._0;
                       var _p230 = _p225._3;
                       var decimalPart = function (a) {
                          return a - $Basics.toFloat($Basics.truncate(a));
                       };
                       var nToRand = function (n) {
                          var f = $Basics.toFloat(n);
                          return decimalPart((1.0 + f * f * f * f) * $Basics.e);
                       };
                       var animateNumber = F3(function (i,x,time) {
                          var baseSpeed = 0.4;
                          var frequency = baseSpeed * (0.25 + nToRand(i));
                          var theta = time * frequency * 2.0 * $Basics.pi;
                          return x * (1 + 0.2 * $Basics.sin(theta));
                       });
                       var locIdsAndNumbers = $LangTools.unfrozenLocIdsAndNumbers(_p231);
                       var subst = $Dict.fromList(A2($Utils.mapi,
                       function (_p226) {
                          var _p227 = _p226;
                          return {ctor: "_Tuple2"
                                 ,_0: _p227._1._0
                                 ,_1: A3(animateNumber,
                                 _p227._0,
                                 _p227._1._1,
                                 model.syncSelectTime)};
                       },
                       locIdsAndNumbers));
                       var newExp = A2($Lang.applyLocSubst,subst,_p231);
                       var newVal = function () {
                          var _p228 = $Eval.run(newExp);
                          if (_p228.ctor === "Ok") {
                                return _p228._0._0;
                             } else {
                                return _p233;
                             }
                       }();
                       var _p229 = A4($LangSvg.resolveToIndexedTree,
                       model.slideNumber,
                       model.movieNumber,
                       model.movieTime,
                       newVal);
                       if (_p229.ctor === "Ok") {
                             return {ctor: "_Tuple2"
                                    ,_0: _p229._0
                                    ,_1: {ctor: "_Tuple4",_0: _p231,_1: _p233,_2: _p232,_3: _p230}};
                          } else {
                             return {ctor: "_Tuple2"
                                    ,_0: _p232
                                    ,_1: {ctor: "_Tuple4",_0: _p231,_1: _p233,_2: _p232,_3: _p230}};
                          }
                    };
                    var possibleChangeToSvg = function (_p234) {
                       var _p235 = _p234;
                       var _p236 = _p235._1._3;
                       var model$ = model;
                       return A2($Svg.svg,
                       _U.list([$Svg$Attributes.viewBox(A2($String.join,
                               " ",
                               A2($List.map,$Basics.toString,_U.list([0,0,w,h]))))
                               ,$Html$Attributes.style(possibleChangeStyle)
                               ,A2($Html$Events.onClick,
                               $InterfaceModel.events.address,
                               $InterfaceModel.SelectOption({ctor: "_Tuple4"
                                                            ,_0: _p235._1._0
                                                            ,_1: _p235._1._1
                                                            ,_2: _p235._1._2
                                                            ,_3: _p236}))
                               ,A2($Html$Events.onMouseOver,
                               $InterfaceModel.events.address,
                               $InterfaceModel.PreviewCode($Maybe.Just(_p236)))
                               ,A2($Html$Events.onMouseOut,
                               $InterfaceModel.events.address,
                               $InterfaceModel.PreviewCode($Maybe.Nothing))]),
                       _U.list([A2(buildSvg,
                       {ctor: "_Tuple2",_0: model$,_1: false},
                       _p235._0)]));
                    };
                    var cancelButton = A2($Html.button,
                    _U.list([$Html$Attributes.style(A2($Basics._op["++"],
                            possibleChangeStyle,
                            _U.list([{ctor: "_Tuple2",_0: "font-size",_1: "25px"}])))
                            ,A2($Html$Events.onClick,
                            $InterfaceModel.events.address,
                            $InterfaceModel.CancelSync)]),
                    _U.list([$Html.text("Cancel")]));
                    return A2($Graphics$Element.color,
                    $Color.grayscale(0.1),
                    A3($Html.toElement,
                    w,
                    h,
                    A2($Html.div,
                    _U.list([$Html$Attributes.style(_U.list([{ctor: "_Tuple2"
                                                             ,_0: "overflow"
                                                             ,_1: "auto"}
                                                            ,{ctor: "_Tuple2",_0: "width",_1: $Basics.toString(w)}
                                                            ,{ctor: "_Tuple2",_0: "height",_1: $Basics.toString(h)}]))]),
                    A2($Basics._op["++"],
                    A2($List.map,
                    possibleChangeToSvg,
                    A2($List.map,animatePossibleChange,_p223._0._0)),
                    _U.list([cancelButton])))));
                  default: break _v100_2;}
            } else {
               break _v100_2;
            }
      } while (false);
      return A3($Html.toElement,w,h,A2(mkSvg,addZones,mainCanvas));
   });
   var canvas = F3(function (w,h,model) {
      var _p237 = model.mode;
      if (_p237.ctor === "Print") {
            return A3(basicCodeBox_,w,h,_p237._0);
         } else {
            return A3(canvas_,w,h,model);
         }
   });
   var mainSectionVertical = F3(function (w,h,model) {
      var wExtra = $Config.params.mainSection.horizontal.wExtra;
      var hWidget = $Config.params.mainSection.widgets.hBtn + $Config.params.mainSection.vertical.hExtra;
      var hZInfo = $Config.params.mainSection.canvas.hZoneInfo;
      var hCanvas = h - hZInfo;
      var wMiddle = wBtn;
      var wGut = $Config.params.mainSection.vertical.wGut;
      var wCode_ = (w - wMiddle - wGut - wGut) / 2 | 0;
      var wCode = model.hideCode ? 0 : model.hideCanvas ? w - wMiddle - wGut - wGut : wCode_ + model.midOffsetX;
      var wCanvas = w - wMiddle - wGut - wGut - wCode;
      var codeSection = model.basicCodeBox ? A3(basicCodeBox,
      wCode,
      h,
      model) : A2(fancyCodeBox,wCode,h);
      var canvasSection = function () {
         var _p238 = model.errorBox;
         if (_p238.ctor === "Nothing") {
               return A3($Graphics$Element.size,
               wCanvas,
               h,
               A2($Graphics$Element.flow,
               $Graphics$Element.down,
               _U.list([A3(canvas,wCanvas,hCanvas,model)
                       ,A2($Graphics$Element.flow,
                       $Graphics$Element.left,
                       _U.list([A2(colorDebug,
                               $Color.red,
                               A4($Graphics$Element.container,
                               wBtn,
                               hZInfo + 1,
                               $Graphics$Element.middle,
                               A3(outputButton,model,wBtn,hBtn)))
                               ,A2(colorDebug,
                               $Color.orange,
                               A2($Graphics$Element.spacer,wExtra,hZInfo + 1))
                               ,A2(colorDebug,
                               $Color.green,
                               A4($Graphics$Element.container,
                               wBtnWide,
                               hZInfo + 1,
                               $Graphics$Element.middle,
                               A3(ghostsButton,model,wBtnWide,hBtn)))
                               ,A3(caption,
                               model,
                               wCanvas + 1 - (wBtn + wExtra + wBtnWide),
                               hZInfo + 1)]))])));
            } else {
               return A3(errorBox,wCanvas,h,_p238._0);
            }
      }();
      var gutter = A3(gutterForResizing,model.orient,wGut,h);
      var middleSection = A2(colorDebug,
      $Color.lightBlue,
      A3($Graphics$Element.size,
      wMiddle,
      h,
      A2($Graphics$Element.flow,
      $Graphics$Element.down,
      A7(middleWidgets,true,true,wBtn,hBtn,wMiddle,hWidget,model))));
      return A2($Graphics$Element.flow,
      $Graphics$Element.right,
      _U.list([codeSection
              ,gutter
              ,middleSection
              ,gutter
              ,canvasSection]));
   });
   var mainSectionHorizontal = F3(function (w,h,model) {
      var wExtra = $Config.params.mainSection.horizontal.wExtra;
      var hWidget = $Config.params.mainSection.widgets.hBtn + $Config.params.mainSection.vertical.hExtra;
      var hZInfo = $Config.params.mainSection.canvas.hZoneInfo;
      var hGut = $Config.params.mainSection.horizontal.hGut;
      var hCode_ = (h - hGut) / 2 | 0;
      var hCode = hCode_ + model.midOffsetY;
      var hCanvas = hCode_ - model.midOffsetY - hZInfo;
      var wGut = $Config.params.mainSection.vertical.wGut;
      var wTools = wBtn + wGut;
      var wRest = w - wTools;
      var codeSection = model.basicCodeBox ? A3(basicCodeBox,
      wRest,
      hCode,
      model) : A2(fancyCodeBox,wRest,hCode);
      var canvasSection = function () {
         var _p239 = model.errorBox;
         if (_p239.ctor === "Nothing") {
               return A3($Graphics$Element.size,
               wRest,
               hCanvas + hZInfo,
               A2($Graphics$Element.flow,
               $Graphics$Element.down,
               _U.list([A3(canvas,wRest,hCanvas,model)
                       ,A2($Graphics$Element.flow,
                       $Graphics$Element.left,
                       _U.list([A2(colorDebug,
                               $Color.red,
                               A4($Graphics$Element.container,
                               wBtn,
                               hZInfo + 1,
                               $Graphics$Element.middle,
                               A3(outputButton,model,wBtn,hBtn)))
                               ,A2(colorDebug,
                               $Color.orange,
                               A2($Graphics$Element.spacer,wExtra,hZInfo + 1))
                               ,A2(colorDebug,
                               $Color.green,
                               A4($Graphics$Element.container,
                               wBtnWide,
                               hZInfo + 1,
                               $Graphics$Element.middle,
                               A3(ghostsButton,model,wBtnWide,hBtn)))
                               ,A3(caption,
                               model,
                               wRest - (wBtn + wExtra + wBtnWide),
                               hZInfo + 1)]))])));
            } else {
               return A3(errorBox,wRest,hCanvas + hZInfo,_p239._0);
            }
      }();
      var hGutter = A3(gutterForResizing,model.orient,wRest,hGut);
      var vGutter = A2(colorDebug,
      $Color.darkBlue,
      A2($Graphics$Element.spacer,wGut,h));
      var mainTools = A2(colorDebug,
      $Color.lightBlue,
      A3($Graphics$Element.size,
      wBtn,
      h,
      A2($Graphics$Element.flow,
      $Graphics$Element.down,
      A7(middleWidgets,true,true,wBtn,hBtn,wBtn,hWidget,model))));
      var codeAndOutput = A2($Graphics$Element.flow,
      $Graphics$Element.down,
      _U.list([codeSection,hGutter,canvasSection]));
      return A2($Graphics$Element.flow,
      $Graphics$Element.right,
      _U.list([mainTools,vGutter,codeAndOutput]));
   });
   var view = F2(function (_p240,model) {
      var _p241 = _p240;
      var _p247 = _p241._0;
      var _p246 = _p241._1;
      var hBot = $Config.params.botSection.h;
      var hTop = $Config.params.topSection.h;
      var hMid = _p246 - hTop - hBot - 1;
      var hTot = hTop + hMid + hBot;
      var wGut = $Config.params.wGut;
      var wAll = _p247 - 2 * wGut - 1;
      var topSection = function () {
         var wSpcB = $Config.params.mainSection.horizontal.wExtra;
         var spcH = A2($Graphics$Element.spacer,wSpcB,hTop);
         var wJunk = $Config.params.topSection.wJunk;
         var hBtnO = $Config.params.topSection.hBtnO;
         var wBtnO = $Config.params.topSection.wBtnO;
         var btnO = function (e) {
            return A4($Graphics$Element.container,
            $Graphics$Element.widthOf(e),
            hTop,
            $Graphics$Element.middle,
            e);
         }(A3(orientationButton,wBtnO,hBtnO,model));
         var btnH = function (e) {
            return A4($Graphics$Element.container,
            $Graphics$Element.widthOf(e),
            hTop,
            $Graphics$Element.middle,
            e);
         }(A3(luckyButton,model,wBtnO,hBtnO));
         var wLogo = $Config.params.topSection.wLogo;
         var logo = A3($Graphics$Element.image,
         wLogo,
         wLogo,
         imgPath("light_logo.svg"));
         var wSep = A2($Graphics$Element.spacer,
         wAll - (wLogo + 2 * wBtnO + wJunk + wSpcB),
         1);
         var title = function (e) {
            return A4($Graphics$Element.container,
            $Graphics$Element.widthOf(e),
            hTop,
            $Graphics$Element.middle,
            e);
         }($Graphics$Element.leftAligned(A2($Text.style,
         titleStyle,
         $Text.fromString(strTitle))));
         return A3($Graphics$Element.size,
         wAll,
         hTop,
         A2($Graphics$Element.flow,
         $Graphics$Element.right,
         _U.list([A4($Graphics$Element.container,
                 wLogo,
                 hTop,
                 $Graphics$Element.middle,
                 logo)
                 ,A4($Graphics$Element.container,
                 wAll - wLogo,
                 hTop,
                 $Graphics$Element.middle,
                 A2($Graphics$Element.flow,
                 $Graphics$Element.right,
                 _U.list([title,wSep,btnH,spcH,btnO])))])));
      }();
      var midSection = A3($Graphics$Element.size,
      wAll,
      hMid,
      function () {
         var _p242 = model.orient;
         if (_p242.ctor === "Vertical") {
               return A3(mainSectionVertical,wAll,hMid,model);
            } else {
               return A3(mainSectionHorizontal,wAll,hMid,model);
            }
      }());
      var botSection = A2($Graphics$Element.spacer,wAll,hBot);
      var sideGutter = A2(colorDebug,
      $Color.black,
      A2($Graphics$Element.spacer,wGut,hTot));
      var basicUI = A2($Graphics$Element.flow,
      $Graphics$Element.right,
      _U.list([sideGutter
              ,A2($Graphics$Element.flow,
              $Graphics$Element.down,
              _U.list([A2(colorDebug,$Color.lightYellow,topSection)
                      ,midSection
                      ,A2(colorDebug,$Color.lightYellow,botSection)]))
              ,sideGutter]));
      var _p243 = {ctor: "_Tuple2",_0: model.startup,_1: model.mode};
      _v111_2: do {
         if (_p243.ctor === "_Tuple2") {
               if (_p243._0 === true) {
                     var foo = function (_p244) {
                        return A2($Signal.message,
                        $InterfaceStorage.taskMailbox.address,
                        A2($Task.andThen,
                        $InterfaceStorage.getLocalSaves,
                        function (_p245) {
                           return A2($Signal.send,
                           $InterfaceModel.events.address,
                           $InterfaceModel.UpdateModel(function (m) {
                              return _U.update(m,{startup: false});
                           }));
                        }));
                     };
                     return A2($Graphics$Element.flow,
                     $Graphics$Element.inward,
                     _U.list([A2($Graphics$Input.hoverable,
                             foo,
                             A2($Graphics$Element.spacer,_p247,_p246))
                             ,basicUI]));
                  } else {
                     if (_p243._1.ctor === "SaveDialog") {
                           return A2($Graphics$Element.flow,
                           $Graphics$Element.inward,
                           _U.list([A3(saveElement,model,_p247,_p246),basicUI]));
                        } else {
                           break _v111_2;
                        }
                  }
            } else {
               break _v111_2;
            }
      } while (false);
      return basicUI;
   });
   var debugLog = $Config.debugLog($Config.debugView);
   return _elm.InterfaceView2.values = {_op: _op,view: view};
};
Elm.ExpressionBasedTransform = Elm.ExpressionBasedTransform || {};
Elm.ExpressionBasedTransform.make = function (_elm) {
   "use strict";
   _elm.ExpressionBasedTransform = _elm.ExpressionBasedTransform || {};
   if (_elm.ExpressionBasedTransform.values)
   return _elm.ExpressionBasedTransform.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Blobs = Elm.Blobs.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $InterfaceModel = Elm.InterfaceModel.make(_elm),
   $Keys = Elm.Keys.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $LangTransform = Elm.LangTransform.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $ShapeWidgets = Elm.ShapeWidgets.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Types = Elm.Types.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var annotatedNumToComparable = function (_p0) {
      var _p1 = _p0;
      var _p4 = _p1._0;
      var _p3 = _p1._1;
      var _p2 = _p1._2.val;
      switch (_p2.ctor)
      {case "IntSlider": return {ctor: "_Tuple4"
                                ,_0: _p4
                                ,_1: _p3
                                ,_2: $Basics.toFloat(_p2._0.val)
                                ,_3: $Basics.toFloat(_p2._2.val)};
         case "NumSlider": return {ctor: "_Tuple4"
                                  ,_0: _p4
                                  ,_1: _p3
                                  ,_2: _p2._0.val
                                  ,_3: _p2._2.val};
         default: return {ctor: "_Tuple4",_0: _p4,_1: _p3,_2: 1,_3: -1};}
   };
   var mergeTypes = F2(function (tFirst,tRest) {
      return A2($List.all,
      $Types.equal(tFirst),
      tRest) ? $Maybe.Just({ctor: "_Tuple0"}) : $Maybe.Nothing;
   });
   var matchAllAndBind = F3(function (f,xs,g) {
      return A2($Utils.bindMaybe,
      g,
      $Utils.projJusts(A2($List.map,f,xs)));
   });
   var matchAllAndCheckEqual = F3(function (f,xs,x) {
      var g = function (ys) {
         return A2($List.all,
         F2(function (x,y) {    return _U.eq(x,y);})(x),
         ys) ? $Maybe.Just({ctor: "_Tuple0"}) : $Maybe.Nothing;
      };
      return A3(matchAllAndBind,f,xs,g);
   });
   var mergePatterns = F2(function (pFirst,pRest) {
      var _p5 = pFirst.val;
      switch (_p5.ctor)
      {case "PVar": var match = function (pNext) {
              var _p6 = pNext.val;
              if (_p6.ctor === "PVar") {
                    return $Maybe.Just(_p6._1);
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndCheckEqual,match,pRest,_p5._1);
         case "PConst": var match = function (pNext) {
              var _p7 = pNext.val;
              if (_p7.ctor === "PConst") {
                    return $Maybe.Just(_p7._1);
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndCheckEqual,match,pRest,_p5._1);
         case "PBase": var match = function (pNext) {
              var _p8 = pNext.val;
              if (_p8.ctor === "PBase") {
                    return $Maybe.Just(_p8._1);
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndCheckEqual,match,pRest,_p5._1);
         case "PList": var match = function (pNext) {
              var _p9 = pNext.val;
              if (_p9.ctor === "PList") {
                    return $Maybe.Just({ctor: "_Tuple2",_0: _p9._1,_1: _p9._3});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           pRest,
           function (stuff) {
              var _p10 = $List.unzip(stuff);
              var psList = _p10._0;
              var mpList = _p10._1;
              return A3($Utils.bindMaybe2,
              F2(function (_p12,_p11) {
                 var _p13 = _p11;
                 return $Maybe.Just({ctor: "_Tuple0"});
              }),
              mergePatternLists(A2($List._op["::"],_p5._1,psList)),
              A2(mergeMaybePatterns,_p5._3,mpList));
           });
         default: var match = function (pNext) {
              var _p14 = pNext.val;
              if (_p14.ctor === "PAs") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: _p14._1
                                       ,_1: _p14._3});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           pRest,
           function (stuff) {
              var _p15 = $List.unzip(stuff);
              var indentList = _p15._0;
              var pList = _p15._1;
              return A2($Utils.bindMaybe,
              function (_p16) {
                 var _p17 = _p16;
                 return A2($List.all,
                 F2(function (x,y) {    return _U.eq(x,y);})(_p5._1),
                 indentList) ? $Maybe.Just({ctor: "_Tuple0"}) : $Maybe.Nothing;
              },
              A2(mergePatterns,_p5._3,pList));
           });}
   });
   var mergeMaybePatterns = F2(function (mp,mps) {
      var _p18 = mp;
      if (_p18.ctor === "Nothing") {
            return A2($List.all,
            F2(function (x,y) {    return _U.eq(x,y);})($Maybe.Nothing),
            mps) ? $Maybe.Just({ctor: "_Tuple0"}) : $Maybe.Nothing;
         } else {
            return A2($Utils.bindMaybe,
            mergePatterns(_p18._0),
            $Utils.projJusts(mps));
         }
   });
   var mergePatternLists = function (lists) {
      var _p19 = $Utils.maybeZipN(lists);
      if (_p19.ctor === "Nothing") {
            return $Maybe.Nothing;
         } else {
            var foo = F2(function (listPat,maybeAcc) {
               var _p20 = {ctor: "_Tuple2",_0: listPat,_1: maybeAcc};
               if (_p20.ctor === "_Tuple2" && _p20._0.ctor === "::" && _p20._1.ctor === "Just" && _p20._1._0.ctor === "_Tuple0")
               {
                     return A2(mergePatterns,_p20._0._0,_p20._0._1);
                  } else {
                     return $Maybe.Nothing;
                  }
            });
            return A3($List.foldl,
            foo,
            $Maybe.Just({ctor: "_Tuple0"}),
            _p19._0);
         }
   };
   var mergeExpressions = F2(function (eFirst,eRest) {
      var $return = F2(function (e__,list) {
         return $Maybe.Just({ctor: "_Tuple2"
                            ,_0: A2($Lang.replaceE__,eFirst,e__)
                            ,_1: list});
      });
      var _p21 = eFirst.val.e__;
      switch (_p21.ctor)
      {case "EConst": var match = function (eNext) {
              var _p22 = eNext.val.e__;
              if (_p22.ctor === "EConst" && _p22._2.ctor === "_Tuple3") {
                    return $Maybe.Just({ctor: "_Tuple3"
                                       ,_0: _p22._1
                                       ,_1: _p22._2._1
                                       ,_2: _p22._3});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (restAnnotatedNums) {
              var _p23 = _p21._2;
              var locid = _p23._0;
              var ann = _p23._1;
              var x = _p23._2;
              var allAnnotatedNums = A2($List._op["::"],
              {ctor: "_Tuple3",_0: _p21._1,_1: ann,_2: _p21._3},
              restAnnotatedNums);
              var _p24 = A2($Utils.dedup_,
              annotatedNumToComparable,
              allAnnotatedNums);
              if (_p24.ctor === "::" && _p24._1.ctor === "[]") {
                    return A2($return,eFirst.val.e__,_U.list([]));
                 } else {
                    var $var = _U.eq(x,"") ? A2($Basics._op["++"],
                    "k",
                    $Basics.toString(locid)) : x;
                    return A2($return,
                    A2($Lang.EVar,_p21._0,$var),
                    _U.list([{ctor: "_Tuple2",_0: $var,_1: allAnnotatedNums}]));
                 }
           });
         case "EBase": var match = function (eNext) {
              var _p25 = eNext.val.e__;
              if (_p25.ctor === "EBase") {
                    return $Maybe.Just(_p25._1);
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (bvs) {
              return A2($List.all,
              F2(function (x,y) {    return _U.eq(x,y);})(_p21._1),
              bvs) ? A2($return,eFirst.val.e__,_U.list([])) : $Maybe.Nothing;
           });
         case "EVar": var match = function (eNext) {
              var _p26 = eNext.val.e__;
              if (_p26.ctor === "EVar") {
                    return $Maybe.Just(_p26._1);
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (xs) {
              return A2($List.all,
              F2(function (x,y) {    return _U.eq(x,y);})(_p21._1),
              xs) ? A2($return,eFirst.val.e__,_U.list([])) : $Maybe.Nothing;
           });
         case "EFun": var _p33 = _p21._1;
           var match = function (eNext) {
              var _p27 = eNext.val.e__;
              if (_p27.ctor === "EFun") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: _p27._1
                                       ,_1: _p27._2});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p28 = $List.unzip(stuff);
              var psList = _p28._0;
              var eBodyList = _p28._1;
              return A3($Utils.bindMaybe2,
              F2(function (_p30,_p29) {
                 var _p31 = _p30;
                 var _p32 = _p29;
                 return A2($return,
                 A4($Lang.EFun,_p21._0,_p33,_p32._0,_p21._3),
                 _p32._1);
              }),
              mergePatternLists(A2($List._op["::"],_p33,psList)),
              A2(mergeExpressions,_p21._2,eBodyList));
           });
         case "EApp": var match = function (eNext) {
              var _p34 = eNext.val.e__;
              if (_p34.ctor === "EApp") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: _p34._1
                                       ,_1: _p34._2});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p35 = $List.unzip(stuff);
              var eFuncList = _p35._0;
              var eArgsList = _p35._1;
              return A3($Utils.bindMaybe2,
              F2(function (_p37,_p36) {
                 var _p38 = _p37;
                 var _p39 = _p36;
                 return A2($return,
                 A4($Lang.EApp,_p21._0,_p38._0,_p39._0,_p21._3),
                 A2($Basics._op["++"],_p38._1,_p39._1));
              }),
              A2(mergeExpressions,_p21._1,eFuncList),
              mergeExpressionLists(A2($List._op["::"],_p21._2,eArgsList)));
           });
         case "ELet": var _p47 = _p21._3;
           var match = function (eNext) {
              var _p40 = eNext.val.e__;
              if (_p40.ctor === "ELet") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: {ctor: "_Tuple2",_0: _p40._3,_1: _p40._4}
                                       ,_1: _p40._5});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p41 = A2($Utils.mapFst,$List.unzip,$List.unzip(stuff));
              var p1List = _p41._0._0;
              var e1List = _p41._0._1;
              var e2List = _p41._1;
              return A4($Utils.bindMaybe3,
              F3(function (_p44,_p43,_p42) {
                 var _p45 = _p43;
                 var _p46 = _p42;
                 return A2($return,
                 A7($Lang.ELet,
                 _p21._0,
                 _p21._1,
                 _p21._2,
                 _p47,
                 _p45._0,
                 _p46._0,
                 _p21._6),
                 A2($Basics._op["++"],_p45._1,_p46._1));
              }),
              A2(mergePatterns,_p47,p1List),
              A2(mergeExpressions,_p21._4,e1List),
              A2(mergeExpressions,_p21._5,e2List));
           });
         case "EList": var match = function (eNext) {
              var _p48 = eNext.val.e__;
              if (_p48.ctor === "EList") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: _p48._1
                                       ,_1: _p48._3});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p49 = $List.unzip(stuff);
              var esList = _p49._0;
              var meList = _p49._1;
              return A3($Utils.bindMaybe2,
              F2(function (_p51,_p50) {
                 var _p52 = _p51;
                 var _p53 = _p50;
                 return A2($return,
                 A5($Lang.EList,_p21._0,_p52._0,_p21._2,_p53._0,_p21._4),
                 A2($Basics._op["++"],_p52._1,_p53._1));
              }),
              mergeExpressionLists(A2($List._op["::"],_p21._1,esList)),
              A2(mergeMaybeExpressions,_p21._3,meList));
           });
         case "EOp": var _p58 = _p21._1;
           var match = function (eNext) {
              var _p54 = eNext.val.e__;
              if (_p54.ctor === "EOp") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: _p54._1
                                       ,_1: _p54._2});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p55 = $List.unzip(stuff);
              var opList = _p55._0;
              var esList = _p55._1;
              return A2($List.all,
              F2(function (x,y) {    return _U.eq(x,y);})(_p58.val),
              A2($List.map,
              function (_) {
                 return _.val;
              },
              opList)) ? A2($Utils.bindMaybe,
              function (_p56) {
                 var _p57 = _p56;
                 return A2($return,
                 A4($Lang.EOp,_p21._0,_p58,_p57._0,_p21._3),
                 _p57._1);
              },
              mergeExpressionLists(A2($List._op["::"],
              _p21._2,
              esList))) : $Maybe.Nothing;
           });
         case "EIf": var match = function (eNext) {
              var _p59 = eNext.val.e__;
              if (_p59.ctor === "EIf") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: {ctor: "_Tuple2",_0: _p59._1,_1: _p59._2}
                                       ,_1: _p59._3});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p60 = A2($Utils.mapFst,$List.unzip,$List.unzip(stuff));
              var e1List = _p60._0._0;
              var e2List = _p60._0._1;
              var e3List = _p60._1;
              return A4($Utils.bindMaybe3,
              F3(function (_p63,_p62,_p61) {
                 var _p64 = _p63;
                 var _p65 = _p62;
                 var _p66 = _p61;
                 return A2($return,
                 A5($Lang.EIf,_p21._0,_p64._0,_p65._0,_p66._0,_p21._4),
                 A2($Basics._op["++"],
                 _p64._1,
                 A2($Basics._op["++"],_p65._1,_p66._1)));
              }),
              A2(mergeExpressions,_p21._1,e1List),
              A2(mergeExpressions,_p21._2,e2List),
              A2(mergeExpressions,_p21._3,e3List));
           });
         case "EComment": var match = function (eNext) {
              var _p67 = eNext.val.e__;
              if (_p67.ctor === "EComment") {
                    return $Maybe.Just(_p67._2);
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (es) {
              return A2($Utils.bindMaybe,
              function (_p68) {
                 var _p69 = _p68;
                 return A2($return,
                 A3($Lang.EComment,_p21._0,_p21._1,_p69._0),
                 _p69._1);
              },
              A2(mergeExpressions,_p21._2,es));
           });
         case "ETyp": var _p77 = _p21._2;
           var _p76 = _p21._1;
           var match = function (eNext) {
              var _p70 = eNext.val.e__;
              if (_p70.ctor === "ETyp") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: {ctor: "_Tuple2",_0: _p70._1,_1: _p70._2}
                                       ,_1: _p70._3});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p71 = A2($Utils.mapFst,$List.unzip,$List.unzip(stuff));
              var patList = _p71._0._0;
              var typeList = _p71._0._1;
              var eList = _p71._1;
              return A4($Utils.bindMaybe3,
              F3(function (_p74,_p73,_p72) {
                 var _p75 = _p72;
                 return A2($return,
                 A5($Lang.ETyp,_p21._0,_p76,_p77,_p75._0,_p21._4),
                 _p75._1);
              }),
              A2(mergePatterns,_p76,patList),
              A2(mergeTypes,_p77,typeList),
              A2(mergeExpressions,_p21._3,eList));
           });
         case "EColonType": var _p83 = _p21._3;
           var match = function (eNext) {
              var _p78 = eNext.val.e__;
              if (_p78.ctor === "EColonType") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: _p78._1
                                       ,_1: _p78._3});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p79 = $List.unzip(stuff);
              var eList = _p79._0;
              var typeList = _p79._1;
              return A3($Utils.bindMaybe2,
              F2(function (_p81,_p80) {
                 var _p82 = _p81;
                 return A2($return,
                 A5($Lang.EColonType,_p21._0,_p82._0,_p21._2,_p83,_p21._4),
                 _p82._1);
              }),
              A2(mergeExpressions,_p21._1,eList),
              A2(mergeTypes,_p83,typeList));
           });
         case "ETypeAlias": var _p91 = _p21._2;
           var _p90 = _p21._1;
           var match = function (eNext) {
              var _p84 = eNext.val.e__;
              if (_p84.ctor === "ETypeAlias") {
                    return $Maybe.Just({ctor: "_Tuple2"
                                       ,_0: {ctor: "_Tuple2",_0: _p84._1,_1: _p84._2}
                                       ,_1: _p84._3});
                 } else {
                    return $Maybe.Nothing;
                 }
           };
           return A3(matchAllAndBind,
           match,
           eRest,
           function (stuff) {
              var _p85 = A2($Utils.mapFst,$List.unzip,$List.unzip(stuff));
              var patList = _p85._0._0;
              var typeList = _p85._0._1;
              var eList = _p85._1;
              return A4($Utils.bindMaybe3,
              F3(function (_p88,_p87,_p86) {
                 var _p89 = _p86;
                 return A2($return,
                 A5($Lang.ETypeAlias,_p21._0,_p90,_p91,_p89._0,_p21._4),
                 _p89._1);
              }),
              A2(mergePatterns,_p90,patList),
              A2(mergeTypes,_p91,typeList),
              A2(mergeExpressions,_p21._3,eList));
           });
         case "ECase": var _p92 = A2($Debug.log,
           "mergeExpressions: TODO handle: ",
           eFirst);
           return $Maybe.Nothing;
         case "ETypeCase": var _p93 = A2($Debug.log,
           "mergeExpressions: TODO handle: ",
           eFirst);
           return $Maybe.Nothing;
         default: var _p94 = A2($Debug.log,
           "mergeExpressions: options shouldn\'t appear nested: ",
           {ctor: "_Tuple0"});
           return $Maybe.Nothing;}
   });
   var mergeExpressionLists = function (lists) {
      var _p95 = $Utils.maybeZipN(lists);
      if (_p95.ctor === "Nothing") {
            return $Maybe.Nothing;
         } else {
            var foo = F2(function (listExp,maybeAcc) {
               var _p96 = {ctor: "_Tuple2",_0: listExp,_1: maybeAcc};
               if (_p96.ctor === "_Tuple2" && _p96._0.ctor === "::" && _p96._1.ctor === "Just" && _p96._1._0.ctor === "_Tuple2")
               {
                     var _p97 = A2(mergeExpressions,_p96._0._0,_p96._0._1);
                     if (_p97.ctor === "Nothing") {
                           return $Maybe.Nothing;
                        } else {
                           return $Maybe.Just({ctor: "_Tuple2"
                                              ,_0: A2($Basics._op["++"],_p96._1._0._0,_U.list([_p97._0._0]))
                                              ,_1: A2($Basics._op["++"],_p96._1._0._1,_p97._0._1)});
                        }
                  } else {
                     return $Maybe.Nothing;
                  }
            });
            return A3($List.foldl,
            foo,
            $Maybe.Just({ctor: "_Tuple2",_0: _U.list([]),_1: _U.list([])}),
            _p95._0);
         }
   };
   var mergeMaybeExpressions = F2(function (me,mes) {
      var _p98 = me;
      if (_p98.ctor === "Nothing") {
            return A2($List.all,
            F2(function (x,y) {    return _U.eq(x,y);})($Maybe.Nothing),
            mes) ? $Maybe.Just({ctor: "_Tuple2"
                               ,_0: $Maybe.Nothing
                               ,_1: _U.list([])}) : $Maybe.Nothing;
         } else {
            return A2($Utils.bindMaybe,
            function (_p99) {
               return A2($Utils.mapMaybe,
               $Utils.mapFst($Maybe.Just),
               A2(mergeExpressions,_p98._0,_p99));
            },
            $Utils.projJusts(mes));
         }
   });
   var deleteSelectedBlobs = function (model) {
      var _p100 = $Blobs.splitExp(model.inputExp);
      var defs = _p100._0;
      var mainExp = _p100._1;
      var _p101 = mainExp;
      if (_p101.ctor === "Blobs") {
            var blobs$ = A2($Utils.filteri,
            function (_p102) {
               var _p103 = _p102;
               return $Basics.not(A2($Dict.member,
               _p103._0,
               model.selectedBlobs));
            },
            _p101._0);
            var code$ = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                             ,_0: defs
                                                             ,_1: A2($Blobs.Blobs,blobs$,_p101._1)}));
            return _U.update(model,
            {code: code$,selectedBlobs: $Dict.empty});
         } else {
            return model;
         }
   };
   var stripBoundsExp = function (e) {
      stripBoundsExp: while (true) {
         var _p104 = e.val.e__;
         _v50_2: do {
            switch (_p104.ctor)
            {case "EList": if (_p104._3.ctor === "Nothing") {
                       var _p106 = A2($List.map,
                       function (_p105) {
                          return function (_) {
                             return _.e__;
                          }(function (_) {    return _.val;}(_p105));
                       },
                       _p104._1);
                       if (_p106.ctor === "::" && _p106._0.ctor === "EConst" && _p106._1.ctor === "::" && _p106._1._0.ctor === "EConst" && _p106._1._1.ctor === "::" && _p106._1._1._0.ctor === "EConst" && _p106._1._1._1.ctor === "::" && _p106._1._1._1._0.ctor === "EConst" && _p106._1._1._1._1.ctor === "[]")
                       {
                             return $Maybe.Just({ctor: "_Tuple4"
                                                ,_0: _p106._0._1
                                                ,_1: _p106._1._0._1
                                                ,_2: _p106._1._1._0._1
                                                ,_3: _p106._1._1._1._0._1});
                          } else {
                             return $Maybe.Nothing;
                          }
                    } else {
                       break _v50_2;
                    }
               case "EColonType": var _v52 = _p104._1;
                 e = _v52;
                 continue stripBoundsExp;
               default: break _v50_2;}
         } while (false);
         return $Maybe.Nothing;
      }
   };
   var stripPointExp = function (e) {
      stripPointExp: while (true) {
         var _p107 = e.val.e__;
         _v53_2: do {
            switch (_p107.ctor)
            {case "EList":
               if (_p107._1.ctor === "::" && _p107._1._1.ctor === "::" && _p107._1._1._1.ctor === "[]" && _p107._3.ctor === "Nothing")
                 {
                       var _p108 = {ctor: "_Tuple2"
                                   ,_0: _p107._1._0.val.e__
                                   ,_1: _p107._1._1._0.val.e__};
                       if (_p108.ctor === "_Tuple2" && _p108._0.ctor === "EConst" && _p108._1.ctor === "EConst")
                       {
                             return $Maybe.Just({ctor: "_Tuple2"
                                                ,_0: _p108._0._1
                                                ,_1: _p108._1._1});
                          } else {
                             return $Maybe.Nothing;
                          }
                    } else {
                       break _v53_2;
                    }
               case "EColonType": var _v55 = _p107._1;
                 e = _v55;
                 continue stripPointExp;
               default: break _v53_2;}
         } while (false);
         return $Maybe.Nothing;
      }
   };
   var redundantBinding = function (_p109) {
      redundantBinding: while (true) {
         var _p110 = _p109;
         var _p112 = _p110._0;
         var _p111 = {ctor: "_Tuple2"
                     ,_0: _p112.val
                     ,_1: _p110._1.val.e__};
         _v57_6: do {
            if (_p111.ctor === "_Tuple2") {
                  switch (_p111._1.ctor)
                  {case "EConst": if (_p111._0.ctor === "PConst") {
                             return _U.eq(_p111._0._1,_p111._1._1);
                          } else {
                             break _v57_6;
                          }
                     case "EBase": if (_p111._0.ctor === "PBase") {
                             return _U.eq(_p111._0._1,_p111._1._1);
                          } else {
                             break _v57_6;
                          }
                     case "EVar": if (_p111._0.ctor === "PVar") {
                             return _U.eq(_p111._0._1,_p111._1._1);
                          } else {
                             break _v57_6;
                          }
                     case "EList": if (_p111._0.ctor === "PList") {
                             if (_p111._0._3.ctor === "Nothing") {
                                   if (_p111._1._3.ctor === "Nothing") {
                                         return A2($List.all,
                                         redundantBinding,
                                         A2($Utils.zip,_p111._0._1,_p111._1._1));
                                      } else {
                                         break _v57_6;
                                      }
                                } else {
                                   if (_p111._1._3.ctor === "Just") {
                                         return A2($List.all,
                                         redundantBinding,
                                         A2($Utils.zip,
                                         A2($List._op["::"],_p111._0._3._0,_p111._0._1),
                                         A2($List._op["::"],_p111._1._3._0,_p111._1._1)));
                                      } else {
                                         break _v57_6;
                                      }
                                }
                          } else {
                             break _v57_6;
                          }
                     case "EColonType": var _v58 = {ctor: "_Tuple2"
                                                   ,_0: _p112
                                                   ,_1: _p111._1._1};
                       _p109 = _v58;
                       continue redundantBinding;
                     default: break _v57_6;}
               } else {
                  break _v57_6;
               }
         } while (false);
         return false;
      }
   };
   var removeRedundantBindings = $Lang.mapExp(function (e) {
      var _p113 = e.val.e__;
      if (_p113.ctor === "ELet") {
            return redundantBinding({ctor: "_Tuple2"
                                    ,_0: _p113._3
                                    ,_1: _p113._4}) ? _p113._5 : e;
         } else {
            return e;
         }
   });
   var clean = function (_p114) {
      return removeRedundantBindings($LangTransform.simplify(_p114));
   };
   var AnchorBindings = F2(function (a,b) {
      return {ctor: "AnchorBindings",_0: a,_1: b};
   });
   var findAnchorInMapping = function (mapping) {
      var _p115 = mapping;
      if (_p115.ctor === "::" && _p115._0.ctor === "_Tuple2" && _p115._0._0 === "xAnchor" && _p115._1.ctor === "::" && _p115._1._0.ctor === "_Tuple2" && _p115._1._0._0 === "yAnchor")
      {
            return $Maybe.Just({ctor: "_Tuple2"
                               ,_0: _p115._1._1
                               ,_1: A2(AnchorBindings,_p115._0._1,_p115._1._0._1)});
         } else {
            return $Maybe.Nothing;
         }
   };
   var BoundsBindings = F4(function (a,b,c,d) {
      return {ctor: "BoundsBindings",_0: a,_1: b,_2: c,_3: d};
   });
   var findBoundsInMapping = function (mapping) {
      var _p116 = mapping;
      if (_p116.ctor === "::" && _p116._0.ctor === "_Tuple2" && _p116._0._0 === "left" && _p116._1.ctor === "::" && _p116._1._0.ctor === "_Tuple2" && _p116._1._0._0 === "top" && _p116._1._1.ctor === "::" && _p116._1._1._0.ctor === "_Tuple2" && _p116._1._1._0._0 === "right" && _p116._1._1._1.ctor === "::" && _p116._1._1._1._0.ctor === "_Tuple2" && _p116._1._1._1._0._0 === "bot")
      {
            return $Maybe.Just({ctor: "_Tuple2"
                               ,_0: _p116._1._1._1._1
                               ,_1: A4(BoundsBindings,
                               _p116._0._1,
                               _p116._1._0._1,
                               _p116._1._1._0._1,
                               _p116._1._1._1._0._1)});
         } else {
            return $Maybe.Nothing;
         }
   };
   var findSpecialBindingsInMapping = function (mapping) {
      return A2($Utils.plusMaybe,
      findBoundsInMapping(mapping),
      findAnchorInMapping(mapping));
   };
   var collectUnfrozenConstants_ = F2(function (maybeVarCounts,e) {
      var foo = function (e__) {
         var $default = {ctor: "_Tuple2",_0: e__,_1: _U.list([])};
         var _p117 = e__;
         if (_p117.ctor === "EConst" && _p117._2.ctor === "_Tuple3") {
               var _p120 = _p117._2._2;
               var _p119 = _p117._2._1;
               if (_U.eq(_p119,$Lang.unann) || _U.eq(_p119,$Lang.thawed))
               if (_U.eq(_p120,"")) return $default; else {
                        var addVar = function (y) {
                           return {ctor: "_Tuple2"
                                  ,_0: A2($Lang.EVar,_p117._0,y)
                                  ,_1: _U.list([{ctor: "_Tuple2"
                                                ,_0: y
                                                ,_1: {ctor: "_Tuple3",_0: _p117._1,_1: _p119,_2: _p117._3}}])};
                        };
                        var _p118 = maybeVarCounts;
                        if (_p118.ctor === "Nothing") {
                              return addVar(_p120);
                           } else {
                              return _U.eq(A2($Utils.justGet,_p120,_p118._0),
                              1) ? addVar(_p120) : addVar(A2($Basics._op["++"],
                              _p120,
                              $Basics.toString(_p117._2._0)));
                           }
                     } else return $default;
            } else {
               return $default;
            }
      };
      var e$ = A2($Lang.mapExpViaExp__,
      function (_p121) {
         return $Basics.fst(foo(_p121));
      },
      e);
      var mapping = A3($Lang.foldExpViaE__,
      function (_p122) {
         return F2(function (x,y) {
            return A2($Basics._op["++"],x,y);
         })($Basics.snd(foo(_p122)));
      },
      _U.list([]),
      e);
      return {ctor: "_Tuple2",_0: e$,_1: mapping};
   });
   var collectUnfrozenConstants = function (e) {
      var _p123 = A2(collectUnfrozenConstants_,$Maybe.Nothing,e);
      var list0 = _p123._1;
      var varCounts = A3($List.foldl,
      F2(function ($var,acc) {
         var _p124 = A2($Dict.get,$var,acc);
         if (_p124.ctor === "Nothing") {
               return A3($Dict.insert,$var,1,acc);
            } else {
               return A3($Dict.insert,$var,1 + _p124._0,acc);
            }
      }),
      $Dict.empty,
      A2($List.map,$Basics.fst,list0));
      var _p125 = A2(collectUnfrozenConstants_,
      $Maybe.Just(varCounts),
      e);
      var e$ = _p125._0;
      var list = _p125._1;
      return {ctor: "_Tuple2",_0: clean(e$),_1: $List.reverse(list)};
   };
   var pAsTight = F2(function (x,p) {
      var p$ = A2($LangUnparser.replacePrecedingWhitespacePat,
      "",
      p);
      return $Lang.withDummyRange(A4($Lang.PAs," ",x,"",p$));
   });
   var eAsPoint = function (e) {
      var insertPointAnnotations = false;
      if ($Basics.not(insertPointAnnotations)) return e; else {
            var e$ = A2($LangUnparser.replacePrecedingWhitespace,"",e);
            return $Lang.withDummyPos(A5($Lang.EColonType,
            " ",
            e$,
            " ",
            $Lang.withDummyRange(A2($Lang.TNamed," ","Point")),
            ""));
         }
   };
   var eBaseOffset = F2(function (baseVar,offsetNum) {
      var allowZeroOffsets = true;
      return _U.eq(offsetNum,
      0) && $Basics.not(allowZeroOffsets) ? A2($Lang.EVar,
      " ",
      baseVar) : function (_) {
         return _.e__;
      }(function (_) {
         return _.val;
      }(A2($LangUnparser.replacePrecedingWhitespace,
      " ",
      A2($Lang.ePlus,
      $Lang.eVar(baseVar),
      A2($Lang.eConst,offsetNum,$Lang.dummyLoc_($Lang.unann))))));
   });
   var rewritePrimitivePointsOfSelectedBlobs = F3(function (model,
   _p127,
   _p126) {
      var _p128 = _p127;
      var _p140 = _p128._0;
      var _p129 = _p126;
      var _p139 = _p129._0;
      var _p130 = _p128._1;
      var xId = _p130._0;
      var xName = _p130._2;
      var _p131 = _p129._1;
      var yId = _p131._0;
      var yName = _p131._2;
      var _p132 = {ctor: "_Tuple2",_0: "xAnchor",_1: "yAnchor"};
      var xAnchor = _p132._0;
      var yAnchor = _p132._1;
      var pointsOfSelectedBlobs = A3($Dict.foldl,
      F3(function (_p133,nodeId,acc) {
         return A2($Basics._op["++"],
         acc,
         A2($ShapeWidgets.getPrimitivePointEquations,
         model.slate,
         nodeId));
      }),
      _U.list([]),
      model.selectedBlobs);
      var anchorDef = {ctor: "_Tuple4"
                      ,_0: "\n  "
                      ,_1: A2($Lang.pAs,
                      "anchor",
                      $Lang.pList($Lang.listOfPVars(_U.list([xAnchor,yAnchor]))))
                      ,_2: eAsPoint(A2($Lang.eList,
                      $Lang.listOfNums(_U.list([_p140,_p139])),
                      $Maybe.Nothing))
                      ,_3: ""};
      var eSubst = A3($List.foldl,
      F2(function (_p134,acc) {
         var _p135 = _p134;
         var _p138 = _p135._1;
         var _p137 = _p135._0;
         if (_U.eq({ctor: "_Tuple2",_0: _p140,_1: _p139},
         {ctor: "_Tuple2"
         ,_0: $Basics.fst(_p137)
         ,_1: $Basics.fst(_p138)})) return A3($Dict.insert,
            yId,
            A2($Lang.EVar," ",yAnchor),
            A3($Dict.insert,xId,A2($Lang.EVar," ",xAnchor),acc)); else {
               var _p136 = {ctor: "_Tuple2",_0: _p137,_1: _p138};
               if (_p136.ctor === "_Tuple2" && _p136._0.ctor === "_Tuple2" && _p136._0._1.ctor === "TrLoc" && _p136._0._1._0.ctor === "_Tuple3" && _p136._1.ctor === "_Tuple2" && _p136._1._1.ctor === "TrLoc" && _p136._1._1._0.ctor === "_Tuple3")
               {
                     return A3($Dict.insert,
                     _p136._1._1._0._0,
                     A2(eBaseOffset,yAnchor,_p136._1._0 - _p139),
                     A3($Dict.insert,
                     _p136._0._1._0._0,
                     A2(eBaseOffset,xAnchor,_p136._0._0 - _p140),
                     acc));
                  } else {
                     return acc;
                  }
            }
      }),
      $Dict.empty,
      pointsOfSelectedBlobs);
      return {ctor: "_Tuple2",_0: _U.list([anchorDef]),_1: eSubst};
   });
   var anchorOfSelectedFeatures = function (selectedFeatures) {
      var err = $Result.Err("To group around an anchor, need to select exactly one point.");
      var _p141 = $Set.toList(selectedFeatures);
      if (_p141.ctor === "::") {
            if (_p141._1.ctor === "::" && _p141._1._1.ctor === "[]") {
                  var _p142 = A2($ShapeWidgets.selectedPointFeatureOf,
                  _p141._0,
                  _p141._1._0);
                  if (_p142.ctor === "Just") {
                        return $Result.Ok($Maybe.Just(_p142._0));
                     } else {
                        return err;
                     }
               } else {
                  return err;
               }
         } else {
            return $Result.Ok($Maybe.Nothing);
         }
   };
   var undoGroupPadding = function (_p143) {
      var _p144 = _p143;
      var clean = function (_p145) {
         var _p146 = _p145;
         var _p149 = _p146._1;
         var _p148 = _p146._0;
         var _p147 = _p149;
         _v73_4: do {
            if (_p147.ctor === "TrOp" && _p147._1.ctor === "::" && _p147._1._1.ctor === "::" && _p147._1._1._0.ctor === "TrLoc" && _p147._1._1._0._0.ctor === "_Tuple3" && _p147._1._1._1.ctor === "[]")
            {
                  switch (_p147._0.ctor)
                  {case "Minus": switch (_p147._1._1._0._0._2)
                       {case "nGroupPad": return {ctor: "_Tuple2"
                                                 ,_0: _p148 + 20
                                                 ,_1: _p147._1._0};
                          case "nPolyPathPad": return {ctor: "_Tuple2"
                                                      ,_0: _p148 + 10
                                                      ,_1: _p147._1._0};
                          default: break _v73_4;}
                     case "Plus": switch (_p147._1._1._0._0._2)
                       {case "nGroupPad": return {ctor: "_Tuple2"
                                                 ,_0: _p148 - 20
                                                 ,_1: _p147._1._0};
                          case "nPolyPathPad": return {ctor: "_Tuple2"
                                                      ,_0: _p148 - 10
                                                      ,_1: _p147._1._0};
                          default: break _v73_4;}
                     default: break _v73_4;}
               } else {
                  break _v73_4;
               }
         } while (false);
         return {ctor: "_Tuple2",_0: _p148,_1: _p149};
      };
      return {ctor: "_Tuple4"
             ,_0: clean(_p144._0)
             ,_1: clean(_p144._1)
             ,_2: clean(_p144._2)
             ,_3: clean(_p144._3)};
   };
   var computeSelectedBlobsAndBounds = function (model) {
      var tree = $Basics.snd(model.slate);
      return A2($Dict.map,
      F2(function (blobId,nodeId) {
         return undoGroupPadding(function () {
            var _p150 = A2($Dict.get,nodeId,tree);
            _v74_7: do {
               if (_p150.ctor === "Just" && _p150._0.ctor === "SvgNode") {
                     switch (_p150._0._0)
                     {case "BOX": var get = function (attr) {
                             return A3($LangSvg.findNumishAttr,nodeId,attr,_p150._0._1);
                          };
                          return {ctor: "_Tuple4"
                                 ,_0: get("LEFT")
                                 ,_1: get("TOP")
                                 ,_2: get("RIGHT")
                                 ,_3: get("BOT")};
                        case "OVAL": var get = function (attr) {
                             return A3($LangSvg.findNumishAttr,nodeId,attr,_p150._0._1);
                          };
                          return {ctor: "_Tuple4"
                                 ,_0: get("LEFT")
                                 ,_1: get("TOP")
                                 ,_2: get("RIGHT")
                                 ,_3: get("BOT")};
                        case "g": var _p151 = $LangSvg.maybeFindBounds(_p150._0._1);
                          if (_p151.ctor === "Just") {
                                return _p151._0;
                             } else {
                                return _U.crashCase("ExpressionBasedTransform",
                                {start: {line: 281,column: 12},end: {line: 283,column: 72}},
                                _p151)("computeSelectedBlobsAndBounds");
                             }
                        case "line": var get = function (attr) {
                             return A3($LangSvg.findNumishAttr,nodeId,attr,_p150._0._1);
                          };
                          var _p153 = {ctor: "_Tuple4"
                                      ,_0: get("x1")
                                      ,_1: get("y1")
                                      ,_2: get("x2")
                                      ,_3: get("y2")};
                          var x1 = _p153._0;
                          var y1 = _p153._1;
                          var x2 = _p153._2;
                          var y2 = _p153._3;
                          return {ctor: "_Tuple4"
                                 ,_0: A2($Lang.minNumTr,x1,x2)
                                 ,_1: A2($Lang.minNumTr,y1,y2)
                                 ,_2: A2($Lang.maxNumTr,x1,x2)
                                 ,_3: A2($Lang.maxNumTr,y1,y2)};
                        case "ellipse": var get = function (attr) {
                             return A3($LangSvg.findNumishAttr,nodeId,attr,_p150._0._1);
                          };
                          var _p154 = {ctor: "_Tuple4"
                                      ,_0: get("cx")
                                      ,_1: get("cy")
                                      ,_2: get("rx")
                                      ,_3: get("ry")};
                          var cx = _p154._0;
                          var cy = _p154._1;
                          var rx = _p154._2;
                          var ry = _p154._3;
                          return {ctor: "_Tuple4"
                                 ,_0: A2($Lang.minusNumTr,cx,rx)
                                 ,_1: A2($Lang.minusNumTr,cy,ry)
                                 ,_2: A2($Lang.plusNumTr,cx,rx)
                                 ,_3: A2($Lang.plusNumTr,cy,ry)};
                        case "circle": var get = function (attr) {
                             return A3($LangSvg.findNumishAttr,nodeId,attr,_p150._0._1);
                          };
                          var _p155 = {ctor: "_Tuple3"
                                      ,_0: get("cx")
                                      ,_1: get("cy")
                                      ,_2: get("r")};
                          var cx = _p155._0;
                          var cy = _p155._1;
                          var r = _p155._2;
                          return {ctor: "_Tuple4"
                                 ,_0: A2($Lang.minusNumTr,cx,r)
                                 ,_1: A2($Lang.minusNumTr,cy,r)
                                 ,_2: A2($Lang.plusNumTr,cx,r)
                                 ,_3: A2($Lang.plusNumTr,cy,r)};
                        case "rect": var get = function (attr) {
                             return A3($LangSvg.findNumishAttr,nodeId,attr,_p150._0._1);
                          };
                          var _p156 = {ctor: "_Tuple4"
                                      ,_0: get("x")
                                      ,_1: get("y")
                                      ,_2: get("width")
                                      ,_3: get("height")};
                          var x = _p156._0;
                          var y = _p156._1;
                          var width = _p156._2;
                          var height = _p156._3;
                          return {ctor: "_Tuple4"
                                 ,_0: x
                                 ,_1: y
                                 ,_2: A2($Lang.plusNumTr,x,width)
                                 ,_3: A2($Lang.plusNumTr,y,height)};
                        default: break _v74_7;}
                  } else {
                     break _v74_7;
                  }
            } while (false);
            return _U.crashCase("ExpressionBasedTransform",
            {start: {line: 268,column: 8},end: {line: 307,column: 58}},
            _p150)("computeSelectedBlobsAndBounds");
         }());
      }),
      model.selectedBlobs);
   };
   var occursFreeIn = F2(function (x,e) {
      var vars = A3($Lang.foldExpViaE__,
      F2(function (e__,acc) {
         var _p158 = e__;
         if (_p158.ctor === "EVar") {
               return A2($Set.insert,_p158._1,acc);
            } else {
               return acc;
            }
      }),
      $Set.empty,
      e);
      return A2($Set.member,x,vars);
   });
   var offsetXY = F7(function (base1,
   base2,
   baseVal1,
   baseVal2,
   ws,
   _p159,
   eSubst) {
      var _p160 = _p159;
      var _p164 = _p160._0;
      var _p161 = _p160._1;
      if (_p161.ctor === "TrLoc" && _p161._0.ctor === "_Tuple3") {
            var _p162 = {ctor: "_Tuple2"
                        ,_0: _p164 - $Basics.fst(baseVal1)
                        ,_1: _p164 - $Basics.fst(baseVal2)};
            var off1 = _p162._0;
            var off2 = _p162._1;
            var _p163 = _U.cmp(off1,
            $Basics.abs(off2)) < 1 ? {ctor: "_Tuple2"
                                     ,_0: base1
                                     ,_1: off1} : {ctor: "_Tuple2",_0: base2,_1: off2};
            var base = _p163._0;
            var off = _p163._1;
            var app = A2($Basics._op["++"],
            ws,
            $Utils.parens($Utils.spaces(_U.list(["evalOffset"
                                                ,$Utils.bracks($Utils.spaces(_U.list([base
                                                                                     ,$Basics.toString(off)])))]))));
            return A3($Dict.insert,
            _p161._0._0,
            A2($Lang.eRaw__,"",app),
            eSubst);
         } else {
            return eSubst;
         }
   });
   var scaleXY = F7(function (start,
   end,
   startVal,
   widthOrHeight,
   ws,
   _p165,
   eSubst) {
      var _p166 = _p165;
      var _p167 = _p166._1;
      if (_p167.ctor === "TrLoc" && _p167._0.ctor === "_Tuple3") {
            var pct = (_p166._0 - $Basics.fst(startVal)) / widthOrHeight;
            var app = _U.eq(pct,0) ? A2($Basics._op["++"],
            ws,
            start) : _U.eq(pct,1) ? A2($Basics._op["++"],
            ws,
            end) : A2($Basics._op["++"],
            ws,
            $Utils.parens($Utils.spaces(_U.list(["scaleBetween"
                                                ,start
                                                ,end
                                                ,$Basics.toString(pct)]))));
            return A3($Dict.insert,
            _p167._0._0,
            A2($Lang.eRaw__,"",app),
            eSubst);
         } else {
            return eSubst;
         }
   });
   var rewriteBoundingBoxesOfSelectedBlobs = F2(function (model,
   selectedBlobsAndBounds) {
      var selectedBlobIndices = $Dict.keys(model.selectedBlobs);
      var _p168 = function () {
         var _p169 = selectedBlobIndices;
         if (_p169.ctor === "[]") {
               return _U.crashCase("ExpressionBasedTransform",
               {start: {line: 329,column: 5},end: {line: 337,column: 31}},
               _p169)("groupAndRearrange: shouldn\'t get here");
            } else {
               var init = A2($Utils.justGet,
               _p169._0,
               selectedBlobsAndBounds);
               var foo = F2(function (j,_p171) {
                  var _p172 = _p171;
                  var _p173 = A2($Utils.justGet,j,selectedBlobsAndBounds);
                  var a = _p173._0;
                  var b = _p173._1;
                  var c = _p173._2;
                  var d = _p173._3;
                  return {ctor: "_Tuple4"
                         ,_0: A2($Lang.minNumTr,_p172._0,a)
                         ,_1: A2($Lang.minNumTr,_p172._1,b)
                         ,_2: A2($Lang.maxNumTr,_p172._2,c)
                         ,_3: A2($Lang.maxNumTr,_p172._3,d)};
               });
               return A3($List.foldl,foo,init,_p169._1);
            }
      }();
      var left = _p168._0;
      var top = _p168._1;
      var right = _p168._2;
      var bot = _p168._3;
      var _p174 = {ctor: "_Tuple2"
                  ,_0: $Basics.fst(right) - $Basics.fst(left)
                  ,_1: $Basics.fst(bot) - $Basics.fst(top)};
      var width = _p174._0;
      var height = _p174._1;
      var scaleX = A4(scaleXY,"left","right",left,width);
      var scaleY = A4(scaleXY,"top","bot",top,height);
      var offsetX = A4(offsetXY,"left","right",left,right);
      var offsetY = A4(offsetXY,"top","bot",top,bot);
      var eSubst = function () {
         var foo = F2(function (i,acc) {
            var _p175 = A2($Utils.justGet,i,selectedBlobsAndBounds);
            var a = _p175._0;
            var b = _p175._1;
            var c = _p175._2;
            var d = _p175._3;
            return _U.eq(model.keysDown,$Keys.shift) ? A3(offsetY,
            " ",
            d,
            A3(offsetX,
            " ",
            c,
            A3(offsetY," ",b,A3(offsetX,"",a,acc)))) : A3(scaleY,
            " ",
            d,
            A3(scaleX," ",c,A3(scaleY," ",b,A3(scaleX," ",a,acc))));
         });
         return A3($List.foldl,foo,$Dict.empty,selectedBlobIndices);
      }();
      var groupDefs = _U.list([{ctor: "_Tuple4"
                               ,_0: "\n  "
                               ,_1: A2($Lang.pAs,
                               "bounds",
                               $Lang.pList($Lang.listOfPVars(_U.list(["left"
                                                                     ,"top"
                                                                     ,"right"
                                                                     ,"bot"]))))
                               ,_2: A2($Lang.eList,
                               $Lang.listOfNums(_U.list([$Basics.fst(left)
                                                        ,$Basics.fst(top)
                                                        ,$Basics.fst(right)
                                                        ,$Basics.fst(bot)])),
                               $Maybe.Nothing)
                               ,_3: ""}]);
      return {ctor: "_Tuple2",_0: groupDefs,_1: eSubst};
   });
   var pluckFromList = F2(function (pred,xs) {
      var foo = F2(function (x,_p176) {
         var _p177 = _p176;
         var _p181 = _p177._0;
         var _p180 = _p177._1;
         var _p179 = _p177._2;
         var _p178 = {ctor: "_Tuple2",_0: pred(x),_1: _p181};
         if (_p178._0 === true) {
               return {ctor: "_Tuple3"
                      ,_0: A2($Basics._op["++"],_p181,_U.list([x]))
                      ,_1: _p180
                      ,_2: _p179};
            } else {
               if (_p178._1.ctor === "[]") {
                     return {ctor: "_Tuple3"
                            ,_0: _p181
                            ,_1: A2($Basics._op["++"],_p180,_U.list([x]))
                            ,_2: _p179};
                  } else {
                     return {ctor: "_Tuple3"
                            ,_0: _p181
                            ,_1: _p180
                            ,_2: A2($Basics._op["++"],_p179,_U.list([x]))};
                  }
            }
      });
      return A3($List.foldl,
      foo,
      {ctor: "_Tuple3"
      ,_0: _U.list([])
      ,_1: _U.list([])
      ,_2: _U.list([])},
      xs);
   });
   var unsafePluckFromList = F2(function (pred,xs) {
      var _p182 = A2(pluckFromList,pred,$List.reverse(xs));
      var plucked = _p182._0;
      var before = _p182._1;
      var after = _p182._2;
      return {ctor: "_Tuple3"
             ,_0: $List.reverse(plucked)
             ,_1: $List.reverse(after)
             ,_2: $List.reverse(before)};
   });
   var matchesAnySelectedCallBlob_ = F2(function (selectedNiceBlobs,
   def) {
      var findBlobForIdent = function (y) {
         var foo = function (_p183) {
            var _p184 = _p183;
            var _p185 = _p184._2;
            switch (_p185.ctor)
            {case "VarBlob": return false;
               case "WithBoundsBlob": return _U.eq(_p185._0._1,y);
               case "WithAnchorBlob": return _U.eq(_p185._0._1,y);
               default: return _U.eq(_p185._0._0,y);}
         };
         var _p186 = A2($Utils.findFirst,foo,selectedNiceBlobs);
         _v87_3: do {
            if (_p186.ctor === "Just" && _p186._0.ctor === "_Tuple3") {
                  switch (_p186._0._2.ctor)
                  {case "CallBlob": if (_p186._0._2._0.ctor === "_Tuple2") {
                             return $Maybe.Just(_p186._0._2._0._0);
                          } else {
                             break _v87_3;
                          }
                     case "WithBoundsBlob": if (_p186._0._2._0.ctor === "_Tuple3") {
                             return $Maybe.Just(_p186._0._2._0._1);
                          } else {
                             break _v87_3;
                          }
                     case "WithAnchorBlob": if (_p186._0._2._0.ctor === "_Tuple3") {
                             return $Maybe.Just(_p186._0._2._0._1);
                          } else {
                             break _v87_3;
                          }
                     default: break _v87_3;}
               } else {
                  break _v87_3;
               }
         } while (false);
         return $Maybe.Nothing;
      };
      var _p187 = def;
      var p = _p187._1;
      var _p188 = p.val;
      switch (_p188.ctor)
      {case "PVar": return findBlobForIdent(_p188._1);
         case "PAs": return findBlobForIdent(_p188._1);
         default: return $Maybe.Nothing;}
   });
   var matchesAnySelectedCallBlob = F2(function (selectedNiceBlobs,
   def) {
      var _p189 = A2(matchesAnySelectedCallBlob_,
      selectedNiceBlobs,
      def);
      if (_p189.ctor === "Just") {
            return true;
         } else {
            return false;
         }
   });
   var matchesAnySelectedVarBlob_ = F2(function (selectedNiceBlobs,
   def) {
      var findBlobForIdent = function (y) {
         var foo = function (_p190) {
            var _p191 = _p190;
            var _p192 = _p191._2;
            switch (_p192.ctor)
            {case "VarBlob": return _U.eq(_p192._0,y);
               case "WithBoundsBlob": return false;
               case "WithAnchorBlob": return false;
               default: return false;}
         };
         var _p193 = A2($Utils.findFirst,foo,selectedNiceBlobs);
         if (_p193.ctor === "Just" && _p193._0.ctor === "_Tuple3" && _p193._0._2.ctor === "VarBlob")
         {
               return $Maybe.Just(_p193._0._2._0);
            } else {
               return $Maybe.Nothing;
            }
      };
      var _p194 = def;
      var p = _p194._1;
      var _p195 = p.val;
      switch (_p195.ctor)
      {case "PVar": return findBlobForIdent(_p195._1);
         case "PAs": return findBlobForIdent(_p195._1);
         default: return $Maybe.Nothing;}
   });
   var matchesAnySelectedVarBlob = F2(function (selectedNiceBlobs,
   def) {
      var _p196 = A2(matchesAnySelectedVarBlob_,
      selectedNiceBlobs,
      def);
      if (_p196.ctor === "Just") {
            return true;
         } else {
            return false;
         }
   });
   var abstractOne = F2(function (_p198,_p197) {
      var _p199 = _p198;
      var _p225 = _p199._0;
      var _p200 = _p197;
      var _p224 = _p200._0;
      var _p223 = _p200._1;
      var _p201 = A2(pluckFromList,
      matchesAnySelectedVarBlob(_U.list([{ctor: "_Tuple3"
                                         ,_0: _p225
                                         ,_1: _p199._1
                                         ,_2: $Blobs.VarBlob(_p199._2)}])),
      _p224);
      var pluckedDefs = _p201._0;
      var beforeDefs = _p201._1;
      var afterDefs = _p201._2;
      var _p202 = function () {
         var matches = function (_p203) {
            var _p204 = _p203;
            return _U.eq(_p225,_p204._0);
         };
         var _p205 = A2(pluckFromList,
         matches,
         A2($Utils.zip,_U.range(1,$List.length(_p223)),_p223));
         var plucked = _p205._0;
         var before = _p205._1;
         var after = _p205._2;
         return {ctor: "_Tuple3"
                ,_0: A2($List.map,$Basics.snd,plucked)
                ,_1: A2($List.map,$Basics.snd,before)
                ,_2: A2($List.map,$Basics.snd,after)};
      }();
      var pluckedBlobs = _p202._0;
      var beforeBlobs = _p202._1;
      var afterBlobs = _p202._2;
      var _p206 = {ctor: "_Tuple2",_0: pluckedDefs,_1: pluckedBlobs};
      if (_p206.ctor === "_Tuple2" && _p206._0.ctor === "::" && _p206._0._0.ctor === "_Tuple4" && _p206._0._1.ctor === "[]" && _p206._1.ctor === "::" && _p206._1._0.ctor === "NiceBlob" && _p206._1._0._1.ctor === "VarBlob" && _p206._1._1.ctor === "[]")
      {
            var _p221 = _p206._1._0._1._0;
            var _p220 = _p206._0._0._3;
            var _p219 = _p206._0._0._0;
            var _p218 = _p206._0._0._1;
            var _p207 = collectUnfrozenConstants(_p206._0._0._2);
            var e$ = _p207._0;
            var mapping = _p207._1;
            var _p208 = function () {
               var _p209 = findSpecialBindingsInMapping(mapping);
               if (_p209.ctor === "Just") {
                     if (_p209._0._1.ctor === "BoundsBindings") {
                           var _p212 = _p209._0._0;
                           var newFunc = function () {
                              var pBounds = function () {
                                 var pVars = $Lang.listOfPVars(_U.list(["left"
                                                                       ,"top"
                                                                       ,"right"
                                                                       ,"bot"]));
                                 var _p210 = _p212;
                                 if (_p210.ctor === "[]") {
                                       return $Lang.pList0(pVars);
                                    } else {
                                       return $Lang.pList(pVars);
                                    }
                              }();
                              var params = $Lang.listOfPVars(A2($List.map,$Basics.fst,_p212));
                              return $Lang.withDummyPos(A4($Lang.EFun,
                              " ",
                              A2($Basics._op["++"],params,_U.list([pBounds])),
                              e$,
                              ""));
                           }();
                           var eBounds = A2($Lang.eList,
                           $Lang.listOfAnnotatedNums(_U.list([_p209._0._1._0
                                                             ,_p209._0._1._1
                                                             ,_p209._0._1._2
                                                             ,_p209._0._1._3])),
                           $Maybe.Nothing);
                           var newCall = function () {
                              var eBlah = function () {
                                 var _p211 = $Lang.listOfAnnotatedNums1(A2($List.map,
                                 $Basics.snd,
                                 _p212));
                                 if (_p211.ctor === "[]") {
                                       return $Lang.eVar(_p221);
                                    } else {
                                       return $Lang.withDummyPos(A4($Lang.EApp,
                                       "\n    ",
                                       $Lang.eVar0(_p221),
                                       _p211,
                                       ""));
                                    }
                              }();
                              return $Lang.withDummyPos(A4($Lang.EApp,
                              "\n  ",
                              $Lang.eVar0("withBounds"),
                              _U.list([eBounds,eBlah]),
                              ""));
                           }();
                           var newBlob = A2($Blobs.NiceBlob,
                           newCall,
                           $Blobs.WithBoundsBlob({ctor: "_Tuple3"
                                                 ,_0: eBounds
                                                 ,_1: _p221
                                                 ,_2: _U.list([])}));
                           return {ctor: "_Tuple2"
                                  ,_0: {ctor: "_Tuple4",_0: _p219,_1: _p218,_2: newFunc,_3: _p220}
                                  ,_1: newBlob};
                        } else {
                           var _p215 = _p209._0._0;
                           var newFunc = function () {
                              var pBounds = function () {
                                 var pVars = $Lang.listOfPVars(_U.list(["xAnchor"
                                                                       ,"yAnchor"]));
                                 var _p213 = _p215;
                                 if (_p213.ctor === "[]") {
                                       return $Lang.pList0(pVars);
                                    } else {
                                       return $Lang.pList(pVars);
                                    }
                              }();
                              var params = $Lang.listOfPVars(A2($List.map,$Basics.fst,_p215));
                              return $Lang.withDummyPos(A4($Lang.EFun,
                              " ",
                              A2($Basics._op["++"],
                              params,
                              _U.list([A2(pAsTight,"anchor",pBounds)])),
                              e$,
                              ""));
                           }();
                           var eAnchor = eAsPoint(A2($Lang.eList,
                           $Lang.listOfAnnotatedNums(_U.list([_p209._0._1._0
                                                             ,_p209._0._1._1])),
                           $Maybe.Nothing));
                           var newCall = function () {
                              var eBlah = function () {
                                 var _p214 = $Lang.listOfAnnotatedNums1(A2($List.map,
                                 $Basics.snd,
                                 _p215));
                                 if (_p214.ctor === "[]") {
                                       return $Lang.eVar(_p221);
                                    } else {
                                       return $Lang.withDummyPos(A4($Lang.EApp,
                                       " ",
                                       $Lang.eVar0(_p221),
                                       _p214,
                                       ""));
                                    }
                              }();
                              return $Lang.withDummyPos(A4($Lang.EApp,
                              "\n  ",
                              $Lang.eVar0("withAnchor"),
                              _U.list([eAnchor,eBlah]),
                              ""));
                           }();
                           var newBlob = A2($Blobs.NiceBlob,
                           newCall,
                           $Blobs.WithAnchorBlob({ctor: "_Tuple3"
                                                 ,_0: eAnchor
                                                 ,_1: _p221
                                                 ,_2: _U.list([])}));
                           return {ctor: "_Tuple2"
                                  ,_0: {ctor: "_Tuple4",_0: _p219,_1: _p218,_2: newFunc,_3: _p220}
                                  ,_1: newBlob};
                        }
                  } else {
                     var newFunc = function () {
                        var params = $Lang.listOfPVars(A2($List.map,
                        $Basics.fst,
                        mapping));
                        return $Lang.withDummyPos(A4($Lang.EFun," ",params,e$,""));
                     }();
                     var newBlob = function () {
                        var _p216 = $Lang.listOfAnnotatedNums1(A2($List.map,
                        $Basics.snd,
                        mapping));
                        if (_p216.ctor === "[]") {
                              return A2($Blobs.varBlob,$Lang.eVar(_p221),_p221);
                           } else {
                              var _p217 = _p216;
                              var newCall = $Lang.withDummyPos(A4($Lang.EApp,
                              "\n  ",
                              $Lang.eVar0(_p221),
                              _p217,
                              ""));
                              return A2($Blobs.callBlob,
                              newCall,
                              {ctor: "_Tuple2",_0: _p221,_1: _p217});
                           }
                     }();
                     return {ctor: "_Tuple2"
                            ,_0: {ctor: "_Tuple4",_0: _p219,_1: _p218,_2: newFunc,_3: _p220}
                            ,_1: newBlob};
                  }
            }();
            var newDef = _p208._0;
            var newBlob = _p208._1;
            var defs$ = A2($Basics._op["++"],
            beforeDefs,
            A2($Basics._op["++"],_U.list([newDef]),afterDefs));
            var blobs$ = A2($Basics._op["++"],
            beforeBlobs,
            A2($Basics._op["++"],_U.list([newBlob]),afterBlobs));
            return {ctor: "_Tuple2",_0: defs$,_1: blobs$};
         } else {
            var _p222 = $Debug.log("abstractOne: multiple defs...");
            return {ctor: "_Tuple2",_0: _p224,_1: _p223};
         }
   });
   var mergeSelectedVarBlobs = F4(function (model,
   defs,
   blobs,
   selectedVarBlobs) {
      var _p226 = function () {
         var selectedNiceBlobs = A2($List.map,
         function (_p227) {
            var _p228 = _p227;
            return {ctor: "_Tuple3"
                   ,_0: _p228._0
                   ,_1: _p228._1
                   ,_2: $Blobs.VarBlob(_p228._2)};
         },
         selectedVarBlobs);
         return A2(pluckFromList,
         matchesAnySelectedVarBlob(selectedNiceBlobs),
         defs);
      }();
      var pluckedDefs = _p226._0;
      var beforeDefs = _p226._1;
      var afterDefs = _p226._2;
      var _p229 = function () {
         var matches = function (_p230) {
            var _p231 = _p230;
            return A2($Dict.member,_p231._0,model.selectedBlobs);
         };
         var _p232 = A2(pluckFromList,
         matches,
         A2($Utils.zip,_U.range(1,$List.length(blobs)),blobs));
         var plucked = _p232._0;
         var before = _p232._1;
         var after = _p232._2;
         return {ctor: "_Tuple3"
                ,_0: A2($List.map,$Basics.snd,plucked)
                ,_1: A2($List.map,$Basics.snd,before)
                ,_2: A2($List.map,$Basics.snd,after)};
      }();
      var pluckedBlobs = _p229._0;
      var beforeBlobs = _p229._1;
      var afterBlobs = _p229._2;
      var _p233 = function () {
         var _p234 = pluckedDefs;
         if (_p234.ctor === "::") {
               return {ctor: "_Tuple2"
                      ,_0: _p234._0
                      ,_1: A2($List.map,
                      function (_p235) {
                         var _p236 = _p235;
                         return _p236._2;
                      },
                      _p234._1)};
            } else {
               return _U.crashCase("ExpressionBasedTransform",
               {start: {line: 954,column: 5},end: {line: 956,column: 76}},
               _p234)("mergeSelectedVarBlobs: shouldn\'t get here");
            }
      }();
      var ws1 = _p233._0._0;
      var p = _p233._0._1;
      var e = _p233._0._2;
      var ws2 = _p233._0._3;
      var es = _p233._1;
      var _p238 = A2(mergeExpressions,e,es);
      if (_p238.ctor === "Nothing") {
            return {ctor: "_Tuple2",_0: defs,_1: blobs};
         } else {
            if (_p238._0._1.ctor === "[]") {
                  var defs$ = A2($Basics._op["++"],
                  beforeDefs,
                  A2($Basics._op["++"],
                  _U.list([{ctor: "_Tuple4",_0: ws1,_1: p,_2: e,_3: ws2}]),
                  afterDefs));
                  var blobs$ = A2($Basics._op["++"],
                  beforeBlobs,
                  A2($Basics._op["++"],
                  _U.list([$Utils.head_(pluckedBlobs)]),
                  afterBlobs));
                  return {ctor: "_Tuple2",_0: defs$,_1: blobs$};
               } else {
                  var _p243 = _p238._0._1;
                  var newDef = function () {
                     var newFunc = function () {
                        var params = $Lang.listOfPVars(A2($List.map,
                        $Basics.fst,
                        _p243));
                        return $Lang.withDummyPos(A4($Lang.EFun,
                        " ",
                        params,
                        clean(_p238._0._0),
                        ""));
                     }();
                     return {ctor: "_Tuple4",_0: ws1,_1: p,_2: newFunc,_3: ws2};
                  }();
                  var f = function () {
                     var _p239 = p.val;
                     if (_p239.ctor === "PVar") {
                           return _p239._1;
                        } else {
                           return _U.crashCase("ExpressionBasedTransform",
                           {start: {line: 979,column: 9},end: {line: 981,column: 61}},
                           _p239)("mergeSelected: not var");
                        }
                  }();
                  var newBlobs = function () {
                     var _p241 = $Utils.maybeZipN(A2($List.map,
                     $Basics.snd,
                     _p243));
                     if (_p241.ctor === "Nothing") {
                           return _U.crashCase("ExpressionBasedTransform",
                           {start: {line: 984,column: 9},end: {line: 993,column: 26}},
                           _p241)("mergeSelected: no arg lists?");
                        } else {
                           return A2($List.map,
                           function (nums) {
                              var args = $Lang.listOfAnnotatedNums1(nums);
                              var e = $Lang.withDummyPos(A4($Lang.EApp,
                              "\n  ",
                              $Lang.eVar0(f),
                              args,
                              ""));
                              return A2($Blobs.callBlob,e,{ctor: "_Tuple2",_0: f,_1: args});
                           },
                           _p241._0);
                        }
                  }();
                  var defs$ = A2($Basics._op["++"],
                  beforeDefs,
                  A2($Basics._op["++"],_U.list([newDef]),afterDefs));
                  var blobs$ = A2($Basics._op["++"],
                  beforeBlobs,
                  A2($Basics._op["++"],newBlobs,afterBlobs));
                  return {ctor: "_Tuple2",_0: defs$,_1: blobs$};
               }
         }
   });
   var matchesAnySelectedBlob = F2(function (selectedNiceBlobs,
   def) {
      var _p244 = A2(matchesAnySelectedVarBlob_,
      selectedNiceBlobs,
      def);
      if (_p244.ctor === "Just") {
            return true;
         } else {
            var _p245 = A2(matchesAnySelectedCallBlob_,
            selectedNiceBlobs,
            def);
            if (_p245.ctor === "Just") {
                  return true;
               } else {
                  return false;
               }
         }
   });
   var groupAndRearrange = F8(function (model,
   newGroup,
   defs,
   blobs,
   selectedNiceBlobs,
   groupDefs,
   eSubst,
   finalExpOfNewGroup) {
      var _p246 = function () {
         var indexedBlobs = A2($Utils.zip,
         _U.range(1,$List.length(blobs)),
         blobs);
         var matches = function (_p247) {
            var _p248 = _p247;
            return A2($Dict.member,_p248._0,model.selectedBlobs);
         };
         var _p249 = A2(pluckFromList,matches,indexedBlobs);
         var plucked_ = _p249._0;
         var before_ = _p249._1;
         var after_ = _p249._2;
         return {ctor: "_Tuple3"
                ,_0: A2($List.map,$Basics.snd,plucked_)
                ,_1: A2($List.map,$Basics.snd,before_)
                ,_2: A2($List.map,$Basics.snd,after_)};
      }();
      var pluckedBlobs = _p246._0;
      var beforeBlobs = _p246._1;
      var afterBlobs = _p246._2;
      var defs$ = function () {
         var matches = matchesAnySelectedBlob(selectedNiceBlobs);
         var _p250 = function () {
            var _p251 = A2(unsafePluckFromList,matches,defs);
            var plucked = _p251._0;
            var before = _p251._1;
            var after = _p251._2;
            var getExps = $List.map(function (_p252) {
               var _p253 = _p252;
               return _p253._2;
            });
            var _p254 = A3($List.foldr,
            F2(function (beforeDef,_p255) {
               var _p256 = _p255;
               var _p259 = _p256._1;
               var _p258 = _p256._0;
               var _p257 = beforeDef;
               var p = _p257._1;
               var vars = $Lang.varsOfPat(p);
               var someVarAppearsIn = function (e) {
                  return A2($List.any,
                  function (x) {
                     return A2(occursFreeIn,x,e);
                  },
                  vars);
               };
               var noVarAppearsIn = function (e) {
                  return A2($List.all,
                  function (x) {
                     return $Basics.not(A2(occursFreeIn,x,e));
                  },
                  vars);
               };
               return A2($List.any,
               someVarAppearsIn,
               getExps(A2($Basics._op["++"],plucked,_p258))) && A2($List.all,
               noVarAppearsIn,
               getExps(A2($Basics._op["++"],after,_p259))) ? {ctor: "_Tuple2"
                                                             ,_0: A2($List._op["::"],beforeDef,_p258)
                                                             ,_1: _p259} : {ctor: "_Tuple2"
                                                                           ,_0: _p258
                                                                           ,_1: A2($List._op["::"],beforeDef,_p259)};
            }),
            {ctor: "_Tuple2",_0: _U.list([]),_1: _U.list([])},
            before);
            var beforeInside = _p254._0;
            var beforeOutside = _p254._1;
            return {ctor: "_Tuple3"
                   ,_0: A2($Basics._op["++"],beforeInside,plucked)
                   ,_1: beforeOutside
                   ,_2: after};
         }();
         var pluckedDefs = _p250._0;
         var beforeDefs = _p250._1;
         var afterDefs = _p250._2;
         var listGroup = function () {
            var pluckedBlobs$ = A2($List.map,
            function (_p260) {
               return A2($LangUnparser.replacePrecedingWhitespace,
               " ",
               $Blobs.fromBlobExp(_p260));
            },
            pluckedBlobs);
            return finalExpOfNewGroup(pluckedBlobs$);
         }();
         var pluckedDefs$ = function () {
            var tab = "  ";
            return A2($List.map,
            function (_p261) {
               var _p262 = _p261;
               return {ctor: "_Tuple4"
                      ,_0: A2($Basics._op["++"],_p262._0,tab)
                      ,_1: _p262._1
                      ,_2: A2($LangUnparser.indent,tab,_p262._2)
                      ,_3: _p262._3};
            },
            pluckedDefs);
         }();
         var newGroupExp = A2($Lang.applyESubst,
         eSubst,
         $Blobs.fuseExp({ctor: "_Tuple2"
                        ,_0: A2($Basics._op["++"],groupDefs,pluckedDefs$)
                        ,_1: $Blobs.OtherExp(listGroup)}));
         var newDef = {ctor: "_Tuple4"
                      ,_0: "\n\n"
                      ,_1: $Lang.pVar(newGroup)
                      ,_2: newGroupExp
                      ,_3: ""};
         return A2($Basics._op["++"],
         beforeDefs,
         A2($Basics._op["++"],afterDefs,_U.list([newDef])));
      }();
      var blobs$ = function () {
         var newBlob = A2($Blobs.varBlob,
         $Lang.withDummyPos(A2($Lang.EVar,"\n  ",newGroup)),
         newGroup);
         return A2($Basics._op["++"],
         beforeBlobs,
         A2($Basics._op["++"],_U.list([newBlob]),afterBlobs));
      }();
      return {ctor: "_Tuple2",_0: defs$,_1: blobs$};
   });
   var selectedBlobsToSelectedNiceBlobs = F2(function (model,
   blobs) {
      var selectedExps = A2($List.filter,
      function (_p263) {
         return A3($Basics.flip,
         $Dict.member,
         model.selectedBlobs,
         $Basics.fst(_p263));
      },
      A2($Utils.zip,_U.range(1,$List.length(blobs)),blobs));
      return $Utils.filterJusts(A2($List.map,
      function (_p264) {
         var _p265 = _p264;
         var _p266 = _p265._1;
         if (_p266.ctor === "NiceBlob") {
               return $Maybe.Just({ctor: "_Tuple3"
                                  ,_0: _p265._0
                                  ,_1: _p266._0
                                  ,_2: _p266._1});
            } else {
               return $Maybe.Nothing;
            }
      },
      selectedExps));
   });
   var groupSelectedBlobs = F2(function (model,_p267) {
      var _p268 = _p267;
      var _p271 = _p268._1;
      var selectedNiceBlobs = A2(selectedBlobsToSelectedNiceBlobs,
      model,
      _p271);
      var selectedBlobsAndBounds = computeSelectedBlobsAndBounds(model);
      var newGroup = A2($Basics._op["++"],
      "newGroup",
      $Basics.toString(model.genSymCount));
      var _p269 = A2(rewriteBoundingBoxesOfSelectedBlobs,
      model,
      selectedBlobsAndBounds);
      var groupDefs = _p269._0;
      var eSubst = _p269._1;
      var _p270 = A8(groupAndRearrange,
      model,
      newGroup,
      _p268._0,
      _p271,
      selectedNiceBlobs,
      groupDefs,
      eSubst,
      function (pluckedBlobs$) {
         return $Lang.withDummyPos(A5($Lang.EList,
         "\n\n  ",
         _U.list([$Lang.withDummyPos(A4($Lang.EApp,
         " ",
         $Lang.eVar0("group"),
         _U.list([$Lang.eVar("bounds")
                 ,$Lang.withDummyPos(A4($Lang.EApp,
                 " ",
                 $Lang.eVar0("concat"),
                 _U.list([$Lang.withDummyPos(A5($Lang.EList,
                 " ",
                 pluckedBlobs$,
                 "",
                 $Maybe.Nothing,
                 " "))]),
                 ""))]),
         ""))]),
         "",
         $Maybe.Nothing,
         " "));
      });
      var defs$ = _p270._0;
      var blobs$ = _p270._1;
      var code$ = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                       ,_0: defs$
                                                       ,_1: A2($Blobs.Blobs,blobs$,_p268._2)}));
      return _U.update(model,
      {code: code$
      ,genSymCount: model.genSymCount + 1
      ,selectedBlobs: $Dict.empty});
   });
   var groupSelectedBlobsAround = F3(function (model,_p273,_p272) {
      var _p274 = _p273;
      var _p284 = _p274._1;
      var _p275 = _p272;
      var _p283 = _p275._0;
      var _p276 = A3($LangSvg.justGetSvgNode,
      "groupSelectedBlobsAround",
      _p283,
      model.slate);
      var anchorKind = _p276._0;
      var anchorAttrs = _p276._1;
      var _p277 = A4($ShapeWidgets.getPointEquations,
      _p283,
      anchorKind,
      anchorAttrs,
      _p275._1);
      if (_p277.ctor === "_Tuple2" && _p277._0.ctor === "EqnNum" && _p277._0._0.ctor === "_Tuple2" && _p277._1.ctor === "EqnNum" && _p277._1._0.ctor === "_Tuple2")
      {
            var _p278 = {ctor: "_Tuple2"
                        ,_0: _p277._0._0._1
                        ,_1: _p277._1._0._1};
            if (_p278.ctor === "_Tuple2" && _p278._0.ctor === "TrLoc" && _p278._1.ctor === "TrLoc")
            {
                  var selectedNiceBlobs = A2(selectedBlobsToSelectedNiceBlobs,
                  model,
                  _p284);
                  var newGroup = A2($Basics._op["++"],
                  "newGroup",
                  $Basics.toString(model.genSymCount));
                  var _p279 = A3(rewritePrimitivePointsOfSelectedBlobs,
                  model,
                  {ctor: "_Tuple2",_0: _p277._0._0._0,_1: _p278._0._0},
                  {ctor: "_Tuple2",_0: _p277._1._0._0,_1: _p278._1._0});
                  var groupDefs = _p279._0;
                  var eSubst = _p279._1;
                  var _p280 = A8(groupAndRearrange,
                  model,
                  newGroup,
                  _p274._0,
                  _p284,
                  selectedNiceBlobs,
                  groupDefs,
                  eSubst,
                  function (pluckedBlobs$) {
                     return $Lang.withDummyPos(A5($Lang.EList,
                     "\n\n  ",
                     _U.list([$Lang.withDummyPos(A4($Lang.EApp,
                     " ",
                     $Lang.eVar0("anchoredGroup"),
                     _U.list([$Lang.withDummyPos(A4($Lang.EApp,
                     " ",
                     $Lang.eVar0("concat"),
                     _U.list([$Lang.withDummyPos(A5($Lang.EList,
                     " ",
                     pluckedBlobs$,
                     "",
                     $Maybe.Nothing,
                     " "))]),
                     ""))]),
                     ""))]),
                     "",
                     $Maybe.Nothing,
                     " "));
                  });
                  var defs$ = _p280._0;
                  var blobs$ = _p280._1;
                  var code$ = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                                   ,_0: defs$
                                                                   ,_1: A2($Blobs.Blobs,blobs$,_p274._2)}));
                  return _U.update(model,
                  {code: code$
                  ,genSymCount: model.genSymCount + 1
                  ,selectedBlobs: $Dict.empty
                  ,selectedFeatures: $Set.empty});
               } else {
                  var _p281 = A2($Debug.log,
                  "WARN: anchor must be defined by constants",
                  {ctor: "_Tuple0"});
                  return model;
               }
         } else {
            var _p282 = A2($Debug.log,
            "WARN: for now, anchor must be a primitive point",
            {ctor: "_Tuple0"});
            return model;
         }
   });
   var selectedBlobsToSelectedVarBlobs = F2(function (model,
   blobs) {
      return A2($List.concatMap,
      function (_p285) {
         var _p286 = _p285;
         var _p287 = _p286._2;
         switch (_p287.ctor)
         {case "VarBlob": return _U.list([{ctor: "_Tuple3"
                                          ,_0: _p286._0
                                          ,_1: _p286._1
                                          ,_2: _p287._0}]);
            case "WithBoundsBlob": return _U.list([]);
            case "WithAnchorBlob": return _U.list([]);
            default: return _U.list([]);}
      },
      A2(selectedBlobsToSelectedNiceBlobs,model,blobs));
   });
   var abstractSelectedBlobs = function (model) {
      var _p288 = $Blobs.splitExp(model.inputExp);
      var defs = _p288._0;
      var mainExp = _p288._1;
      var _p289 = mainExp;
      if (_p289.ctor === "Blobs") {
            var _p291 = _p289._0;
            var selectedVars = A2(selectedBlobsToSelectedVarBlobs,
            model,
            _p291);
            var _p290 = A3($List.foldl,
            abstractOne,
            {ctor: "_Tuple2",_0: defs,_1: _p291},
            selectedVars);
            var defs$ = _p290._0;
            var blobs$ = _p290._1;
            var code$ = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                             ,_0: defs$
                                                             ,_1: A2($Blobs.Blobs,blobs$,_p289._1)}));
            return _U.update(model,
            {code: code$,selectedBlobs: $Dict.empty});
         } else {
            return model;
         }
   };
   var mergeSelectedBlobs = function (model) {
      var _p292 = $Blobs.splitExp(model.inputExp);
      var defs = _p292._0;
      var mainExp = _p292._1;
      var _p293 = mainExp;
      if (_p293.ctor === "Blobs") {
            var _p295 = _p293._0;
            var selectedVarBlobs = A2(selectedBlobsToSelectedVarBlobs,
            model,
            _p295);
            if (!_U.eq($List.length(selectedVarBlobs),
            $Dict.size(model.selectedBlobs))) return model; else {
                  var _p294 = A4(mergeSelectedVarBlobs,
                  model,
                  defs,
                  _p295,
                  selectedVarBlobs);
                  var defs$ = _p294._0;
                  var blobs$ = _p294._1;
                  var code$ = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                                   ,_0: defs$
                                                                   ,_1: A2($Blobs.Blobs,blobs$,_p293._1)}));
                  return _U.update(model,
                  {code: code$,selectedBlobs: $Dict.empty});
               }
         } else {
            return model;
         }
   };
   var replicateSelectedBlob = F3(function (replicateKind,
   model,
   _p296) {
      var _p297 = _p296;
      var _p313 = _p297._2;
      var _p312 = _p297._0;
      var _p311 = _p297._1;
      var _p298 = A2(selectedBlobsToSelectedNiceBlobs,model,_p311);
      _v130_2: do {
         if (_p298.ctor === "::" && _p298._0.ctor === "_Tuple3" && _p298._1.ctor === "[]")
         {
               switch (_p298._0._2.ctor)
               {case "WithAnchorBlob": if (_p298._0._2._0.ctor === "_Tuple3") {
                          var _p303 = _p298._0._2._0._0;
                          var eGroupFunc = $Lang.withDummyPos(A4($Lang.EApp,
                          "\n    ",
                          $Lang.eVar0(_p298._0._2._0._1),
                          _p298._0._2._0._2,
                          ""));
                          var eAnchor = A2($LangUnparser.replacePrecedingWhitespace,
                          "\n    ",
                          _p303);
                          var _p299 = function () {
                             var _p300 = replicateKind;
                             switch (_p300.ctor)
                             {case "HorizontalRepeat":
                                var eNum = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  3,
                                  $Lang.dummyLoc_($Lang.frozen),
                                  A2($Lang.intSlider,1,20)));
                                  var eSep = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  20,
                                  $Lang.dummyLoc,
                                  $Lang.noWidgetDecl));
                                  return {ctor: "_Tuple2"
                                         ,_0: "horizontalArray"
                                         ,_1: _U.list([eNum,eSep,eGroupFunc,eAnchor])};
                                case "LinearRepeat":
                                var eNum = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  3,
                                  $Lang.dummyLoc_($Lang.frozen),
                                  A2($Lang.intSlider,1,20)));
                                  var eStart = A2($LangUnparser.replacePrecedingWhitespace,
                                  "\n    ",
                                  _p303);
                                  var eEnd = function () {
                                     var _p301 = stripPointExp(_p303);
                                     if (_p301.ctor === "Nothing") {
                                           return eAnchor;
                                        } else {
                                           var ex$ = A2($Lang.eConst0,_p301._0._0 + 100,$Lang.dummyLoc);
                                           var ey$ = A2($Lang.eConst,_p301._0._1 + 50,$Lang.dummyLoc);
                                           return A2($LangUnparser.replacePrecedingWhitespace,
                                           "\n    ",
                                           eAsPoint(A2($Lang.eList,_U.list([ex$,ey$]),$Maybe.Nothing)));
                                        }
                                  }();
                                  return {ctor: "_Tuple2"
                                         ,_0: "linearArrayFromTo"
                                         ,_1: _U.list([eNum,eGroupFunc,eStart,eEnd])};
                                default: var nRadius = 100;
                                  var eNum = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  3,
                                  $Lang.dummyLoc_($Lang.frozen),
                                  A2($Lang.intSlider,1,20)));
                                  var eRadius = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  nRadius,
                                  $Lang.dummyLoc_($Lang.unann),
                                  $Lang.noWidgetDecl));
                                  var eRot = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  0,
                                  $Lang.dummyLoc_($Lang.frozen),
                                  A2($Lang.numSlider,0,6.28)));
                                  var eCenter = function () {
                                     var _p302 = stripPointExp(_p303);
                                     if (_p302.ctor === "Nothing") {
                                           return eAnchor;
                                        } else {
                                           var ex$ = A2($Lang.eConst0,_p302._0._0,$Lang.dummyLoc);
                                           var ey$ = A2($Lang.eConst,_p302._0._1 + nRadius,$Lang.dummyLoc);
                                           return A2($LangUnparser.replacePrecedingWhitespace,
                                           "\n    ",
                                           eAsPoint(A2($Lang.eList,_U.list([ex$,ey$]),$Maybe.Nothing)));
                                        }
                                  }();
                                  return {ctor: "_Tuple2"
                                         ,_0: "radialArray"
                                         ,_1: _U.list([eNum,eRadius,eRot,eGroupFunc,eCenter])};}
                          }();
                          var arrayFunction = _p299._0;
                          var arrayArgs = _p299._1;
                          var newBlob = A2($Blobs.NiceBlob,
                          $Lang.withDummyPos(A4($Lang.EApp,
                          "\n  ",
                          $Lang.eVar0(arrayFunction),
                          arrayArgs,
                          "")),
                          $Blobs.CallBlob({ctor: "_Tuple2"
                                          ,_0: arrayFunction
                                          ,_1: arrayArgs}));
                          var blobs$ = A3($Utils.replacei,_p298._0._0,newBlob,_p311);
                          var code$ = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                                           ,_0: _p312
                                                                           ,_1: A2($Blobs.Blobs,blobs$,_p313)}));
                          return _U.update(model,
                          {code: code$,selectedBlobs: $Dict.empty});
                       } else {
                          break _v130_2;
                       }
                  case "WithBoundsBlob": if (_p298._0._2._0.ctor === "_Tuple3") {
                          var _p310 = _p298._0._2._0._0;
                          var eGroupFunc = $Lang.withDummyPos(A4($Lang.EApp,
                          "\n    ",
                          $Lang.eVar0(_p298._0._2._0._1),
                          _p298._0._2._0._2,
                          ""));
                          var eBounds = A2($LangUnparser.replacePrecedingWhitespace,
                          "\n    ",
                          _p310);
                          var _p304 = function () {
                             var _p305 = replicateKind;
                             switch (_p305.ctor)
                             {case "HorizontalRepeat":
                                var eNum = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  3,
                                  $Lang.dummyLoc_($Lang.frozen),
                                  A2($Lang.intSlider,1,10)));
                                  var eSep = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  20,
                                  $Lang.dummyLoc,
                                  $Lang.noWidgetDecl));
                                  return {ctor: "_Tuple2"
                                         ,_0: "horizontalArrayByBounds"
                                         ,_1: _U.list([eNum,eSep,eGroupFunc,eBounds])};
                                case "LinearRepeat": var _p306 = {ctor: "_Tuple2",_0: 3,_1: 20};
                                  var nNum = _p306._0;
                                  var nSep = _p306._1;
                                  var eNum = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  nNum,
                                  $Lang.dummyLoc_($Lang.frozen),
                                  A2($Lang.intSlider,1,20)));
                                  var eSep = $Lang.withDummyPos(A4($Lang.EConst,
                                  " ",
                                  nSep,
                                  $Lang.dummyLoc,
                                  $Lang.noWidgetDecl));
                                  var eGroupBounds = function () {
                                     var _p307 = stripBoundsExp(_p310);
                                     if (_p307.ctor === "Nothing") {
                                           return eBounds;
                                        } else {
                                           var _p308 = _p307._0._0;
                                           var eLeft = A2($Lang.eConst0,_p308,$Lang.dummyLoc);
                                           var eTop = A2($Lang.eConst,_p307._0._1,$Lang.dummyLoc);
                                           var eRight = A2($Lang.eConst,
                                           _p308 + nNum * (_p307._0._2 - _p308) + (nNum - 1) * nSep,
                                           $Lang.dummyLoc);
                                           var eBot = A2($Lang.eConst,_p307._0._3,$Lang.dummyLoc);
                                           return A2($LangUnparser.replacePrecedingWhitespace,
                                           "\n    ",
                                           A2($Lang.eList,
                                           _U.list([eLeft,eTop,eRight,eBot]),
                                           $Maybe.Nothing));
                                        }
                                  }();
                                  return {ctor: "_Tuple2"
                                         ,_0: "repeatInsideBounds"
                                         ,_1: _U.list([eNum,eSep,eGroupFunc,eGroupBounds])};
                                default: return _U.crashCase("ExpressionBasedTransform",
                                  {start: {line: 774,column: 9},end: {line: 799,column: 54}},
                                  _p305)("replicateSelectedBlob: TODO");}
                          }();
                          var arrayFunction = _p304._0;
                          var arrayArgs = _p304._1;
                          var newBlob = A2($Blobs.NiceBlob,
                          $Lang.withDummyPos(A4($Lang.EApp,
                          "\n  ",
                          $Lang.eVar0(arrayFunction),
                          arrayArgs,
                          "")),
                          $Blobs.CallBlob({ctor: "_Tuple2"
                                          ,_0: arrayFunction
                                          ,_1: arrayArgs}));
                          var blobs$ = A3($Utils.replacei,_p298._0._0,newBlob,_p311);
                          var code$ = $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                                           ,_0: _p312
                                                                           ,_1: A2($Blobs.Blobs,blobs$,_p313)}));
                          return _U.update(model,
                          {code: code$,selectedBlobs: $Dict.empty});
                       } else {
                          break _v130_2;
                       }
                  default: break _v130_2;}
            } else {
               break _v130_2;
            }
      } while (false);
      return model;
   });
   var duplicateSelectedBlobs = function (model) {
      var _p314 = $Blobs.splitExp(model.inputExp);
      var defs = _p314._0;
      var mainExp = _p314._1;
      var _p315 = mainExp;
      if (_p315.ctor === "Blobs") {
            var _p331 = _p315._0;
            var _p316 = function () {
               var selectedNiceBlobs = A2(selectedBlobsToSelectedNiceBlobs,
               model,
               _p331);
               var _p317 = A3($List.foldl,
               F2(function (def,_p318) {
                  var _p319 = _p318;
                  var _p325 = _p319._0;
                  var _p324 = _p319._2;
                  var _p323 = _p319._1;
                  if ($Basics.not(A2(matchesAnySelectedVarBlob,
                  selectedNiceBlobs,
                  def))) return {ctor: "_Tuple3",_0: _p325,_1: _p323,_2: _p324};
                  else {
                        var _p320 = def;
                        var ws1 = _p320._0;
                        var p = _p320._1;
                        var e = _p320._2;
                        var ws2 = _p320._3;
                        var _p321 = p.val;
                        if (_p321.ctor === "PVar") {
                              var x$ = A2($Basics._op["++"],
                              _p321._1,
                              A2($Basics._op["++"],"_copy",$Basics.toString(_p325)));
                              var acc1$ = A2($List._op["::"],
                              {ctor: "_Tuple4"
                              ,_0: ws1
                              ,_1: _U.update(p,{val: A3($Lang.PVar,_p321._0,x$,_p321._2)})
                              ,_2: e
                              ,_3: ws2},
                              _p323);
                              var acc2$ = A2($List._op["::"],
                              A2($Blobs.varBlob,
                              $Lang.withDummyPos(A2($Lang.EVar,"\n  ",x$)),
                              x$),
                              _p324);
                              return {ctor: "_Tuple3",_0: 1 + _p325,_1: acc1$,_2: acc2$};
                           } else {
                              var _p322 = A2($Debug.log,
                              "duplicateSelectedBlobs: weird...",
                              {ctor: "_Tuple0"});
                              return {ctor: "_Tuple3",_0: _p325,_1: _p323,_2: _p324};
                           }
                     }
               }),
               {ctor: "_Tuple3"
               ,_0: model.genSymCount
               ,_1: _U.list([])
               ,_2: _U.list([])},
               defs);
               var nextGenSym_ = _p317._0;
               var newDefs_ = _p317._1;
               var newVarBlobs_ = _p317._2;
               var newWithAndCallBlobs = A2($List.concatMap,
               function (_p326) {
                  var _p327 = _p326;
                  var _p330 = _p327._2;
                  var _p329 = _p327._1;
                  var _p328 = _p330;
                  switch (_p328.ctor)
                  {case "WithBoundsBlob": return _U.list([A2($Blobs.NiceBlob,
                       _p329,
                       _p330)]);
                     case "WithAnchorBlob": return _U.list([A2($Blobs.NiceBlob,
                       _p329,
                       _p330)]);
                     case "CallBlob": return _U.list([A2($Blobs.NiceBlob,
                       _p329,
                       _p330)]);
                     default: return _U.list([]);}
               },
               selectedNiceBlobs);
               var newDefs = $List.reverse(newDefs_);
               var newBlobs = A2($Basics._op["++"],
               $List.reverse(newVarBlobs_),
               newWithAndCallBlobs);
               return {ctor: "_Tuple3"
                      ,_0: nextGenSym_
                      ,_1: newDefs
                      ,_2: newBlobs};
            }();
            var nextGenSym = _p316._0;
            var newDefs = _p316._1;
            var newBlobs = _p316._2;
            var code$ = function () {
               var blobs$ = A2($Basics._op["++"],_p331,newBlobs);
               var defs$ = A2($Basics._op["++"],defs,newDefs);
               return $LangUnparser.unparse($Blobs.fuseExp({ctor: "_Tuple2"
                                                           ,_0: defs$
                                                           ,_1: A2($Blobs.Blobs,blobs$,_p315._1)}));
            }();
            return _U.update(model,
            {code: code$
            ,genSymCount: $List.length(newBlobs) + model.genSymCount});
         } else {
            return model;
         }
   };
   return _elm.ExpressionBasedTransform.values = {_op: _op
                                                 ,groupSelectedBlobs: groupSelectedBlobs
                                                 ,abstractSelectedBlobs: abstractSelectedBlobs
                                                 ,replicateSelectedBlob: replicateSelectedBlob
                                                 ,duplicateSelectedBlobs: duplicateSelectedBlobs
                                                 ,mergeSelectedBlobs: mergeSelectedBlobs
                                                 ,deleteSelectedBlobs: deleteSelectedBlobs
                                                 ,anchorOfSelectedFeatures: anchorOfSelectedFeatures
                                                 ,groupSelectedBlobsAround: groupSelectedBlobsAround};
};
Elm.ValueBasedTransform = Elm.ValueBasedTransform || {};
Elm.ValueBasedTransform.make = function (_elm) {
   "use strict";
   _elm.ValueBasedTransform = _elm.ValueBasedTransform || {};
   if (_elm.ValueBasedTransform.values)
   return _elm.ValueBasedTransform.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Eval = Elm.Eval.make(_elm),
   $Lang = Elm.Lang.make(_elm),
   $LangParser2 = Elm.LangParser2.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $LangTools = Elm.LangTools.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $LocEqn = Elm.LocEqn.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Regex = Elm.Regex.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $ShapeWidgets = Elm.ShapeWidgets.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm),
   $Sync = Elm.Sync.make(_elm),
   $Utils = Elm.Utils.make(_elm);
   var _op = {};
   var equationToLittle = F2(function (substStr,eqn) {
      var _p0 = eqn;
      if (_p0.ctor === "EqnNum") {
            var littlizedTrace = A2($LangUnparser.traceToLittle,
            substStr,
            _p0._0._1);
            return !_U.eq(littlizedTrace,
            "?") ? littlizedTrace : A2($Basics._op["++"],
            $Basics.toString(_p0._0._0),
            "!");
         } else {
            var childLittleStrs = A2($List.map,
            equationToLittle(substStr),
            _p0._1);
            return A2($Basics._op["++"],
            "(",
            A2($Basics._op["++"],
            $Lang.strOp(_p0._0),
            A2($Basics._op["++"],
            " ",
            A2($Basics._op["++"],
            A2($String.join," ",childLittleStrs),
            ")"))));
         }
   });
   var xOrYFeatureNameRegex = $Regex.regex("^(?!ellipseR)(.*)[XY](\\d*)$");
   var featureNameIsXOrY = function (featureName) {
      return A2($Regex.contains,xOrYFeatureNameRegex,featureName);
   };
   var featurePointAndNumber = function (featureName) {
      return function (_) {
         return _.submatches;
      }($Utils.head_(A3($Regex.find,
      $Regex.AtMost(1),
      xOrYFeatureNameRegex,
      featureName)));
   };
   var featuresNamesAreXYPairs = F2(function (featureNameA,
   featureNameB) {
      return featureNameIsXOrY(featureNameA) && (featureNameIsXOrY(featureNameB) && (!_U.eq(featureNameA,
      featureNameB) && _U.eq(featurePointAndNumber(featureNameA),
      featurePointAndNumber(featureNameB))));
   });
   var yFeatureNameRegex = $Regex.regex("^(?!ellipseR)(.*)Y(\\d*)$");
   var featureNameIsY = function (featureName) {
      return A2($Regex.contains,yFeatureNameRegex,featureName);
   };
   var xFeatureNameRegex = $Regex.regex("^(?!ellipseR)(.*)X(\\d*)$");
   var featureNameIsX = function (featureName) {
      return A2($Regex.contains,xFeatureNameRegex,featureName);
   };
   var featurePoints = function (features) {
      featurePoints: while (true) {
         var _p1 = features;
         if (_p1.ctor === "[]") {
               return _U.list([]);
            } else {
               var _p8 = _p1._0;
               var _p7 = _p1._1;
               var _p2 = _p8;
               var selectedType = _p2._0;
               var nodeId = _p2._1;
               var featureName = _p2._2;
               if ($Basics.not(featureNameIsXOrY(featureName))) {
                     var _v2 = _p7;
                     features = _v2;
                     continue featurePoints;
                  } else {
                     var nodeFeatures = A2($List.filter,
                     function (_p3) {
                        return A2(F2(function (x,y) {    return _U.eq(x,y);}),
                        nodeId,
                        $Utils.snd3(_p3));
                     },
                     _p7);
                     var maybePairedFeature = A2($Utils.findFirst,
                     function (_p4) {
                        return A2(featuresNamesAreXYPairs,
                        featureName,
                        $Utils.thd3(_p4));
                     },
                     nodeFeatures);
                     var _p5 = maybePairedFeature;
                     if (_p5.ctor === "Just") {
                           var _p6 = _p5._0;
                           var pairToReturn = featureNameIsX(featureName) ? {ctor: "_Tuple2"
                                                                            ,_0: _p8
                                                                            ,_1: _p6} : {ctor: "_Tuple2",_0: _p6,_1: _p8};
                           var remainingFeatures = A2($Utils.removeFirst,_p6,_p7);
                           return A2($List._op["::"],
                           pairToReturn,
                           featurePoints(remainingFeatures));
                        } else {
                           var _v4 = _p7;
                           features = _v4;
                           continue featurePoints;
                        }
                  }
            }
      }
   };
   var featureEquationToLocEquation = function (featureEqn) {
      var _p9 = featureEqn;
      if (_p9.ctor === "EqnNum") {
            if (_p9._0._1.ctor === "TrLoc") {
                  if (_p9._0._1._0._0 === 0) {
                        return $LocEqn.LocEqnConst(_p9._0._0);
                     } else {
                        return $LocEqn.LocEqnLoc(_p9._0._1._0._0);
                     }
               } else {
                  return A2($LocEqn.LocEqnOp,
                  _p9._0._1._0,
                  A2($List.map,$LocEqn.traceToLocEquation,_p9._0._1._1));
               }
         } else {
            return A2($LocEqn.LocEqnOp,
            _p9._0,
            A2($List.map,featureEquationToLocEquation,_p9._1));
         }
   };
   var maybeExtractUnsharedExpression = F2(function (lhs,rhs) {
      var _p10 = {ctor: "_Tuple2",_0: lhs,_1: rhs};
      _v6_3: do {
         if (_p10.ctor === "_Tuple2") {
               switch (_p10._0.ctor)
               {case "LocEqnConst": if (_p10._1.ctor === "LocEqnConst") {
                          return _U.eq(_p10._0._0,
                          _p10._1._0) ? $Maybe.Nothing : $Maybe.Just({ctor: "_Tuple2"
                                                                     ,_0: lhs
                                                                     ,_1: rhs});
                       } else {
                          break _v6_3;
                       }
                  case "LocEqnLoc": if (_p10._1.ctor === "LocEqnLoc") {
                          return _U.eq(_p10._0._0,
                          _p10._1._0) ? $Maybe.Nothing : $Maybe.Just({ctor: "_Tuple2"
                                                                     ,_0: lhs
                                                                     ,_1: rhs});
                       } else {
                          break _v6_3;
                       }
                  default: if (_p10._1.ctor === "LocEqnOp") {
                          var _p14 = _p10._1._1;
                          var _p13 = _p10._0._1;
                          if (!_U.eq(_p10._0._0,_p10._1._0))
                          return $Maybe.Just({ctor: "_Tuple2",_0: lhs,_1: rhs});
                          else if (_U.eq(_p13,_p14)) return $Maybe.Nothing;
                             else if (!_U.eq($List.length(_p13),$List.length(_p14)))
                                return $Maybe.Just({ctor: "_Tuple2",_0: lhs,_1: rhs}); else {
                                      var unsharedSubexpressions = A2($List.map,
                                      function (_p11) {
                                         var _p12 = _p11;
                                         return A2(maybeExtractUnsharedExpression,_p12._0,_p12._1);
                                      },
                                      A2($Utils.zip,_p13,_p14));
                                      if (A2($List.all,
                                      F2(function (x,y) {    return _U.eq(x,y);})($Maybe.Nothing),
                                      unsharedSubexpressions)) return $Maybe.Nothing;
                                      else if (_U.cmp(A2($Utils.count,
                                         F2(function (x,y) {    return !_U.eq(x,y);})($Maybe.Nothing),
                                         unsharedSubexpressions),
                                         1) > 0) return $Maybe.Just({ctor: "_Tuple2",_0: lhs,_1: rhs});
                                         else {
                                               var justUnsharedSubexpressionPair = A2($Utils.fromJust_,
                                               "extractUnsharedExpression this is logically impossible",
                                               A2($Utils.findFirst,
                                               F2(function (x,y) {    return !_U.eq(x,y);})($Maybe.Nothing),
                                               unsharedSubexpressions));
                                               return justUnsharedSubexpressionPair;
                                            }
                                   }
                       } else {
                          break _v6_3;
                       }}
            } else {
               break _v6_3;
            }
      } while (false);
      return $Maybe.Just({ctor: "_Tuple2",_0: lhs,_1: rhs});
   });
   var solveForLoc = F5(function (locId,locIdToNum,subst,lhs,rhs) {
      var rhs$ = featureEquationToLocEquation(rhs);
      var lhs$ = featureEquationToLocEquation(lhs);
      var maybeEqn = function () {
         var _p15 = A2(maybeExtractUnsharedExpression,rhs$,lhs$);
         if (_p15.ctor === "Nothing") {
               return $Maybe.Nothing;
            } else {
               var rhs$$$ = A2($LocEqn.constantifyLocs,
               locIdToNum,
               _p15._0._1);
               var lhs$$$ = A2($LocEqn.constantifyLocs,locIdToNum,_p15._0._0);
               var _p16 = A2($LocEqn.locEqnTerms,
               locId,
               A2($LocEqn.LocEqnOp,$Lang.Minus,_U.list([lhs$$$,rhs$$$])));
               if (_p16.ctor === "Just") {
                     var _p19 = _p16._0._2;
                     var _p18 = _p16._0._0;
                     var _p17 = _p16._0._1;
                     return _U.eq(_p18,0) || _U.eq(_p17,
                     $LocEqn.LocEqnConst(0)) ? $Maybe.Nothing : _U.eq(_p18,
                     1) ? $Maybe.Just($LocEqn.locEqnSimplify(A2($LocEqn.LocEqnOp,
                     $Lang.Div,
                     _U.list([A2($LocEqn.LocEqnOp,
                             $Lang.Minus,
                             _U.list([$LocEqn.LocEqnConst(0),_p19]))
                             ,_p17])))) : _U.eq(_p18,
                     -1) ? $Maybe.Just($LocEqn.locEqnSimplify(A2($LocEqn.LocEqnOp,
                     $Lang.Div,
                     _U.list([_p17
                             ,A2($LocEqn.LocEqnOp,
                             $Lang.Minus,
                             _U.list([$LocEqn.LocEqnConst(0),_p19]))])))) : $Maybe.Nothing;
                  } else {
                     return $Maybe.Nothing;
                  }
            }
      }();
      var _p20 = maybeEqn;
      if (_p20.ctor === "Just") {
            var _p21 = _p20._0;
            var evaled = A2($LocEqn.locEqnEval,subst,_p21);
            return $Basics.isNaN(evaled) || $Basics.isInfinite(evaled) ? $Maybe.Nothing : $Maybe.Just(_p21);
         } else {
            return $Maybe.Nothing;
         }
   });
   var equationVals = function (eqn) {
      var _p22 = eqn;
      if (_p22.ctor === "EqnNum") {
            return _U.list([_p22._0]);
         } else {
            return A2($List.concatMap,equationVals,_p22._1);
         }
   };
   var equationLocs = F2(function (syncOptions,eqn) {
      return A2($List.concatMap,
      function (_p23) {
         return $Set.toList(A2($Sync.locsOfTrace,
         syncOptions,
         $Basics.snd(_p23)));
      },
      equationVals(eqn));
   });
   var typeAndNodeIdAndFeatureToEquation = F3(function (_p24,
   tree,
   locIdToNumberAndLoc) {
      var _p25 = _p24;
      var _p31 = _p25._0;
      var _p30 = _p25._1;
      var _p29 = _p25._2;
      if (_U.eq(_p31,$ShapeWidgets.selectedTypeShapeFeature)) {
            var _p26 = A2($Dict.get,_p30,tree);
            if (_p26.ctor === "Just") {
                  if (_p26._0.ctor === "SvgNode") {
                        return $Maybe.Just(A4($ShapeWidgets.featureEquation,
                        _p30,
                        _p26._0._0,
                        _p29,
                        _p26._0._1));
                     } else {
                        return $Maybe.Nothing;
                     }
               } else {
                  return _U.crashCase("ValueBasedTransform",
                  {start: {line: 676,column: 5},end: {line: 684,column: 107}},
                  _p26)(A2($Basics._op["++"],
                  "typeAndNodeIdAndFeatureToEquation ",
                  A2($Basics._op["++"],
                  $Basics.toString(_p30),
                  A2($Basics._op["++"]," ",$Basics.toString(tree)))));
               }
         } else if (_U.eq(_p31,$ShapeWidgets.selectedTypeWidget)) {
               var locIdStr = A2($String.dropLeft,
               $String.length("widget"),
               _p29);
               var locId = A2($Utils.fromOk,
               A2($Basics._op["++"],"Couldn\'t parse locId out of ",_p29),
               $String.toInt(locIdStr));
               var _p28 = A3($Utils.justGet_,
               A2($Basics._op["++"],
               "Couldn\'t find locId ",
               A2($Basics._op["++"],
               $Basics.toString(locId),
               A2($Basics._op["++"],
               " in ",
               $Basics.toString(locIdToNumberAndLoc)))),
               locId,
               locIdToNumberAndLoc);
               var n = _p28._0;
               var loc = _p28._1;
               return $Maybe.Just($ShapeWidgets.EqnNum({ctor: "_Tuple2"
                                                       ,_0: n
                                                       ,_1: $Lang.TrLoc(loc)}));
            } else return _U.crash("ValueBasedTransform",
            {start: {line: 702,column: 5}
            ,end: {line: 702,column: 16}})(A2($Basics._op["++"],
            "Unknown selected feature type: ",
            _p31));
   });
   var evaluateFeature = F3(function (typeAndNodeIdAndFeatureName,
   slate,
   locIdToNumberAndLoc) {
      var _p32 = slate;
      var tree = _p32._1;
      var _p33 = A3(typeAndNodeIdAndFeatureToEquation,
      typeAndNodeIdAndFeatureName,
      tree,
      locIdToNumberAndLoc);
      if (_p33.ctor === "Just") {
            return $ShapeWidgets.evaluateFeatureEquation(_p33._0);
         } else {
            return $Maybe.Nothing;
         }
   });
   var locIdToWidgetDeclOf = function (exp) {
      return A3($Lang.foldExpViaE__,
      F2(function (e__,dict) {
         var _p34 = e__;
         if (_p34.ctor === "EConst" && _p34._2.ctor === "_Tuple3") {
               return A3($Dict.insert,_p34._2._0,_p34._3,dict);
            } else {
               return dict;
            }
      }),
      $Dict.empty,
      exp);
   };
   var locIdToWidgetDeclLittleOf = function (exp) {
      return A2($Dict.map,
      F2(function (locId,wd) {
         return $LangUnparser.unparseWD(wd);
      }),
      locIdToWidgetDeclOf(exp));
   };
   var locIdToNumberAndLocOf = function (exp) {
      return A3($Lang.foldExpViaE__,
      F2(function (e__,dict) {
         var _p35 = e__;
         if (_p35.ctor === "EConst" && _p35._2.ctor === "_Tuple3") {
               var _p36 = _p35._2._0;
               return A3($Dict.insert,
               _p36,
               {ctor: "_Tuple2"
               ,_0: _p35._1
               ,_1: {ctor: "_Tuple3",_0: _p36,_1: _p35._2._1,_2: _p35._2._2}},
               dict);
            } else {
               return dict;
            }
      }),
      $Dict.empty,
      exp);
   };
   var pluckFeatureEquationNamed = F3(function (_p37,
   slate,
   locIdToNumberAndLoc) {
      var _p38 = _p37;
      var _p41 = _p38._2;
      var _p39 = slate;
      var tree = _p39._1;
      var _p40 = A3(typeAndNodeIdAndFeatureToEquation,
      {ctor: "_Tuple3",_0: _p38._0,_1: _p38._1,_2: _p41},
      tree,
      locIdToNumberAndLoc);
      if (_p40.ctor === "Just") {
            return $Maybe.Just({ctor: "_Tuple2",_0: _p41,_1: _p40._0});
         } else {
            return $Maybe.Nothing;
         }
   });
   var pluckSelectedFeatureEquationsNamed = F3(function (selectedFeatures,
   slate,
   locIdToNumberAndLoc) {
      var accumulator = F2(function (typeAndNodeIdAndFeature,acc) {
         var _p42 = A3(pluckFeatureEquationNamed,
         typeAndNodeIdAndFeature,
         slate,
         locIdToNumberAndLoc);
         if (_p42.ctor === "Just") {
               return A2($List._op["::"],
               {ctor: "_Tuple2",_0: _p42._0._0,_1: _p42._0._1},
               acc);
            } else {
               return acc;
            }
      });
      return A3($Set.foldr,accumulator,_U.list([]),selectedFeatures);
   });
   var pluckSelectedFeatureEquations = F3(function (selectedFeatures,
   slate,
   locIdToNumberAndLoc) {
      return A2($List.map,
      $Basics.snd,
      A3(pluckSelectedFeatureEquationsNamed,
      selectedFeatures,
      slate,
      locIdToNumberAndLoc));
   });
   var pluckSelectedVals = F3(function (selectedFeatures,
   slate,
   locIdToNumberAndLoc) {
      var featureEquations = A3(pluckSelectedFeatureEquations,
      selectedFeatures,
      slate,
      locIdToNumberAndLoc);
      return A2($List.concatMap,equationVals,featureEquations);
   });
   var wrapWithLets = F3(function (listOfListsOfNamesAndAssigns,
   isTopLevel,
   bodyExp) {
      var nonEmptyListOfListsOfNamesAndAssigns = A2($List.filter,
      function (_p43) {
         return $Basics.not($List.isEmpty(_p43));
      },
      listOfListsOfNamesAndAssigns);
      var _p44 = nonEmptyListOfListsOfNamesAndAssigns;
      if (_p44.ctor === "[]") {
            return bodyExp;
         } else {
            var oldPrecedingWhitespace = $LangUnparser.precedingWhitespace(bodyExp);
            var extraWhitespace = A2($String.contains,
            "\n",
            oldPrecedingWhitespace) ? "" : "\n";
            var limitedOldPrecedingWhitespace = function () {
               var _p45 = $List.reverse(A2($String.split,
               "\n",
               oldPrecedingWhitespace));
               if (_p45.ctor === "::") {
                     return A2($Basics._op["++"],"\n",_p45._0);
                  } else {
                     return oldPrecedingWhitespace;
                  }
            }();
            var templateStr = function () {
               var letOrDef = F3(function (patsStr,assignsStr,body) {
                  return isTopLevel ? A2($Basics._op["++"],
                  "(def [",
                  A2($Basics._op["++"],
                  patsStr,
                  A2($Basics._op["++"],
                  "] [",
                  A2($Basics._op["++"],
                  assignsStr,
                  A2($Basics._op["++"],"])",body))))) : A2($Basics._op["++"],
                  "(let [",
                  A2($Basics._op["++"],
                  patsStr,
                  A2($Basics._op["++"],
                  "] [",
                  A2($Basics._op["++"],
                  assignsStr,
                  A2($Basics._op["++"],"]",A2($Basics._op["++"],body,")"))))));
               });
               var letStr = F3(function (precedingWs,letNamesAndAssigns,body) {
                  var patStrs = A2($List.map,$Basics.fst,letNamesAndAssigns);
                  var assignStrs = A2($List.map,$Basics.snd,letNamesAndAssigns);
                  var patsStr = A2($String.join," ",patStrs);
                  var assignsStr = A2($String.join," ",assignStrs);
                  return A2($Basics._op["++"],
                  precedingWs,
                  A3(letOrDef,patsStr,assignsStr,body));
               });
               var letsStr = function (body) {
                  var superWrapper = A3($List.foldl,
                  F2(function (letNamesAndAssigns,letsFunc) {
                     var preceedingWs = A2($Basics._op["++"],
                     extraWhitespace,
                     limitedOldPrecedingWhitespace);
                     return function (_p46) {
                        return letsFunc(A3(letStr,
                        preceedingWs,
                        letNamesAndAssigns,
                        _p46));
                     };
                  }),
                  A2(letStr,limitedOldPrecedingWhitespace,_p44._0),
                  _p44._1);
                  return superWrapper(body);
               };
               return letsStr("\n  \'dummy body\'");
            }();
            var template = function () {
               var _p47 = $LangParser2.parseE(templateStr);
               if (_p47.ctor === "Ok") {
                     return _p47._0;
                  } else {
                     return _U.crashCase("ValueBasedTransform",
                     {start: {line: 593,column: 9},end: {line: 595,column: 96}},
                     _p47)(A2($Basics._op["++"],
                     "Dig template err: ",
                     A2($Basics._op["++"],
                     _p47._0._0,
                     A2($Basics._op["++"],"\n\n",templateStr))));
                  }
            }();
            var wrappedWithLets = A2($Lang.mapExpViaExp__,
            function (e__) {
               var _p49 = e__;
               if (_p49.ctor === "EBase" && _p49._1.ctor === "EString" && _p49._1._1 === "dummy body")
               {
                     return A2($LangUnparser.addPrecedingWhitespace,
                     extraWhitespace,
                     bodyExp).val.e__;
                  } else {
                     return e__;
                  }
            },
            template);
            return wrappedWithLets;
         }
   });
   var nonCollidingName = F2(function (suggestedName,
   existingNames) {
      if ($Basics.not(A2($Set.member,suggestedName,existingNames)))
      return suggestedName; else {
            var nonCollidingName = function (i) {
               nonCollidingName: while (true) {
                  var newName = A2($Basics._op["++"],
                  suggestedName,
                  $Basics.toString(i));
                  if ($Basics.not(A2($Set.member,newName,existingNames)))
                  return newName; else {
                        var _v24 = i + 1;
                        i = _v24;
                        continue nonCollidingName;
                     }
               }
            };
            return nonCollidingName(2);
         }
   });
   var deepestCommonScope = F3(function (exp,locset,syncOptions) {
      var isLocsetNode = function (exp) {
         var _p50 = exp.val.e__;
         if (_p50.ctor === "EConst") {
               return A2($Set.member,_p50._2,locset);
            } else {
               return false;
            }
      };
      var locsAncestors = A2($Lang.findAllWithAncestors,
      isLocsetNode,
      exp);
      var locsAncestorsWithParents = A2($List.map,
      function (locAncestors) {
         return A2($Utils.zip,
         A2($List._op["::"],
         $Maybe.Nothing,
         A2($List.map,$Maybe.Just,locAncestors)),
         locAncestors);
      },
      locsAncestors);
      var locsAncestorScopesWithParents = A2($List.map,
      $List.filter(function (_p51) {
         var _p52 = _p51;
         return A2($Lang.isScope,_p52._0,_p52._1);
      }),
      locsAncestorsWithParents);
      var locsAncestorScopes = A2($List.map,
      $List.map($Basics.snd),
      locsAncestorScopesWithParents);
      var deepestCommonScope = $Utils.last_(A2($List._op["::"],
      exp,
      $Utils.commonPrefix(locsAncestorScopes)));
      return deepestCommonScope;
   });
   var debugLog = $Config.debugLog($Config.debugSync);
   var variableifyConstantsAndWrapTargetExpWithLets = F4(function (locIdToNewName,
   listOfListsOfNamesAndAssigns,
   targetExp,
   program) {
      var targetExpReplaced = A2($LangTools.replaceConstsWithVars,
      locIdToNewName,
      targetExp);
      var wrappedTargetExp = A3(wrapWithLets,
      listOfListsOfNamesAndAssigns,
      A2($LangTools.isTopLevel,targetExp,program),
      targetExpReplaced);
      var _p53 = A2(debugLog,
      "wrappedTargetExp",
      $LangUnparser.unparse(wrappedTargetExp));
      var newProgram = $LangParser2.freshen(A3($Lang.replaceExpNode,
      targetExp,
      wrappedTargetExp,
      program));
      return newProgram;
   });
   var digHole = F4(function (originalExp,
   selectedFeatures,
   slate,
   syncOptions) {
      var locIdToNumberAndLoc = locIdToNumberAndLocOf(originalExp);
      var selectedFeatureEquationsNamed = A2(debugLog,
      "selectedFeatureEquations",
      A3(pluckSelectedFeatureEquationsNamed,
      selectedFeatures,
      slate,
      locIdToNumberAndLoc));
      var locset = function () {
         var selectedVals = A2(debugLog,
         "selectedVals",
         A3(pluckSelectedVals,
         selectedFeatures,
         slate,
         locIdToNumberAndLoc));
         var tracesLocsets = A2($List.map,
         function (_p54) {
            return A2($Sync.locsOfTrace,syncOptions,$Basics.snd(_p54));
         },
         selectedVals);
         var allLocs = A3($List.foldl,
         $Set.union,
         $Set.empty,
         tracesLocsets);
         var _p55 = A2($Set.partition,
         function (_p56) {
            var _p57 = _p56;
            return _U.eq(_p57._1,$Lang.thawed);
         },
         allLocs);
         var thawed = _p55._0;
         var others = _p55._1;
         return $Set.isEmpty(thawed) ? others : thawed;
      }();
      var locsetList = $Set.toList(locset);
      var subst = $LangParser2.substOf(originalExp);
      var commonScope = A3(deepestCommonScope,
      originalExp,
      locset,
      syncOptions);
      var existingNames = $LangTools.identifiersSet(originalExp);
      var locIdNameOrigNamePrime = function () {
         var _p58 = A3($List.foldr,
         F2(function (_p60,_p59) {
            var _p61 = _p60;
            var _p65 = _p61._0;
            var _p64 = _p61._2;
            var _p62 = _p59;
            var _p63 = _p62._0;
            var baseIdent = _U.eq(_p64,"") ? A2($Basics._op["++"],
            "k",
            $Basics.toString(_p65)) : _p64;
            var scopeNamesLiftedThrough = A2($LangTools.scopeNamesLocLiftedThrough,
            commonScope,
            {ctor: "_Tuple3",_0: _p65,_1: _p61._1,_2: _p64});
            var scopesAndBaseIdent = A2($String.join,
            "_",
            A2($Basics._op["++"],
            scopeNamesLiftedThrough,
            _U.list([baseIdent])));
            var baseIdentOrig = _U.eq(scopesAndBaseIdent,
            baseIdent) ? A2($Basics._op["++"],
            baseIdent,
            "_orig") : scopesAndBaseIdent;
            var baseIdentPrime = A2($Basics._op["++"],
            scopesAndBaseIdent,
            "\'");
            var identOrig = A2(nonCollidingName,baseIdentOrig,_p63);
            var identPrime = A2(nonCollidingName,baseIdentPrime,_p63);
            return {ctor: "_Tuple2"
                   ,_0: A2($Set.union,
                   _p63,
                   $Set.fromList(_U.list([identOrig,identPrime])))
                   ,_1: A2($List._op["::"],
                   {ctor: "_Tuple3",_0: _p65,_1: identOrig,_2: identPrime},
                   _p62._1)};
         }),
         {ctor: "_Tuple2",_0: existingNames,_1: _U.list([])},
         locsetList);
         var result = _p58._1;
         return result;
      }();
      var newNames = A2($List.concatMap,
      function (_p66) {
         var _p67 = _p66;
         return _U.list([_p67._1,_p67._2]);
      },
      locIdNameOrigNamePrime);
      var namesToAvoid = A2($Set.union,
      existingNames,
      $Set.fromList(newNames));
      var locIdToNewName = A2(debugLog,
      "locIdToNewName",
      $Dict.fromList(A2($List.map,
      function (_p68) {
         var _p69 = _p68;
         return {ctor: "_Tuple2",_0: _p69._0,_1: _p69._2};
      },
      locIdNameOrigNamePrime)));
      var origNames = $List.reverse(A2($List.map,
      $Utils.snd3,
      locIdNameOrigNamePrime));
      var primeNames = $List.reverse(A2($List.map,
      $Utils.thd3,
      locIdNameOrigNamePrime));
      var valueStrs = function () {
         var locIdToWidgetDeclLittle = locIdToWidgetDeclLittleOf(originalExp);
         return A2($List.map,
         function (_p70) {
            var _p71 = _p70;
            var _p72 = _p71._0;
            return A2($Basics._op["++"],
            $Basics.toString(A3($Utils.justGet_,
            "ValueBasedTransform.digHole valueStrs",
            _p72,
            subst)),
            A2($Basics._op["++"],
            _p71._1,
            A3($Utils.justGet_,
            "ValueBasedTransform.digHole valueStrs widgetDecl",
            _p72,
            locIdToWidgetDeclLittle)));
         },
         $List.reverse(locsetList));
      }();
      var selectedFeatureEquationsNamedWithScopes = A2($List.map,
      function (_p73) {
         var _p74 = _p73;
         var _p75 = _p74._1;
         var featureLocs = A2(equationLocs,syncOptions,_p75);
         var scopeNamesLocsLiftedThrough = A2($List.map,
         $LangTools.scopeNamesLocLiftedThrough(commonScope),
         featureLocs);
         var commonScopeNamesLocsLiftedThrough = $Utils.commonPrefix(scopeNamesLocsLiftedThrough);
         var featureName$ = A2($String.join,
         "_",
         A2($Basics._op["++"],
         commonScopeNamesLocsLiftedThrough,
         _U.list([_p74._0])));
         return {ctor: "_Tuple2",_0: featureName$,_1: _p75};
      },
      selectedFeatureEquationsNamed);
      var featureNamesWithExpressionStrs = function () {
         var locIdToOrigName = $Dict.fromList(A2($List.map,
         function (_p76) {
            var _p77 = _p76;
            return {ctor: "_Tuple2",_0: _p77._0,_1: _p77._1};
         },
         locIdNameOrigNamePrime));
         var locIdToLittleConst = A2($Dict.map,
         F2(function (_p78,str) {
            return A2($Basics._op["++"],str,"!");
         }),
         $LangParser2.substStrOf(originalExp));
         var substStr = A2($Dict.union,
         locIdToOrigName,
         locIdToLittleConst);
         return A2($List.map,
         $Utils.mapSnd(equationToLittle(substStr)),
         selectedFeatureEquationsNamedWithScopes);
      }();
      var significantFeatureNamesWithExpressionStrs = A2($List.filter,
      function (_p79) {
         var _p80 = _p79;
         return A2($String.contains," ",_p80._1);
      },
      featureNamesWithExpressionStrs);
      var featureNames = A2($List.map,
      $Basics.fst,
      significantFeatureNamesWithExpressionStrs);
      var featureExpressionStrs = A2($List.map,
      $Basics.snd,
      significantFeatureNamesWithExpressionStrs);
      var nonCollidingFeatureNames = function () {
         var _p81 = A3($List.foldr,
         F2(function (featureName,_p82) {
            var _p83 = _p82;
            var _p84 = _p83._0;
            var featureName$ = A2(nonCollidingName,featureName,_p84);
            return {ctor: "_Tuple2"
                   ,_0: A2($Set.insert,featureName$,_p84)
                   ,_1: A2($List._op["::"],featureName$,_p83._1)};
         }),
         {ctor: "_Tuple2",_0: namesToAvoid,_1: _U.list([])},
         featureNames);
         var newNamesToAvoid = _p81._0;
         var result = _p81._1;
         return result;
      }();
      var listOfListsOfNamesAndAssigns = _U.list([A2($Utils.zip,
                                                 origNames,
                                                 valueStrs)
                                                 ,A2($Utils.zip,nonCollidingFeatureNames,featureExpressionStrs)
                                                 ,A2($Utils.zip,primeNames,origNames)]);
      var newExp = A4(variableifyConstantsAndWrapTargetExpWithLets,
      locIdToNewName,
      listOfListsOfNamesAndAssigns,
      commonScope,
      originalExp);
      return newExp;
   });
   var makeEqual__ = F4(function (originalExp,
   featureAEqn,
   featureBEqn,
   syncOptions) {
      var unfrozenLocset = $Set.fromList(A2($Basics._op["++"],
      A2(equationLocs,syncOptions,featureAEqn),
      A2(equationLocs,syncOptions,featureBEqn)));
      var subst = $LangParser2.substOf(originalExp);
      var frozenLocIdToNum = $Dict.fromList(A2($Basics._op["++"],
      $LangTools.frozenLocIdsAndNumbers(originalExp),
      $LangTools.frozenLocIdsAndNumbers($LangParser2.prelude)));
      var findSolution = function (locs) {
         findSolution: while (true) {
            var _p85 = locs;
            if (_p85.ctor === "[]") {
                  return $Maybe.Nothing;
               } else {
                  var _p87 = _p85._0._0;
                  var _p86 = A5(solveForLoc,
                  _p87,
                  frozenLocIdToNum,
                  subst,
                  featureAEqn,
                  featureBEqn);
                  if (_p86.ctor === "Nothing") {
                        var _v39 = _p85._1;
                        locs = _v39;
                        continue findSolution;
                     } else {
                        return $Maybe.Just({ctor: "_Tuple2",_0: _p87,_1: _p86._0});
                     }
               }
         }
      };
      var thawedLocsFirst = function () {
         var _p88 = A2($List.partition,
         function (_p89) {
            var _p90 = _p89;
            return _U.eq(_p90._1,$Lang.thawed);
         },
         $Set.toList(unfrozenLocset));
         var thawed = _p88._0;
         var others = _p88._1;
         return A2($Basics._op["++"],thawed,others);
      }();
      var _p91 = findSolution(thawedLocsFirst);
      if (_p91.ctor === "Nothing") {
            return $Maybe.Nothing;
         } else {
            var _p110 = _p91._0._1;
            var _p109 = _p91._0._0;
            var locIdSet = A2($Set.insert,
            _p109,
            $LocEqn.locEqnLocIds(_p110));
            var locsetToDig = A2($Set.filter,
            function (_p92) {
               var _p93 = _p92;
               return A2($Set.member,_p93._0,locIdSet);
            },
            unfrozenLocset);
            var subst = $LangParser2.substOf(originalExp);
            var commonScope = A3(deepestCommonScope,
            originalExp,
            locsetToDig,
            syncOptions);
            var existingNames = $LangTools.identifiersSet(originalExp);
            var _p94 = A2($Set.partition,
            function (_p95) {
               var _p96 = _p95;
               return _U.eq(_p96._0,_p109);
            },
            locsetToDig);
            var dependentLocset = _p94._0;
            var independentLocset = _p94._1;
            var dependentLoc = $Utils.head_($Set.toList(dependentLocset));
            var independentLocs = $Set.toList(independentLocset);
            var independentLocIds = A2($List.map,
            $Utils.fst3,
            independentLocs);
            var locIdToNewName = function () {
               var _p97 = A3($List.foldr,
               F2(function (_p99,_p98) {
                  var _p100 = _p99;
                  var _p104 = _p100._0;
                  var _p103 = _p100._2;
                  var _p101 = _p98;
                  var _p102 = _p101._0;
                  var baseIdent = _U.eq(_p103,"") ? A2($Basics._op["++"],
                  "k",
                  $Basics.toString(_p104)) : _p103;
                  var scopeNamesLiftedThrough = A2($LangTools.scopeNamesLocLiftedThrough,
                  commonScope,
                  {ctor: "_Tuple3",_0: _p104,_1: _p100._1,_2: _p103});
                  var scopesAndBaseIdent = A2($String.join,
                  "_",
                  A2($Basics._op["++"],
                  scopeNamesLiftedThrough,
                  _U.list([baseIdent])));
                  var ident = _U.eq(_p104,_p109) ? A2(nonCollidingName,
                  A2($Basics._op["++"],baseIdent,"\'"),
                  _p102) : _U.eq(scopesAndBaseIdent,
                  baseIdent) ? A2(nonCollidingName,
                  A2($Basics._op["++"],baseIdent,"_orig"),
                  _p102) : A2(nonCollidingName,scopesAndBaseIdent,_p102);
                  return {ctor: "_Tuple2"
                         ,_0: A2($Set.insert,ident,_p102)
                         ,_1: A2($List._op["::"],
                         {ctor: "_Tuple2",_0: _p104,_1: ident},
                         _p101._1)};
               }),
               {ctor: "_Tuple2",_0: existingNames,_1: _U.list([])},
               A2($List._op["::"],dependentLoc,independentLocs));
               var result = _p97._1;
               return $Dict.fromList(result);
            }();
            var independentLocNames = A2($List.map,
            function (locId) {
               return A3($Utils.justGet_,
               "ValueBasedTransform.makeEqual__ independentLocNames",
               locId,
               locIdToNewName);
            },
            independentLocIds);
            var independentLocValueStrs = function () {
               var locIdToWidgetDeclLittle = locIdToWidgetDeclLittleOf(originalExp);
               return A2($List.map,
               function (_p105) {
                  var _p106 = _p105;
                  var _p107 = _p106._0;
                  return A2($Basics._op["++"],
                  $Basics.toString(A3($Utils.justGet_,
                  "ValueBasedTransform.makeEqual__ independentLocValueStrs",
                  _p107,
                  subst)),
                  A2($Basics._op["++"],
                  _p106._1,
                  A3($Utils.justGet_,
                  "ValueBasedTransform.makeEqual__ independentLocValueStrs widgetDecl",
                  _p107,
                  locIdToWidgetDeclLittle)));
               },
               independentLocs);
            }();
            var dependentLocNameStr = A3($Utils.justGet_,
            "ValueBasedTransform.makeEqual__ dependentLocNameStr",
            _p109,
            locIdToNewName);
            var frozenLocIdToLittle = A2($Dict.map,
            F2(function (locId,n) {
               return A2($Basics._op["++"],$Basics.toString(n),"!");
            }),
            frozenLocIdToNum);
            var locIdToLittle = A2($Dict.union,
            locIdToNewName,
            frozenLocIdToLittle);
            var _p108 = A2(debugLog,"locIdToLittle",locIdToLittle);
            var dependentLocValueStr = A2($LocEqn.locEqnToLittle,
            locIdToLittle,
            _p110);
            var listOfListsOfNamesAndAssigns = _U.list([A2($Utils.zip,
                                                       independentLocNames,
                                                       independentLocValueStrs)
                                                       ,_U.list([{ctor: "_Tuple2"
                                                                 ,_0: dependentLocNameStr
                                                                 ,_1: dependentLocValueStr}])]);
            var newExp = A4(variableifyConstantsAndWrapTargetExpWithLets,
            locIdToNewName,
            listOfListsOfNamesAndAssigns,
            commonScope,
            originalExp);
            return $Maybe.Just(newExp);
         }
   });
   var makeEquidistantOverlappingTriples = F8(function (originalExp,
   sortedFeatures,
   slideNumber,
   movieNumber,
   movieTime,
   slate,
   syncOptions,
   locIdToNumberAndLoc) {
      var relateMore = function (exp) {
         var _p111 = sortedFeatures;
         if (_p111.ctor === "::" && _p111._1.ctor === "::" && _p111._1._1.ctor === "::" && _p111._1._1._1.ctor === "::")
         {
               var newSlateRes = A2($Result.andThen,
               $Eval.run(exp),
               function (_p112) {
                  var _p113 = _p112;
                  return A4($LangSvg.resolveToIndexedTree,
                  slideNumber,
                  movieNumber,
                  movieTime,
                  _p113._0);
               });
               var _p114 = newSlateRes;
               if (_p114.ctor === "Err") {
                     return exp;
                  } else {
                     var newLocIdToNumberAndLoc = locIdToNumberAndLocOf(exp);
                     return A8(makeEquidistantOverlappingTriples,
                     exp,
                     A2($List._op["::"],
                     _p111._1._0,
                     A2($List._op["::"],
                     _p111._1._1._0,
                     A2($List._op["::"],_p111._1._1._1._0,_p111._1._1._1._1))),
                     slideNumber,
                     movieNumber,
                     movieTime,
                     _p114._0,
                     syncOptions,
                     newLocIdToNumberAndLoc);
                  }
            } else {
               return exp;
            }
      };
      var _p115 = A2($List.take,3,sortedFeatures);
      if (_p115.ctor === "::" && _p115._1.ctor === "::" && _p115._1._1.ctor === "::" && _p115._1._1._1.ctor === "[]")
      {
            var maybeNewExp = function () {
               var _p116 = slate;
               var tree = _p116._1;
               var maybeAEqn = A3(typeAndNodeIdAndFeatureToEquation,
               _p115._0,
               tree,
               locIdToNumberAndLoc);
               var maybeBEqn = A3(typeAndNodeIdAndFeatureToEquation,
               _p115._1._0,
               tree,
               locIdToNumberAndLoc);
               var maybeCEqn = A3(typeAndNodeIdAndFeatureToEquation,
               _p115._1._1._0,
               tree,
               locIdToNumberAndLoc);
               var _p117 = {ctor: "_Tuple3"
                           ,_0: maybeAEqn
                           ,_1: maybeBEqn
                           ,_2: maybeCEqn};
               if (_p117.ctor === "_Tuple3" && _p117._0.ctor === "Just" && _p117._1.ctor === "Just" && _p117._2.ctor === "Just")
               {
                     var _p118 = _p117._1._0;
                     var distanceAB = A2($ShapeWidgets.EqnOp,
                     $Lang.Minus,
                     _U.list([_p118,_p117._0._0]));
                     var distanceBC = A2($ShapeWidgets.EqnOp,
                     $Lang.Minus,
                     _U.list([_p117._2._0,_p118]));
                     return A4(makeEqual__,
                     originalExp,
                     distanceAB,
                     distanceBC,
                     syncOptions);
                  } else {
                     return $Maybe.Nothing;
                  }
            }();
            var _p119 = maybeNewExp;
            if (_p119.ctor === "Just") {
                  return relateMore(_p119._0);
               } else {
                  return relateMore(originalExp);
               }
         } else {
            return originalExp;
         }
   });
   var makeEquidistant = F7(function (originalExp,
   selectedFeatures,
   slideNumber,
   movieNumber,
   movieTime,
   slate,
   syncOptions) {
      var locIdToNumberAndLoc = locIdToNumberAndLocOf(originalExp);
      var features = $Set.toList(selectedFeatures);
      var evaluatedFeatures = A2($List.map,
      function (feature) {
         return A3(evaluateFeature,feature,slate,locIdToNumberAndLoc);
      },
      features);
      if (A2($List.all,
      F2(function (x,y) {    return !_U.eq(x,y);})($Maybe.Nothing),
      evaluatedFeatures)) {
            var sortedFeatures = A2($List.sortBy,
            function (feature) {
               return $Utils.fromJust(A3(evaluateFeature,
               feature,
               slate,
               locIdToNumberAndLoc));
            },
            features);
            return A8(makeEquidistantOverlappingTriples,
            originalExp,
            sortedFeatures,
            slideNumber,
            movieNumber,
            movieTime,
            slate,
            syncOptions,
            locIdToNumberAndLoc);
         } else return originalExp;
   });
   var makeEqual_ = F5(function (originalExp,
   featureA,
   featureB,
   slate,
   syncOptions) {
      var _p120 = slate;
      var tree = _p120._1;
      var locIdToNumberAndLoc = locIdToNumberAndLocOf(originalExp);
      var _p121 = {ctor: "_Tuple2"
                  ,_0: A3(typeAndNodeIdAndFeatureToEquation,
                  featureA,
                  tree,
                  locIdToNumberAndLoc)
                  ,_1: A3(typeAndNodeIdAndFeatureToEquation,
                  featureB,
                  tree,
                  locIdToNumberAndLoc)};
      if (_p121._0.ctor === "Nothing") {
            return $Maybe.Nothing;
         } else {
            if (_p121._1.ctor === "Nothing") {
                  return $Maybe.Nothing;
               } else {
                  return A4(makeEqual__,
                  originalExp,
                  _p121._0._0,
                  _p121._1._0,
                  syncOptions);
               }
         }
   });
   var makeEqualOverlappingPairs = F6(function (originalExp,
   features,
   slideNumber,
   movieNumber,
   movieTime,
   syncOptions) {
      var relateMore = function (exp) {
         var _p122 = features;
         if (_p122.ctor === "::") {
               return A6(makeEqualOverlappingPairs,
               exp,
               _p122._1,
               slideNumber,
               movieNumber,
               movieTime,
               syncOptions);
            } else {
               return _U.crashCase("ValueBasedTransform",
               {start: {line: 211,column: 5},end: {line: 217,column: 59}},
               _p122)("makeEqualOverlappingPairs relateMore");
            }
      };
      var _p124 = A2($List.take,2,features);
      if (_p124.ctor === "::" && _p124._1.ctor === "::" && _p124._1._1.ctor === "[]")
      {
            var slateRes = A2($Result.andThen,
            $Eval.run(originalExp),
            function (_p125) {
               var _p126 = _p125;
               return A4($LangSvg.resolveToIndexedTree,
               slideNumber,
               movieNumber,
               movieTime,
               _p126._0);
            });
            var _p127 = slateRes;
            if (_p127.ctor === "Err") {
                  return originalExp;
               } else {
                  var maybeNewExp = A5(makeEqual_,
                  originalExp,
                  _p124._0,
                  _p124._1._0,
                  _p127._0,
                  syncOptions);
                  var _p128 = maybeNewExp;
                  if (_p128.ctor === "Just") {
                        return relateMore(_p128._0);
                     } else {
                        return relateMore(originalExp);
                     }
               }
         } else {
            return originalExp;
         }
   });
   var makeEqual = F6(function (originalExp,
   selectedFeatures,
   slideNumber,
   movieNumber,
   movieTime,
   syncOptions) {
      var equalize = F2(function (exp,features) {
         return A6(makeEqualOverlappingPairs,
         exp,
         features,
         slideNumber,
         movieNumber,
         movieTime,
         syncOptions);
      });
      var selectedPoints = featurePoints($Set.toList(selectedFeatures));
      if (_U.eq(2 * $List.length(selectedPoints),
      $Set.size(selectedFeatures))) {
            var xFeatures = A2($List.map,$Basics.fst,selectedPoints);
            var yFeatures = A2($List.map,$Basics.snd,selectedPoints);
            var xsEqualized = A2(equalize,originalExp,xFeatures);
            var xysEqualized = A2(equalize,xsEqualized,yFeatures);
            return xysEqualized;
         } else return A2(equalize,
         originalExp,
         $Set.toList(selectedFeatures));
   });
   return _elm.ValueBasedTransform.values = {_op: _op
                                            ,debugLog: debugLog
                                            ,digHole: digHole
                                            ,makeEqual: makeEqual
                                            ,makeEqualOverlappingPairs: makeEqualOverlappingPairs
                                            ,makeEquidistant: makeEquidistant
                                            ,makeEquidistantOverlappingTriples: makeEquidistantOverlappingTriples
                                            ,makeEqual_: makeEqual_
                                            ,makeEqual__: makeEqual__
                                            ,deepestCommonScope: deepestCommonScope
                                            ,nonCollidingName: nonCollidingName
                                            ,variableifyConstantsAndWrapTargetExpWithLets: variableifyConstantsAndWrapTargetExpWithLets
                                            ,wrapWithLets: wrapWithLets
                                            ,pluckFeatureEquationNamed: pluckFeatureEquationNamed
                                            ,pluckSelectedFeatureEquationsNamed: pluckSelectedFeatureEquationsNamed
                                            ,pluckSelectedFeatureEquations: pluckSelectedFeatureEquations
                                            ,locIdToNumberAndLocOf: locIdToNumberAndLocOf
                                            ,locIdToWidgetDeclOf: locIdToWidgetDeclOf
                                            ,locIdToWidgetDeclLittleOf: locIdToWidgetDeclLittleOf
                                            ,pluckSelectedVals: pluckSelectedVals
                                            ,evaluateFeature: evaluateFeature
                                            ,typeAndNodeIdAndFeatureToEquation: typeAndNodeIdAndFeatureToEquation
                                            ,equationVals: equationVals
                                            ,equationLocs: equationLocs
                                            ,solveForLoc: solveForLoc
                                            ,maybeExtractUnsharedExpression: maybeExtractUnsharedExpression
                                            ,featureEquationToLocEquation: featureEquationToLocEquation
                                            ,xFeatureNameRegex: xFeatureNameRegex
                                            ,yFeatureNameRegex: yFeatureNameRegex
                                            ,xOrYFeatureNameRegex: xOrYFeatureNameRegex
                                            ,featureNameIsX: featureNameIsX
                                            ,featureNameIsY: featureNameIsY
                                            ,featureNameIsXOrY: featureNameIsXOrY
                                            ,featurePointAndNumber: featurePointAndNumber
                                            ,featuresNamesAreXYPairs: featuresNamesAreXYPairs
                                            ,featurePoints: featurePoints
                                            ,equationToLittle: equationToLittle};
};
Elm.InterfaceController = Elm.InterfaceController || {};
Elm.InterfaceController.make = function (_elm) {
   "use strict";
   _elm.InterfaceController = _elm.InterfaceController || {};
   if (_elm.InterfaceController.values)
   return _elm.InterfaceController.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Ace = Elm.Ace.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Blobs = Elm.Blobs.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $Draw = Elm.Draw.make(_elm),
   $Either = Elm.Either.make(_elm),
   $Eval = Elm.Eval.make(_elm),
   $ExamplesGenerated = Elm.ExamplesGenerated.make(_elm),
   $ExpressionBasedTransform = Elm.ExpressionBasedTransform.make(_elm),
   $InterfaceModel = Elm.InterfaceModel.make(_elm),
   $InterfaceStorage = Elm.InterfaceStorage.make(_elm),
   $Keys = Elm.Keys.make(_elm),
   $LangParser2 = Elm.LangParser2.make(_elm),
   $LangSvg = Elm.LangSvg.make(_elm),
   $LangTransform = Elm.LangTransform.make(_elm),
   $LangUnparser = Elm.LangUnparser.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $ShapeWidgets = Elm.ShapeWidgets.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Sync = Elm.Sync.make(_elm),
   $Types = Elm.Types.make(_elm),
   $Utils = Elm.Utils.make(_elm),
   $ValueBasedTransform = Elm.ValueBasedTransform.make(_elm);
   var _op = {};
   var onClickPrimaryZone = F4(function (i,k,z,old) {
      var hoveredCrosshairs$ = function () {
         var _p0 = A2($ShapeWidgets.zoneToCrosshair,k,z);
         if (_p0.ctor === "Just" && _p0._0.ctor === "_Tuple2") {
               return A2($Set.insert,
               {ctor: "_Tuple3",_0: i,_1: _p0._0._0,_2: _p0._0._1},
               old.hoveredCrosshairs);
            } else {
               return old.hoveredCrosshairs;
            }
      }();
      var _p1 = function () {
         var selectThisShape = function (_p2) {
            var _p3 = _p2;
            return A2($Set.insert,
            i,
            _U.eq(old.keysDown,
            $Keys.shift) ? old.selectedShapes : $Set.empty);
         };
         var selectBlob = function (blobId) {
            return A3($Dict.insert,
            blobId,
            i,
            _U.eq(old.keysDown,
            $Keys.shift) ? old.selectedBlobs : $Dict.empty);
         };
         var maybeBlobId = function () {
            var _p4 = A2($Dict.get,i,$Basics.snd(old.slate));
            if (_p4.ctor === "Just" && _p4._0.ctor === "SvgNode") {
                  return $LangSvg.maybeFindBlobId(_p4._0._1);
               } else {
                  return _U.crashCase("InterfaceController",
                  {start: {line: 269,column: 7},end: {line: 271,column: 73}},
                  _p4)("onClickPrimaryZone");
               }
         }();
         var _p6 = {ctor: "_Tuple3",_0: k,_1: z,_2: maybeBlobId};
         _v3_4: do {
            if (_p6.ctor === "_Tuple3") {
                  if (_p6._2.ctor === "Just") {
                        switch (_p6._1)
                        {case "Edge": if (_p6._0 === "line") {
                                   return {ctor: "_Tuple2"
                                          ,_0: selectThisShape({ctor: "_Tuple0"})
                                          ,_1: selectBlob(_p6._2._0)};
                                } else {
                                   break _v3_4;
                                }
                           case "Interior": return {ctor: "_Tuple2"
                                                   ,_0: selectThisShape({ctor: "_Tuple0"})
                                                   ,_1: selectBlob(_p6._2._0)};
                           default: break _v3_4;}
                     } else {
                        switch (_p6._1)
                        {case "Edge": if (_p6._0 === "line") {
                                   return {ctor: "_Tuple2"
                                          ,_0: selectThisShape({ctor: "_Tuple0"})
                                          ,_1: old.selectedBlobs};
                                } else {
                                   break _v3_4;
                                }
                           case "Interior": return {ctor: "_Tuple2"
                                                   ,_0: selectThisShape({ctor: "_Tuple0"})
                                                   ,_1: old.selectedBlobs};
                           default: break _v3_4;}
                     }
               } else {
                  break _v3_4;
               }
         } while (false);
         return {ctor: "_Tuple2"
                ,_0: old.selectedShapes
                ,_1: old.selectedBlobs};
      }();
      var selectedShapes$ = _p1._0;
      var selectedBlobs$ = _p1._1;
      return _U.update(old,
      {hoveredCrosshairs: hoveredCrosshairs$
      ,selectedShapes: selectedShapes$
      ,selectedBlobs: selectedBlobs$});
   });
   var canvasOriginHorizontal = function (old) {
      var wTools = $Config.params.mainSection.widgets.wBtn + 2 * $Config.params.mainSection.vertical.wGut;
      var hGut = $Config.params.mainSection.horizontal.hGut;
      var hBot = $Config.params.botSection.h;
      var hTop = $Config.params.topSection.h;
      var hCode_ = ($Basics.snd(old.dimensions) - hTop - hBot - hGut) / 2 | 0;
      var hCode = hCode_ + old.midOffsetY;
      return {ctor: "_Tuple2"
             ,_0: wTools
             ,_1: $Config.params.topSection.h + hCode + hGut};
   };
   var canvasOriginVertical = function (old) {
      var wMiddle = $Config.params.mainSection.widgets.wBtn;
      var wGut = $Config.params.mainSection.vertical.wGut;
      var sideGut = $Config.params.topSection.h;
      var wCode_ = ($Basics.fst(old.dimensions) - sideGut - sideGut - wMiddle - wGut - wGut) / 2 | 0;
      var wCode = old.hideCode ? 0 : old.hideCanvas ? $Basics.fst(old.dimensions) - sideGut - sideGut - wMiddle - wGut - wGut : wCode_ + old.midOffsetX;
      return {ctor: "_Tuple2"
             ,_0: sideGut + wCode + 2 * wGut + wMiddle
             ,_1: $Config.params.topSection.h};
   };
   var clickToCanvasPoint = F2(function (old,_p7) {
      var _p8 = _p7;
      var _p9 = function () {
         var _p10 = old.orient;
         if (_p10.ctor === "Vertical") {
               return canvasOriginVertical(old);
            } else {
               return canvasOriginHorizontal(old);
            }
      }();
      var xOrigin = _p9._0;
      var yOrigin = _p9._1;
      return {ctor: "_Tuple2"
             ,_0: _p8._0 - xOrigin
             ,_1: _p8._1 - yOrigin};
   });
   var switchToCursorTool = function (old) {
      return _U.update(old,
      {mouseMode: $InterfaceModel.MouseNothing
      ,tool: $InterfaceModel.Cursor});
   };
   var updateCodeBoxWithParseError = F2(function (annot,
   codeBoxInfo) {
      return _U.update(codeBoxInfo,
      {annotations: _U.list([annot])
      ,highlights: _U.list([])
      ,tooltips: _U.list([])});
   });
   var updateCodeBoxWithTypes = F2(function (ati,codeBoxInfo) {
      return _U.update(codeBoxInfo,
      {annotations: ati.annotations
      ,highlights: ati.highlights
      ,tooltips: ati.tooltips});
   });
   var handleError = F2(function (oldModel,result) {
      var _p11 = result;
      if (_p11.ctor === "Ok") {
            return _p11._0;
         } else {
            return _U.update(oldModel,{errorBox: $Maybe.Just(_p11._0)});
         }
   });
   var onMouseMove = F2(function (_p12,old) {
      var _p13 = _p12;
      var _p31 = _p13._1;
      var _p30 = _p13._0;
      var _p14 = A2(clickToCanvasPoint,
      old,
      {ctor: "_Tuple2",_0: _p30,_1: _p31});
      var mx = _p14._0;
      var my = _p14._1;
      var _p15 = old.mouseMode;
      switch (_p15.ctor)
      {case "MouseNothing": return old;
         case "MouseResizeMid": if (_p15._0.ctor === "Nothing") {
                 var f = function () {
                    var _p16 = old.orient;
                    if (_p16.ctor === "Vertical") {
                          return function (_p17) {
                             var _p18 = _p17;
                             return {ctor: "_Tuple2"
                                    ,_0: old.midOffsetX + _p18._0 - _p30
                                    ,_1: old.midOffsetY};
                          };
                       } else {
                          return function (_p19) {
                             var _p20 = _p19;
                             return {ctor: "_Tuple2"
                                    ,_0: old.midOffsetY
                                    ,_1: old.midOffsetY + _p20._1 - _p31};
                          };
                       }
                 }();
                 return _U.update(old,
                 {mouseMode: $InterfaceModel.MouseResizeMid($Maybe.Just(f))});
              } else {
                 var _p21 = _p15._0._0({ctor: "_Tuple2",_0: _p30,_1: _p31});
                 var x = _p21._0;
                 var y = _p21._1;
                 return _U.update(old,{midOffsetX: x,midOffsetY: y});
              }
         case "MouseDragZone": if (_p15._1.ctor === "Nothing") {
                 return old;
              } else {
                 var _p28 = _p15._1._0._0;
                 var _p27 = _p15._1._0._1._1;
                 var _p26 = _p15._1._0._1._0;
                 var dx = _U.eq(old.keysDown,$Keys.y) ? 0 : mx - _p26;
                 var dy = _U.eq(old.keysDown,$Keys.x) ? 0 : my - _p27;
                 var _p22 = A2(_p28,
                 {ctor: "_Tuple2",_0: _p26,_1: _p27},
                 {ctor: "_Tuple2",_0: dx,_1: dy});
                 var newExp = _p22._0;
                 var highlights = _p22._1;
                 var codeBoxInfo$ = function () {
                    var codeBoxInfo = old.codeBoxInfo;
                    return _U.update(codeBoxInfo,{highlights: highlights});
                 }();
                 var dragInfo$ = {ctor: "_Tuple3"
                                 ,_0: _p28
                                 ,_1: {ctor: "_Tuple2",_0: _p26,_1: _p27}
                                 ,_2: true};
                 return A2(handleError,
                 old,
                 A2($Result.andThen,
                 $Eval.run(newExp),
                 function (_p23) {
                    var _p24 = _p23;
                    var _p25 = _p24._0;
                    return A2($Result.map,
                    function (newSlate) {
                       return _U.update(old,
                       {code: $LangUnparser.unparse(newExp)
                       ,inputExp: newExp
                       ,inputVal: _p25
                       ,slate: newSlate
                       ,widgets: _p24._1
                       ,codeBoxInfo: codeBoxInfo$
                       ,mouseMode: A2($InterfaceModel.MouseDragZone,
                       _p15._0,
                       $Maybe.Just(dragInfo$))});
                    },
                    $LangSvg.valToIndexedTree(_p25));
                 }));
              }
         default: var _p29 = {ctor: "_Tuple2",_0: old.tool,_1: _p15._0};
           _v13_1: do {
              _v13_0: do {
                 if (_p29._1.ctor === "[]") {
                       switch (_p29._0.ctor)
                       {case "Poly": break _v13_0;
                          case "Path": break _v13_1;
                          default: var pointOnCanvas = {ctor: "_Tuple2"
                                                       ,_0: old.keysDown
                                                       ,_1: {ctor: "_Tuple2",_0: mx,_1: my}};
                            return _U.update(old,
                            {mouseMode: $InterfaceModel.MouseDrawNew(_U.list([pointOnCanvas
                                                                             ,pointOnCanvas]))});}
                    } else {
                       switch (_p29._0.ctor)
                       {case "Poly": break _v13_0;
                          case "Path": break _v13_1;
                          default: var pointOnCanvas = {ctor: "_Tuple2"
                                                       ,_0: old.keysDown
                                                       ,_1: {ctor: "_Tuple2",_0: mx,_1: my}};
                            return _U.update(old,
                            {mouseMode: $InterfaceModel.MouseDrawNew(A2($List._op["::"],
                            pointOnCanvas,
                            _p29._1._1))});}
                    }
              } while (false);
              return old;
           } while (false);
           return old;}
   });
   var slateAndCode = F2(function (old,_p32) {
      var _p33 = _p32;
      return A2($Result.map,
      function (slate) {
         return {ctor: "_Tuple2"
                ,_0: slate
                ,_1: $LangUnparser.unparse(_p33._0)};
      },
      A4($LangSvg.resolveToIndexedTree,
      old.slideNumber,
      old.movieNumber,
      old.movieTime,
      _p33._1));
   });
   var runWithErrorHandling = F3(function (model,exp,onOk) {
      var result = A2($Result.andThen,
      $Eval.run(exp),
      function (_p34) {
         var _p35 = _p34;
         var _p38 = _p35._0;
         return A2($Result.map,
         function (_p36) {
            var _p37 = _p36;
            return A4(onOk,_p38,_p35._1,_p37._0,_p37._1);
         },
         A2(slateAndCode,model,{ctor: "_Tuple2",_0: exp,_1: _p38}));
      });
      return A2(handleError,model,result);
   });
   var between1 = F2(function (i,_p39) {
      var _p40 = _p39;
      return A2($Utils.between,
      i,
      {ctor: "_Tuple2",_0: _p40._0 + 1,_1: _p40._1 + 1});
   });
   var addToHistory = F2(function (currentCode,h) {
      var _p41 = h;
      var past = _p41._0;
      var _p42 = past;
      if (_p42.ctor === "[]") {
            return {ctor: "_Tuple2"
                   ,_0: A2($List._op["::"],currentCode,past)
                   ,_1: _U.list([])};
         } else {
            return _U.eq(currentCode,_p42._0) ? h : {ctor: "_Tuple2"
                                                    ,_0: A2($List._op["::"],currentCode,past)
                                                    ,_1: _U.list([])};
         }
   });
   var switchOrient = function (m) {
      var _p43 = m;
      if (_p43.ctor === "Vertical") {
            return $InterfaceModel.Horizontal;
         } else {
            return $InterfaceModel.Vertical;
         }
   };
   var refreshHighlights = F2(function (zoneKey,model) {
      var codeBoxInfo = model.codeBoxInfo;
      var hi = A2($InterfaceModel.liveInfoToHighlights,zoneKey,model);
      return _U.update(model,
      {codeBoxInfo: _U.update(codeBoxInfo,{highlights: hi})});
   });
   var refreshMode = F2(function (model,e) {
      var _p44 = model.mode;
      switch (_p44.ctor)
      {case "Live": return A2($Utils.fromOk,
           "refreshMode",
           A5($InterfaceModel.mkLive_,
           model.syncOptions,
           model.slideNumber,
           model.movieNumber,
           model.movieTime,
           e));
         case "Print": return A2($Utils.fromOk,
           "refreshMode",
           A5($InterfaceModel.mkLive_,
           model.syncOptions,
           model.slideNumber,
           model.movieNumber,
           model.movieTime,
           e));
         default: return _p44;}
   });
   var refreshMode_ = function (model) {
      return A2(refreshMode,model,model.inputExp);
   };
   var tryRun = function (old) {
      var _p45 = $LangParser2.parseE(old.code);
      if (_p45.ctor === "Err") {
            return $Result.Err({ctor: "_Tuple2"
                               ,_0: _p45._0._0
                               ,_1: $Maybe.Just(_p45._0._1)});
         } else {
            var _p53 = _p45._0;
            var result = function () {
               var aceTypeInfo = $Types.dummyAceTypeInfo;
               return A2($Result.andThen,
               $Eval.run(_p53),
               function (_p46) {
                  var _p47 = _p46;
                  var _p51 = _p47._0;
                  return A2($Result.map,
                  function (_p48) {
                     var _p49 = _p48;
                     var _p50 = _p49._2;
                     var newCode = $LangUnparser.unparse(_p53);
                     var lambdaTools$ = function () {
                        var program = $Blobs.splitExp(_p53);
                        var options = A2($Basics._op["++"],
                        $Draw.lambdaToolOptionsOf(program),
                        $Basics.snd($InterfaceModel.sampleModel.lambdaTools));
                        var selectedIdx = A2($Basics.min,
                        $Basics.fst(old.lambdaTools),
                        $List.length(options));
                        return {ctor: "_Tuple2",_0: selectedIdx,_1: options};
                     }();
                     var $new = _U.update(old,
                     {inputExp: _p53
                     ,inputVal: _p51
                     ,code: newCode
                     ,slideCount: _p49._0
                     ,movieCount: _p49._1
                     ,movieTime: 0
                     ,movieDuration: _p50
                     ,movieContinue: _p49._3
                     ,runAnimation: _U.cmp(_p50,0) > 0
                     ,slate: _p49._4
                     ,widgets: _p47._1
                     ,history: A2(addToHistory,newCode,old.history)
                     ,caption: $Maybe.Nothing
                     ,syncOptions: A2($Sync.syncOptionsOf,old.syncOptions,_p53)
                     ,lambdaTools: lambdaTools$
                     ,codeBoxInfo: A2(updateCodeBoxWithTypes,
                     aceTypeInfo,
                     old.codeBoxInfo)});
                     return _U.update($new,
                     {mode: refreshMode_($new),errorBox: $Maybe.Nothing});
                  },
                  A4($LangSvg.fetchEverything,
                  old.slideNumber,
                  old.movieNumber,
                  0.0,
                  _p51));
               });
            }();
            var _p52 = result;
            if (_p52.ctor === "Err") {
                  return $Result.Err({ctor: "_Tuple2"
                                     ,_0: _p52._0
                                     ,_1: $Maybe.Nothing});
               } else {
                  return $Result.Ok(_p52._0);
               }
         }
   };
   var debugLog = $Config.debugLog($Config.debugController);
   var upstate = F2(function (evt,old) {
      upstate: while (true) {
         var _p54 = A2(debugLog,"Event",evt);
         switch (_p54.ctor)
         {case "Noop": return old;
            case "WindowDimensions": return _U.update(old,
              {dimensions: _p54._0});
            case "Run": var _p55 = tryRun(old);
              if (_p55.ctor === "Err") {
                    if (_p55._0._1.ctor === "Just") {
                          return _U.update(old,
                          {errorBox: $Maybe.Just(_p55._0._0)
                          ,codeBoxInfo: A2(updateCodeBoxWithParseError,
                          _p55._0._1._0,
                          old.codeBoxInfo)});
                       } else {
                          return _U.update(old,{errorBox: $Maybe.Just(_p55._0._0)});
                       }
                 } else {
                    return _p55._0;
                 }
            case "TryParseRun": var _p56 = tryRun(_p54._0);
              if (_p56.ctor === "Err") {
                    if (_p56._0._1.ctor === "Just") {
                          return _U.update(old,
                          {caption: $Maybe.Just($InterfaceModel.LangError(_p56._0._0))
                          ,codeBoxInfo: A2(updateCodeBoxWithParseError,
                          _p56._0._1._0,
                          old.codeBoxInfo)});
                       } else {
                          return _U.update(old,
                          {caption: $Maybe.Just($InterfaceModel.LangError(_p56._0._0))});
                       }
                 } else {
                    return _p56._0;
                 }
            case "StartAnimation": var _v28 = $InterfaceModel.Redraw,
              _v29 = _U.update(old,{movieTime: 0,runAnimation: true});
              evt = _v28;
              old = _v29;
              continue upstate;
            case "Redraw": var _p57 = A4($LangSvg.fetchEverything,
              old.slideNumber,
              old.movieNumber,
              old.movieTime,
              old.inputVal);
              if (_p57.ctor === "Ok") {
                    return _U.update(old,
                    {slideCount: _p57._0._0
                    ,movieCount: _p57._0._1
                    ,movieDuration: _p57._0._2
                    ,movieContinue: _p57._0._3
                    ,slate: _p57._0._4});
                 } else {
                    return _U.update(old,{errorBox: $Maybe.Just(_p57._0)});
                 }
            case "ToggleOutput": var m = function () {
                 var _p58 = old.mode;
                 if (_p58.ctor === "Print") {
                       return refreshMode_(old);
                    } else {
                       return $InterfaceModel.Print(A2($LangSvg.printSvg,
                       old.showGhosts,
                       old.slate));
                    }
              }();
              return _U.update(old,{mode: m});
            case "StartResizingMid":
            return old.hideCode ? old : old.hideCanvas ? old : _U.update(old,
              {mouseMode: $InterfaceModel.MouseResizeMid($Maybe.Nothing)});
            case "ClickZone": var _p61 = _p54._0;
              var _p59 = old.mode;
              if (_p59.ctor === "Live") {
                    var _p60 = A2(clickToCanvasPoint,
                    old,
                    $Basics.snd(old.mouseState));
                    var mx = _p60._0;
                    var my = _p60._1;
                    var trigger = A3($Sync.prepareLiveTrigger,
                    _p59._0,
                    old.inputExp,
                    _p61);
                    var dragInfo = {ctor: "_Tuple3"
                                   ,_0: trigger
                                   ,_1: {ctor: "_Tuple2",_0: mx,_1: my}
                                   ,_2: false};
                    return _U.update(old,
                    {mouseMode: A2($InterfaceModel.MouseDragZone,
                    _p61,
                    $Maybe.Just(dragInfo))});
                 } else {
                    return old;
                 }
            case "MouseClickCanvas": var _p62 = {ctor: "_Tuple2"
                                                ,_0: old.tool
                                                ,_1: old.mouseMode};
              _v33_3: do {
                 _v33_1: do {
                    if (_p62.ctor === "_Tuple2") {
                          if (_p62._0.ctor === "Cursor") {
                                switch (_p62._1.ctor)
                                {case "MouseDragZone": if (_p62._1._0.ctor === "Left") {
                                           return old;
                                        } else {
                                           break _v33_1;
                                        }
                                   case "MouseNothing": break _v33_1;
                                   default: break _v33_1;}
                             } else {
                                if (_p62._1.ctor === "MouseNothing") {
                                      return _U.update(old,
                                      {mouseMode: $InterfaceModel.MouseDrawNew(_U.list([]))
                                      ,selectedShapes: $Set.empty
                                      ,selectedBlobs: $Dict.empty});
                                   } else {
                                      break _v33_3;
                                   }
                             }
                       } else {
                          break _v33_3;
                       }
                 } while (false);
                 return _U.update(old,
                 {selectedShapes: $Set.empty,selectedBlobs: $Dict.empty});
              } while (false);
              return old;
            case "MousePosition": var _p64 = _p54._0;
              var _p63 = old.mouseState;
              if (_p63._0.ctor === "Nothing") {
                    return _U.update(old,
                    {mouseState: {ctor: "_Tuple2",_0: $Maybe.Nothing,_1: _p64}});
                 } else {
                    if (_p63._0._0 === false) {
                          return A2(onMouseMove,
                          _p64,
                          _U.update(old,
                          {mouseState: {ctor: "_Tuple2"
                                       ,_0: $Maybe.Just(true)
                                       ,_1: _p64}}));
                       } else {
                          return A2(onMouseMove,
                          _p64,
                          _U.update(old,
                          {mouseState: {ctor: "_Tuple2"
                                       ,_0: $Maybe.Just(true)
                                       ,_1: _p64}}));
                       }
                 }
            case "MouseIsDown": var old = function () {
                 var _p65 = $Basics.snd(old.mouseState);
                 var x = _p65._0;
                 var y = _p65._1;
                 var lightestColor = 470;
                 return _U.update(old,
                 {randomColor: A2($Basics._op["%"],
                 old.randomColor + x + y,
                 lightestColor)});
              }();
              var _p66 = {ctor: "_Tuple2",_0: _p54._0,_1: old.mouseState};
              if (_p66._0 === false) {
                    if (_p66._1._0.ctor === "Just") {
                          if (_p66._1._0._0 === false) {
                                var _p69 = _p66._1._1;
                                var _p68 = A2(debugLog,"mouse click",{ctor: "_Tuple0"});
                                return A2(onMouseClick,
                                _p69,
                                _U.update(old,
                                {mouseState: {ctor: "_Tuple2",_0: $Maybe.Nothing,_1: _p69}}));
                             } else {
                                var _p70 = A2(debugLog,"mouse up",{ctor: "_Tuple0"});
                                return onMouseUp(_U.update(old,
                                {mouseState: {ctor: "_Tuple2"
                                             ,_0: $Maybe.Nothing
                                             ,_1: _p66._1._1}}));
                             }
                       } else {
                          var _p71 = A2(debugLog,
                          "mouse down was preempted by a handler in View",
                          {ctor: "_Tuple0"});
                          return old;
                       }
                 } else {
                    if (_p66._1._0.ctor === "Nothing") {
                          var _p67 = A2(debugLog,"mouse down",{ctor: "_Tuple0"});
                          return _U.update(old,
                          {mouseState: {ctor: "_Tuple2"
                                       ,_0: $Maybe.Just(false)
                                       ,_1: _p66._1._1}});
                       } else {
                          var _p72 = A2($Debug.log,
                          "upstate MouseIsDown: impossible",
                          {ctor: "_Tuple0"});
                          return old;
                       }
                 }
            case "TickDelta": var _p74 = _p54._0;
              var _p73 = old.mode;
              if (_p73.ctor === "SyncSelect") {
                    var adjustedDeltaT = _U.eq(old.syncSelectTime,
                    0.0) ? A3($Basics.clamp,0.0,50,_p74) : _p74;
                    var _v37 = $InterfaceModel.Redraw,
                    _v38 = _U.update(old,
                    {syncSelectTime: old.syncSelectTime + adjustedDeltaT / 1000});
                    evt = _v37;
                    old = _v38;
                    continue upstate;
                 } else {
                    if (_U.cmp(old.movieTime,old.movieDuration) < 0) {
                          var adjustedDeltaT = _U.eq(old.movieTime,
                          0.0) ? A3($Basics.clamp,0.0,50,_p74) : _p74;
                          var newMovieTime = A3($Basics.clamp,
                          0.0,
                          old.movieDuration,
                          old.movieTime + adjustedDeltaT / 1000);
                          var _v39 = $InterfaceModel.Redraw,
                          _v40 = _U.update(old,{movieTime: newMovieTime});
                          evt = _v39;
                          old = _v40;
                          continue upstate;
                       } else if (_U.eq(old.movieContinue,true)) {
                             var _v41 = $InterfaceModel.NextMovie,_v42 = old;
                             evt = _v41;
                             old = _v42;
                             continue upstate;
                          } else return _U.update(old,{runAnimation: false});
                 }
            case "DigHole": var newExp = A4($ValueBasedTransform.digHole,
              old.inputExp,
              old.selectedFeatures,
              old.slate,
              old.syncOptions);
              return A3(runWithErrorHandling,
              old,
              newExp,
              F4(function (newVal,newWidgets,newSlate,newCode) {
                 return A2(debugLog,
                 "new model",
                 _U.update(old,
                 {code: newCode
                 ,inputExp: newExp
                 ,inputVal: newVal
                 ,history: A2(addToHistory,old.code,old.history)
                 ,slate: newSlate
                 ,widgets: newWidgets
                 ,previewCode: $Maybe.Nothing
                 ,mode: A2($Utils.fromOk,
                 "DigHole MkLive",
                 A6($InterfaceModel.mkLive,
                 old.syncOptions,
                 old.slideNumber,
                 old.movieNumber,
                 old.movieTime,
                 newExp,
                 {ctor: "_Tuple2",_0: newVal,_1: newWidgets}))
                 ,selectedFeatures: $Set.empty}));
              }));
            case "MakeEqual":
            var newExp = A6($ValueBasedTransform.makeEqual,
              old.inputExp,
              old.selectedFeatures,
              old.slideNumber,
              old.movieNumber,
              old.movieTime,
              old.syncOptions);
              return A3(runWithErrorHandling,
              old,
              newExp,
              F4(function (newVal,newWidgets,newSlate,newCode) {
                 return A2(upstate,
                 $InterfaceModel.CleanCode,
                 A2(debugLog,
                 "new model",
                 _U.update(old,
                 {code: newCode
                 ,inputExp: newExp
                 ,inputVal: newVal
                 ,history: A2(addToHistory,old.code,old.history)
                 ,slate: newSlate
                 ,widgets: newWidgets
                 ,previewCode: $Maybe.Nothing
                 ,mode: A2($Utils.fromOk,
                 "MakeEqual MkLive",
                 A6($InterfaceModel.mkLive,
                 old.syncOptions,
                 old.slideNumber,
                 old.movieNumber,
                 old.movieTime,
                 newExp,
                 {ctor: "_Tuple2",_0: newVal,_1: newWidgets}))
                 ,selectedFeatures: $Set.empty})));
              }));
            case "MakeEquidistant":
            var newExp = A7($ValueBasedTransform.makeEquidistant,
              old.inputExp,
              old.selectedFeatures,
              old.slideNumber,
              old.movieNumber,
              old.movieTime,
              old.slate,
              old.syncOptions);
              return A3(runWithErrorHandling,
              old,
              newExp,
              F4(function (newVal,newWidgets,newSlate,newCode) {
                 return A2(debugLog,
                 "new model",
                 _U.update(old,
                 {code: newCode
                 ,inputExp: newExp
                 ,inputVal: newVal
                 ,history: A2(addToHistory,old.code,old.history)
                 ,slate: newSlate
                 ,widgets: newWidgets
                 ,previewCode: $Maybe.Nothing
                 ,mode: A2($Utils.fromOk,
                 "MakeEquidistant MkLive",
                 A6($InterfaceModel.mkLive,
                 old.syncOptions,
                 old.slideNumber,
                 old.movieNumber,
                 old.movieTime,
                 newExp,
                 {ctor: "_Tuple2",_0: newVal,_1: newWidgets}))
                 ,selectedFeatures: $Set.empty}));
              }));
            case "GroupBlobs":
            var _p75 = $Blobs.isSimpleProgram(old.inputExp);
              if (_p75.ctor === "Nothing") {
                    return old;
                 } else {
                    var _p78 = _p75._0;
                    var maybeAnchorPoint = $ExpressionBasedTransform.anchorOfSelectedFeatures(old.selectedFeatures);
                    var multipleSelectedBlobs = _U.cmp($Dict.size(old.selectedBlobs),
                    1) > 0;
                    var _p76 = {ctor: "_Tuple2"
                               ,_0: maybeAnchorPoint
                               ,_1: multipleSelectedBlobs};
                    if (_p76._0.ctor === "Ok") {
                          if (_p76._0._0.ctor === "Nothing") {
                                if (_p76._1 === false) {
                                      return old;
                                   } else {
                                      var _v45 = $InterfaceModel.Run,
                                      _v46 = A2($ExpressionBasedTransform.groupSelectedBlobs,
                                      old,
                                      _p78);
                                      evt = _v45;
                                      old = _v46;
                                      continue upstate;
                                   }
                             } else {
                                var _v47 = $InterfaceModel.Run,
                                _v48 = A3($ExpressionBasedTransform.groupSelectedBlobsAround,
                                old,
                                _p78,
                                _p76._0._0._0);
                                evt = _v47;
                                old = _v48;
                                continue upstate;
                             }
                       } else {
                          var _p77 = A2($Debug.log,"bad anchor",_p76._0._0);
                          return old;
                       }
                 }
            case "DuplicateBlobs": var _v49 = $InterfaceModel.Run,
              _v50 = $ExpressionBasedTransform.duplicateSelectedBlobs(old);
              evt = _v49;
              old = _v50;
              continue upstate;
            case "MergeBlobs": if (_U.cmp($Dict.size(old.selectedBlobs),
              1) < 1) return old; else {
                    var _v51 = $InterfaceModel.Run,
                    _v52 = $ExpressionBasedTransform.mergeSelectedBlobs(old);
                    evt = _v51;
                    old = _v52;
                    continue upstate;
                 }
            case "AbstractBlobs": var _v53 = $InterfaceModel.Run,
              _v54 = $ExpressionBasedTransform.abstractSelectedBlobs(old);
              evt = _v53;
              old = _v54;
              continue upstate;
            case "ReplicateBlob":
            var _p79 = $Blobs.isSimpleProgram(old.inputExp);
              if (_p79.ctor === "Nothing") {
                    return old;
                 } else {
                    var _v56 = $InterfaceModel.Run,
                    _v57 = A3($ExpressionBasedTransform.replicateSelectedBlob,
                    _p54._0,
                    old,
                    _p79._0);
                    evt = _v56;
                    old = _v57;
                    continue upstate;
                 }
            case "SelectOption": var _p81 = _p54._0._1;
              var _p80 = _p54._0._0;
              return _U.update(old,
              {code: _p54._0._3
              ,inputExp: _p80
              ,inputVal: _p81
              ,history: A2(addToHistory,old.code,old.history)
              ,slate: _p54._0._2
              ,previewCode: $Maybe.Nothing
              ,tool: $InterfaceModel.Cursor
              ,mode: A2($Utils.fromOk,
              "SelectOption mkLive",
              A6($InterfaceModel.mkLive,
              old.syncOptions,
              old.slideNumber,
              old.movieNumber,
              old.movieTime,
              _p80,
              {ctor: "_Tuple2",_0: _p81,_1: _U.list([])}))});
            case "PreviewCode": return _U.update(old,
              {previewCode: _p54._0});
            case "CancelSync": var _v58 = $InterfaceModel.Run,
              _v59 = _U.update(old,
              {mode: A2($Utils.fromOk,
              "CancelSync mkLive_",
              A5($InterfaceModel.mkLive_,
              old.syncOptions,
              old.slideNumber,
              old.movieNumber,
              old.movieTime,
              old.inputExp))});
              evt = _v58;
              old = _v59;
              continue upstate;
            case "SelectExample": var _p88 = _p54._0;
              if (_U.eq(_p88,$ExamplesGenerated.scratchName)) {
                    var _v60 = $InterfaceModel.Run,
                    _v61 = _U.update(old,
                    {exName: _p88
                    ,code: old.scratchCode
                    ,history: {ctor: "_Tuple2",_0: _U.list([]),_1: _U.list([])}});
                    evt = _v60;
                    old = _v61;
                    continue upstate;
                 } else {
                    var _p82 = _p54._1({ctor: "_Tuple0"});
                    var e = _p82.e;
                    var v = _p82.v;
                    var ws = _p82.ws;
                    var ati = _p82.ati;
                    var _p83 = function () {
                       var _p84 = old.mode;
                       switch (_p84.ctor)
                       {case "Live": var so = A2($Sync.syncOptionsOf,
                            old.syncOptions,
                            e);
                            return {ctor: "_Tuple2"
                                   ,_0: so
                                   ,_1: A2($Utils.fromOk,
                                   "SelectExample mkLive_",
                                   A6($InterfaceModel.mkLive,
                                   so,
                                   old.slideNumber,
                                   old.movieNumber,
                                   old.movieTime,
                                   e,
                                   {ctor: "_Tuple2",_0: v,_1: ws}))};
                          case "Print": var so = A2($Sync.syncOptionsOf,
                            old.syncOptions,
                            e);
                            return {ctor: "_Tuple2"
                                   ,_0: so
                                   ,_1: A2($Utils.fromOk,
                                   "SelectExample mkLive_",
                                   A6($InterfaceModel.mkLive,
                                   so,
                                   old.slideNumber,
                                   old.movieNumber,
                                   old.movieTime,
                                   e,
                                   {ctor: "_Tuple2",_0: v,_1: ws}))};
                          default: return {ctor: "_Tuple2"
                                          ,_0: old.syncOptions
                                          ,_1: old.mode};}
                    }();
                    var so = _p83._0;
                    var m = _p83._1;
                    var scratchCode$ = _U.eq(old.exName,
                    $ExamplesGenerated.scratchName) ? old.code : old.scratchCode;
                    return A2(handleError,
                    old,
                    A2($Result.map,
                    function (_p85) {
                       var _p86 = _p85;
                       var _p87 = _p86._2;
                       var code = $LangUnparser.unparse(e);
                       return _U.update(old,
                       {scratchCode: scratchCode$
                       ,exName: _p88
                       ,inputExp: e
                       ,inputVal: v
                       ,code: code
                       ,history: {ctor: "_Tuple2",_0: _U.list([code]),_1: _U.list([])}
                       ,mode: m
                       ,syncOptions: so
                       ,slideNumber: 1
                       ,slideCount: _p86._0
                       ,movieCount: _p86._1
                       ,movieTime: 0
                       ,movieDuration: _p87
                       ,movieContinue: _p86._3
                       ,runAnimation: _U.cmp(_p87,0) > 0
                       ,slate: _p86._4
                       ,widgets: ws
                       ,codeBoxInfo: A2(updateCodeBoxWithTypes,ati,old.codeBoxInfo)});
                    },
                    A4($LangSvg.fetchEverything,
                    old.slideNumber,
                    old.movieNumber,
                    old.movieTime,
                    v)));
                 }
            case "SwitchMode": return _U.update(old,{mode: _p54._0});
            case "SwitchOrient": return _U.update(old,
              {orient: switchOrient(old.orient)});
            case "Undo": var _p89 = old.history;
              if (_p89._0.ctor === "[]") {
                    return old;
                 } else {
                    if (_p89._0._1.ctor === "[]") {
                          return old;
                       } else {
                          var _p90 = _p89._0._1._0;
                          var $new = _U.update(old,
                          {history: {ctor: "_Tuple2"
                                    ,_0: A2($List._op["::"],_p90,_p89._0._1._1)
                                    ,_1: A2($List._op["::"],_p89._0._0,_p89._1)}
                          ,code: _p90});
                          var _v65 = $InterfaceModel.Run,_v66 = $new;
                          evt = _v65;
                          old = _v66;
                          continue upstate;
                       }
                 }
            case "Redo": var _p91 = old.history;
              if (_p91._1.ctor === "[]") {
                    return old;
                 } else {
                    var _p92 = _p91._1._0;
                    var $new = _U.update(old,
                    {history: {ctor: "_Tuple2"
                              ,_0: A2($List._op["::"],_p92,_p91._0)
                              ,_1: _p91._1._1}
                    ,code: _p92});
                    var _v68 = $InterfaceModel.Run,_v69 = $new;
                    evt = _v68;
                    old = _v69;
                    continue upstate;
                 }
            case "NextSlide": if (_U.cmp(old.slideNumber,
              old.slideCount) > -1) {
                    var _v70 = $InterfaceModel.StartAnimation,
                    _v71 = _U.update(old,
                    {slideNumber: old.slideNumber,movieNumber: old.movieCount});
                    evt = _v70;
                    old = _v71;
                    continue upstate;
                 } else {
                    var _v72 = $InterfaceModel.StartAnimation,
                    _v73 = _U.update(old,
                    {slideNumber: old.slideNumber + 1,movieNumber: 1});
                    evt = _v72;
                    old = _v73;
                    continue upstate;
                 }
            case "PreviousSlide": if (_U.cmp(old.slideNumber,1) < 1) {
                    var _v74 = $InterfaceModel.StartAnimation,
                    _v75 = _U.update(old,{slideNumber: 1,movieNumber: 1});
                    evt = _v74;
                    old = _v75;
                    continue upstate;
                 } else {
                    var previousSlideNumber = old.slideNumber - 1;
                    var result = A2($Result.andThen,
                    $Eval.run(old.inputExp),
                    function (_p93) {
                       var _p94 = _p93;
                       return A2($Result.map,
                       function (previousMovieCount) {
                          return A2(upstate,
                          $InterfaceModel.StartAnimation,
                          _U.update(old,
                          {slideNumber: previousSlideNumber
                          ,movieNumber: previousMovieCount}));
                       },
                       A2($LangSvg.resolveToMovieCount,previousSlideNumber,_p94._0));
                    });
                    return A2(handleError,old,result);
                 }
            case "NextMovie": if (_U.eq(old.movieNumber,
              old.movieCount) && _U.cmp(old.slideNumber,old.slideCount) < 0) {
                    var _v77 = $InterfaceModel.NextSlide,_v78 = old;
                    evt = _v77;
                    old = _v78;
                    continue upstate;
                 } else if (_U.cmp(old.movieNumber,old.movieCount) < 0) {
                       var _v79 = $InterfaceModel.StartAnimation,
                       _v80 = _U.update(old,{movieNumber: old.movieNumber + 1});
                       evt = _v79;
                       old = _v80;
                       continue upstate;
                    } else {
                       var _v81 = $InterfaceModel.Redraw,
                       _v82 = _U.update(old,
                       {movieTime: old.movieDuration,runAnimation: false});
                       evt = _v81;
                       old = _v82;
                       continue upstate;
                    }
            case "PreviousMovie": if (_U.eq(old.movieNumber,1)) {
                    var _v83 = $InterfaceModel.PreviousSlide,_v84 = old;
                    evt = _v83;
                    old = _v84;
                    continue upstate;
                 } else {
                    var _v85 = $InterfaceModel.StartAnimation,
                    _v86 = _U.update(old,{movieNumber: old.movieNumber - 1});
                    evt = _v85;
                    old = _v86;
                    continue upstate;
                 }
            case "KeysDown": var _p97 = _p54._0;
              var _p95 = A2(debugLog,"keys",$Basics.toString(_p97));
              var $new = _U.update(old,{keysDown: _p97});
              if (_U.eq(_p97,$Keys.escape)) {
                    var _p96 = {ctor: "_Tuple2"
                               ,_0: $new.tool
                               ,_1: $new.mouseMode};
                    _v87_3: do {
                       _v87_0: do {
                          if (_p96.ctor === "_Tuple2") {
                                switch (_p96._1.ctor)
                                {case "MouseNothing": if (_p96._0.ctor === "Cursor") {
                                           break _v87_0;
                                        } else {
                                           return _U.update($new,{tool: $InterfaceModel.Cursor});
                                        }
                                   case "MouseDrawNew": if (_p96._0.ctor === "Cursor") {
                                           break _v87_0;
                                        } else {
                                           return _U.update($new,
                                           {mouseMode: $InterfaceModel.MouseNothing});
                                        }
                                   default: if (_p96._0.ctor === "Cursor") {
                                           break _v87_0;
                                        } else {
                                           break _v87_3;
                                        }}
                             } else {
                                break _v87_3;
                             }
                       } while (false);
                       return _U.update($new,
                       {selectedFeatures: $Set.empty
                       ,selectedShapes: $Set.empty
                       ,selectedBlobs: $Dict.empty});
                    } while (false);
                    return $new;
                 } else if (_U.eq(_p97,$Keys.$delete)) {
                       var _v88 = $InterfaceModel.Run,
                       _v89 = $ExpressionBasedTransform.deleteSelectedBlobs($new);
                       evt = _v88;
                       old = _v89;
                       continue upstate;
                    } else return $new;
            case "CleanCode": var _p98 = $LangParser2.parseE(old.code);
              if (_p98.ctor === "Err") {
                    return _U.update(old,
                    {caption: $Maybe.Just($InterfaceModel.LangError(A2($Basics._op["++"],
                    "PARSE ERROR!\n",
                    _p98._0._0)))});
                 } else {
                    var cleanedExp = $LangParser2.freshen(A2($LangTransform.removeExtraPostfixes,
                    _U.list(["_orig","\'"]),
                    $LangTransform.simplify(_p98._0)));
                    var code$ = $LangUnparser.unparse(cleanedExp);
                    if (_U.eq(old.code,code$)) return old; else {
                          var _p99 = A2(debugLog,"Cleaned: ",code$);
                          var _v91 = $InterfaceModel.Run,
                          _v92 = _U.update(old,{inputExp: cleanedExp,code: code$});
                          evt = _v91;
                          old = _v92;
                          continue upstate;
                       }
                 }
            case "InstallSaveState":
            return $InterfaceStorage.installSaveState(old);
            case "RemoveDialog": return A3($InterfaceStorage.removeDialog,
              _p54._0,
              _p54._1,
              old);
            case "ToggleBasicCodeBox": return _U.update(old,
              {basicCodeBox: $Basics.not(old.basicCodeBox)});
            case "UpdateFieldContents": return _U.update(old,
              {fieldContents: _p54._0});
            case "UpdateModel": return _p54._0(old);
            case "MultiEvent": var _p100 = _p54._0;
              if (_p100.ctor === "[]") {
                    return old;
                 } else {
                    var _v94 = $InterfaceModel.MultiEvent(_p100._1),
                    _v95 = A2(upstate,_p100._0,old);
                    evt = _v94;
                    old = _v95;
                    continue upstate;
                 }
            case "WaitRun": return old;
            case "WaitSave": return _U.update(old,{exName: _p54._0});
            case "WaitClean": return old;
            default: return old;}
      }
   });
   var onMouseClick = F2(function (click,old) {
      var _p101 = {ctor: "_Tuple2",_0: old.tool,_1: old.mouseMode};
      _v96_6: do {
         if (_p101.ctor === "_Tuple2") {
               switch (_p101._1.ctor)
               {case "MouseDragZone":
                  if (_p101._0.ctor === "Cursor" && _p101._1._0.ctor === "Left" && _p101._1._0._0.ctor === "_Tuple3")
                    {
                          if (_p101._1._1.ctor === "Nothing") {
                                return A4(onClickPrimaryZone,
                                _p101._1._0._0._0,
                                _p101._1._0._0._1,
                                _p101._1._0._0._2,
                                _U.update(old,{mouseMode: $InterfaceModel.MouseNothing}));
                             } else {
                                if (_p101._1._1._0.ctor === "_Tuple3" && _p101._1._1._0._2 === false)
                                {
                                      return A4(onClickPrimaryZone,
                                      _p101._1._0._0._0,
                                      _p101._1._0._0._1,
                                      _p101._1._0._0._2,
                                      _U.update(old,{mouseMode: $InterfaceModel.MouseNothing}));
                                   } else {
                                      break _v96_6;
                                   }
                             }
                       } else {
                          break _v96_6;
                       }
                  case "MouseDrawNew": switch (_p101._0.ctor)
                    {case "Poly": var _p105 = _p101._1._0;
                         var pointOnCanvas = A2(clickToCanvasPoint,old,click);
                         var add = function (_p102) {
                            var _p103 = _p102;
                            var points$ = A2($List._op["::"],
                            {ctor: "_Tuple2",_0: old.keysDown,_1: pointOnCanvas},
                            _p105);
                            return _U.update(old,
                            {mouseMode: $InterfaceModel.MouseDrawNew(points$)});
                         };
                         if (_U.eq(_p105,_U.list([]))) return add({ctor: "_Tuple0"});
                         else {
                               var _p104 = $Utils.last_(_p105);
                               var initialPoint = _p104._1;
                               return _U.cmp(A2($Utils.distanceInt,pointOnCanvas,initialPoint),
                               $Draw.drawDotSize) > 0 ? add({ctor: "_Tuple0"}) : _U.eq($List.length(_p105),
                               2) ? _U.update(old,
                               {mouseMode: $InterfaceModel.MouseNothing}) : _U.eq($List.length(_p105),
                               1) ? switchToCursorTool(old) : A2(upstate,
                               $InterfaceModel.Run,
                               A3($Draw.addPolygon,_p101._0._0,old,_p105));
                            }
                       case "Path": var _p110 = _p101._0._0;
                         var _p109 = _p101._1._0;
                         var pointOnCanvas = A2(clickToCanvasPoint,old,click);
                         var add = function ($new) {
                            var points$ = A2($List._op["::"],
                            {ctor: "_Tuple2",_0: old.keysDown,_1: $new},
                            _p109);
                            return {ctor: "_Tuple2"
                                   ,_0: points$
                                   ,_1: _U.update(old,
                                   {mouseMode: $InterfaceModel.MouseDrawNew(points$)})};
                         };
                         var _p106 = _p109;
                         if (_p106.ctor === "[]") {
                               return $Basics.snd(add(pointOnCanvas));
                            } else {
                               if (_p106._1.ctor === "[]") {
                                     return _U.cmp(A2($Utils.distanceInt,
                                     pointOnCanvas,
                                     _p106._0._1),
                                     $Draw.drawDotSize) < 0 ? switchToCursorTool(old) : $Basics.snd(add(pointOnCanvas));
                                  } else {
                                     if (_U.cmp(A2($Utils.distanceInt,pointOnCanvas,_p106._0._1),
                                     $Draw.drawDotSize) < 0) return A2(upstate,
                                        $InterfaceModel.Run,
                                        A3($Draw.addPath,_p110,old,_p109)); else {
                                           var _p107 = $Utils.last_(_p109);
                                           var firstClick = _p107._1;
                                           if (_U.cmp(A2($Utils.distanceInt,pointOnCanvas,firstClick),
                                           $Draw.drawDotSize) < 0) {
                                                 var _p108 = add(firstClick);
                                                 var points$ = _p108._0;
                                                 var old$ = _p108._1;
                                                 return A2(upstate,
                                                 $InterfaceModel.Run,
                                                 A3($Draw.addPath,_p110,old$,points$));
                                              } else return $Basics.snd(add(pointOnCanvas));
                                        }
                                  }
                            }
                       case "HelperDot": if (_p101._1._0.ctor === "[]") {
                               var pointOnCanvas = {ctor: "_Tuple2"
                                                   ,_0: old.keysDown
                                                   ,_1: A2(clickToCanvasPoint,old,click)};
                               return _U.update(old,
                               {mouseMode: $InterfaceModel.MouseDrawNew(_U.list([pointOnCanvas]))});
                            } else {
                               break _v96_6;
                            }
                       default: if (_p101._1._0.ctor === "[]") {
                               return switchToCursorTool(old);
                            } else {
                               break _v96_6;
                            }}
                  default: break _v96_6;}
            } else {
               break _v96_6;
            }
      } while (false);
      return old;
   });
   var onMouseUp = function (old) {
      var _p111 = {ctor: "_Tuple2",_0: old.mode,_1: old.mouseMode};
      _v99_3: do {
         _v99_0: do {
            if (_p111.ctor === "_Tuple2") {
                  switch (_p111._1.ctor)
                  {case "MouseDragZone": if (_p111._0.ctor === "Print") {
                             break _v99_0;
                          } else {
                             if (_p111._1._1.ctor === "Just") {
                                   var e = A2($Utils.fromOkay,
                                   "onMouseUp",
                                   $LangParser2.parseE(old.code));
                                   var old$ = _U.update(old,{inputExp: e});
                                   return A2(refreshHighlights,
                                   _p111._1._0,
                                   _U.update(old$,
                                   {mouseMode: $InterfaceModel.MouseNothing
                                   ,mode: refreshMode_(old$)
                                   ,history: A2(addToHistory,old.code,old$.history)}));
                                } else {
                                   break _v99_3;
                                }
                          }
                     case "MouseDrawNew": if (_p111._0.ctor === "Print") {
                             break _v99_0;
                          } else {
                             var _p112 = {ctor: "_Tuple3"
                                         ,_0: old.tool
                                         ,_1: _p111._1._0
                                         ,_2: _U.eq(old.keysDown,$Keys.shift)};
                             _v100_16: do {
                                _v100_15: do {
                                   if (_p112.ctor === "_Tuple3") {
                                         switch (_p112._0.ctor)
                                         {case "Line": if (_p112._1.ctor === "::") {
                                                    if (_p112._1._1.ctor === "::" && _p112._1._1._1.ctor === "[]")
                                                    {
                                                          return A2(upstate,
                                                          $InterfaceModel.Run,
                                                          A3($Draw.addLine,old,_p112._1._0,_p112._1._1._0));
                                                       } else {
                                                          break _v100_16;
                                                       }
                                                 } else {
                                                    break _v100_15;
                                                 }
                                            case "HelperLine": if (_p112._1.ctor === "::") {
                                                    if (_p112._1._1.ctor === "::" && _p112._1._1._1.ctor === "[]")
                                                    {
                                                          return A2(upstate,
                                                          $InterfaceModel.Run,
                                                          A3($Draw.addLine,old,_p112._1._0,_p112._1._1._0));
                                                       } else {
                                                          break _v100_16;
                                                       }
                                                 } else {
                                                    break _v100_15;
                                                 }
                                            case "Rect": if (_p112._1.ctor === "::") {
                                                    if (_p112._1._1.ctor === "::" && _p112._1._1._1.ctor === "[]")
                                                    {
                                                          if (_p112._2 === false) {
                                                                switch (_p112._0._0.ctor)
                                                                {case "Raw": return A2(upstate,
                                                                     $InterfaceModel.Run,
                                                                     A3($Draw.addRawRect,old,_p112._1._0,_p112._1._1._0));
                                                                   case "Stretchy": return A2(upstate,
                                                                     $InterfaceModel.Run,
                                                                     A3($Draw.addStretchyRect,old,_p112._1._0,_p112._1._1._0));
                                                                   default: break _v100_16;}
                                                             } else {
                                                                switch (_p112._0._0.ctor)
                                                                {case "Raw": return A2(upstate,
                                                                     $InterfaceModel.Run,
                                                                     A3($Draw.addRawSquare,old,_p112._1._0,_p112._1._1._0));
                                                                   case "Stretchy": return A2(upstate,
                                                                     $InterfaceModel.Run,
                                                                     A3($Draw.addStretchySquare,old,_p112._1._0,_p112._1._1._0));
                                                                   default: break _v100_16;}
                                                             }
                                                       } else {
                                                          break _v100_16;
                                                       }
                                                 } else {
                                                    break _v100_15;
                                                 }
                                            case "Oval": if (_p112._1.ctor === "::") {
                                                    if (_p112._1._1.ctor === "::" && _p112._1._1._1.ctor === "[]")
                                                    {
                                                          if (_p112._2 === false) {
                                                                switch (_p112._0._0.ctor)
                                                                {case "Raw": return A2(upstate,
                                                                     $InterfaceModel.Run,
                                                                     A3($Draw.addRawOval,old,_p112._1._0,_p112._1._1._0));
                                                                   case "Stretchy": return A2(upstate,
                                                                     $InterfaceModel.Run,
                                                                     A3($Draw.addStretchyOval,old,_p112._1._0,_p112._1._1._0));
                                                                   default: break _v100_16;}
                                                             } else {
                                                                switch (_p112._0._0.ctor)
                                                                {case "Raw": return A2(upstate,
                                                                     $InterfaceModel.Run,
                                                                     A3($Draw.addRawCircle,old,_p112._1._0,_p112._1._1._0));
                                                                   case "Stretchy": return A2(upstate,
                                                                     $InterfaceModel.Run,
                                                                     A3($Draw.addStretchyCircle,old,_p112._1._0,_p112._1._1._0));
                                                                   default: break _v100_16;}
                                                             }
                                                       } else {
                                                          break _v100_16;
                                                       }
                                                 } else {
                                                    break _v100_15;
                                                 }
                                            case "HelperDot": if (_p112._1.ctor === "::") {
                                                    if (_p112._1._1.ctor === "[]") {
                                                          return A2(upstate,
                                                          $InterfaceModel.Run,
                                                          A2($Draw.addHelperDot,old,_p112._1._0));
                                                       } else {
                                                          break _v100_16;
                                                       }
                                                 } else {
                                                    break _v100_15;
                                                 }
                                            case "Lambda": if (_p112._1.ctor === "::") {
                                                    if (_p112._1._1.ctor === "::" && _p112._1._1._1.ctor === "[]")
                                                    {
                                                          return A2(upstate,
                                                          $InterfaceModel.Run,
                                                          A3($Draw.addLambda,old,_p112._1._0,_p112._1._1._0));
                                                       } else {
                                                          break _v100_16;
                                                       }
                                                 } else {
                                                    break _v100_15;
                                                 }
                                            case "Poly": return old;
                                            case "Path": return old;
                                            case "Text": if (_p112._1.ctor === "::") {
                                                    if (_p112._1._1.ctor === "::" && _p112._1._1._1.ctor === "[]")
                                                    {
                                                          return A2(upstate,
                                                          $InterfaceModel.Run,
                                                          A3($Draw.addTextBox,old,_p112._1._0,_p112._1._1._0));
                                                       } else {
                                                          break _v100_16;
                                                       }
                                                 } else {
                                                    break _v100_15;
                                                 }
                                            default: if (_p112._1.ctor === "[]") {
                                                    break _v100_15;
                                                 } else {
                                                    break _v100_16;
                                                 }}
                                      } else {
                                         break _v100_16;
                                      }
                                } while (false);
                                return switchToCursorTool(old);
                             } while (false);
                             return old;
                          }
                     default: if (_p111._0.ctor === "Print") {
                             break _v99_0;
                          } else {
                             break _v99_3;
                          }}
               } else {
                  break _v99_3;
               }
         } while (false);
         return old;
      } while (false);
      return _U.update(old,
      {mouseMode: $InterfaceModel.MouseNothing
      ,mode: refreshMode_(old)});
   };
   var adjustMidOffsetX = F2(function (old,dx) {
      var _p113 = old.orient;
      if (_p113.ctor === "Vertical") {
            return _U.update(old,{midOffsetX: old.midOffsetX + dx});
         } else {
            return A2(upstate,$InterfaceModel.SwitchOrient,old);
         }
   });
   var adjustMidOffsetY = F2(function (old,dy) {
      var _p114 = old.orient;
      if (_p114.ctor === "Horizontal") {
            return _U.update(old,{midOffsetY: old.midOffsetY + dy});
         } else {
            return A2(upstate,$InterfaceModel.SwitchOrient,old);
         }
   });
   return _elm.InterfaceController.values = {_op: _op
                                            ,upstate: upstate};
};
Elm.Main = Elm.Main || {};
Elm.Main.make = function (_elm) {
   "use strict";
   _elm.Main = _elm.Main || {};
   if (_elm.Main.values) return _elm.Main.values;
   var _U = Elm.Native.Utils.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $CodeBox = Elm.CodeBox.make(_elm),
   $Config = Elm.Config.make(_elm),
   $Debug = Elm.Debug.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $InterfaceController = Elm.InterfaceController.make(_elm),
   $InterfaceModel = Elm.InterfaceModel.make(_elm),
   $InterfaceStorage = Elm.InterfaceStorage.make(_elm),
   $InterfaceView2 = Elm.InterfaceView2.make(_elm),
   $Keyboard = Elm.Keyboard.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Mouse = Elm.Mouse.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Signal$Extra = Elm.Signal.Extra.make(_elm),
   $Task = Elm.Task.make(_elm),
   $Time = Elm.Time.make(_elm),
   $Window = Elm.Window.make(_elm);
   var _op = {};
   var theTurn = Elm.Native.Port.make(_elm).inboundSignal("theTurn",
   "CodeBox.AceMessage",
   function (v) {
      return typeof v === "object" && "evt" in v && "strArg" in v && "cursorArg" in v && "selectionArg" in v && "exNameArg" in v ? {_: {}
                                                                                                                                   ,evt: typeof v.evt === "string" || typeof v.evt === "object" && v.evt instanceof String ? v.evt : _U.badPort("a string",
                                                                                                                                   v.evt)
                                                                                                                                   ,strArg: typeof v.strArg === "string" || typeof v.strArg === "object" && v.strArg instanceof String ? v.strArg : _U.badPort("a string",
                                                                                                                                   v.strArg)
                                                                                                                                   ,cursorArg: typeof v.cursorArg === "object" && "row" in v.cursorArg && "column" in v.cursorArg ? {_: {}
                                                                                                                                                                                                                                    ,row: typeof v.cursorArg.row === "number" && isFinite(v.cursorArg.row) && Math.floor(v.cursorArg.row) === v.cursorArg.row ? v.cursorArg.row : _U.badPort("an integer",
                                                                                                                                                                                                                                    v.cursorArg.row)
                                                                                                                                                                                                                                    ,column: typeof v.cursorArg.column === "number" && isFinite(v.cursorArg.column) && Math.floor(v.cursorArg.column) === v.cursorArg.column ? v.cursorArg.column : _U.badPort("an integer",
                                                                                                                                                                                                                                    v.cursorArg.column)} : _U.badPort("an object with fields `row`, `column`",
                                                                                                                                   v.cursorArg)
                                                                                                                                   ,selectionArg: typeof v.selectionArg === "object" && v.selectionArg instanceof Array ? Elm.Native.List.make(_elm).fromArray(v.selectionArg.map(function (v) {
                                                                                                                                      return typeof v === "object" && "start" in v && "end" in v ? {_: {}
                                                                                                                                                                                                   ,start: typeof v.start === "object" && "row" in v.start && "column" in v.start ? {_: {}
                                                                                                                                                                                                                                                                                    ,row: typeof v.start.row === "number" && isFinite(v.start.row) && Math.floor(v.start.row) === v.start.row ? v.start.row : _U.badPort("an integer",
                                                                                                                                                                                                                                                                                    v.start.row)
                                                                                                                                                                                                                                                                                    ,column: typeof v.start.column === "number" && isFinite(v.start.column) && Math.floor(v.start.column) === v.start.column ? v.start.column : _U.badPort("an integer",
                                                                                                                                                                                                                                                                                    v.start.column)} : _U.badPort("an object with fields `row`, `column`",
                                                                                                                                                                                                   v.start)
                                                                                                                                                                                                   ,end: typeof v.end === "object" && "row" in v.end && "column" in v.end ? {_: {}
                                                                                                                                                                                                                                                                            ,row: typeof v.end.row === "number" && isFinite(v.end.row) && Math.floor(v.end.row) === v.end.row ? v.end.row : _U.badPort("an integer",
                                                                                                                                                                                                                                                                            v.end.row)
                                                                                                                                                                                                                                                                            ,column: typeof v.end.column === "number" && isFinite(v.end.column) && Math.floor(v.end.column) === v.end.column ? v.end.column : _U.badPort("an integer",
                                                                                                                                                                                                                                                                            v.end.column)} : _U.badPort("an object with fields `row`, `column`",
                                                                                                                                                                                                   v.end)} : _U.badPort("an object with fields `start`, `end`",
                                                                                                                                      v);
                                                                                                                                   })) : _U.badPort("an array",
                                                                                                                                   v.selectionArg)
                                                                                                                                   ,exNameArg: typeof v.exNameArg === "string" || typeof v.exNameArg === "object" && v.exNameArg instanceof String ? v.exNameArg : _U.badPort("a string",
                                                                                                                                   v.exNameArg)} : _U.badPort("an object with fields `evt`, `strArg`, `cursorArg`, `selectionArg`, `exNameArg`",
      v);
   });
   var animateSignal = Elm.Native.Port.make(_elm).inboundSignal("animateSignal",
   "Bool",
   function (v) {
      return typeof v === "boolean" ? v : _U.badPort("a boolean (true or false)",
      v);
   });
   var combinedEventSig = $Signal.mergeMany(_U.list([A2($Signal.map,
                                                    $InterfaceModel.WindowDimensions,
                                                    $Window.dimensions)
                                                    ,A2($Signal.map,$InterfaceModel.MouseIsDown,$Mouse.isDown)
                                                    ,A2($Signal.map,$InterfaceModel.MousePosition,$Mouse.position)
                                                    ,A2($Signal.map,
                                                    function (_p0) {
                                                       return $InterfaceModel.KeysDown($List.sort($Set.toList(_p0)));
                                                    },
                                                    $Keyboard.keysDown)
                                                    ,A2($Signal.map,
                                                    $InterfaceModel.TickDelta,
                                                    A2($Time.fpsWhen,60,animateSignal))
                                                    ,$InterfaceModel.events.signal]));
   var sigModel = function () {
      var foo = function (initVal) {
         var _p1 = A3($Config.debugLog,
         $Config.debugController,
         "initVal",
         initVal);
         if (_p1.ctor === "WindowDimensions") {
               return _U.update($InterfaceModel.sampleModel,
               {dimensions: _p1._0});
            } else {
               return $InterfaceModel.sampleModel;
            }
      };
      return A3($Signal$Extra.foldp$,
      $InterfaceController.upstate,
      foo,
      combinedEventSig);
   }();
   var main = A3($Signal.map2,
   $InterfaceView2.view,
   $Window.dimensions,
   sigModel);
   var modelRunAnimation = Elm.Native.Port.make(_elm).outboundSignal("modelRunAnimation",
   function (v) {
      return v;
   },
   $Signal.dropRepeats(A2($Signal.map,
   function (_) {
      return _.runAnimation;
   },
   sigModel)));
   var taskPort = Elm.Native.Task.make(_elm).performSignal("taskPort",
   $Signal.mergeMany(_U.list([$InterfaceStorage.taskMailbox.signal
                             ,A3($Signal.map2,
                             $CodeBox.interpretAceEvents,
                             theTurn,
                             A2($Signal.sampleOn,theTurn,sigModel))])));
   var aceInTheHole = Elm.Native.Port.make(_elm).outboundSignal("aceInTheHole",
   function (v) {
      return {kind: v.kind
             ,code: v.code
             ,cursorPos: {row: v.cursorPos.row,column: v.cursorPos.column}
             ,selections: Elm.Native.List.make(_elm).toArray(v.selections).map(function (v) {
                return {start: {row: v.start.row,column: v.start.column}
                       ,end: {row: v.end.row,column: v.end.column}};
             })
             ,highlights: Elm.Native.List.make(_elm).toArray(v.highlights).map(function (v) {
                return {range: {start: {row: v.range.start.row
                                       ,column: v.range.start.column}
                               ,end: {row: v.range.end.row,column: v.range.end.column}}
                       ,color: v.color};
             })
             ,annotations: Elm.Native.List.make(_elm).toArray(v.annotations).map(function (v) {
                return {row: v.row,type_: v.type_,text: v.text};
             })
             ,tooltips: Elm.Native.List.make(_elm).toArray(v.tooltips).map(function (v) {
                return {row: v.row,col: v.col,text: v.text};
             })
             ,bounce: v.bounce
             ,exName: v.exName};
   },
   function () {
      var pickAsserts = function (_p2) {
         var _p3 = _p2;
         var _p4 = _p3._1;
         _v2_12: do {
            switch (_p4.ctor)
            {case "WaitRun": return true;
               case "WaitSave": return true;
               case "WaitClean": return true;
               case "MultiEvent":
               if (_p4._0.ctor === "::" && _p4._0._1.ctor === "::" && _p4._0._1._0.ctor === "CleanCode" && _p4._0._1._1.ctor === "[]")
                 {
                       return true;
                    } else {
                       break _v2_12;
                    }
               case "WaitCodeBox": return true;
               case "UpdateModel": return true;
               case "SwitchOrient": return true;
               case "Noop": return true;
               case "SelectExample": return true;
               case "InstallSaveState": return true;
               case "RemoveDialog": return true;
               case "ToggleBasicCodeBox": return true;
               default: break _v2_12;}
         } while (false);
         return false;
      };
      return A3($Signal.filterMap,
      function (_p5) {
         var _p6 = _p5;
         return _p6._0 ? $Maybe.Just(_p6._1) : $Maybe.Nothing;
      },
      $CodeBox.initAceCodeBoxInfo,
      A3($Signal.foldp,
      $CodeBox.packageModel,
      $CodeBox.initFoldpAceCodeBoxInfo,
      A3($Signal.map2,
      F2(function (v0,v1) {
         return {ctor: "_Tuple2",_0: v0,_1: v1};
      }),
      sigModel,
      combinedEventSig)));
   }());
   return _elm.Main.values = {_op: _op
                             ,sigModel: sigModel
                             ,combinedEventSig: combinedEventSig
                             ,main: main};
};
