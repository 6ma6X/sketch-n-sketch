<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <title>Sketch-n-Sketch</title>
  <link rel="shortcut icon" type="image/png" href="../static/images/sketch-n-sketch-logo.png">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../static/css/arvo.css">
  <link rel="stylesheet" type="text/css" href="../static/css/style.css">
</head>
<body>
  <div id="wrapper">

    <div id="header">
      <div id="logo"> <h1>Sketch-n-Sketch [<a href="index.html">Blog</a>]</h1> </div>
      <div id="menu">
        <ul>
          <li class="first current_page_item"><a href="../index.html">Home</a></li>
          <li><a href="../releases/index.html">Try It!</a></li>
          <li><a href="../tutorial/index.html">Tutorial</a></li>
          <li><a href="../blog/index.html">Blog</a></li>
          <li class="last"><a href="https://github.com/ravichugh/sketch-n-sketch">Code</a></li>
        </ul>
        <br class="clearfix">
      </div>
    </div>

    <div id="page">

      <div class="content_wide">
      <div class="blog_post">
      <span><h1>Initial Case Studies</h1>

<p><em>July 17, 2015</em> <br><br></p>

<p>Our long-term goal is to tightly
integrate programmatic and direction manipulation in two primary
ways. First, to have users write a <code>little</code> program that generates
an SVG canvas, allow them to directly manipulate the output, and then
automatically infer changes to the program that matches the new output.
Second, to allow users to design content as usual in direct manipulation
interfaces, and then infer programs that capture the high-level intent
of the design.</p>

<p>The first workflow is what we call <em><strong>live mode</strong></em>, where
Sketch-N-Sketch infers program updates in real-time along with the
user's changes, without asking the user for any help. We call the
second workflow <em><strong>ad hoc mode</strong></em>, where we attempt to infer more complicated
program updates and will rely on the user to help identify the
desired program. Smoothly integrating both of these modes will allow
programmers and designers to get the best of both worlds.</p>

<p>In our initial milestone (<a href="../releases/v0.0/"><code>v0.0</code></a>), we have focused primarily
on designing algorithms and a basic user experience for live mode.
So for now, the user must start by writing a complete <code>little</code> program,
which then gets implicitly updated when the output canvas is
directly manipulated. In the coming months, we will be developing
more of the story for ad hoc mode.</p>

<p>Even with just live mode, however, we have used Sketch-N-Sketch to
effectively program and manipulate several designs that would be difficult
using existing direct manipulation tools, such as Illustrator and PowerPoint.
The rest of this article will describe several case studies to
back up this claim. You may want to
<a href="../releases/v0.0/" target="_blank">open Sketch-N-Sketch in a new tab</a>
and try out the <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/">examples</a> along with the discussion.
If you find yourself in a bind (syntactically), the <code>little</code>
<a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/README.md">Syntax Guide</a> and standard <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/prelude.little"><code>Prelude</code></a> may help.</p>

<p>Note: Much of the discussion below draws from <a href="http://arxiv.org/abs/1507.02988v1">this report</a>.</p>

<h3>Example: Evenly-Spaced Boxes</h3>

<p>The <code>nBoxes</code> program is our "hello world" example for
prodirect manipulation. The number of boxes and their location, width,
and height are simple parameters to change in the program.
In addition, the location, width, and height
can easily be changed in the direct manipulation editor.
When manipulated in live mode, all of the boxes are updated
together in real-time.</p>

<pre><code>(def nBoxes
  (let [x0 y0 w h sep n] [40 28 60 130 110 3]
  (let boxi (\i
    (let xi (+ x0 (mult i sep))
    (rect 'lightblue' xi y0 w h)))
  (map boxi (list0N (- n 1))))))

; this is the "main" expression
(svg nBoxes)</code></pre>

<p><img class="img_on_right" src="../static/images/post01/three-boxes.png"></p>

<p>The screenshot on the right shows the <em><strong>zones</strong></em> (interior, edges, corners, etc.)
displayed to the user. When multiple program updates may be assigned to a user
action, Sketch-N-Sketch uses heuristics to break the ambiguity
without asking the programmer. Try dragging the interior zone of each
box to see what parts of the program are affected.</p>

<p>Notice that, by default, Sketch-N-Sketch may change any of the numeric
constants in the program in order to match the updates to the canvas.
The programmer can <em>freeze</em> a constant, however, by annotating it with
an exclamation point.</p>

<p>Try freezing the initial <code>x0</code> and <code>y0</code> positions
in the program (i.e. <code>40!</code> and <code>28!</code>) and see what happens. Then
try freezing the <code>sep</code>aration parameter instead.</p>

<h3>Example: <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/elmLogo.little">Elm Logo</a></h3>

<p>The <a href="http://github.com/evancz/elm-svg/blob/1.0.2/examples/Logo.elm">Elm logo</a> is a tangram consisting of seven polygons.
We implemented this logo by massaging the definition from the SVG format
to the representation in <code>little</code>.
This process will be automatic once we add support for importing
SVG images directly.</p>

<p><img class="img_on_right" src="../static/images/post01/elm-logo.png"></p>

<p>There are two noteworthy aspects of this example in Sketch-N-Sketch.
The first is that our definition uses the <code>'viewBox'</code>
attribute to define a local coordinate system for shapes within
the canvas. Because of the thin wrapper around SVG, the result in
Sketch-N-Sketch is that the output canvas is scaled to fit the size of the
canvas, no matter how large or small the application window it is.
As a result, even though our current implementation does not provide a way
to pan within or scale a canvas, one can use <code>'viewBox'</code> in order
to render the output in "full screen" mode.</p>

<p>The second interesting aspect is the square, which is rotated using
the SVG <code>matrix</code> command within the <code>transform</code> attribute.
Again, even though we currently provide no special support for these
features, the zone we display for the square (though not rotated to
match) can still be used to directly manipulate it.</p>

<h3>Example: <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/logo.little">Sketch-N-Sketch Logo</a></h3>

<p>The high-level relationships between the shapes in the
Elm logo are not captured by the definition in SVG format,
nor in its direct translation to <code>little</code>.
As a result, directly manipulating any one of the pieces does not
affect the others, therefore breaking the intended abstraction
of the logo.</p>

<p><img class="img_on_right" src="../static/images/post01/sns-logo.png"></p>

<p>Our logo for Sketch-N-Sketch, which pays homage to the Elm logo,
uses the abstraction facilities afforded by a programming language to
declare relationships between multiple shapes.
The definition is parameterized by a position <code>(x0,y0)</code> for the top-left
corner, a width <code>w</code> and height <code>h</code>, and a <code>delta</code> parameter that
determines the size of the gap between the three shapes:</p>

<pre><code>(let [x0 y0 w h delta] [50 50 200 200 10] ...)</code></pre>

<p>The rest of the definition (not shown) computes the three polygons
in terms of these parameters. It is, thus, simple to change any of
these values and re-run the program to generate an updated logo.</p>

<p>Better yet is the ability to manipulate the parameters <em>directly</em>
through the canvas in live mode. For example, say that we want to stretch the
logo, that is, by changing the <code>w</code> and <code>h</code> parameters. If we
click and drag bottom-right corner zone of the
bottom triangle in live mode,
the height of the logo is adjusted but not the width;
instead, the x-position of the logo is.
This is because of the heuristics that are used to automatically
break ambiguities.</p>

<p>We can proceed in a couple of ways. One option is to edit the code
to freeze the <code>x0</code>, <code>y0</code>, and <code>delta</code> values,
thereby directing Sketch-N-Sketch towards assigning the desired program
updates for this corner zone. With this change, directly
manipulating this corner point allows us to stretch the
logo in either direction.</p>

<p>Another option is to create a dummy,
transparent rectangle in the background with dimensions
<code>w</code> and <code>h</code> to surround the logo.
The bottom-right corner zone of this box will, predictably,
be assigned to manipulate the <code>w</code> and <code>h</code> parameters, thus,
providing direct manipulation control over the desired attributes of
the logo. This second option, creating an explicit "group box,"
is a design pattern that is often useful for mixing programmatic
and direct manipulation (i.e. prodirect manipulation) in the
current version of Sketch-N-Sketch. In future work, it may be useful to
provide some built-in support for grouping shapes.</p>


<h3>Example: <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/chicago.little">Chicago Flag</a></h3>

<p>It is useful to define abstractions on top of the primitive
SVG shapes. We define a <code>nStar</code> function (and include it
in <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/prelude.little">Prelude</a>) that creates an <code>n</code>-sided star
centered at <code>(cx,cy)</code> and rotated <code>rot</code> radians
in the clockwise direction, where the distance from the center to the outer
points is <code>len1</code> and the distance to the inner points is <code>len2</code>.</p>

<pre><code>(def nStar
  (\(fill stroke w n len1 len2 rot cx cy) ...))</code></pre>

<p><img class="img_on_right" src="../static/images/post01/chicago-flag.png"></p>

<p>We use <code>nStar</code> to implement the City of Chicago flag, which contains
four evenly-spaced six-sided stars. By directly manipulating the point
zones of a star in live mode, we can control the outer and
inner distances of all four stars. Modifying length parameters this way
can be surprising. For example, using negative lengths leads to
interesting patterns, even though one might not think to try them when
programming without immediate visual feedback.</p>

<p>Like with the Sketch-N-Sketch logo, we define a transparent group box
(visible when displaying zones, as in the screenshot) to give direct
manipulation control over the width and height of the flag. Unlike that
example, however, there is no way to produce the same exact result by manipulating
only one of the polygons. If the user changes, say, the bottom stripe by
moving the mouse cursor a given distance, the overall dimensions of the flag
will change, but <em>not</em> by the amount the cursor has moved. As a result,
the relationship between stretching one of the stripes and the overall
flag is not a smooth, intuitive one. Using a group box, however, provides
the simple and expected behavior.</p>


<h3>Example: <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/botanic.little">Chicago Botanic Garden Logo</a></h3>

<p><img class="img_on_right" src="../static/images/post01/botanic-logo.png"></p>

<p>The symmetric design of the <a href="http://www.chicagobotanic.org/">Chicago Botanic Graden</a> logo
uses curves, defined with Bezier <code>path</code> commands.
By programming in <code>little</code>, we can define the coordinates
and control points such that they are reflected across
a vertical axis running down the middle of the logo.
Then, in live mode, direct manipulation of any position or control point
(the "floating" point zones in the screenshot)
in either half is immediately reflected in the other half.</p>



<h3>Custom UI Widgets</h3>

<p>The approach in Sketch-N-Sketch provides
control over many parameters in a program
by directly manipulating zones in the visual editor.
Some parameters — such as the number of boxes in <code>nBoxes</code>,
or boolean values, which are not paired with traces —
are hard to directly manipulate, however.
In such cases, the only option we have seen so far is to edit the program.</p>

<p><img class="img_on_right" src="../static/images/post01/widgets.png"></p>

<p>We observe that we can implement "helper" shapes whose properties affect
other parameters of interest.
For example, the <code>slider</code> function (discussed below)
defines visual slider abstractions that are used by the program below
(depicted in the screenshot to the right).
There are four sliders,
one for a floating-point number <code>n</code>,
one for an integer <code>i</code>, and
two for booleans <code>b1</code> and <code>b2</code>
(we refer to boolean sliders as "buttons").</p>

<pre><code>(let [n s1] (numSlider ... 0! 5! 'n = ' 3.1415)
(let [i s2] (intSlider ... 0! 5! 'i = ' 3.1415)
(let [b1 s3] (button ... 'b1 = ' 0.25)
(let [b2 s4] (button ... 'b2 = ' 0.75) ...))))</code></pre>

<p><em>Directly</em> manipulating the sliders <em>indirectly</em>
manipulates four constants, the unfrozen constant on each line
(and, hence, the values bound to <code>n</code>, <code>i</code>, <code>b1</code>, and <code>b2</code>).
Both <code>numSlider</code> and <code>intSlider</code> are defined in terms
of the <code>slider</code> helper function:</p>

<pre><code>; slider : Bool -> Int -> Int -> Int -> Num -> Num -> Str -> Num -> [Num (List Svg)]
(def slider
  (\(roundInt x0 x1 y minVal maxVal caption srcVal)
    (let targetVal
      (let preVal (clamp minVal maxVal srcVal)
        (if roundInt (round preVal) preVal))
    (let shapes
      (let ball
        (let [xDiff valDiff] [(- x1 x0) (- maxVal minVal)]
        (let xBall (+ x0 (* xDiff (/ (- targetVal minVal) valDiff)))
        (let rBall (if (= targetVal srcVal) 10! 0!)
          (circle 'black' xBall y rBall))))
      [ (line 'black' 3! x0 y x1 y)
        (text (+ x1 10) (+ y 5) (+ caption (toString targetVal)))
        (circle 'black' x0 y 4!) (circle 'black' x1 y 4!) ball ])
    [targetVal shapes]))))

(def [numSlider intSlider] [(slider false) (slider true)])</code></pre>

<p>The former returns <code>srcVal</code> clamped to the range
<code>[minVal, maxVal]</code>, if necessary;
the latter, furthermore, rounds <code>srcVal</code> to the nearest integer.
We refer to the number supplied as the <code>srcVal</code> parameter to
be the "source" number used to derive the "target"
value, which is the first element of the pair returned by <code>slider</code>.
The second element of the pair is the list of shapes
that comprise the visuals of the slider. The idea is to place a "ball"
on the line between <code>(x0,y)</code> and <code>(x1,y)</code> at a distance
proportional to <code>(srcVal - minVal) / (maxVal - minVal)</code>.
The visual editor does nothing to prevent the user from dragging
the ball beyond the endpoints of the line.
So, the approach we choose is to hide the ball
(i.e. by setting its radius <code>rBall</code> to <code>0</code>) when it is out of
range.</p>

<p>We employ the same approach to implement <code>button</code> for directly
manipulating booleans (defined in <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/prelude.little">Prelude</a>).
In particular, a button is tied to a
source value between <code>0.0</code> and <code>1.0</code>, where
values less than (resp. greater than) <code>0.5</code>
represent <code>true</code> (resp. <code>false</code>).
The last two sliders in the screenshot are buttons that control
the boolean variables <code>b1</code> and <code>b2</code>.</p>

<p>Helper shapes in <code>little</code> like sliders and buttons, which we
refer to as custom <em>user interface widgets</em>, are similar to the
notions of <em>instruments</em> and <em>surrogate objects</em> in HCI research,
both of which aim to provide GUI-based control over properties that are
not traditionally easy to directly manipulate.
What is interesting about our development is that the Sketch-N-Sketch
editor does not provide any special support for indirect manipulation
via user interface widgets; instead, they are derivable using the
basic prodirect manipulation approach we have described.</p>


<h3>Example: <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/activeTrans.little">Active Trans Logo</a></h3>

<p><img class="img_on_right" src="../static/images/post01/active-trans-logo.png"></p>

<p>The logo of the <a href="http://activetrans.org/">Active Transportation Alliance</a> contains two
paths, each of which has a single curved edge and some number of straight edges.
In our current implementation, Sketch-N-Sketch does not provide a GUI-based way
to create shapes or add extra points to existing shapes. Therefore,
these two paths must be generated using <code>little</code> code, at least initially.</p>

<p>Nevertheless, we found that we can quickly and easily begin implementing
this logo as follows. First, we implement a <code>makePath</code> function
that stitches together a path based on a list of points and a single
Bezier control point. Next, we define two intially-empty lists,
<code>grayPts</code> and <code>greenPts</code>, that will store the points of each
path. Then, we use <code>makePath</code> to construct two paths out of these lists.</p>

<pre><code>(let makePath (\(color pts [xCtrl yCtrl]) ...)
(let [grayPts greenPts] [ [] [] ]
(let [p1 p2] [(makePath ...) (makePath ...)]
  ...)))</code></pre>

<p>Now the task is to define the list of points for each path.
We would like to do this visually by directly manipulating points
into the desired positions, but we need some points to begin with.
As is, <code>grayPts</code> and <code>greenPts</code> are empty, so there are
no shapes to render.</p>

<p>One option is to use a text editor to populate the list with dummy
points, but this could be tedious for a large number of points,
especially because they should be reasonably spaced out so that
they can be manipulated in the visual editor. Instead, we wrote
a <code>little</code> function to generate such a list of points and
evaluated it using the Elm REPL (read-eval-print loop). We
then copied this list into our program, rendered it, and proceeded
to directly manipulate the points. Our helper function essentially
created a "ball of clay" that we massaged into the desired shapes.
In future work, the visual editor might provide support for generating
complex shapes using templates such as this one.</p>

<p>Once we settled on the desired shapes of our paths, we returned to
the program to introduce structure that relates the topmost points of
the top shape (corresponding to the city skyline). As a result,
dragging any one of these points up or down in live mode affects
all of the others. So, if the skyline grows taller (which has been
known to happen in Chicago), we can easily adapt the logo to match.</p>

<p>Lastly, we include a button in our development
and use it to toggle between a "positive" version, where the
shapes are colored and the background is white, and a "negative"
version, where the shapes are white and the background is colored.
These two versions of the logo are easy to develop
in tandem using Sketch-N-Sketch.</p>


<h3>Example: <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/ferris.little">Ferris Wheel</a></h3>

<p>For the final case study we will discuss, we designed a ferris wheel that
consists of some number of equal-length spokes emanating from a central
hub, each of which has a passenger car at its end. Furthermore,
we wanted the ability to rotate the wheel while
keeping the passenger cars vertical, in order to accurately
portray the physical characteristics of a ferris wheel in motion.
It is hard to imagine how one could develop these relationships
in a modular way using tools like Illustrator or PowerPoint.</p>

<p><img class="img_on_right" src="../static/images/post01/ferris.png"></p>

<p>In Sketch-N-Sketch, we combine programmatic, direct manipulation,
and indirect manipulation (via user-defined sliders) to develop
our design in a way that is highly-reusable and easy to edit.
First, we write a function</p>

<pre><code>(def ferrisWheel
  (\(numSpokes spokeLen rotAngle sizeCar radiusCenter cx cy) ...))</code></pre>

<p>that, given several parameters, draws the desired circles, lines,
and rectangles. The function is straightforward to write, making use
of a <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/prelude.little">Prelude</a> function</p>

<pre><code>(def nPointsOnCircle (\(n rot cx cy r) ...))</code></pre>

<p>that generates a list of <code>n</code> points evenly spaced around a circle
of <code>r</code> radius centered at <code>(cx,cy)</code>.
A drawing that results from <code>ferrisWheel</code> is shown in the screenshot.</p>

<p>We can directly manipulate several parameters of the ferris wheel:
we can adjust the location <code>(cx,cy)</code> of the wheel by dragging
the interior zone of the central hub;
we can adjust <code>radiusCenter</code> to change the size of the central hub by
manipulating its edge zone; and
we can adjust the width <code>sizeCar</code> of all passenger cars by
manipulating any one of their edge zones.</p>

<p>While this workflow in Sketch-N-Sketch is already unique and quite useful,
it would be nice to also have a way to adjust <code>numSpokes</code>
and <code>rotAngle</code> in the visual editor. However, no zones are connected
to these parameters.
Therefore, we add <code>slider</code>s to expose control over <code>numSpokes</code>,
<code>rotAngle</code>, and <code>spokeLen</code> from the GUI editor.</p>

<pre><code>(let [num s1] (intSlider ... 5)
(let [len s2] (intSlider ... 80)
(let [rot s3] (numSlider ... 0)

(let wheel (ferrisWheel num len rot ...)
(let sliders
  (let show true
  (if show (concat [s1 s2 s3]) []))

(svg (append sliders wheel)))))))</code></pre>

<p>The resulting canvas is shown above.
With this setup, we can easily tweak any of the parameters
to <code>ferrisWheel</code> in live mode without having to modify the
program. If we wanted to change something about the ferris wheel
abstraction, of course, we could easily switch to programmatic
manipulation as needed.</p>

<p>To wrap up, we note how easy it is to export our ferris wheel
design once we have finished modifying it.
We can set the <code>show</code> parameter to <code>false</code> in order to hide
the sliders from the output. From there, we use the export
facility in Sketch-N-Sketch to generate the raw SVG for our design, which
we can copy and paste into other SVG editors or HTML documents.</p>

<p><!-- ### "Animations" --></p>

<h3>More Examples</h3>

<p><img class="img_on_right" src="../static/images/post01/flw.png">
<img class="img_on_right" src="../static/images/post01/us13-flag.png"></p>

<p>Our Git repo contains several more <a href="https://github.com/ravichugh/sketch-n-sketch/blob/v0.0/examples/">examples</a> to play with.</p>

<p>Note that performance does start to lag a bit as the number of shapes
grows larger. We have not yet played any optimization tricks, but we
will in the future.</p>





</span>
      </div>
      </div>

      <br class="clearfix">

    </div> 

  </div> 

  <div id="footer">
  © 2015 – 2020 ravi chugh |
	stylesheet based on
  <a href="http://www.freecsstemplates.org/preview/resolved/">Resolved</a>
</div>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-5371203-2', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>