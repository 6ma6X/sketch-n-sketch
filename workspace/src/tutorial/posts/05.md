# Step 5

This lesson will focus on using the thin wrapper syntax in `little` to interface
directly with the underlying SVG output to create SVG nodes and attributes that
aren't a part of built-in functionality. Excited? Let's get going!

<!--
What we will cover in this lesson:

- How to use the thin wrapper syntax to define SVG nodes that aren't built in

Cover how `svgViewBox` works
Go into detail about the `['nodeType' [attrs] [children]]` structure works

We need to use Prelude as an example for this; good examples are the defs for:

circle
ellipse
rect
line
polygon
polyline
path
text

Talking about addAttr is probably a good thing as well, as it simplifies some of
the function definitions tha do complicated things.

This lesson will focus on the implementation of a something that isn't currently
part of built-in functionality, after reimplementing something that is. So:

* Reimplement a shape or shapes
* Pick an SVG node type (anything from
  https://developer.mozilla.org/en-US/docs/web/SVG/Element works, especially
  something unusual like feTurbulence) and implement it
* Focus on how to structure this as a function that is reusable so that you can
  use it in your later designs
* Ask the user to impelement an element that looks cool to them. It's okay to
  reimplement one that we have already (so long as you don't peek!)
-->

## Thin Wrapper Syntax

Talk about the syntax

Implement rect

Talk about addAttr

Implement a function that adds a particular attribute (maybe increments
z-ordering?)

## SVG ViewBox

Talk about SVG ViewBox and how it is implemented

Walk through making a pan/zoom example where there is a combination of sliders
and such that allow the pannigng and zooming of a graphic

## Adding a new SVG feature

Talk about where an SVG feature reference is and what kinds of features have yet
to have built-in functionality

Implement a kind of 'out there' piece of SVG, perhaps feTurbulence, to show how
pretty much anything can be added

Have them pick and implement their own SVG feature
