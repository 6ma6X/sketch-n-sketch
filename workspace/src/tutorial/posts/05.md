# Step 5

This lesson will focus on using the thin wrapper syntax in `little` to interface
directly with the underlying SVG output to create SVG nodes and attributes that
aren't a part of built-in functionality. Excited? Let's get going!

<!--
What we will cover in this lesson:

- How to use the thin wrapper syntax to define SVG nodes that aren't built in

Cover how `svgViewBox` works
Go into detail about the `['nodeType' [attrs] [children]]` structure works

We need to use Prelude as an example for this; good examples are the defs for:

circle
ellipse
rect
line
polygon
polyline
path
text

Talking about addAttr is probably a good thing as well, as it simplifies some of
the function definitions tha do complicated things.

This lesson will focus on the implementation of a something that isn't currently
part of built-in functionality, after reimplementing something that is. So:

* Reimplement a shape or shapes
* Pick an SVG node type (anything from
  https://developer.mozilla.org/en-US/docs/web/SVG/Element works, especially
  something unusual like feTurbulence) and implement it
* Focus on how to structure this as a function that is reusable so that you can
  use it in your later designs
* Ask the user to impelement an element that looks cool to them. It's okay to
  reimplement one that we have already (so long as you don't peek!)
-->

## Thin Wrapper Syntax

As mentioned in lesson 1, the output of a `little` program is an SVG node that
has type `svg`. However, while SVG nodes are represented in text form as XML-
style nodes and attributes delimited with `<` and `>`, SVG nodes in `little` are
represented by three element lists of the following form:

```
[ 'nodename' [attributes] [children] ]
```

Further, each attribute takes the following form:

```
[ 'attrname' value ]
```

Where the value can be a string, which is dropped in-place, a number, or a
function. The nodename can be any string and, along with the attributes, will
simply be dropped as-is into the SVG output. This is how all of the shape
functions in `little` are implemented. In fact, let's reimplement `rect` now.

In textual SVG output, a rectangle is specified in the following fashion:

```
<rect x="xval" y="yval" width="widthval" height="heightval" fill="colorname">
	... Usually no children ...
</rect>
```

Usually the rectangle has no children, so we may leave the children list empty.
Further, the attributes that are usually specified are `x`, `y`, `width`,
`height`, and `fill`. So, we should make those arguments to our function. Thus,
we can specify the following `little` function to make a rectangle:

```
(def ourRect (\(x y w h fill)
  [ 'rect' 
    [ [ 'x' x ]
      [ 'y' y ]
      [ 'width' w ]
      [ 'height' h ]
      [ 'fill' fill ]
    ]
    []
   ] ) )
```

This doesn't match the syntax for the actual implementation exactly (which can
be found in prelude, if you haven't already peeked), but it allows for exactly
the same functionality as the built-in `rect`. As mentioned on the
[documentation page](https://developer.mozilla.org/en-
US/docs/Web/SVG/Element/rect) for `rect`, another common usage is to specify a
rectangle with rounded corners. Go ahead and, in your own document, change the
specification for `ourRectangle` to allow for specifying the radius of the
rounded corners.


There's a nice helper function in `prelude` called `addAttr` which could be very helpful for creating complicated SVG nodes. Its definition is as follows:

```
(def addAttr (\([shapeKind oldAttrs children] newAttr)
  [shapeKind (snoc newAttr oldAttrs) children]))
```

This allows attributes to be appended to existing SVG nodes with
ease.[^designchoice] It is easy to imagine a similar function that allows for
the appending of children as well. Further, as attributes and children are just
lists with elements that are straightforward to pattern match on with `case`,
there's plenty of functionality for any function to modify any shape in any way.
To illustrate the functionality, let's create a function that sets the `fill`
attribute of an SVG node if it isn't there and changes it to the given value if
it is:

[^designchoice]: Currently, we've stuck with the design decision to have the
[^built-in functionality lend itself towards a single statement that creates the
[^SVG node for a given shape or other structure after which that node isn't
[^manipulated any further. There's no reason why things need to be done this way
[^and it's simply how we chose to go about things - a design method that
[^involves creating shapes and then passing adding attributes to them after the
[^fact is equally as legitimate and just doesn't have a nice group of functions
[^to go along with it in `prelude`.


<!-- This could be made an exercise instead, but I feel like it's more a functional programming problem than illustrative of the structure of our thin wrappers, so I just put the solution as an example here. However, I could be convinced otherwise, let me know what you think - Mitch -->

```
(defrec setFill_ (\(attrs fill) (case attrs
  ([] [ [ 'fill' fill ] ])
  ([ [ 'fill' _ ] | rest ] [ [ 'fill' fill ] | rest ] )
  ([ a | rest ] [ a | (setFill_ rest fill) ]) ) ) )
(def setFill (\([ nodename attrs children ] fill) 
  [nodename (setFill_ attrs fill) children ] ) )
```
 
Notice how we need to be careful about how the attributes themselves are two-
element lists inside of lists. This leads to more than a few nested brackets,
but the syntax should become familiar after you use it once or twice. Go ahead
and enter this into a document and use it to set the fill of one or more shapes.
Then, modify the function to have it set a different attribute.

<!--
Talk about the syntax

Implement rect

Talk about addAttr

Implement a function that adds a particular attribute (maybe increments
z-ordering?)
-->

## SVG ViewBox

Though much of the time the location in which you use the SVG images that you
create in Sketch-n-Sketch is such that it will scale the image appropriately,
the best way to guarantee that your image will be scaled appropriately,
including any border spacing around the edges, is to make sure that the top
level `svg` definition includes the `viewBox` attribute. The general structure
of using a `viewBox` is that the top-level SVG node ends up as follows:

```
<svg width="totalwidth" height="totalheight" viewBox="minx miny width height">
  ...
</svg>
```

What using a `viewBox` does is create an internal coordinate system that your
design uses that goes from `0` to `width` in the x-direction and `0` to `height`
in the y-direction. This is offset by `minx` and `miny`, effectively defining a
rectangle within the `totalwidth` and `totalheight` of your working svg
definition that is actually shown when it is rendered. If the `totalwidth` and
`totalheight` parameters are omitted from the `svg` definition, then the
`viewBox` implicitly defines the width and height of the image, and the `minx`
and `miny` parameters can only specify a subset of the image that reaches all
the way to width and height.

Alright, that was all a bit specific. In general, a good way to think about a
`viewBox`, at least when it comes to exporting your images, is to start by
defining your SVG using raw pixel values (as we've been doing in this and
previous lessons). Then, when you're ready to export, change your call to `svg`
to a call to `svgViewBox` with the overall width and height of your image and
then right away your image will scale itself to fit its container! A great
example of this is in the Bar Graph example, which uses a variable called
`doneEditing` that, if set to `true`, renders the document using a `viewBox` and
if set to `false` doesn't. Further, it also doesn't render the helper slider
when `doneEditing` is set to `true`, making a convenient mechanism to switch
between a 'working' mode and an 'export' mode. In fact, if you're working with
any complicated graphic that uses UI Widgets, this setup makes for a very good
workflow.

To get a little more practice with `viewBox` as well as our thin wrapper syntax,
we're going to go through an example of how to make helper widgets to allow
panning and zooming around a larger graphic.

<!-- Proving more difficult than I thought to get this working. Will write this up tomorrow before we meet. - Mitch -->

<!--
Talk about SVG ViewBox and how it is implemented

Walk through making a pan/zoom example where there is a combination of sliders
and such that allow the pannigng and zooming of a graphic
-->

## Adding a new SVG feature

Though the built-in functions include all of the most commonly used SVG
features, it is by no means exhaustive. Just as we did in the zoom and pan
example, we can use the thin wrapper syntax to add features of SVG that are not
built-in to our designs. In that case, we only needed to add attributes, but
there is no reason why whole new SVG node types cannot be added. For this last
section of the lessons, we're going to demonstrate incorporating an SVG element
that has no current implementation in `little`, and then you will implement your
own SVG node in `little`.

A good reference for all the features of the most recent SVG specification can
be found [here](https://developer.mozilla.org/en-US/docs/Web/SVG). From this,
let's go ahead and implement the `animate` tag with some very simple attributes.
As with any additional element that you incorporate into little, there will be
no built-in zones that allow you to directly manipulate its attributes. However,
as we covered in a previous lesson, UI Widgets work very well for manipulating
the attributes of these elements despite this limitation.

The `animate` tag, in a simple form, follows the following structure:

```
<nodeToAnimaate itsAttributes>
  <animate  attributeType="XML"
            attributeName="attrName"
            from="attrMin" to="attrMax"
            dur="duration"
            repeatCount="indefinite or count"></animate>
</nodeToAnimate>
```

So, we will need to have a method of passing the above attributes into our
animate node and to remember that we need to insert the animate node as a child
node for whatever node we would like to vary over time. In our case, we can
assume that the attributeType will always be XML, so we need not pass that as an
argument to our function. So, we could define our animate function as the
following:

```
(def animate (\(attrName from to dur repeat)
  ['animate'
    [ ['attributeType' 'XML']
      ['attributeName' attrName]
      ['from' (toString from)]
      ['to' (toString to)]
      ['dur' (+ (toString dur) 's')]
      [repeatCount repeat]
    ]
    []
  ] ) )
```

Having this function is a big improvement over having to specify this by hand,
as this does a lot of the packaging for us. So, when we want to create an
animate node, we don't need to worry about string conversion for several of the
fields as well as taking care of the thin wrapper syntax. From this, we can
create a rectangle that moves in the x-direction:

```
(def coolRect 
  [ 'rect'
    [ ['x' '100']
      ['y' '100']
      ['width' '100']
      ['height' '100']
    ]
    [ (animate 'x' 100 200 5 'indefinite') ]
  ]
)
```

Placing this into a call to `svg`, we have our rectangle that moves! Cool,
right? It's then very straightforward to turn `coolRect` into a function that
takes an argument for the y-position, and we can then get a lot of animated
rectangles on the screen at once:

```
(def coolRect (\ypos
  [ 'rect'
    [ ['x' '100']
      ['y' (toString ypos)]
      ['width' '100']
      ['height' '100']
    ]
    [ (animate 'x' 100 200 5 'indefinite') ]
  ]
) )
(def manyRects (map coolRect [100 200 300 400 500]))
```

Now, we can programmatically generate animated rectangles with just as much
flexibility as we can any other shape, with the ability to change the low-level
placement function definitions to boot. However, as you can see by turning on
the zone view, the zones for these shapes are not where you might expect them to
be. Sketch-n-Sketch currently expects shapes to remain in the same location, so
it does not alter the positions of the zones based on where they are in the
animation. Further, there are no built-in tools to help work animations. If
working on the edge of what the built-in functionality allows, be ready for a
little bit of strange behavior here and there. That being said, our tool is
expressive enough to allow for any features of SVG to be expressed and still be
able to take advantage of the benefits of programmatically specifying the image.

Anyways, now that we implemented a new element, it's your turn! Go ahead and
pick an SVG element or other non-built-in SVG structure and attempt to implement
it in `little`. Good candidates include the `g` element, a filter, or a
gradient. Don't forget to look at the [SVG
documentation](https://developer.mozilla.org/en-US/docs/Web/SVG) for inspiration
and implementation details.

<!--
Talk about where an SVG feature reference is and what kinds of features have yet
to have built-in functionality

Implement a kind of 'out there' piece of SVG, perhaps feTurbulence, to show how
pretty much anything can be added

Have them pick and implement their own SVG feature
-->

## That's It

That's all the material we have for our basic tutorial! We hope that you have
enjoyed working with our tool and were able to make the designs you wanted to.

<!-- Final feedback stuff here -->