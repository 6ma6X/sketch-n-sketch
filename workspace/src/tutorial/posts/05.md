# Step 5

This lesson will focus on using the thin wrapper syntax in `little` to interface
directly with the underlying SVG output to create SVG nodes and attributes that
aren't a part of built-in functionality. Excited? Let's get going!

<!--
What we will cover in this lesson:

- How to use the thin wrapper syntax to define SVG nodes that aren't built in

Cover how `svgViewBox` works
Go into detail about the `['nodeType' [attrs] [children]]` structure works

We need to use Prelude as an example for this; good examples are the defs for:

circle
ellipse
rect
line
polygon
polyline
path
text

Talking about addAttr is probably a good thing as well, as it simplifies some of
the function definitions tha do complicated things.

This lesson will focus on the implementation of a something that isn't currently
part of built-in functionality, after reimplementing something that is. So:

* Reimplement a shape or shapes
* Pick an SVG node type (anything from
  https://developer.mozilla.org/en-US/docs/web/SVG/Element works, especially
  something unusual like feTurbulence) and implement it
* Focus on how to structure this as a function that is reusable so that you can
  use it in your later designs
* Ask the user to impelement an element that looks cool to them. It's okay to
  reimplement one that we have already (so long as you don't peek!)
-->

## Thin Wrapper Syntax

As mentioned in lesson 1, the output of a `little` program is an SVG node that has type `svg`. However, while SVG nodes are represented in text form as XML-style nodes and attributes delimited with `<` and `>`, SVG nodes in `little` are represented by three element lists of the following form:

```
[ 'nodename' [attributes] [children] ]
```

Further, each attribute takes the following form:

```
[ 'attrname' value ]
```

Where the value can be a string, which is dropped in-place, a number, or a
function. The nodename can be any string and, along with the attributes, will
simply be dropped as-is into the SVG output. This is how all of the shape
functions in `little` are implemented. In fact, let's reimplement `rect` now.

In textual SVG output, a rectangle is specified in the following fashion:

```
<rect x="xval" y="yval" width="widthval" height="heightval" fill="colorname">
	... Usually no children ...
</rect>
```

Usually the rectangle has no children, so we may leave the children list empty. Further, the attributes that are usually specified are `x`, `y`, `width`, `height`, and `fill`. So, we should make those arguments to our function. Thus, we can specify the following `little` function to make a rectangle:

```
(def ourRect (\(x y w h fill)
  [ 'rect' 
    [ [ 'x' x ]
      [ 'y' y ]
      [ 'width' w ]
      [ 'height' h ]
      [ 'fill' fill ]
    ]
    []
   ] ) )
```

This doesn't match the syntax for the actual implementation exactly (which can be found in prelude, if you haven't already peeked), but it allows for exactly the same functionality as the built-in `rect`. As mentioned on the [documentation page](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect) for `rect`, another common usage is to specify a rectangle with rounded corners. Go ahead and, in your own document, change the specification for `ourRectangle` to allow for specifying the radius of the rounded corners.


There's a nice helper function in `prelude` called `addAttr` which could be very helpful for creating complicated SVG nodes. Its definition is as follows:

```
(def addAttr (\([shapeKind oldAttrs children] newAttr)
  [shapeKind (snoc newAttr oldAttrs) children]))
```

This allows attributes to be appended to existing SVG nodes with ease.[^designchoice] It is easy to imagine a similar function that allows for the appending of children as well. Further, as attributes and children are just lists with elements that are straightforward to pattern match on with `case`, there's plenty of functionality for any function to modify any shape in any way. To illustrate the functionality, let's create a function that sets the `fill` attribute of an SVG node if it isn't there and changes it to the given value if it is:

[^designchoice]: Currently, we've stuck with the design decision to have the built-in functionality lend itself towards a single statement that creates the SVG node for a given shape or other structure after which that node isn't manipulated any further. There's no reason why things need to be done this way and it's simply how we chose to go about things - a design method that involves creating shapes and then passing adding attributes to them after the fact is equally as legitimate and just doesn't have a nice group of functions to go along with it in `prelude`. 


<!-- This could be made an exercise instead, but I feel like it's more a functional programming problem than illustrative of the structure of our thin wrappers, so I just put the solution as an example here. I could be convinced otherwise though, let me know what you think - Mitch -->

```
(defrec setFill_ (\(attrs fill) (case attrs
  ([] [ [ 'fill' fill ] ])
  ([ [ 'fill' _ ] | rest ] [ [ 'fill' fill ] | rest ] )
  ([ a | rest ] [ a | (setFill_ rest fill) ]) ) ) )
(def setFill (\([ nodename attrs children ] fill) 
  [nodename (setFill_ attrs fill) children ] ) )
```
 
Notice how we need to be careful about how the attributes themselves are two-element lists inside of lists. This leads to more than a few nested brackets, but the syntax should become familiar after you use it once or twice.

<!--
Talk about the syntax

Implement rect

Talk about addAttr

Implement a function that adds a particular attribute (maybe increments
z-ordering?)
-->

## SVG ViewBox

Talk about SVG ViewBox and how it is implemented

Walk through making a pan/zoom example where there is a combination of sliders
and such that allow the pannigng and zooming of a graphic

## Adding a new SVG feature

Talk about where an SVG feature reference is and what kinds of features have yet
to have built-in functionality

Implement a kind of 'out there' piece of SVG, perhaps feTurbulence, to show how
pretty much anything can be added

Have them pick and implement their own SVG feature
