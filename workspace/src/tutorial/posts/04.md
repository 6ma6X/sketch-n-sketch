# Step 4

Welcome to the fourth lesson in the Sketch-n-Sketch tutorial. In this tutorial,
we will cover:

- How to use the `line` function to make simple line segments
- How to use the `path` function to create arbitrary forms
- How to introduce parameters into the `path` function as a useful design
    pattern
- How to generate paths to make up a design

Let's dive in!

<!--
What we will cover in this lesson:

- How to use `line`
- Understand how `path` works, and the particular concerns that come with it.

Key aspects to `path`:

That it's a list of movement commands in basically the same fashion that the
normal SVG path is specified.

How to read the documentation for all the different curve types and such.
(www.w3.org/TR/SVG/paths.html

Paths start withe a `moveto`, usually ends with a `closepath` (for closed
shapes, not for open ones). In between are either `lineto` or curve commands.

They allow for the creation of any shape, and most designs will probably end up
incorporating them in some fashion. In Sketch-n-Sketch, they end up being used
in a few ways, each with their own attributes:
-->

## Using `line` and `case`

So far, the only basic shape that we have not covered is creating finite line
segments. Just like the other basic shapes, there is a built-in function that
allows the creation of the appropriate SVG node called, naturally, `line`:

```
(line fill w x1 y1 x2 y2)
```

This creates a line from the point `(x1,y1)` to `(x2,y2)` with the color `fill`
and width `w`. This function works very well for making very simple line
segments between shapes, and can be used to approximate a rotated rectangle if
the width is set particularly wide, as the endcaps of the line are rectangular
and there is no limit on how wide the line segment can be. To draw a polygon,
you could link these line segments together one at a time around the perimeter
of the shape. In fact, let's do just that.

Our goal is to get a function that, given a list of points `[x y]`, creates an
empty polygon that draws line segments between all the adjacent points. To do
this, we will need to introduce syntax that allows us to operate on lists
differently depending on if they happen to be empty or not. The function in
question is called `case` and takes arguments in a slightly different way than
other functions:

```
(case parameterToCheckAgainst
  (pattern1 returnIfPattern1Matches)
  (pattern2 returnIfPattern2Matches)
  ...
  (_ returnIfNoOtherPatternsMatch) )
```

The newlines between the cases are optional, but helps readibility greatly. The
notion is that if `parameterToCheckAgainst` matches one of the patterns, then
the expression that is associated with that pattern is returned. The patterns
are checked from the top down, and an underscore `_` matches anything. As an
example, here is a case statement, some example inputs, and which pattern gets
matched:

```
(case inputList
  ([]               ...) ; pattern 1
  ([x]              ...) ; pattern 2
  ([x y]            ...) ; pattern 3
  ([x]              ...) ; pattern 4
  ([ [a b] | rest ] ...) ; pattern 5
  (_                ...) ; pattern 6

[] matches pattern 1
[ 2 ] matches pattern 2, and not pattern 4
[ 1 2 3 ] matches pattern 6
[ [ 2 4 ] ] matches pattern 5
[ [ 2 3 4 ] ] matches pattern 6
'string' matches pattern 6
5 matches pattern 6
```

Since `little` does not enforce any type constraints, the catchall `_` could
catch some inputs that you would not like to attempt to operate on at all, so be
careful with it! A very common pattern is to use `case` in recursive functions
to define a base case and a recursive case for operating on lists. So, to define
our own version of `concat`, we could do the following:

```
(defrec ourConcat (\list (case list
    ([] [])
    ([ [] | rest ] (ourConcat rest))
    ([ [ x | xs ] | rest ] [x | (ourConcat [ xs | rest ])]) ) ) )
```

Notice that we combined `case` with an anonymouse function to make it such that
we could take in a list, and that we used `defrec` instead of `def` here, as we
recursively call `ourConcat` inside of `ourConcat`. 
Further, if we input anything that is not a list of
lists, then our program will fail at runtime. This is a very standard definition
of a recursive concatenation, and will likely look familiar to you (albeit with
a different syntax than you're used to).

Knowing how to write functions that operate on lists, we can now write our
function to create a polygon from a list of points. Our approach will be to call
`line` for each pairwise set of points as well as the first and last points.
Doing this, we could write:

<!-- TODO check this to make sure it works -->
```
(def [linecolor linewd] ['black' 10])
(defrec ourPolygon_ (\(points [ firstx firsty ]) (case points
  ([ [lastx lasty ] [ (line linecolor linewd firstx firsty lastx lasty ) ])
  ([ [x1 y1] [x2 y2] | rest ] [ (line linecolor linewd x1 y1 x2 y2) [x2 y2] | rest] ) ) ) )
(def ourPolygon (\points (case points
  ([] [])
  ([ onlyOne ] [])
  ([ first | rest ]  (ourPolygon_ points first)) ) ) )
```

Awesome! Our function `ourPolygon` handles preparing the arguments for the
second function, `ourPolygon_`, which then operates recursively on the elements
of the points list. Go ahead and enter this into a document in Sketch-n-Sketch
and enter some points to see it in action.

To get you really comfortable with this syntax, go ahead and perform the
following exercise: [[ Rephrase this ]]

* As it is, entering the list `[ [ 10 10 ] [ 50 50 ] ]` into `ourPolygon`
    draws two near-identical line segments. Add an additional case in
    `ourPolygon_` to make it such that only one line segment is drawn.
* (Optional) Redefine `ourPolygon` to use `foldr` instead.

## Basic Path Commands

As drawing paths that involve multiple line segments is extremely common when
writing designs, it is usually more convenient to create a `path` instead of a
collection of line segments. The goal of this following section is to get you
familiar enough with SVG paths such that you will be comfortable exploring
all of the functionality the
[specification](http://www.w3.org/TR/SVG11/paths.html) has to offer.

The general structure of an SVG path is a list of draw commands, each of which
has associated 'control points'  that are
interpreted in order to draw the shape. This list of commands is put into a
`path` node in SVG with some additional attributes and the web browser handles
the rendering of the overall path. Sketch-n-Sketch supports manipulation of the
control points of a path for all of the most commonly used commands, which
allows for intuitive direct manipulation of SVG paths.[^supportedcommands] To
create an SVG path node in `little`, the `path` command can be invoked with
arguments of the following form:

```
(path fillcolor linecolor linethickness pathcommands)
```

[^supportedcommands]: The interpretation of supported commands can be found
in the Sketch-n-Sketch source
[here](https://github.com/ravichugh/sketch-n-sketch/blob/master/src/LangSvg.elm#L117).

Where `fillcolor` represents the color of the interior of the path where
`'none'` is a valid entry if you would like no fill, `linecolor` represents the
color of the path itself where `'none'` is again a valid entry if you would like
no boder to be drawn along the path, `linethickness` represents the thickness of
the border that `linecolor` colors, and `pathcommands` is a list of commands
with their control points that define the SVG path. In general, the list of path
commands for any given path begins with a `moveto` command, which sets the
'cursor' for the path to that location without drawing anything. Then, there is
a sequence of draw commands which may optinally be followed by a `closepath`
command which connects the end of the path back to the beginning. There's
fancier things that can be done with subpaths and such, but this structure is
all that's really needed to make your own complicated shapes and forms.

Here is an example path which draws a square with a light blue fill and a gray
outline:

```
(path 'lightblue' 'gray' 5 
  [ 'M' 100 100
    'L' 200 100
    'L' 200 200
    'L' 100 200
    'Z' ] )
```

We begin the path command list with a `moveto`, indicated with a captial `M`.
Then, we have three successive `lineto` commands with a capital `L` which draws
three edges starting from the initial `(100,100)` coordinate going clockwise
around a square with edge length `100`. Then, we end the command list with a
`closepath` command, indicated with a capital `Z`. This draws an edge back to
the start at `(100,100)`. This syntax is exactly the syntax defined in the
specification linked above, and so you can use it as a reference for how to
specify all the control points for each command.

This is definitely nicer than using a whole bunch of line segments like we did
before! What's especialy nice is that SVG paths also have support for specifying
a variety of curves. Here we will demonstrate only the quadratic bezier curve,
which is the simplest type of curve to define and is specified with a `'Q'` if
using absolute coordinates. Below is an example that draws an unfilled
sinusoidal-looking curve.

```
(def curve
  (path 'none' 'black' 5
    [ 'M' 300 300
      'Q' 350 250
          400 300
      'Q' 450 350
          500 300 ] ) )
(svg [ curve ])
```

Go ahead and enter this into a document in Sketch-n-Sketch and turn on the basic
zones. See the points that are off of the line? Try manipulating those and
seeing what happens. Those are the control points for the first and second
quadratic curve, respectively, which is how the control points for the other
sorts of curves also function.

Now that you've seen how basic paths work, go ahead and try making your own
path. Try experimenting with mixing `lineto` and curve commands. After that, go
ahead and look at some of the built-in examples that use paths in this way, such
as Botanic Gardens or Eye Icon.

You will see in these designs that there are a handful of variables defined as
top-level definitions that are directly or near-directly dropped in to the
coordinate positions inside of the command list. This results in a lot of
constants and variable names in play, which can get unwieldy. However, such as
in the case of the Eye Icon, sometimes there is no way to avoid having a lot of
parameters at once, as the design inherently requires them. 

<!--
After defining some key values, defining the entirety of a shape in terms of
those parameters (see Botanic Garden, Eye Icon). This is akin to hard-coding
most of the shapes in a design. Sometimes it's necessary (the design just
inherently has a lot of parameters), but it's good to think about if you're in
that situation or if you can design your program in such a fashion that it's
more composable/extensible.
Pros: 
    Entire path is visible in the code at once
    Each point is easily manipulated
Cons:
    Many variables end up being in play (but, sometimes this in unavoidable)
Remember:
    You're in for a lot of entry of numbers by hand in this case. Sometimes it's
    the only way it can be done, but usually it can benefit from simplification
    according to the next method.
-->

## Parameters in Paths

Oftentimes the specification for a path can be improved upon by introducing a
parameter that is shared by some or all the points. For example, if we knew that
we wanted our curve to have both the up and down portions to have the same
amplitude and that we would like the curves to be evenly spaced between each
other, we could redefine it in the following way:

```
(def [amplitude spacing x0 y0] [50 100 300 300])
(def curve
  (path 'none' black' 5
    [ 'M' x0 y0
      'Q' (+ x0 (/ spacing 2!)) (- y0 amplitude)
          (+ x0 spacing) y0
      'Q' (+ x0 (* 1.5! spacing)) (+ y0 amplitude)
          (+ x0 (* 2! spacing)) y0 ] ) )
(svg [ curve ])
```

Enter this into your document and manipulate the control points as before. You
should now see that your changes affect the other parts of the path that depend
upon the same parameters. Depending on your design, this can be a great
improvement over defining each portion individually both in terms of number of
parameters that are in play as well as adjusting attributes shared by many
portions of your path.

Quite a few of the built-in examples that utilize paths fall into this pattern of design,
including Active Trans, the Haskell.org logo, POP-PL logo, and the Wikimedia
logo, of which the Active Trans logo is a particularly good example. Go ahead
and switch to the Active Trans logo, and look at the definition for `grayPts`.
Notice how all of the points of the skyline are defined as offsets from a shared
height parameter. Try manipulating the control points of the skyline and observe
how they all move up and down together. Since the skyline profile of the design
is meant to be fixed, this allows for a nice manipulation of this otherwise
annoying-to-change characteristic of the graphic.

Go ahead and define your own path in terms of a parameter that is shared between
all or some of the points. Try to use at least one curve and one straight line
in your design.

<!--
After defining some shared parameter, defining the entirety of a shape in terms
of that parameter with some modifier for each point (see Active Trans,
Haskell.org, POP-PL Logo, Wikimedia Logo). Between the three, this seems to be a
good sweet spot of complexity and utility.
Pros:
    Fewer variables are in play than previously
    Each point is easily manipulated
    Manipulating groups of points is drastically easier
Cons:
    More complex than previously, manipulating one point manipulates many
Remember:
    This is a big improvement over hard-coding most everything if there are a
    small number of parameters that affect a lot of the points, and there is
    hardly a design that cannot benefit from this simplification.
-->

## Generating Paths

While the former design pattern is suitable for a lot of the graphics that you
will work with, there are certain types of designs that lend themselves to a
program structure that *generates* a path instead of being specified by hand.
This could be for a few different reasons, including that the path is such that
the control points are tedious to write by hand, the path has such a large
number of control points as to be unwieldy to edit, or that the user would like
to experiment with different numbers of control points, which cannot be
accomplished without changing the number of path commands, which can only be
done either by hand or if the list of commands is being generated by a function.

A good example of the parameters being tedious to specify by hand is in the Pie
Chart built-in example. Notice that each wedge is a path with a specific fill
and edge style, but that they all share exactly the same structure in terms of
how the 'pie slice' is defined (two straight edges with a circular curve). So,
instead of defining all of the control points by for the number of pie slices
that happen to be in the design at the moment, which would be both time
consuming, repetitive, and difficult to add or remove a pie slice, a function
`wedge` is defined that does all of that for the user. That function is then
mapped over the unique information for each wedge, saving the user the trouble
of writing it all themselves and making the program drastically more extensible.
Further, this allows for a much more dynamic design than is otherwise possible.

<!-- maybe have an exercise here? -->

In the case of Pie Chart, each path is completely specified by one function,
meaning that the initial `moveto` and `closepath` statement is encapsulated in
the function definition. However, in the Sailboat example, the situation is
different. As the waves are intended to be all one path, the commands to create
each wave must be appended to a growing command list, depending on the
particular value of the parameters that currently exist. Namely, the overall
number of times that the wave should be dependent is determined both by the
width of the wave and the overall width of the graphic. So, the number of
control points and path commands that are involved need to be able to change. As
such, the function `mkwaves` is defined such that it builds up the path one wave
at a time. <!-- Care was taken to make sure each wave began with a moveto,
etc... ? Maybe refactor sailboat... -->



After defining a few parameters, *generating* paths to make up a design (see Pie
Chart, Sailboat). This usually only comes up in certain types of designs - this
is not an applicable design pattern for all usages of `path` by any means - but
it lets you manipulate SVG images in a way that is impossible without a means of
programmatically specifying designs.
Pros:
    Allows a dynamic design editing process that is otherwise impossible
    Code is typically drastically more concise than the other two methods
Cons:
    Significantly more complex than either of the previous two methods, leading
    to a more involved write/debug process that usually includes head-scratching
    around how exactly edge cases in SVG paths work
    The whole path is not in view anywhere in the code, making small
    single-picture-location edits much more difficult/impossible
Remember:
    Need to tack on the initial 'M' separately from the generating function
    (usually)
    'Z' creates a subpath and draws a line to connect the end to the start

