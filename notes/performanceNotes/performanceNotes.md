#Performance Notes

As these performance notes might have relevance down the road for the rest of the program, they are included in the master branch.

##Eval Branch vs. Regular Main
Specifically commit 7690297f303d9bfceeecb607b8062f3befc7f034

See https://github.com/ravichugh/sketch-n-sketch/commit/7690297f303d9bfceeecb607b8062f3befc7f034

Performance degraded considerably with this commit, including crashing when loading examples (specifically Active Transit Logo). This commit changed eval to return type Result String (Val, Env) as opposed to  (Val, Env). Consequently, many pattern matches were added to appropriately handle the case when there was was an error in eval. This is nice, because instead of crashing the error could be displayed and the user would have a chance to fix the issue in the input program (or at least save their work). As, conceptually, pattern matches shouldn't add too much computational or memory overhead, it is not obvious what is wrong.

###Potential Causes
* Ballooning Memory Usage
** Addition of Result String onto all Vals adds a gross amount of memory usage, causing much more memory I/O than before and slowing things down
** Case statements that are associated with above addition cause a much more massive memory footprint during evaluation, perhaps because of variables that are not being garbage collected like they were before
* Expensive Comparisons
** Addition of Result String onto all Vals creates a lot of expensive (for some unknown reason) pattern matches (perhaps on Strings) that slows performance
** The large number of new case statements results in generation of many more nested function calls in the compiled JavaScript, the culmination of all calls slows down performance
* Algorithmic Complexity
** This commit could have introduced some sort of algorithmic complexity along the lines of checking all Vals some gross number of times as it gets more complex

###Observations

The profiles in this directory were generated by Chrome during manipulations of the first Three Boxes example.

The heap snapshots and heap allocation timelines don't suggest an obvious ballooning of heap allocations because of the commit in this code. The total memory usage and heap allocation characteristics seem to be the same. However, these do not display memory references - so, the same memory could be being acceessed a large number of more times. **Another profile should be made in the case when loading of an example causes the page to be brought to its knees**

**Attempt incremental introduction of the type and compile/test in a rolling fashion from source to see which parts in particular, if any, are causing the problem**